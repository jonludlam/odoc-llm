{
  "package": "pyml",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 42,
  "creation_timestamp": "2025-07-15T23:13:55.410731",
  "modules": [
    {
      "module_path": "Py.Sequence",
      "library": "pyml",
      "description": "This module enables type-safe manipulation of Python sequences\u2014such as lists, tuples, and strings\u2014from OCaml, providing operations to access and modify elements, slices, concatenate, repeat, and convert sequences to OCaml lists, arrays, or sequences. It supports functional patterns like mapping, tail-recursive folding, and predicate checks (e.g., `forall`, `exists`), ideal for integrating Python sequence data into OCaml workflows, such as processing Python lists from embedded scripts or transforming data between mixed-language components.",
      "description_length": 544,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Py.Capsule",
      "library": "pyml",
      "description": "This module enables embedding OCaml values into Python as opaque objects, providing functions to wrap and unwrap values of specific types while preserving type identity. It works with arbitrary OCaml types and Python objects, using a string identifier to associate a type with its wrapper pair. Use cases include passing OCaml closures, data structures, or stateful objects to Python code and retrieving them later without loss of type integrity.",
      "description_length": 446,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Class",
      "library": "pyml",
      "description": "This module defines new Python class types with specified parent classes, fields, and methods. It operates on Python objects and strings to configure class behavior and structure. Use it to create custom Python classes from OCaml, such as defining a `Point` class with `x` and `y` attributes and a `distance` method.",
      "description_length": 316,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Py.Mapping",
      "library": "pyml",
      "description": "This module provides operations to interact with Python mapping objects from OCaml, including retrieving, setting, and checking key-value pairs using string keys. It works with `Py.Object.t` values that implement the Python mapping interface, such as dictionaries. Concrete use cases include accessing dictionary entries in Python objects, modifying them, and checking their size or key presence directly from OCaml code.",
      "description_length": 421,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Py.Eval",
      "library": "pyml",
      "description": "This module evaluates Python expressions and executes Python code from within OCaml. It allows direct calls to Python objects with or without keyword arguments, and provides access to the current built-in, global, and local Python scopes. Use it to run Python scripts, invoke Python functions, or interact with Python variables dynamically.",
      "description_length": 340,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Dict",
      "library": "pyml",
      "description": "This module supports manipulation of Python dictionaries through operations like key-based access, iteration, and transformation of key-value pairs, while enabling conversions between Python dictionaries and OCaml data structures such as lists and sequences. It operates on Python dictionary objects (`Py.Object.t`) and typed OCaml values, facilitating use cases like bridging Python APIs with OCaml logic, filtering or mapping dictionary contents, and constructing Python-compatible dictionaries from OCaml-generated data. Key applications include interoperability scenarios where OCaml code processes or generates Python dictionaries for scripting, configuration, or data exchange purposes.",
      "description_length": 692,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Gil",
      "library": "pyml",
      "description": "This module manages the Global Interpreter Lock (GIL) state for Python integration in OCaml. It provides functions to ensure, release, and check the GIL state, along with a scoped locking mechanism to safely execute Python C API calls. Use it to coordinate thread access to Python objects and prevent race conditions during multi-threaded Python/OCaml interoperability.",
      "description_length": 369,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Module",
      "library": "pyml",
      "description": "This module provides operations to create, inspect, and manipulate Python modules from OCaml. It supports working with Python module objects to retrieve and set attributes, call functions, and access module metadata like name and filename. Concrete use cases include dynamically loading Python modules, embedding Python scripts, and exposing OCaml functions as module-level callables within Python.",
      "description_length": 398,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pywrappers.Python2",
      "library": "pyml",
      "description": "This module provides operations to interact with the Python 2 runtime, such as compiling code strings, creating Python classes and instances, managing runtime paths, and handling exceptions and numeric operations, all acting on Python objects encapsulated in the `Pytypes.pyobject` type. It also includes utilities for converting and manipulating Python 2 strings and objects in OCaml, with support for string formatting, comparison, and numeric coercion specific to Python 2 semantics, enabling seamless interoperability between OCaml and embedded Python 2 code.",
      "description_length": 563,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Callable",
      "library": "pyml",
      "description": "This module enables interoperability between OCaml functions and Python callables. It provides functions to wrap OCaml functions as Python callable objects, supporting argument passing via tuples, arrays, and keyword dictionaries. It also includes utilities to convert Python callable objects into OCaml functions for direct invocation, handling errors and exceptions according to Python semantics.",
      "description_length": 398,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pywrappers.Pycaml",
      "library": "pyml",
      "description": "This module enables low-level interoperability between OCaml and Python, offering operations to create and manipulate Python objects (e.g., dictionaries, sequences, modules, exceptions), convert types between the two languages, and execute Python code. It primarily works with `Pytypes.pyobject` values representing Python entities, supporting tasks like exception handling, module import, arithmetic operations on Python objects, and direct access to Python's runtime features (e.g., GIL management, Unicode string encoding). Specific use cases include embedding Python interpreters in OCaml applications, extending Python with OCaml-optimized components, and bidirectional data exchange for hybrid systems.",
      "description_length": 708,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Set",
      "library": "pyml",
      "description": "This module provides operations for creating, modifying, and querying Python set objects from OCaml, including adding, removing, and checking elements. It works directly with Python objects represented as `Py.Object.t` and supports conversion between Python sets and OCaml lists. Concrete use cases include managing collections of unique Python values, such as tracking unique identifiers or handling set-based logic in Python from OCaml code.",
      "description_length": 443,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Py.Number",
      "library": "pyml",
      "description": "This module provides arithmetic, bitwise, and numeric conversion operations for Python number objects, supporting operations like addition, division, bitwise shifts, and exponentiation through both explicit functions and OCaml operator synonyms. It works directly with `Py.Object.t` values representing Python integers and floats, enabling seamless interoperability between OCaml and Python numeric types. Specific use cases include numeric computations requiring Python's dynamic type handling, bitwise manipulations, and conversions between OCaml and Python representations of numbers.",
      "description_length": 587,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pywrappers.Python3",
      "library": "pyml",
      "description": "This module enables interaction with Python 3's runtime through configuration management (e.g., paths, home directory), execution of Python code, and bidirectional conversion between OCaml and Python data types like strings and bytes. It operates on Python objects (`pyobject`), raw string data, and Unicode encodings (UTF-8/16/32), with explicit handling of size and memory layouts, including UCS-4 array conversions. Use cases include embedding Python scripts in OCaml applications, processing internationalized text, and exchanging structured data between the two languages.",
      "description_length": 577,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Err",
      "library": "pyml",
      "description": "This module handles Python exception operations from OCaml, including raising, catching, and inspecting exceptions. It works with Python error types defined in the `t` variant and Python objects representing exceptions, values, and tracebacks. Concrete use cases include propagating Python exceptions into OCaml, handling errors during Python API calls, and restoring fetched exceptions for re-raising.",
      "description_length": 402,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Marshal",
      "library": "pyml",
      "description": "This module serializes and deserializes Python objects to and from files and strings. It supports reading and writing single or multiple objects, with control over the file format version. Use cases include saving and loading Python object states for inter-process communication or persistent storage.",
      "description_length": 301,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.String",
      "library": "pyml",
      "description": "This module handles conversion, manipulation, and inspection of Python string objects, including operations for encoding and decoding UTF-8, UTF-16, and UTF-32. It provides direct access to string length, formatting, and type-checking for both bytes and Unicode strings, enabling precise interaction with Python's string representations. Use cases include converting OCaml strings to Python strings, extracting string lengths, and decoding raw byte sequences into Unicode strings.",
      "description_length": 480,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pywrappers.UCS4",
      "library": "pyml",
      "description": "This module provides direct operations for creating, decoding, and converting Unicode strings in various encodings (UTF-8, UTF-16, UTF-32) to and from Python objects. It works primarily with `pyobject` and `int array` types, supporting concrete tasks such as encoding OCaml strings into Python Unicode objects, extracting Unicode code points, and parsing encoded byte sequences into Unicode values. Specific use cases include handling Unicode data during Python interoperability, such as preparing strings for Python API calls or extracting string content from Python responses.",
      "description_length": 578,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Py.Object",
      "library": "pyml",
      "description": "The module provides functions for attribute and item access, type inspection, comparison, string conversion, method invocation, and buffer/reference management of Python objects. It operates on values of type `Py.Object.t`, which encapsulate Python objects within OCaml. These capabilities support use cases such as embedding Python interpreters, exchanging data between Python and OCaml, dynamic scripting, and safe manipulation of Python objects with controlled error handling and resource management.",
      "description_length": 503,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Py.Type",
      "library": "pyml",
      "description": "This module defines a variant type `t` representing Python types and provides functions to inspect and compare them. It includes operations to check if an object is a specific type, retrieve its name, and determine subtype relationships using Python's type system. Concrete use cases include validating Python object types during OCaml-Python interoperation and constructing new Python types dynamically.",
      "description_length": 404,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Long",
      "library": "pyml",
      "description": "This module handles conversions between Python long integers and OCaml integer types, providing functions to create Python longs from `int` or `int64`, parse them from strings with configurable base, and convert them back to OCaml integers. It works directly with `Py.Object.t` values representing Python longs, raising exceptions on type mismatches. Use this module when interfacing OCaml code with Python code that requires arbitrary-precision integer handling, such as parsing numeric inputs or passing integer values between languages.",
      "description_length": 539,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Import",
      "library": "pyml",
      "description": "This module supports importing and reloading Python modules from OCaml, providing direct access to Python\u2019s import system. It works with module names as strings and Python objects representing modules, allowing operations like executing bytecode, compiling source code into modules, and querying the module dictionary. Concrete use cases include dynamically loading Python modules by name, importing modules from OCaml-compiled bytecode, and reloading modified modules during development.",
      "description_length": 488,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Bytes",
      "library": "pyml",
      "description": "This module handles conversion between OCaml strings and bytes and Python byte sequences. It provides functions to create Python byte objects from OCaml strings or bytes, and to extract the contents of Python byte objects as OCaml strings or bytes. Use this module when passing binary data between OCaml and Python, such as processing file contents or network data.",
      "description_length": 365,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Method",
      "library": "pyml",
      "description": "This module creates Python method objects from functions and instances, extracts the underlying function from methods, and retrieves the instance associated with bound methods. It operates on Python objects representing methods and functions. Use it to bind Python functions to instances or inspect method properties in Python-C API interactions.",
      "description_length": 346,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Py.Bool",
      "library": "pyml",
      "description": "This module provides direct access to Python's boolean values and operations. It includes functions to convert between OCaml `bool` and Python boolean objects, as well as predicates to test whether a Python object is `True` or `False`. Use this module to safely interoperate boolean values between OCaml and Python, ensuring correct identity checks and conversions.",
      "description_length": 365,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pywrappers.UCS2",
      "library": "pyml",
      "description": "This module handles Unicode string conversions and manipulations for UCS-2 encoded data. It provides functions to encode and decode strings in UTF-8, UTF-16, and UTF-32 formats, convert between OCaml strings and Python Unicode objects, and access internal Unicode representations. Concrete use cases include processing Python Unicode objects in OCaml extensions and interfacing with Python APIs that require specific Unicode encodings.",
      "description_length": 435,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Traceback",
      "library": "pyml",
      "description": "Handles Python traceback data by converting OCaml frame lists into Python traceback objects. Works with lists of frame records containing filename, function name, and line number. Used to construct Python exception tracebacks from OCaml error contexts.",
      "description_length": 252,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Iter",
      "library": "pyml",
      "description": "This module provides operations to check iterator types, traverse elements, convert between Python iterators and OCaml collections (like lists and sequences), and create custom iterators with both memoizing and non-memoizing conversion strategies. It works with `Py",
      "description_length": 265,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Py.Int",
      "library": "pyml",
      "description": "This module handles conversions between OCaml and Python integer values, supporting both 32-bit and 64-bit integers. It provides functions to wrap OCaml integers into Python objects and unwrap Python integers into OCaml values, with explicit handling for string representations using arbitrary bases. Use this module when passing integer values between OCaml and Python, especially when interfacing with Python APIs expecting integer arguments or returning integer results.",
      "description_length": 473,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Float",
      "library": "pyml",
      "description": "This module provides functions to convert between OCaml and Python floating-point values. It includes operations to check if a Python object is a float, convert an OCaml float to a Python float, and extract an OCaml float from a Python float. It works directly with `Py.Object.t` and `float` types, and is used for numerical computations involving Python floats in OCaml code.",
      "description_length": 376,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.List",
      "library": "pyml",
      "description": "This interface enables creation, modification, and conversion of Python lists through operations like element access, iteration, and logical checks, while handling data represented as `Py.Object.t`. It supports bidirectional transformations between Python lists and OCaml arrays/lists, along with sequence-based construction and traversal. Typical applications include integrating OCaml logic with Python libraries requiring list inputs or processing Python list data in OCaml programs.",
      "description_length": 486,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Array",
      "library": "pyml",
      "description": "This module creates Python array-like objects from OCaml data structures and provides direct interoperability with Numpy arrays. It supports wrapping OCaml arrays into Python sequences using custom accessors and enables zero-copy sharing of float arrays with Python via Numpy. Specific operations include constructing mutable or read-only array wrappers, exposing Numpy array APIs, and converting between OCaml float arrays and Numpy arrays without data copying.",
      "description_length": 462,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Py.Run",
      "library": "pyml",
      "description": "This module evaluates Python expressions and executes Python code from strings or files, returning the resulting Python objects. It supports interactive sessions, IPython integration, and direct execution of scripts with customizable global and local scopes. Concrete use cases include embedding Python evaluation in OCaml applications, running user-provided Python code, and integrating Python scripting into interactive OCaml tools.",
      "description_length": 434,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py.Tuple",
      "library": "pyml",
      "description": "This module enables creating, accessing, and converting Python tuples through operations like element extraction, slicing, and bidirectional transformations with OCaml arrays, lists, and sequences. It works with `Py.Object.t` instances representing Python tuples, supporting functional iteration, size queries, and in-place modifications. Typical use cases include bridging OCaml data structures with Python APIs requiring tuples, handling fixed-length sequences from Python libraries, and unpacking tuple values into OCaml pairs or collections.",
      "description_length": 545,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Py",
      "library": "pyml",
      "description": "This module provides a comprehensive interface for interoperability between OCaml and Python, enabling seamless integration through type conversion, runtime control, and execution management. It introduces core data types like `Py.Object.t` to represent Python objects in OCaml, and supports operations such as module imports, exception handling, and evaluation of Python code. With it, developers can embed Python interpreters, expose OCaml functions to Python, and manage Python runtime state, allowing tasks like executing Python scripts, calling Python functions dynamically, and converting between Python and OCaml data structures. Submodules extend this functionality to handle sequences, dictionaries, numeric types, strings, and more, enabling fine-grained manipulation of Python objects while preserving type safety and functional patterns.",
      "description_length": 849,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pytypes",
      "library": "pyml",
      "description": "This module defines core types and conversions for handling Python-like objects and operations. It includes types for Python objects (`pyobject`), comparison operators (`compare`), and input modes (`input`), along with functions to convert between these types and integers. It is used for implementing Python semantics in OCaml, particularly for interpreting and evaluating Python code.",
      "description_length": 386,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Numpy",
      "library": "pyml",
      "description": "This module enables seamless interoperability between OCaml and Python by allowing in-place sharing of numerical arrays between the two languages. It supports specific bigarray kinds and layouts, mapping them directly to NumPy element types, and provides functions to convert between OCaml bigarrays and NumPy arrays without copying data. Concrete use cases include passing large numerical datasets between OCaml and Python for processing, and modifying array contents in one language and seeing the updates reflected in the other.",
      "description_length": 531,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pyops",
      "library": "pyml",
      "description": "This module provides infix operators for accessing and modifying Python objects and dictionaries using either arbitrary keys or string keys. It supports operations like item lookup and assignment, mirroring Python's `__getitem__`, `__setitem__`, and dictionary-specific access patterns. Concrete use cases include interacting with Python objects from OCaml, such as reading and writing attributes or dictionary entries in a Pythonic syntax.",
      "description_length": 440,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pywrappers",
      "library": "pyml",
      "description": "This module enables low-level interoperability between OCaml and Python by exposing direct access to Python objects (`pyobject`), supporting operations such as dictionary and sequence manipulation, exception handling, type conversion, and runtime control. It includes child modules that extend functionality for Python 2 and Python 3 runtimes, Unicode string handling, and UCS-encoded data conversions, all centered around exchanging and transforming data between the two languages. You can compile and execute Python code from OCaml, import and call Python modules, convert strings with specific encodings, and manage the GIL to coordinate execution between OCaml and Python threads. Specific tasks include embedding Python interpreters, exchanging structured data like sequences and dictionaries, and handling internationalized text through precise Unicode and UCS encoding and decoding operations.",
      "description_length": 900,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pyutils",
      "library": "pyml",
      "description": "This module includes functions for string manipulation, such as extracting substrings and splitting strings on characters, along with conversions from octal and hexadecimal strings to integers. It provides utilities for handling input/output operations, including reading lines from channels, redirecting standard input, and managing temporary files and pipes. Specific use cases include parsing structured text data, handling binary or custom-encoded input, and writing scripts that manipulate file and channel operations safely, such as ensuring channels are closed or temporary files are cleaned up after use.",
      "description_length": 612,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pycaml",
      "library": "pyml",
      "description": "The module enables seamless integration of Python into OCaml by providing operations to convert between OCaml and Python data types, execute Python code, and manipulate Python objects through type-safe wrappers. It operates on Python objects represented as `pyobject`, supporting conversions for lists, strings, integers, floats, dictionaries, tuples, and Unicode encodings, while offering functions for attribute access, function calls, and exception handling. This allows developers to embed Python scripts within OCaml applications, utilize Python libraries for numerical computations, or bridge data between the two languages in hybrid systems.",
      "description_length": 648,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pyml_arch",
      "library": "pyml",
      "description": "This module defines a variant type `t` representing different operating system architectures (Windows, Mac, Unix) and provides a value `os` indicating the current system. It includes a function `fd_of_int` to convert an integer file descriptor into a Unix-specific file descriptor type. This module is used to handle platform-specific file descriptors and architecture checks in low-level system operations.",
      "description_length": 407,
      "index": 41,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 42,
    "meaningful_modules": 42,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 900,
    "min_description_length": 252,
    "avg_description_length": 477.95238095238096,
    "embedding_file_size_mb": 0.1529865264892578
  }
}