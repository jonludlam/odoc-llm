{
  "package": "catala",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 208,
  "creation_timestamp": "2025-08-18T19:01:52.929591",
  "modules": [
    {
      "module_path": "Runtime_ocaml.Runtime.Oper",
      "library": "catala.runtime_ocaml",
      "description": "This module provides arithmetic, comparison, and transformation operations for primitive and temporal types, including integers, decimals, money, dates, durations, and arrays. It supports element-wise array manipulations (map, filter, reduce), type conversions, date calculations, and type-safe mathematical operations with error tracking for division and ordered comparisons. These functions enable financial computations, temporal logic handling, and structured data processing in a strongly typed context.",
      "description_length": 508,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Runtime_ocaml.Runtime.EventParser",
      "library": "catala.runtime_ocaml",
      "description": "Parses low-level event data into structured event representations. Works with raw event lists and converts them into processed event lists. Used to transform unprocessed event streams into usable event objects for analysis or logging.",
      "description_length": 234,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Runtime_ocaml.Runtime.Json",
      "library": "catala.runtime_ocaml",
      "description": "Converts internal runtime data structures like io_log, runtime_value, and event into JSON-formatted strings for serialization and external communication. Works directly with the io_log, runtime_value, and event types defined in the Runtime module. Useful for logging runtime events, transmitting values over a network, or persisting execution traces in a structured format.",
      "description_length": 373,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Runtime_ocaml.Runtime",
      "library": "catala.runtime_ocaml",
      "description": "This module provides precise numeric and temporal computations, structured data embedding, and error-tracked arithmetic operations across specialized types like `money`, `decimal`, `date`, and `duration`. It handles financial calculations with rounding modes, date manipulations (e.g., month boundaries), and type-safe array operations, while supporting JSON serialization and runtime event logging for auditable workflows. Use cases include financial systems requiring exact decimal arithmetic, temporal logic in scheduling, and data processing pipelines needing robust error handling and structured metadata tracking.",
      "description_length": 619,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Runtime_ocaml",
      "library": "catala.runtime_ocaml",
      "description": "This module implements precise arithmetic for financial calculations using types like `money` and `decimal`, with support for rounding modes and error tracking. It provides date and duration manipulations accounting for calendar boundaries, along with type-safe array operations and JSON serialization. It is used in financial systems for exact decimal computations, scheduling applications for temporal logic, and data pipelines requiring structured metadata and auditable event logging.",
      "description_length": 488,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python",
      "library": "python",
      "description": "This module provides a command-line interface for executing Catala programs using a Python backend plugin. It handles input files and options to control execution behavior, such as enabling optimizations or output formats. A concrete use case is running Catala source files directly through Python for testing or prototyping, bypassing the standard compilation process.",
      "description_length": 369,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Uid.Gen.Map",
      "library": "catala.catala_utils",
      "description": "This module provides associative map operations for managing collections where keys are unique identifiers generated by a UID factory. It supports creation, modification, querying, and traversal of ordered maps with arbitrary value types, along with transformations like filtering, merging, and structured output formatting. Typical use cases include tracking UID-keyed data relationships, manipulating ordered key-value pairs, and generating customizable textual representations of map contents.",
      "description_length": 496,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Make.Set",
      "library": "catala.catala_utils",
      "description": "This module provides operations for managing immutable sets of unique identifiers with ordered traversal, supporting standard set algebra (union, intersection, difference), conditional filtering, and element access via safe (option-returning) or unsafe (exception-raising) methods. It works with sets built from totally ordered identifiers generated by the `Uid.Make` functor, leveraging `Set.Make` for efficient ordered structure and interoperating with sequences and lists for bulk transformations. Typical use cases include tracking distinct identifier collections in contexts like variable scoping, dependency resolution, or state management where type-level separation of identifier kinds is critical.",
      "description_length": 706,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Uid.Make.Map",
      "library": "catala.catala_utils",
      "description": "This module implements type-safe maps with unique identifiers as keys, offering operations for creating, modifying, and querying these maps while preserving strict type boundaries between different identifier origins. It works with ordered key-value pairs where keys derive from a generative identifier factory and values can be arbitrary, supporting transformations like folds, filters, and merges alongside ordered traversal and key-based decomposition. Typical applications include managing disjoint sets of bindings across compiler phases or analysis tools where identifier provenance must remain distinct to prevent logical errors.",
      "description_length": 636,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Module.Map",
      "library": "catala.catala_utils",
      "description": "This module provides ordered associative map operations for Uid keys, including creation, insertion, deletion, and traversal with predicate-based filtering. It supports merging, splitting, and conversion between maps, lists, and sequences while preserving key ordering, alongside customizable formatting of bindings. These capabilities are suited for managing unique identifier mappings in structured data workflows, ordered collection transformations, or scenarios requiring precise control over key-based ordering and separation.",
      "description_length": 531,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Cli.Flags.Global",
      "library": "catala.catala_utils",
      "description": "Handles command-line parsing for global options and input files, providing terms for integrating with Cmdliner-based CLI interfaces. Works with `Global.options` records containing configuration like input sources, language settings, and output formats. Used to set up global state and parse arguments common across Catala commands, such as specifying input files or enabling debug mode.",
      "description_length": 386,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Uid.Gen_qualified.Set",
      "library": "catala.catala_utils",
      "description": "This module provides ordered set operations (union, intersection, difference, membership checks) and transformations (filtering, partitioning, bounded iteration) over immutable collections of structured identifiers with hierarchical paths. It works with ordered sets built via a custom comparator, supporting conversions to and from sequences and lists, as well as safe accessors like `min_elt` or `find` that return optional values. These tools are particularly suited for managing unique",
      "description_length": 489,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Uid.Module.Set",
      "library": "catala.catala_utils",
      "description": "This module offers standard set operations\u2014union, intersection, difference, subset checks\u2014and ordered manipulation capabilities for sets of unique identifiers. It works with `Catala_utils.Uid.Module.t` elements, maintaining a comparator-defined order to enable predictable traversal, extremal element retrieval, and conversions to/from lists or sequences. These features support use cases like managing sorted collections of identifiers, enforcing strict ordering constraints, or efficiently querying membership and ranges.",
      "description_length": 523,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Gen_qualified.Map",
      "library": "catala.catala_utils",
      "description": "This module implements associative maps with qualified identifiers as keys, supporting operations for creating, modifying, and querying ordered collections while preserving physical equality and key ordering. It provides functions for merging, transforming, and formatting map contents, with specialized utilities for structured output generation using OCaml's `Format` module. Typical use cases include managing hierarchical identifier mappings, generating path-aware unique keys with ordered semantics, and producing human-readable representations of map structures.",
      "description_length": 568,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Gen",
      "library": "catala.catala_utils",
      "description": "This module generates unique identifiers (UIDs) over marked strings, providing operations to create fresh UIDs, retrieve associated metadata, and compare, hash, or format them. It works with a marked string type that carries additional information, supporting precise identifier tracking. Concrete use cases include managing distinct identifiers in compiler components or analysis tools where traceability and uniqueness are critical.",
      "description_length": 434,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.File.Tree",
      "library": "catala.catala_utils",
      "description": "Represents a lazy tree structure that mirrors the filesystem using case-insensitive path comparisons. It supports operations to build a tree from a filesystem path, retrieve subtrees or specific files, and merge trees with conflict resolution. This structure is used to efficiently manage and access virtualized filesystem hierarchies, particularly in scenarios requiring case-insensitive path resolution and tree composition.",
      "description_length": 426,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.String.Set",
      "library": "catala.catala_utils",
      "description": "This module supports operations for creating, combining, and transforming ordered collections of unique strings, with functionality for membership checks, set algebra (union, intersection, difference), and ordered traversal. It works with immutable sets of type `t` containing `string` elements arranged via `Ord.compare`, enabling efficient filtering, partitioning, and sequence generation. Typical use cases include managing sorted string dictionaries, deduplicating string sequences, and performing ordered set computations in functional pipelines.",
      "description_length": 551,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Cli.Flags",
      "library": "catala.catala_utils",
      "description": "This module provides command-line interface functionalities through Cmdliner, enabling configuration of compilation, interpretation, and output workflows via boolean, string, and file-path options. It operates on global configuration records, file paths, and dependency metadata to support use cases like input validation, optimization toggling, and structured output generation for commands such as dependency resolution and source processing.",
      "description_length": 444,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Module",
      "library": "catala.catala_utils",
      "description": "This module generates and manages unique identifiers with attached metadata, providing operations to create fresh identifiers, retrieve associated information, and compare, hash, or format identifiers. It works with abstract identifier values and string-based metadata, supporting concrete use cases such as tracking distinct program entities in a compiler or managing labeled unique references in a document model. The Set and Map submodules enable ordered collections and associative lookups keyed by these identifiers, useful for maintaining sorted environments or structured mappings.",
      "description_length": 588,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Uid.MarkedString",
      "library": "catala.catala_utils",
      "description": "This module represents identifiers with source code positions, carrying the original string and its declaration or usage location. It provides equality and comparison operations that ignore positional information, along with functions to convert and format the identifier for debugging or output. Concrete use cases include tracking variable names in a compiler or interpreter while allowing structural comparisons.",
      "description_length": 415,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.String.Map",
      "library": "catala.catala_utils",
      "description": "This module implements associative containers mapping string keys to arbitrary values, enabling creation, modification, and ordered traversal of such maps. It supports operations like merging, filtering, and converting to sequences or formatted strings, with use cases including configuration management, dictionary processing, and structured output generation. Ordered key comparisons facilitate sorted iteration and range-based queries, while transformation utilities handle disjoint unions and predicate-driven searches.",
      "description_length": 523,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Map.Make",
      "library": "catala.catala_utils",
      "description": "The module provides operations for creating, modifying, and querying finite maps with ordered keys, supporting transformations like merging, filtering, and splitting based on key order. It works with polymorphic map structures parameterized over key and value types, where keys adhere to a user-defined ordering. Specific use cases include building maps from sequences, performing disjoint unions, and formatting map contents for display with custom layouts.",
      "description_length": 458,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Message.Content",
      "library": "catala.catala_utils",
      "description": "This module constructs and manipulates structured compiler messages with support for colored output formatting. It handles messages as functions producing formatted text, with operations to enrich messages with positional information, suggestions, or error context. Concrete use cases include emitting compiler diagnostics with source positions, adding fix-it hints to warnings, and formatting error messages with color when supported.",
      "description_length": 435,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.File.Map",
      "library": "catala.catala_utils",
      "description": "This module implements ordered key-value maps with efficient operations for file-based keys, supporting creation, modification, and combination of mappings through functions like insertion, deletion, and merging. It works with key-value pairs ordered by a comparator, enabling sorted traversal, range queries, and transformations while leveraging physical equality for performance. Typical use cases include managing file metadata, tracking configuration settings, or organizing structured data where keys correspond to file identifiers, with built-in support for generating human-readable representations of map contents.",
      "description_length": 622,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Path",
      "library": "catala.catala_utils",
      "description": "Handles paths of globally unique identifiers for modules in a structured format. Provides operations to convert paths to strings, format them, and compare or check equality between paths. Useful for tracking hierarchical module structures in a type-safe way.",
      "description_length": 258,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.File.Set",
      "library": "catala.catala_utils",
      "description": "This module implements core set operations\u2014including union, intersection, difference, and subset checks\u2014for collections of `Catala_utils.File.t` elements. It provides functions to filter, partition, and convert sets to ordered sequences, supporting use cases like file group management, ordered traversal, and sequence-driven set construction. Operations follow OCaml idioms for efficient set manipulation with file-based data.",
      "description_length": 427,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Gen_qualified",
      "library": "catala.catala_utils",
      "description": "This module generates unique identifiers paired with hierarchical path information and metadata, providing operations to create, compare, and format these identifiers. It works with structured identifiers that combine paths and marked strings, supporting use cases like tracking source code locations or managing scoped symbols in a compiler. The module also includes set and map implementations for handling collections of these identifiers with ordered semantics.",
      "description_length": 465,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Make",
      "library": "catala.catala_utils",
      "description": "This module generates unique identifier types with strict type separation, ensuring identifiers from different instantiations cannot be confused. It provides operations to create fresh identifiers with associated metadata, retrieve metadata, and compare, hash, or format identifiers. Used to manage distinct identifier spaces in compiler components or analysis tools where type-level isolation prevents accidental mixing of identifiers from different domains.",
      "description_length": 459,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Mark",
      "library": "catala.catala_utils",
      "description": "This module handles annotations attached to abstract syntax tree (AST) nodes, such as source positions or type information. It provides operations to add, remove, retrieve, and transform both the values and their associated metadata. Use cases include tracking source code locations during parsing and attaching type information during semantic analysis.",
      "description_length": 354,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.String",
      "library": "catala.catala_utils",
      "description": "This module offers a comprehensive toolkit for string manipulation, encompassing operations like character indexing, case conversion, substring extraction, and encoding transformations for UTF-8/16 data. It works directly with strings as byte sequences, supporting binary data processing, integer serialization, and ordered set/map structures for string collections. Key use cases include text validation, diacritic stripping, prefix/suffix handling, and constructing efficient string-based data structures with case-insensitive comparison logic.",
      "description_length": 546,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Version",
      "library": "catala.catala_utils",
      "description": "This module defines a single value `v` representing the current version of the software as a static string. It is used to embed version information directly into the codebase during the build process. Consumers of this module typically use the `v` value to display version numbers in logs, error messages, or command-line interfaces.",
      "description_length": 333,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Pos",
      "library": "catala.catala_utils",
      "description": "This module handles source code positions with precision, providing operations to construct positions from lexing data or explicit coordinates, retrieve file and line/column details, and merge ranges. It supports structured navigation and formatting of source locations, including extracting contextual text and generating human-readable representations. Use cases include error reporting with accurate source references and managing law-related metadata in parsed documents.",
      "description_length": 475,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Suggestions",
      "library": "catala.catala_utils",
      "description": "This module identifies close matches to a keyword from a list of candidate strings using the Levenshtein distance algorithm. It provides a function to find the closest word matches and another to format and print those matches. It is useful in scenarios like spell-checking or command-line auto-completion where approximate string matching is needed.",
      "description_length": 350,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Message",
      "library": "catala.catala_utils",
      "description": "This module handles compiler message emission with structured formatting, color support, and output routing. It defines levels like error, warning, and debug, and provides formatters that respect terminal capabilities for colored output. Functions include logging, emitting diagnostic messages with positional context, and converting formatted content to strings while suppressing unnecessary whitespace.",
      "description_length": 404,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid",
      "library": "catala.catala_utils",
      "description": "This module implements a system for generating and managing unique identifiers with metadata and path information. It provides operations to create fresh identifiers, compare and hash identifiers while ignoring positional details, and manage hierarchical paths of identifiers. These features support use cases like tracking variables and modules in a compiler, where distinct entities must be reliably identified and organized.",
      "description_length": 427,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Map",
      "library": "catala.catala_utils",
      "description": "This module extends standard map operations with functions for constructing maps from sequences, merging maps with disjoint keys, and formatting map contents using custom layouts. It supports polymorphic maps with ordered keys, enabling transformations like filtering, splitting, and union based on key ordering. Use cases include managing symbol tables, processing configuration data, and generating human-readable representations of map structures.",
      "description_length": 450,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Cli",
      "library": "catala.catala_utils",
      "description": "This module handles command-line interface tasks, providing language code conversions, file extension language detection, and command-line flag parsing through Cmdliner. It works with global configuration enums, file paths, and command-line arguments to support use cases like selecting compilation targets based on language codes, validating file inputs, and toggling execution modes via CLI flags. Specific functions enable retrieving the executable's directory, defining command metadata, and structuring command-line help sections.",
      "description_length": 535,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Global",
      "library": "catala.catala_utils",
      "description": "This module defines global configuration flags and types used across the compiler, including input sources, backend languages, and output formatting options. It provides functions to create and enforce global settings like debug mode, color output, and message formats, primarily initialized from command-line arguments. These configurations influence compiler behavior such as error reporting, language selection, and file path handling during execution.",
      "description_length": 455,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils",
      "library": "catala.catala_utils",
      "description": "This module provides focused utilities for compiler development tasks such as command-line parsing, source position tracking, string manipulation, and structured message handling. It operates on data types including strings, maps, file paths, and abstract syntax tree annotations, supporting concrete use cases like language code conversion, error reporting with source references, and generating unique identifiers. Key functions enable command metadata definition, UTF-8 encoding transformations, Levenshtein-based suggestion matching, and structured logging with color support.",
      "description_length": 580,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Runtime_jsoo.Runtime",
      "library": "catala.runtime_jsoo",
      "description": "This module bridges OCaml and JavaScript representations of runtime values, converting dates to and from ISO8601 strings, translating duration types between the two runtimes, and handling errors by mapping specific OCaml exceptions to JavaScript errors. It provides direct access to an event manager for log retrieval and reset, and ensures precise type conversion for interoperability in a JavaScript environment. Use cases include logging event management, date and duration serialization for web APIs, and safe execution of OCaml functions that may fail with domain-specific errors.",
      "description_length": 585,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Runtime_jsoo",
      "library": "catala.runtime_jsoo",
      "description": "This module converts dates and durations between OCaml and JavaScript representations, maps OCaml exceptions to JavaScript errors, and provides access to an event manager for logging and resetting events. It operates on date, duration, and error types, enabling precise type conversion for interoperability in JavaScript environments. Concrete use cases include managing log events, serializing dates for web APIs, and safely executing OCaml functions that may raise domain-specific errors.",
      "description_length": 490,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Literate.Pygment_lexers.Internal",
      "library": "catala.literate",
      "description": "This module defines several string values used for syntax highlighting configurations and provides `file_chunks`, which splits a file path into a list of strings for processing, and `file_list`, a list of file paths. It works directly with string and list data types, focusing on parsing and organizing file content for further analysis. Concrete use cases include preparing source code files for syntax highlighting or static analysis by breaking them into manageable parts.",
      "description_length": 475,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Literate.Pygmentize",
      "library": "catala.literate",
      "description": "Executes the `pygmentize` binary with support for Catala syntax highlighting. Reads command-line arguments directly from `Sys.argv` and processes input accordingly. Useful for integrating syntax highlighting into documentation or code display tools.",
      "description_length": 249,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Literate.Pygment_lexers",
      "library": "catala.literate",
      "description": "This module provides functions to process and analyze source code files, including reading file contents, computing hashes, and determining file sizes. It operates on string and list data types, focusing on extracting and transforming file data for syntax highlighting or static analysis. Concrete use cases include preparing files for further processing by parsing their content or metadata.",
      "description_length": 392,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Literate.Latex",
      "library": "catala.literate",
      "description": "This module translates Catala source code and legislative text into a formatted LaTeX document for legal professionals. It provides `wrap_latex` to enclose content in a LaTeX document structure and `ast_to_latex` to convert abstract syntax trees into LaTeX output. It operates on Catala ASTs and string lists, targeting legal documentation generation in a specified language.",
      "description_length": 375,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Literate.Literate_common",
      "library": "catala.literate",
      "description": "This module provides functions for generating localized literals, such as titles and disclaimers, based on the target backend language. It includes utilities for running external tools like `pandoc` and `pygmentize` to format and highlight code, as well as checking line lengths in source files. These operations support generating and validating documentation and code output in HTML, LaTeX, and language-specific formats.",
      "description_length": 423,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Literate.Html",
      "library": "catala.literate",
      "description": "This module generates HTML documents that interleave source code with legislative text for legal professionals. It provides `wrap_html` to enclose content in an HTML structure and `ast_to_html` to convert a program's abstract syntax tree into formatted HTML, specifically highlighting code and law text side by side. Use cases include producing readable legal-code documentation and generating compliance reports with executable code embedded.",
      "description_length": 443,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Literate",
      "library": "catala.literate",
      "description": "This module supports generating and processing formatted documentation that combines source code with legislative text. It includes functions to convert abstract syntax trees into HTML or LaTeX, wrap content in document structures, and handle language-specific formatting. Key use cases involve creating compliance reports, legal-code documentation, and syntax-highlighted outputs tailored for legal professionals.",
      "description_length": 414,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.Ast.VarName.Set",
      "library": "catala.scalc",
      "description": "This module offers set algebra operations (union, intersection, difference), membership testing, and element retrieval (min, max, choose) for collections of variable names used in AST analysis. It supports traversal via iteration and filtering, along with conversion utilities for transforming sets to ordered sequences or lists, enabling integration with linear data processing pipelines. Typical applications include tracking variable dependencies in AST nodes, analyzing scope-bound identifiers, or combining variable sets from nested expressions.",
      "description_length": 550,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.Ast.VarName.Map",
      "library": "catala.scalc",
      "description": "This module implements a polymorphic key-value map structure with variable names as keys, supporting operations like merging, filtering, and transforming bindings through combinators and traversal functions. It works with maps that associate `Scalc.Ast.VarName.t` keys to arbitrary values, enabling key-based queries, set-theoretic operations, and conversions to sequences or lists. Typical use cases include managing variable bindings in symbolic computations, generating human-readable representations of variable sets, and combining or partitioning maps during expression evaluation or analysis.",
      "description_length": 598,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.Ast.FuncName.Set",
      "library": "catala.scalc",
      "description": "This module provides a suite of operations for managing immutable sets of function names, supporting standard set manipulations (union, intersection, difference, subset checks) alongside element transformations, filtering, and aggregation (e.g., min, max). It interoperates with sequences and lists, enabling conversions and bulk updates, which is particularly useful for functional workflows like static analysis or processing hierarchical code structures where immutable, set-based reasoning is required.",
      "description_length": 506,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.Ast.VarName",
      "library": "catala.scalc",
      "description": "This module defines a typed representation for variable names in an abstract syntax tree, with operations for creating fresh variables, comparing and hashing them, and converting to strings or formatted output. It includes Set and Map submodules for efficient set-theoretic operations and key-value associations, specifically tailored for analyzing and manipulating collections of variables in AST nodes. Concrete use cases include tracking variable usage across expressions, managing scoped identifiers during evaluation, and combining variable sets from nested language constructs.",
      "description_length": 583,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.Ast.FuncName",
      "library": "catala.scalc",
      "description": "This module implements uniquely identifiable function names with positional source code metadata, supporting operations for creating fresh names, comparing and hashing values, and converting to strings or formatted output. It provides equality checks, ordering relations, and efficient set and map structures tailored for static analysis tasks like tracking function definitions and references. The Set and Map submodules enable set-theoretic operations and keyed lookups, particularly useful in analyses requiring precise, immutable collections of function names with provenance.",
      "description_length": 580,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scalc.To_r",
      "library": "catala.scalc",
      "description": "Converts a lambda calculus program into executable R code by formatting it according to R syntax rules. It takes a formatter, a lambda calculus AST, and a topological ordering of type dependencies to resolve dependencies correctly. Useful for compiling functional programs into R scripts that preserve the original program's semantics.",
      "description_length": 335,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.Print",
      "library": "catala.scalc",
      "description": "This module formats abstract syntax trees into human-readable output. It provides functions to print individual code items and entire programs using OCaml's standard formatting library. Use it to generate readable representations of parsed programs or for debugging during compilation.",
      "description_length": 285,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.To_python",
      "library": "catala.scalc",
      "description": "Converts a lambda calculus program into executable Python code by formatting it with proper indentation and dependencies. It takes a formatter, a lambda calculus AST, and a topological ordering of type dependencies to ensure valid Python output. Useful for compiling functional programs to Python for execution or integration with Python-based tools.",
      "description_length": 350,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.Ast",
      "library": "catala.scalc",
      "description": "This module represents the abstract syntax tree for a calculus language, including expressions, statements, and program constructs. It defines data types for variables, functions, control flow, and error handling, along with metadata such as source positions. It is used for parsing, analyzing, and transforming structured code, particularly in static analysis and compilation tasks.",
      "description_length": 383,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.To_c",
      "library": "catala.scalc",
      "description": "Converts a lambda calculus program into a syntactically correct C89 program. It takes a formatter, a lambda calculus AST, and a topological ordering of type dependencies to generate C code that preserves the original program's semantics. Useful for compiling functional code to C for execution or integration with C-based systems.",
      "description_length": 330,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.From_lcalc",
      "library": "catala.scalc",
      "description": "Translates Lcalc programs into Scalc programs, applying transformations controlled by a configuration. Handles higher-order operators, dead value assignments, and struct literal initialization based on target language requirements. Useful for compiling functional code to languages with restrictions like C or Python.",
      "description_length": 317,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc",
      "library": "catala.scalc",
      "description": "This module provides translation and representation capabilities for a calculus language. It includes an abstract syntax tree for code constructs, functions to convert programs to C, Python, and R, and facilities to print formatted code. It is used to compile functional programs into multiple target languages while preserving semantics and handling language-specific constraints.",
      "description_length": 381,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Driver.Commands",
      "library": "catala.driver",
      "description": "This module implements helper functions for handling output files and formatting, resolving scope and variable identifiers, and defining built-in command-line subcommands. It works with file options, formatting channels, abstract syntax trees, and command-line interface structures. Concrete use cases include opening output files with optional extensions, formatting output streams, and mapping user-provided names to internal scope or variable identifiers during command execution.",
      "description_length": 483,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Driver.Passes",
      "library": "catala.driver",
      "description": "This module implements compiler passes for processing programs through various stages of translation and optimization. It operates on abstract syntax trees (ASTs) defined in different intermediate languages (Surface, Desugared, Scopelang, Dcalc, Lcalc, Scalc) and handles tasks like parsing, desugaring, type checking, optimization, and code generation. Concrete use cases include transforming source code into typed intermediate representations, optimizing expressions, resolving dependencies, and preparing programs for execution or analysis.",
      "description_length": 544,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Driver.Plugin",
      "library": "catala.driver",
      "description": "Registers command-line plugins with documentation and options parsing. Works with command-line arguments and global configuration structures. Used to extend the CLI with new subcommands that share the global configuration logic.",
      "description_length": 228,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Driver",
      "library": "catala.driver",
      "description": "This module orchestrates program execution from entry point to command-line extension, handling source-to-source compilation stages via AST transformations, output management, and plugin registration. It operates on abstract syntax trees across multiple intermediate languages, file options, and command-line structures. Concrete use cases include parsing and optimizing source code through typed intermediate representations, managing output streams with custom formatting, and extending the CLI with documented subcommands that integrate with global configuration.",
      "description_length": 566,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dcalc.Ast",
      "library": "catala.dcalc",
      "description": "Represents the structure of expressions and statements in a calculus-based intermediate language. Includes operations for constructing, traversing, and transforming abstract syntax trees with typed nodes. Used to model program logic for analysis, optimization, and code generation in compiler pipelines.",
      "description_length": 303,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dcalc.Invariants",
      "library": "catala.dcalc",
      "description": "This module enforces structural invariants on typed abstract syntax trees by validating properties such as correct variable scoping, consistent type annotations, and proper expression nesting. It operates on `Shared_ast.typed Dcalc.Ast.program` data structures, ensuring they conform to expected formats. Concrete use cases include verifying program correctness during testing and catching malformed ASTs before compilation proceeds.",
      "description_length": 433,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dcalc.From_scopelang",
      "library": "catala.dcalc",
      "description": "Translates programs from the scope language into the default calculus representation. Works with abstract syntax trees (ASTs) defined in both the Scopelang and Dcalc modules. Useful for converting high-level scope expressions into a lower-level calculus form for further processing or evaluation.",
      "description_length": 296,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dcalc",
      "library": "catala.dcalc",
      "description": "The `Ast` module defines data structures and operations for building, traversing, and transforming typed abstract syntax trees used in a calculus-based intermediate language. `From_scopelang` translates programs written in the scope language into this calculus representation, enabling high-level expressions to be converted into a form suitable for analysis and code generation. `Invariants` checks and enforces correctness properties on these typed ASTs, such as valid scoping and consistent typing, ensuring programs meet structural requirements before further processing.",
      "description_length": 575,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_web.To_jsoo",
      "library": "api_web",
      "description": "This module formats type and structure names into JavaScript-compatible identifiers, handling conversions for structs, enums, literals, and variables. It processes Catala AST elements like `Shared_ast.typ`, `Shared_ast.StructName.t`, and `Shared_ast.EnumName.t`, generating properly cased names for use in `js_of_ocaml` wrappers. Functions like `format_typ`, `format_struct_name`, and `format_enum_name` are used to generate JavaScript bindings, while `format_to_js` and `format_of_js` handle serialization and deserialization logic for type conversions in client-side execution.",
      "description_length": 579,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_web",
      "library": "api_web",
      "description": "This module generates JavaScript-compatible identifiers and serialization logic for Catala AST elements, including structs, enums, and types. It provides functions to convert and format these elements into JavaScript bindings, supporting client-side execution via `js_of_ocaml`. Key use cases include generating JS names from Catala definitions and handling type conversion during runtime.",
      "description_length": 389,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc.Closure_conversion",
      "library": "catala.lcalc",
      "description": "This module transforms programs into an environment-passing style by converting closures into explicit tuple-based environments, using the `TClosureEnv` type to represent captured variables. It generates top-level function definitions for all closures and performs closure hoisting. This enables compilation of higher-order functions by making closure environments explicit and handling their propagation.",
      "description_length": 405,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lcalc.Ast",
      "library": "catala.lcalc",
      "description": "Represents terms and expressions in the lambda calculus using algebraic data types. Provides constructors for variables, abstractions, and applications, along with functions to manipulate and traverse these structures. Useful for implementing interpreters, type checkers, or compilers targeting lambda calculus.",
      "description_length": 311,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc.To_ocaml",
      "library": "catala.lcalc",
      "description": "This module translates lambda calculus programs into valid OCaml code by formatting variables, types, and program structures. It handles naming conventions, type formatting, and program structure to ensure compatibility with OCaml syntax, including proper escaping of keywords and parenthesization. Concrete use cases include compiling lambda calculus expressions into executable OCaml modules and generating OCaml type definitions from structured and enumerated types.",
      "description_length": 469,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc.Compile_without_exceptions",
      "library": "catala.lcalc",
      "description": "Translates programs from the default calculus to the lambda calculus, using an option monad to manage empty default terms. It operates on abstract syntax trees of both calculi. This enables compilation to legacy languages lacking exception support by eliminating default terms in a structured way.",
      "description_length": 297,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc.Monomorphize",
      "library": "catala.lcalc",
      "description": "This function processes a typed Lcalc program to eliminate polymorphism by generating monomorphic versions of functions based on their type usage. It returns the transformed program alongside a list of dependency graph vertices representing the new function instantiations. Use this during compilation to enable efficient code generation by resolving type abstractions into concrete types.",
      "description_length": 389,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc.Compile_with_exceptions",
      "library": "catala.lcalc",
      "description": "Translates programs from the default calculus to the lambda calculus, using exceptions to manage cases with empty default terms. Operates on abstract syntax trees (ASTs) of both the source and target calculi. Useful for implementing compilers or interpreters that require a transformation from a default calculus representation to a lambda calculus equivalent.",
      "description_length": 360,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc.From_dcalc",
      "library": "catala.lcalc",
      "description": "Translates programs from the default calculus to the lambda calculus, handling empty default terms either through exceptions or an option monad. Works with abstract syntax trees (ASTs) of both calculi, preserving their structure during translation. Useful for compiling functional code to environments that lack exception handling, such as certain legacy languages.",
      "description_length": 365,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc",
      "library": "catala.lcalc",
      "description": "This module provides functionality for translating and transforming programs between different calculi, primarily focusing on lambda calculus representations. It supports concrete operations such as closure conversion, monomorphization, and compilation to OCaml code, working with abstract syntax trees and typed program structures. Use cases include implementing compilers for functional languages, translating to legacy systems without exception support, and generating executable OCaml code from lambda calculus expressions.",
      "description_length": 527,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.TopdefName.Map",
      "library": "catala.shared_ast",
      "description": "This module suite provides functional map operations for managing key-value associations where keys are top-level definition names from a shared AST. It supports structural transformations like merging, filtering, and bidirectional iteration, alongside safe querying via optional returns and predicate-driven extraction of elements. Typical applications include symbol table management during semantic analysis, tracking top-level declarations across ASTs, and pretty-printing mappings for debugging or code generation tasks.",
      "description_length": 525,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StructName.Set",
      "library": "catala.shared_ast",
      "description": "This module provides standard set operations like union, intersection, difference, and membership checks for collections of structure names, supporting transformations through mapping, folding, and filtering. It works with immutable sets of `Shared_ast.StructName.t` elements, enabling conversions to and from lists and sequences while maintaining efficient comparison and equality checks. These operations are particularly useful in AST analysis tasks requiring structured name tracking, such as resolving dependencies or validating hierarchical relationships across AST nodes.",
      "description_length": 578,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Type.Map",
      "library": "catala.shared_ast",
      "description": "This module implements ordered map operations for key-value stores where keys are structured types, supporting insertion, deletion, ordered traversal, and transformation via functions like `merge` and `filter`. It works with maps that maintain key order using a comparator, enabling efficient queries for extremal bindings (min/max) and sequence conversions. Typical applications include merging disjoint type mappings, generating human-readable representations with custom formatting, and processing type-annotated AST nodes in a deterministic order.",
      "description_length": 551,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Qident.Set",
      "library": "catala.shared_ast",
      "description": "This module provides operations for managing ordered collections of module identifiers and paths, supporting set arithmetic, element-wise transformations, and ordered sequence conversions. It works with sets of qualified identifiers (`Shared_ast.Qident.t`) and their interactions with sequences, lists, and comparison predicates. Typical applications include dependency tracking in multi-file projects, path resolution in module systems, and static analysis of inter-compilation unit references.",
      "description_length": 495,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StructField.Set",
      "library": "catala.shared_ast",
      "description": "This module implements a functional set abstraction for managing collections of structured AST fields, enabling efficient membership checks, union/intersection/difference operations, and extremum value retrieval. It operates on immutable sets of `StructField` elements while supporting bidirectional transformations with sequences and lists, facilitating iterative processing and bulk construction. Typical applications include static analysis of record-like data structures, dependency tracking in field declarations, or normalizing AST fragments during code transformation passes.",
      "description_length": 582,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Var.Map",
      "library": "catala.shared_ast",
      "description": "This module implements a polymorphic map specialized for variable bindings in AST manipulations, using variables as keys and supporting typed values. It provides standard map operations like insertion, lookup, folding, and key/value extraction, tailored for AST transformations and analysis. Concrete use cases include tracking variable definitions, substitutions, and type mappings across different AST structures.",
      "description_length": 415,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.LabelName.Set",
      "library": "catala.shared_ast",
      "description": "This module implements standard set operations\u2014union, intersection, difference, filtering, and subset checks\u2014for collections of label names, leveraging the `Shared_ast.LabelName.t` type. It supports conversions between sets, lists, and sequences, with utilities for safe element access, reverse-order processing, and bulk additions from sequences. These capabilities are particularly useful in AST analysis or transformation tasks requiring efficient membership checks, uniqueness enforcement, or ordered traversal of label-based identifiers.",
      "description_length": 542,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.EnumConstructor.Set",
      "library": "catala.shared_ast",
      "description": "This module offers standard set operations like union, intersection, and difference for managing collections of `Shared_ast.EnumConstructor.t` elements, with support for membership checks, filtering, and predicate-based element retrieval. It facilitates conversions between sets and sequential structures such as lists and sequences, enabling efficient iteration and bulk manipulation. Typical use cases include analyzing or transforming AST fragments that reference enum constructors, such as aggregating constructors across type definitions or validating constructor usage patterns in expressions.",
      "description_length": 599,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StateName.Set",
      "library": "catala.shared_ast",
      "description": "This module provides standard set operations\u2014including union, intersection, difference, and subset checks\u2014for managing collections of state names, alongside functional manipulations like filtering, partitioning, and element selection. It supports conversions to and from lists and ordered sequences, enabling efficient iteration and ordered processing of state identifiers, which is particularly useful in AST transformations for compilers or state machine management. The module handles sets of `Shared_ast.StateName.t` elements while interfacing with sequences and lists to streamline tasks like variable tracking or state transition analysis.",
      "description_length": 645,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StructName.Map",
      "library": "catala.shared_ast",
      "description": "This module implements ordered maps with keys based on structural names from a shared AST representation, supporting operations like union, merge, and partitioning alongside value transformations and range-based queries. It provides utilities for converting between maps and sequences, extracting min/max entries, and custom formatting of contents using user-defined separators and printers. Such functionality is particularly useful in AST analysis phases for aggregating named metadata, resolving symbol hierarchies, or generating structured reports from compiler intermediate representations.",
      "description_length": 595,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.TopdefName.Set",
      "library": "catala.shared_ast",
      "description": "This module implements a functional set abstraction for managing collections of top-level definition names (`TopdefName.t`), offering operations like membership checks, insertion/deletion, set algebra (union, intersection, difference), and comparisons. It supports transformations via `map`, `fold`, and `iter`, along with utilities for converting between sets, lists, and sequences. These sets are used in compiler contexts to track or analyze top-level declarations, resolve scoping conflicts, or enforce uniqueness constraints across ASTs.",
      "description_length": 542,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.Print.UserFacing",
      "library": "catala.shared_ast",
      "description": "This module provides localized printing functions for specific data types such as unit, boolean, integer, decimal, money, date, and duration, all tied to runtime values. It also includes functions to print literals and expressions in a user-readable format, using a formatter and a specified backend language. Concrete use cases include displaying evaluation results or intermediate values to end users in a localized manner, and converting literals to strings for reporting or serialization.",
      "description_length": 492,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.StateName.Map",
      "library": "catala.shared_ast",
      "description": "This module facilitates efficient management of associative maps with keys of type `Shared_ast.StateName.t` and arbitrary value types, supporting operations like creation, insertion, deletion, and transformation of entries, as well as merging, filtering, and comparison between maps. It includes utilities for querying bindings, extracting min/max elements, converting maps to sequences or lists, and custom formatting of contents. These capabilities are particularly useful for tasks such as tracking state transitions, aggregating state-associated metadata, or enabling structured data interchange in compiler or analysis tools.",
      "description_length": 630,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.EnumConstructor.Map",
      "library": "catala.shared_ast",
      "description": "This module supports functional map manipulation with keys representing enum constructors from a shared abstract syntax tree, enabling operations like keyed lookups, value transformations, and set-theoretic unions over polymorphic value types. It provides utilities for sequence conversion, ordered traversal, and structured pretty-printing of key-value pairs, tailored for scenarios requiring precise association between AST nodes and metadata or annotations. Common applications include tracking constructor-specific attributes during type checking or generating human-readable representations of AST fragments in compiler toolchains.",
      "description_length": 636,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.LabelName.Map",
      "library": "catala.shared_ast",
      "description": "This module implements standard map operations for key-value pairs where keys are `Shared_ast.LabelName.t` and values are polymorphic, enabling creation, modification, querying, and traversal through functions like insertion, deletion, merging, filtering, and safe access via optional return types. It supports advanced manipulations such as key-based splitting, extremal element retrieval (e.g., min/max), and bidirectional conversion with sequences, alongside traversal strategies for ordered or conditional transformations. The inclusion of formatting utilities allows structured, human-readable output of keys, bindings, or entire maps, making it particularly effective for managing AST metadata (e.g., symbol tables, configuration mappings)",
      "description_length": 745,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.Var.Set",
      "library": "catala.shared_ast",
      "description": "This module provides standard set operations like adding, removing, and checking membership of variables, as well as set union, difference, and iteration. It works with sets of `'e Shared_ast.Var.var`, allowing manipulation of variable collections parameterized over different AST types. Concrete use cases include tracking bound variables, managing free variables in expressions, and performing set-based analysis during type checking or transformation passes.",
      "description_length": 461,
      "index": 93,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.StructField.Map",
      "library": "catala.shared_ast",
      "description": "This module provides a suite of operations for managing associative collections where struct fields act as keys, enabling efficient insertion, lookup, traversal, and transformation of key-value pairs. It supports structured data manipulation tasks such as merging maps, splitting bindings, and converting between lists or sequences, while also offering customizable formatting for human-readable representations. These capabilities are particularly useful in contexts requiring symbolic processing of structured data, such as compiler intermediate representations or configuration management systems.",
      "description_length": 600,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Qident.Map",
      "library": "catala.shared_ast",
      "description": "This module provides associative map operations for managing immutable collections of key-value pairs where keys are qualified identifiers representing module paths. It supports ordered key-based manipulation through insertion, deletion, traversal, and set-theoretic combinations, along with transformations that filter, split, or convert maps to ordered sequences. The structure is particularly useful for analyzing or organizing hierarchical module dependencies in compiler frontends or static analysis tools.",
      "description_length": 511,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Print.ExprGen",
      "library": "catala.shared_ast",
      "description": "This module provides a function to print marked expressions with generic type parameters using OCaml's Format module. It operates on expressions defined in the Shared_ast__.Definitions module, specifically `base_gexpr` with attached marks. A concrete use case is pretty-printing intermediate AST representations during compilation or debugging.",
      "description_length": 344,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.EnumName.Map",
      "library": "catala.shared_ast",
      "description": "This module implements associative maps with keys of type `Shared_ast.EnumName.t` paired with arbitrary values, supporting operations like union, fold, filter, and ordered traversal. It facilitates tasks such as merging disjoint key sets, converting lists to maps, and generating formatted representations for debugging or serialization, with specialized functions for extracting keys/values and splitting maps based on key ranges.",
      "description_length": 431,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.ScopeName.Map",
      "library": "catala.shared_ast",
      "description": "This module provides functional map operations for manipulating ordered associations between `ScopeName` keys and arbitrary values, including creation, modification, querying, and ordered traversal via folds, merges, and filters. It supports conversions to lists, union operations, and structured formatting with OCaml's `Format` module, tailored for managing hierarchical scope data in ASTs\u2014such as variable binding resolution, scope analysis, or pretty-printing scoped metadata.",
      "description_length": 480,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.ScopeVar.Set",
      "library": "catala.shared_ast",
      "description": "This module provides functional set operations\u2014union, intersection, difference, and subset checks\u2014for managing collections of scoped variables (`Shared_ast.ScopeVar.t`) in abstract syntax trees. It includes utilities for sequence conversion, filtering, partitioning, and element retrieval (e.g., min/max), supporting tasks like analyzing variable scope relationships or restructuring AST components through precise set manipulations.",
      "description_length": 433,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.RuleName.Set",
      "library": "catala.shared_ast",
      "description": "This module manipulates collections of rule names using standard set operations like union, intersection, and subset checks, while supporting element retrieval (min/max/choose), filtering, and partitioning. It operates on sets of `Shared_ast.RuleName.t` values and facilitates conversions between these sets and sequences or lists. Typical use cases involve tracking active rules in static analysis, managing transformation passes over ASTs, or validating rule dependencies in compiler workflows.",
      "description_length": 496,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Expr.Box",
      "library": "catala.shared_ast",
      "description": "This module provides operations for constructing and manipulating boxed expressions with separate annotations, using `Bindlib` for binding management. It supports creating boxed expressions with `app0` to `app3`, applying functions over multiple boxed terms with `appn`, `app1n`, and `app2n`, and inspecting free variables with `fv` and `assert_closed`. These functions are used to build and validate complex, annotated expression trees while deferring annotation injection until necessary.",
      "description_length": 490,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.ScopeName.Set",
      "library": "catala.shared_ast",
      "description": "This module provides set-theoretic operations like union, intersection, and difference alongside sequence conversions for managing collections of scope identifiers. It operates on sets of `Shared_ast.ScopeName.t` elements, which represent unique named scopes, and supports functional transformations with safe access patterns via optional return values. Typical applications include tracking declared identifiers in different scopes, validating name uniqueness, and converting between iterative representations like lists or sequences for analysis or traversal tasks.",
      "description_length": 567,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.EnumName.Set",
      "library": "catala.shared_ast",
      "description": "This module provides functions for standard set operations like union, intersection, and difference, as well as filtering, partitioning, and element comparison, specifically for collections of enumeration names. It works with sets containing `Shared_ast.EnumName.t` elements, supporting conversions to and from lists and sequences while maintaining ordered traversal and functional transformation patterns. These operations are useful for managing disjoint sets of named enumerations in AST analysis, such as tracking declared identifiers, resolving naming conflicts, or validating subset relationships during type checking.",
      "description_length": 624,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Print.ExprDebugParam",
      "library": "catala.shared_ast",
      "description": "This module provides custom formatting and preprocessing operations for printing expressions in a debug context. It works with generic expressions, variables, literals, and operators defined in the shared AST. Concrete use cases include selectively skipping subtrees during printing, customizing the display of specific nodes, and applying pre-processing transformations to expressions before output.",
      "description_length": 400,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Print.ExprConciseParam",
      "library": "catala.shared_ast",
      "description": "This module provides functions to print concise representations of expressions, variables, literals, and operators in a generic AST structure. It works with marked expressions, variables, and literals defined in `Shared_ast` and supports customization of printing behavior through a `bypass` function. Concrete use cases include generating readable output for debugging expressions or producing simplified code representations for user-facing tools.",
      "description_length": 449,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Typing.Env",
      "library": "catala.shared_ast",
      "description": "This module manages typing environments for type inference in a calculus with polymorphism and unification. It supports operations to add variables, top-level definitions, and scoped variables or structures to the environment, as well as opening scopes and dumping environment contents for debugging. It works directly with typed AST nodes, scoped variables, and naked types, primarily used during the type-checking phase of program analysis.",
      "description_length": 442,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.RuleName.Map",
      "library": "catala.shared_ast",
      "description": "This module provides functions for creating, modifying, and querying associative maps where keys are of type `Shared_ast.RuleName.t`, supporting operations like insertion, deletion, merging, filtering, and traversal. It works with map structures that associate `RuleName` keys with values of arbitrary types, offering additional capabilities such as extracting key-value bindings, converting between lists or sequences, and formatting contents for debugging. These operations are particularly useful in scenarios involving abstract syntax tree processing, where mappings between rule names and their associated data need to be efficiently managed and transformed.",
      "description_length": 663,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.ScopeVar.Map",
      "library": "catala.shared_ast",
      "description": "This module implements associative maps pairing `ScopeVar` keys with arbitrary values, supporting operations like lookup, union, list conversion, and bidirectional traversal. It provides utilities for safe value retrieval, ordered iteration, and structured transformations, with specialized formatting for AST debugging. These maps are used in compiler phases requiring precise variable scoping, such as type inference and code generation.",
      "description_length": 439,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.EnumConstructor",
      "library": "catala.shared_ast",
      "description": "This module manages enum constructors in a shared abstract syntax tree, providing operations to create, compare, and format them. It supports data types including constructor identifiers with positional information, enabling precise tracking and manipulation within ASTs. Concrete use cases include validating constructor usage in expressions, aggregating constructors across type definitions, and associating metadata with constructors during type checking.",
      "description_length": 458,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Operator",
      "library": "catala.shared_ast",
      "description": "This module defines a generalized algebraic data type (`t`) representing arithmetic, comparison, logical, and structural operations used across Catala's ASTs. It includes typed variants for monomorphic operations like `Not`, `And`, and `Eq`, polymorphic higher-order operations like `Map`, `Filter`, and `Reduce`, and overloaded/resolved arithmetic and comparison operations such as `Add`, `Sub`, `Lt`, and their resolved counterparts over integers, rationals, money, and durations. The module supports resolving operator overloads based on operand types, translating operators across compilation passes, and deriving operator names and types for use in type checking and code generation.",
      "description_length": 688,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Op",
      "library": "catala.shared_ast",
      "description": "This module defines a generalized operator type with classifications for monomorphic, polymorphic, overloaded, and resolved variants. It includes specific operations for arithmetic, comparison, date manipulation, type conversion, and collection transformations, with explicit variants for different operand types like integers, rationals, money, and durations. Concrete use cases include representing typed AST nodes for language expressions, enabling precise type handling during compilation or interpretation of domain-specific languages.",
      "description_length": 540,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.RuleName",
      "library": "catala.shared_ast",
      "description": "This module manages uniquely identified rule names with positional metadata, providing creation, comparison, and formatting operations. It supports concrete use cases like tracking source locations during parsing, ensuring referential consistency in AST transformations, and enabling precise error reporting for rule-based systems. The associated `Set` and `Map` submodules handle collections and mappings of these rule names, optimized for static analysis and compiler pipeline operations.",
      "description_length": 490,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Optimizations",
      "library": "catala.shared_ast",
      "description": "This module performs optimization passes on expressions and programs in default calculus and lambda calculus, specifically handling transformations like iota-reduction. It operates on generic AST structures defined in `Shared_ast`, including expressions and programs with specific type qualifiers such as monomorphic, polymorphic, resolved, and assertions. Concrete use cases include optimizing intermediate representations of programs during compilation to improve efficiency and reduce complexity.",
      "description_length": 499,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Scope",
      "library": "catala.shared_ast",
      "description": "This module provides operations to traverse, transform, and analyze scope structures in the shared AST, including mapping and folding over expressions within scope lets and code items. It works with scope bodies, code items, and variables, handling transformations that may involve type manipulation or variable translation. Concrete use cases include rewriting expressions within scopes, extracting free variables from scope constructs, and converting scope bodies to expressions during type checking or compilation passes.",
      "description_length": 524,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.ScopeName",
      "library": "catala.shared_ast",
      "description": "This module implements uniquely identifiable scopes with path-based hierarchies, combining module identifiers and positioned names. It supports scope creation with `fresh`, decomposition via `path` and `get_info`, and structural comparison with `compare`, `equal`, and `hash`. Direct applications include managing nested scopes in ASTs for binding resolution, ensuring unique scope names during type checking, and tracking source location metadata for error reporting.",
      "description_length": 468,
      "index": 115,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.Type",
      "library": "catala.shared_ast",
      "description": "This module provides operations for comparing, formatting, and checking structural equivalence and unifiability of type expressions, including handling polymorphic variants and nested function types. It works with marked type expressions built from constructs like `TArrow` and `TAny`, supporting both individual types and lists. Concrete use cases include type inference constraint solving, generating type signatures for AST nodes, and validating type compatibility during program transformation passes.",
      "description_length": 505,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Program",
      "library": "catala.shared_ast",
      "description": "This module provides operations to transform and traverse programs, manipulate declaration contexts, and extract scope bodies or expressions. It works with program structures containing expressions, types, and scopes, built from generic AST types defined in `Shared_ast`. Concrete use cases include rewriting expressions within a program, folding over code items or expressions, extracting the body of a specific scope, and converting a program into a single expression representing its main scope.",
      "description_length": 498,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.ScopeVar",
      "library": "catala.shared_ast",
      "description": "This module manages scoped variables in abstract syntax trees with operations for creating fresh variables, comparing and hashing them, and formatting or converting them to strings. It works with a unique type `t` paired with positional source information (`info`). Used in compiler phases like type inference and code generation to track and manipulate variables with precise scope resolution.",
      "description_length": 394,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.BoundList",
      "library": "catala.shared_ast",
      "description": "This module implements operations for traversing and transforming non-empty, ordered linked lists where each element binds a variable over the rest of the list. It works with three type parameters: the environment type `'e`, the element type `'elt`, and the final value type `'last`. Use this module to manipulate nested let-bindings or similar structures where variables are introduced sequentially and each scope depends on the previous.",
      "description_length": 439,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Qident",
      "library": "catala.shared_ast",
      "description": "This module represents qualified identifiers as pairs of module paths and local names, supporting comparison, equality checks, and formatting. It works with module names, identifier strings, and paths as lists of module names. Used for resolving cross-references between compilation units, tracking module dependencies, and enabling static analysis of modular codebases.",
      "description_length": 370,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StructName",
      "library": "catala.shared_ast",
      "description": "This module implements structural names for AST components with operations for comparison, hashing, and formatting. It works with unique identifiers and positioned strings to track structure names in ASTs. Concrete uses include managing named dependencies and validating hierarchical relationships during AST analysis.",
      "description_length": 318,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.EnumName",
      "library": "catala.shared_ast",
      "description": "This module implements unique identifiers for enumeration names with operations for comparison, hashing, and string conversion. It supports data structures like sets and maps for managing collections of enumeration names with efficient lookups, unions, and transformations. Used in AST analysis for tracking declared enums, resolving references, and validating uniqueness constraints across modules.",
      "description_length": 399,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Var",
      "library": "catala.shared_ast",
      "description": "This module represents variables in a generic AST, providing operations to create, compare, and hash variables, along with safe translation between different AST types. It supports working directly with variable sets and maps for managing collections, enabling precise tracking of bound and free variables during AST transformations. Concrete use cases include variable substitution, free variable analysis, and maintaining mappings between variables and their types or definitions.",
      "description_length": 482,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.LabelName",
      "library": "catala.shared_ast",
      "description": "This module represents labeled identifiers with positional metadata, supporting operations to create fresh labels, compare, hash, and format them. It works with abstract `t` values encapsulating label names and source positions, enabling precise tracking and manipulation in AST contexts. Use cases include managing field labels in record expressions, disambiguating constructor names in sum types, and preserving source location information during type checking or code generation.",
      "description_length": 482,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Typing",
      "library": "catala.shared_ast",
      "description": "This module implements type inference and checking for expressions and programs in the calculus, using unification with union-find data structures. It operates on abstract syntax trees (ASTs) annotated with marks and contexts, handling polymorphism and error terms during type analysis. Key functions include `expr` for inferring and annotating types, `check_expr` for efficient type validation without full annotation, and `program` for applying typing to entire programs, ensuring consistency across definitions and expressions.",
      "description_length": 530,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.TopdefName",
      "library": "catala.shared_ast",
      "description": "This module represents names of top-level definitions in a shared AST, each paired with a module path and positioned string. It provides operations for comparing, hashing, and formatting these names, along with constructing fresh instances from module paths and source positions. Used primarily in compiler phases for tracking and resolving top-level declarations across different ASTs, ensuring correct scoping and uniqueness.",
      "description_length": 427,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Interpreter",
      "library": "catala.shared_ast",
      "description": "Implements evaluation of expressions and programs in a custom calculus, handling operators, thunks, and scoped variables. Works with marked expressions, declaration contexts, and program structures defined in `Shared_ast`. Used to execute and test programs by interpreting function bodies with empty defaults and returning computed scope variable values.",
      "description_length": 354,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StateName",
      "library": "catala.shared_ast",
      "description": "This module manages state names in ASTs with operations for creating fresh identifiers, comparing and hashing values, and converting to strings or formatted output. It works with a unique type `t` wrapped with positional info metadata. Concrete use cases include tracking control flow states in compilers and managing state transitions in semantic analysis.",
      "description_length": 357,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StructField",
      "library": "catala.shared_ast",
      "description": "This module implements a typed identifier for structure fields in ASTs, carrying positional information for error reporting. It provides comparison, hashing, and formatting operations for structural analysis and code generation tasks. Used to track field declarations and references across different AST representations in language processing pipelines.",
      "description_length": 353,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Expr",
      "library": "catala.shared_ast",
      "description": "This module enables the construction, transformation, and analysis of generic expressions with embedded metadata, such as variables, tuples, arrays, and control structures. It supports typed AST manipulations through Bindlib-based binding and substitution, facilitating tasks like variable scoping, term comparison, and free variable tracking. Key use cases include compiler passes requiring precise type handling, source location management, and structural optimizations on expression trees.",
      "description_length": 492,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain.G.E",
      "library": "explain",
      "description": "This module represents directed edges in a persistent graph structure, where each edge has a source and destination vertex along with a label. It provides operations to create edges with specified vertices and labels, and to access the components of existing edges. Concrete use cases include modeling relationships between nodes in a graph, such as control flow edges in a compiler or dependency links in a build system.",
      "description_length": 421,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain.G.V",
      "library": "explain",
      "description": "This module defines a labeled vertex type for a persistent directed graph, where each vertex holds a label of type `Explain.V.t`. It provides operations to create vertices, retrieve their labels, and compare, hash, or check equality of vertices based on their labels. Concrete use cases include representing nodes in a control flow graph or dependency graph where each node has a distinct, meaningful label.",
      "description_length": 407,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain.Env",
      "library": "explain",
      "description": "This module manages a mapping from variables to expressions and elements, supporting operations to add, find, and combine environments. It works with typed expressions and annotations defined in the `Shared_ast` module, using a variable map structure. Use cases include tracking variable bindings during program analysis and merging environments in a typed calculus context.",
      "description_length": 374,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain.E",
      "library": "explain",
      "description": "Handles comparison and default initialization of structured explanation data. Works with records containing an optional hand-side indicator and a boolean condition. Useful for sorting and initializing explanation states in logic evaluation systems.",
      "description_length": 248,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain.V",
      "library": "explain",
      "description": "This module implements comparison, hashing, equality checking, and formatting for expressions annotated with marks, specifically working with generalized expressions and their marked versions. It enables efficient structural comparison and serialization of abstract syntax tree nodes used in formal verification or compilation pipelines. Concrete use cases include normalizing expressions for equivalence checks and preparing AST nodes for debugging output or storage.",
      "description_length": 468,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain.GTopo",
      "library": "explain",
      "description": "Traverses graph vertices using fold and iter, applying functions to each node. Works with graph structures defined in Explain.G and their vertex types. Useful for analyzing or transforming graph-based data, such as dependency graphs or control flow representations.",
      "description_length": 265,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain.G",
      "library": "explain",
      "description": "This module implements a persistent directed graph with labeled vertices and edges, offering operations to construct, modify, and analyze graph properties such as vertex degrees, edge counts, and adjacency relationships. It supports functional transformations like vertex and edge iteration, mapping, and folding, along with precise edge removal and traversal of successor and predecessor nodes, making it suitable for modeling control flow or dependency graphs in program analysis and similar applications.",
      "description_length": 507,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain",
      "library": "explain",
      "description": "This module provides operations for program analysis and transformation, including environment management for variable mappings, lazy expression evaluation, and graph manipulation for control flow modeling. It works with annotated abstract syntax trees and typed graph structures, supporting formal verification, dependency analysis, and visualization through DOT format rendering of constructed graphs.",
      "description_length": 403,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification.Io.MakeBackendIO",
      "library": "catala.verification",
      "description": "This module implements IO operations for interacting with a proof backend, including initializing the backend, translating expressions into the backend's encoding, and checking verification conditions. It works with shared AST structures, backend-specific contexts, and models, handling translation and solving workflows. Concrete use cases include encoding and validating expressions in a solver like Z3, and generating error messages from failed verification attempts.",
      "description_length": 470,
      "index": 139,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Verification.Z3backend.Io",
      "library": "catala.verification",
      "description": "This module handles the translation of expressions into Z3 solver constraints, manages solver contexts, and performs verification condition checking. It operates on types like `backend_context`, `vc_encoding`, and `model`, working directly with `Shared_ast` and `Dcalc.Ast.expr` structures. Concrete use cases include encoding and validating verification conditions in a solver-specific format, and printing counterexamples when verification fails.",
      "description_length": 448,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification.Solver",
      "library": "catala.verification",
      "description": "Solves verification conditions by dispatching them to appropriate proof backends. Works with declaration contexts and lists of verification conditions. Used to validate program correctness during static analysis.",
      "description_length": 212,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification.Globals",
      "library": "catala.verification",
      "description": "This module manages global configuration settings for a verification system using mutable references. It provides `setup` to initialize verification options, `optimize` to check optimization status, and `disable_counterexamples` to control counterexample generation. These functions are used to configure verification behavior across different analysis phases.",
      "description_length": 360,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification.Io",
      "library": "catala.verification",
      "description": "Implements IO operations for proof backends, including initialization, expression translation, and verification condition checking. It works with abstract syntax trees, backend-specific contexts, and models. Used to encode expressions for solvers like Z3 and generate error messages from failed verification attempts.",
      "description_length": 317,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification.Z3backend",
      "library": "catala.verification",
      "description": "This module translates expressions into Z3 solver constraints, manages solver contexts, and checks verification conditions. It operates on `backend_context`, `vc_encoding`, and `model` types, working directly with `Shared_ast` and `Dcalc.Ast.expr` structures. It is used to encode and validate verification conditions in a solver-specific format and to print counterexamples when verification fails.",
      "description_length": 399,
      "index": 144,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Verification.Conditions",
      "library": "catala.verification",
      "description": "This module generates verification conditions from scope definitions in a program. It works with types like `verification_condition`, which includes guards, kinds, assertions, scopes, and variables with positions. Concrete use cases include analyzing program variables to ensure they never return empty or conflicting errors, either globally or within specific scopes.",
      "description_length": 368,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Verification",
      "library": "catala.verification",
      "description": "This module coordinates program verification through condition generation, solver interaction, and global configuration. It processes verification conditions derived from program scopes, configures analysis settings, and interfaces with proof backends like Z3 to validate correctness and produce counterexamples. Key data structures include verification conditions, backend contexts, and solver expressions, used in static analysis to enforce program invariants and detect errors.",
      "description_length": 480,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.ExceptionsDependencies.E",
      "library": "catala.desugared",
      "description": "This module defines directed edges labeled with exception dependency information for a persistent graph structure. It supports creating edges between vertices with specific labels, comparing edges, and retrieving source, destination, and label data. It is used to model dependencies between exceptions in a desugared OCaml program, enabling analysis of exception propagation paths.",
      "description_length": 381,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast.ScopeDef.Set",
      "library": "catala.desugared",
      "description": "This module implements set-theoretic operations like membership testing, union, intersection, and difference for collections of scope definitions, which represent variables or inputs within a desugared abstract syntax tree. It supports conversions to ordered sequences, filtering, and partitioning, leveraging a consistent ordering of elements to enable deterministic analysis. These capabilities are particularly useful for static analysis tasks such as tracking variable dependencies, resolving input references across nested scopes, or identifying overlapping definitions in intermediate states.",
      "description_length": 598,
      "index": 148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Desugared.Dependency.ScopeDependencies.V",
      "library": "catala.desugared",
      "description": "This module defines vertices for a persistent graph structure, where each vertex has a unique label type and supports comparison, hashing, and equality checks. It provides operations to create vertices from labels and retrieve their labels. Concrete use cases include representing named program scopes or variables as nodes in a dependency graph for analysis or transformation tools.",
      "description_length": 383,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast.ScopeDef.Map",
      "library": "catala.desugared",
      "description": "This module implements a finite map structure with keys representing scope-bound definitions (variables or subscope inputs) in a desugared AST. It supports precise manipulation through creation, modification, and querying operations, along with ordered traversal and merging capabilities. The module also facilitates pretty-printing of key-value pairs, enabling use cases like static analysis, transformation passes, and debugging tools that require structured mapping between scope definitions and their associated data.",
      "description_length": 521,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast.AssertionName.Map",
      "library": "catala.desugared",
      "description": "This module manipulates ordered maps binding assertion names to arbitrary values, supporting efficient key-based queries, ordered traversal, and structural transformations. It combines standard map operations like insertion and union with ordered map capabilities such as sorted binding retrieval, key-range splitting, and min/max selection. These maps are used to manage assertion metadata in desugared program representations, with utilities for pretty-printing and comparing structured data during analysis or compilation tasks.",
      "description_length": 531,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.ExceptionsDependencies.V",
      "library": "catala.desugared",
      "description": "This module defines a vertex type for a graph where each vertex represents an exception in a dependency analysis. It provides operations to create, label, and compare vertices, with support for hashing and equality checks based on vertex labels. It is used to track and analyze dependencies between exceptions in a desugared OCaml program.",
      "description_length": 339,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.ScopeDependencies.E",
      "library": "catala.desugared",
      "description": "This module defines directed edges for a graph structure, where each edge carries a label of type `Desugared.Dependency.Edge.t`. It provides operations to create edges between vertices and to access edge labels, sources, and destinations. Concrete use cases include representing dependency relationships between program elements during analysis or transformation passes in a compiler or static analysis tool.",
      "description_length": 408,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Desugared.Ast.ScopeDef",
      "library": "catala.desugared",
      "description": "This module represents definitions within a desugared AST scope, distinguishing between variables (with optional state annotations) and subscope inputs. It provides comparison, formatting, and hashing operations for these definitions, supporting precise identification and manipulation. Use cases include static analysis of variable and input references, resolution of intermediate state dependencies, and tracking of subscope data flow in transformed ASTs.",
      "description_length": 457,
      "index": 154,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Desugared.Ast.ExprMap",
      "library": "catala.desugared",
      "description": "This structure implements a sorted map for associating arbitrary values with desugared AST expressions, using their inherent ordering for key comparisons. It supports efficient lookups, range queries, and transformations like union operations, while providing utilities to convert between maps and sequences or lists. Such functionality is particularly useful for compiler passes that track expression metadata, analyze code patterns, or perform ordered traversal of AST nodes during optimization or interpretation tasks.",
      "description_length": 521,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.ExceptionsDependencies",
      "library": "catala.desugared",
      "description": "This module implements a directed graph structure where vertices model exceptions and edges represent dependency relationships between them, supporting analysis of exception hierarchies in desugared OCaml programs. It provides operations to query graph properties (vertex/edge counts, degrees), traverse connections (successors, predecessors), and modify the graph through persistent transformations that add/remove vertices or edges while preserving immutability. The core data structures include a persistent graph type (`t`), vertex and edge modules with labeled edge support, enabling use cases like static analysis of exception propagation paths or dependency resolution in code transformation tools.",
      "description_length": 705,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.ScopeDependencies",
      "library": "catala.desugared",
      "description": "This module provides directed graph operations for modeling and manipulating scope-based dependencies in program analysis. It uses a persistent graph structure with labeled edges and vertices representing scopes or variables, supporting tasks like dependency tracking, reachability checks, and transformation passes. Key use cases include static analysis of variable scoping, control flow dependencies, and incremental graph updates during compiler transformations.",
      "description_length": 465,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.Edge",
      "library": "catala.desugared",
      "description": "This module defines edge labels in a dependency graph where each label represents the source position of an expression that uses a variable. It provides comparison and default value operations for these labels. The module works with OCaml's graph structures to track variable dependencies during analysis.",
      "description_length": 305,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast.AssertionName",
      "library": "catala.desugared",
      "description": "This module manages unique assertion names in the desugared AST, providing operations to create, compare, and format them. It works with the abstract `t` type representing assertion names, built from marked strings with source location info. Used to track and manipulate assertion identifiers during program analysis or compilation, ensuring uniqueness and supporting structured data queries.",
      "description_length": 392,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast.LocationSet",
      "library": "catala.desugared",
      "description": "This module offers a functional set abstraction for managing immutable collections of source code location markers, supporting operations like union, intersection, difference, and ordered iteration. It works with sets of `Catala_utils.Mark.pos` values\u2014positions in desugared AST nodes\u2014using ordered comparisons for structural sharing and efficient transformations. Typical applications include tracking code regions for analysis, merging or filtering location ranges during compilation, and converting between sets and sequences for ordered processing.",
      "description_length": 552,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.Vertex",
      "library": "catala.desugared",
      "description": "Handles comparison, hashing, and formatting of dependency graph vertices representing variables and assertions in a desugared AST. Works directly with the `t` type, which includes variable and assertion cases, providing necessary operations for graph construction and analysis. Used to manage and analyze scope dependencies in the desugaring process of a domain-specific language.",
      "description_length": 380,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.ExceptionVertex",
      "library": "catala.desugared",
      "description": "Handles dependency analysis for exception vertices in a rule-based system. Works with scope dependency graphs and rule-to-position mappings. Used to detect and resolve cyclic dependencies between exception rules during program desugaring.",
      "description_length": 238,
      "index": 162,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Desugared.Ast.Rule",
      "library": "catala.desugared",
      "description": "This module defines the structure and comparison logic for desugared AST rules. It provides a total ordering function to compare rule elements based on their structural identity. It is used to facilitate deterministic processing and analysis of desugared language constructs.",
      "description_length": 275,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.EdgeExceptions",
      "library": "catala.desugared",
      "description": "Handles exceptions for scope dependency edges by storing and comparing lists of positions. Works directly with `Catala_utils.Pos.t` lists to track and manage exceptions in dependency graphs. Useful for resolving conflicting or special-case dependencies during scope analysis.",
      "description_length": 275,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.From_surface",
      "library": "catala.desugared",
      "description": "Translates programs from the surface syntax AST to the desugared AST, resolving names during the process. It operates on `Surface.Ast.program` and produces a `Desugared.Ast.program` using a name resolution context. This module is used to convert parsed, high-level code into a simplified form suitable for further analysis or compilation.",
      "description_length": 338,
      "index": 165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Desugared.Dependency",
      "library": "catala.desugared",
      "description": "This module implements directed graph structures for analyzing scope and exception dependencies in desugared programs. It provides operations to build dependency graphs from scopes and exception rules, detect cycles, and compute dependency orderings. Key functions include building scope dependency graphs, checking for cycles in exception hierarchies, and determining correct evaluation orderings for variables and subscopes.",
      "description_length": 426,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Print",
      "library": "catala.desugared",
      "description": "Prints a visual representation of exception propagation paths for a given variable within a specific scope. Works with scope definitions and exception dependency graphs derived from desugared ASTs. Useful for debugging unhandled exceptions and understanding error flow in complex functions.",
      "description_length": 290,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Disambiguate",
      "library": "catala.desugared",
      "description": "Performs local type inference to resolve missing type annotations in the abstract syntax tree during program desugaring. It processes expressions and declarations to enrich the AST with inferred type information. Useful for preparing code for type checking or compilation passes that require explicit types.",
      "description_length": 307,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast",
      "library": "catala.desugared",
      "description": "This module provides structured representations of rules, assertions, and scope definitions, along with operations for expression manipulation, location tracking, and identifier management using comparison, mapping, and set operations. It works with desugared AST elements like expressions, modules, and programs to enable static analysis, compilation pipelines, and data transformation workflows. Key functionalities include expression traversal, variable scoping, and module hierarchy management for tasks requiring precise code analysis or transformation.",
      "description_length": 558,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Linting",
      "library": "catala.desugared",
      "description": "Performs static analysis on desugared AST programs to detect potential issues, displaying actionable warnings. Works directly with desugared abstract syntax trees after parsing and expansion. Useful for catching redundant code, unused variables, and suspicious patterns before compilation.",
      "description_length": 289,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Name_resolution",
      "library": "catala.desugared",
      "description": "This module implements lexical scoping logic to map identifiers to unique identifiers (UIDs) and type representations in a desugared AST. It manages hierarchical contexts tracking variables, subscopes, type definitions, and module structures, while providing operations to resolve names in expressions, validate scope relationships, and translate surface-level types to AST constructs. Typical applications include resolving variable references in nested function scopes, disambiguating enum/struct definitions across modules, and enforcing correct type associations during semantic analysis.",
      "description_length": 592,
      "index": 171,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Desugared",
      "library": "catala.desugared",
      "description": "This module provides components for transforming and analyzing desugared abstract syntax trees through name resolution, type inference, dependency tracking, and static analysis. It operates on structured AST elements, expressions, modules, and programs to support tasks like variable scoping, exception dependency visualization, and linting. Concrete use cases include converting surface-level programs into desugared forms, detecting cyclic dependencies, inferring missing types, and printing exception propagation paths for debugging.",
      "description_length": 536,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.TDependencies.E",
      "library": "catala.scopelang",
      "description": "This module represents directed edges in a dependency graph, where each edge connects two vertices (functions) and carries a label indicating the position of the expression causing the dependency. It provides operations to create edges, retrieve their source and destination vertices, and access their labels. The module supports ordered comparisons of edges, enabling their use in sorted collections.",
      "description_length": 401,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scopelang.Dependency.TDependencies.V",
      "library": "catala.scopelang",
      "description": "This module defines a labeled vertex type for a dependency graph, where each vertex represents a function in the Catala program. It supports creation and labeling of vertices, along with comparison, equality, and hashing operations for use in graph algorithms. The module is used to track dependencies between functions based on their usage in expressions.",
      "description_length": 356,
      "index": 174,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scopelang.Dependency.SDependencies.V",
      "library": "catala.scopelang",
      "description": "This module defines a vertex type for a dependency graph, where each vertex represents a function in the Catala program and carries a label indicating its name or identifier. It provides operations to create vertices from labels, retrieve labels from vertices, and compare, hash, and check equality of vertices. These operations support building and analyzing function dependency graphs based on scope relationships.",
      "description_length": 416,
      "index": 175,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scopelang.Dependency.SDependencies.E",
      "library": "catala.scopelang",
      "description": "This module represents directed edges in a dependency graph, where each edge connects two vertices (functions) and carries a label indicating the position in the source code where the dependency occurs. It provides operations to create edges, retrieve their source and destination vertices, access their labels, and compare edges for ordering. Concrete use cases include tracking which functions depend on others and identifying the exact source location of each dependency in the Catala program.",
      "description_length": 496,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.TDependencies",
      "library": "catala.scopelang",
      "description": "This module provides operations for analyzing and manipulating directed graphs with labeled edges, where vertices represent functions and edges indicate usage relationships in a Catala program. It supports structural queries (vertex/edge counts, in/out degrees), dependency traversal (predecessors, successors), and transformations (adding/removing vertices or edges with precision via labels). These capabilities enable use cases like dependency resolution, impact analysis of function modifications, and optimizing program structure by examining expression-driven dependency chains.",
      "description_length": 584,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.SDependencies",
      "library": "catala.scopelang",
      "description": "The module implements a directed graph structure where vertices represent labeled functions and edges carry source code position labels to track dependency origins. It supports querying graph properties (e.g., degree, connectivity), manipulating vertices and edges (including label-aware transformations), and traversing predecessor/successor relationships in a persistent manner. This structure is particularly useful for static analysis of function dependencies in Catala programs, enabling tasks like impact analysis of code changes or dependency resolution during compilation.",
      "description_length": 580,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Ast.LocationSet",
      "library": "catala.scopelang",
      "description": "This module implements ordered set operations for managing collections of `Scopelang.Ast.location` values, supporting efficient union, intersection, difference, and subset checks alongside ordered traversal via `to_seq` and `to_rev_seq`. It provides bulk transformations between sets and sequences, element filtering, and ordered mapping while maintaining canonical ordering through `Ord.compare`. Typical applications include tracking hierarchical or temporally ordered source code locations during static analysis or transformation passes.",
      "description_length": 541,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.TVertexSet",
      "library": "catala.scopelang",
      "description": "Implements a functional set interface for managing ordered collections of dependency graph vertices, supporting operations like union, intersection, difference, and ordered traversal. The sets are built over `TVertex.t` elements using a comparator module and support conversion to and from sequences. Useful for dependency analysis tasks such as determining reachable nodes, topological ordering, and dependency resolution in Catala programs.",
      "description_length": 442,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.TVertex",
      "library": "catala.scopelang",
      "description": "This module represents vertices in a dependency graph of scopes within a Catala program, specifically handling structure and enumeration types. It provides operations for formatting, comparing, hashing, and equality checking of vertices, along with retrieving source location metadata. Concrete use cases include tracking dependencies between data structures in the program's type system and enabling efficient graph algorithms over these dependencies.",
      "description_length": 452,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Print",
      "library": "catala.scopelang",
      "description": "This module provides functions to print scope and program structures from the Scopelang AST. It works with `Shared_ast.ScopeName.t`, `Scopelang.Ast.scope_decl`, and `Scopelang.Ast.program` types, using a formatter for output. Concrete use cases include debugging and logging the structure of parsed programs and individual scopes during compilation or analysis.",
      "description_length": 361,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency",
      "library": "catala.scopelang",
      "description": "This module represents dependencies between scopes and types in a Catala program using directed graphs. It provides operations to build and analyze these graphs, including detecting cycles in function and type definitions, determining evaluation orderings, and extracting type dependencies from program structures. Concrete use cases include static analysis for compilation, impact analysis of code changes, and resolving dependencies during type checking.",
      "description_length": 456,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Ast",
      "library": "catala.scopelang",
      "description": "This module defines the abstract syntax tree for a scoped programming language, including expressions, programs, and variable typing information. It provides operations to analyze and transform syntax trees, such as extracting used locations from expressions and typing entire programs. Key data structures include expressions annotated with metadata, scoped variable types, and a set module for managing ordered collections of locations.",
      "description_length": 438,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.From_desugared",
      "library": "catala.scopelang",
      "description": "Translates programs from the desugared AST representation to the scopelang AST representation. It constructs exceptions dependency graphs for scope variables and uses them to produce a transformed program with inferred exception flows. This module is used during compilation to analyze and restructure programs for further processing.",
      "description_length": 334,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang",
      "library": "catala.scopelang",
      "description": "This module translates desugared programs into the scoped AST representation, building exception dependency graphs to infer exception flows. It processes function and type dependencies to transform program structures for compilation. Used during the restructuring phase to prepare programs for static analysis and further optimization.",
      "description_length": 335,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lazy_interpreter.Lazy_interp.Env",
      "library": "lazy_interpreter",
      "description": "This module implements an environment for mapping variables to expressions in a lazy interpreter. It supports variable lookup with `find`, binding with `add`, and combining environments with `join`. The environment works with typed expressions and variables from the `Shared_ast` module, and is used during the evaluation of lazy expressions in a calculator-like language.",
      "description_length": 372,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lazy_interpreter.Lazy_interp",
      "library": "lazy_interpreter",
      "description": "This module evaluates expressions in a lazy interpreter using environments that map variables to expressions. It provides operations for lazy evaluation, error logging, and program interpretation, working with typed expressions and variables from the `Shared_ast` module. Concrete use cases include evaluating calculator-like programs and handling evaluation control through laziness levels.",
      "description_length": 391,
      "index": 188,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lazy_interpreter",
      "library": "lazy_interpreter",
      "description": "This module evaluates typed expressions using lazy evaluation strategies, supporting variable resolution through environment mappings. It handles control of evaluation via laziness levels and includes mechanisms for error logging during interpretation. Use cases include executing calculator-style programs and managing evaluation order in expression trees.",
      "description_length": 357,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Json_schema.To_json",
      "library": "json_schema",
      "description": "This module converts Lcalc Catala program representations into JSON schemas for web forms. It provides functions to format structural field names in camel case, print literal and general types, generate struct properties, and serialize entire programs. Use cases include translating Catala data structures into JSON for form validation and dynamic UI generation in web applications.",
      "description_length": 382,
      "index": 190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Json_schema",
      "library": "json_schema",
      "description": "This module converts Catala program representations into JSON schemas for web forms. It formats field names in camel case, prints types, generates struct properties, and serializes programs. Use cases include form validation and dynamic UI generation in web applications.",
      "description_length": 271,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Parser.Make.MenhirInterpreter",
      "library": "catala.surface",
      "description": "This module enables low-level parsing operations using an incremental parser engine, focusing on token consumption, stack manipulation, and environment introspection. It works with tokens, parser checkpoints, and environments containing typed state elements, offering utilities to inspect positions, control reductions, and manage input flow. These capabilities are particularly useful for implementing custom parser logic, debugging complex grammars, or integrating lexers with precise parsing strategies.",
      "description_length": 506,
      "index": 192,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Surface.Parser.Make.Incremental",
      "library": "catala.surface",
      "description": "This module provides an incremental parser for surface syntax files, starting from a given lexing position. It processes input into a list of law structures, supporting step-by-step parsing via Menhir's checkpoint mechanism. It is used to parse formal law definitions from source files in a structured, resumable manner.",
      "description_length": 320,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Surface.Parser.Make",
      "library": "catala.surface",
      "description": "Parses surface syntax files into law structures using a localized lexer, consuming tokens through a Menhir-based incremental parser engine. Works with lex buffers, parser checkpoints, and typed state environments to enable step-by-step parsing and input flow control. Used to implement precise parsing strategies for formal law definitions, supporting resumable parsing from specific lexing positions.",
      "description_length": 401,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Fill_positions",
      "library": "catala.surface",
      "description": "Processes a program's AST to annotate position tags with legislative article details. Uses the structure of the AST to map positions to their corresponding legislative context. Enables tools to trace source positions back to specific legislative articles during analysis or error reporting.",
      "description_length": 290,
      "index": 195,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Surface.Lexer_pl",
      "library": "catala.surface",
      "description": "This module implements lexing functionality for parsing both code and non-code (law) contexts. It provides functions to tokenize input using different rules depending on the context, supporting built-in expressions, line-level tokens, and language-specific string variations. Concrete use cases include parsing code blocks in a mixed-language document and extracting dependencies from lines of input.",
      "description_length": 400,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Ast",
      "library": "catala.surface",
      "description": "The module defines an abstract syntax tree (AST) structure with operations for representing and transforming Catala source code during parsing. It includes a visitor pattern implementation for efficient traversal and modification of AST nodes, along with utilities like converting rules to definitions and inferring types from function arguments. These features support concrete tasks such as code analysis, transformation, and type checking during compiler processing.",
      "description_length": 469,
      "index": 197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Surface.Parser",
      "library": "catala.surface",
      "description": "Parses surface syntax files into structured law definitions using a Menhir-based incremental parser and a localized lexer. It processes lex buffers and parser checkpoints to support step-by-step parsing, enabling precise control over input flow and resumable parsing from specific positions. Used to implement custom parsing strategies for formal legal text processing.",
      "description_length": 369,
      "index": 198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Surface.Print",
      "library": "catala.surface",
      "description": "Formats primitive types from the Surface AST using a provided formatter. Works with `Surface.Ast.primitive_typ` values and `Format.formatter` objects. Useful for pretty-printing low-level type representations during compilation or debugging.",
      "description_length": 241,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Parser_driver",
      "library": "catala.surface",
      "description": "This module provides functions for parsing and processing Catala source files, including raw line tokenization, interface loading, and top-level file parsing with support for file includes. It operates on file structures and token sequences, producing parsed program and interface data used for further compilation stages. Concrete use cases include reading and preprocessing law texts into structured data, extracting type metadata from interfaces, and assembling modular programs through recursive file parsing.",
      "description_length": 513,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Tokens",
      "library": "catala.surface",
      "description": "This module defines a comprehensive set of lexical token types used for parsing and representing surface-level language constructs. It includes identifiers, literals, operators, and language-specific keywords used in rule definitions and structured text. These tokens are used directly in the concrete syntax of the language, such as representing variables, logical conditions, arithmetic operations, and structural elements like parentheses or brackets.",
      "description_length": 454,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Lexer_en",
      "library": "catala.surface",
      "description": "This module implements lexing functions for parsing code and law blocks, handling language-specific tokens and builtins. It processes input using `Sedlexing.lexbuf` and returns tokens defined in `Surface.Tokens`, with support for context-sensitive lexing and line-level dependency extraction. Concrete use cases include tokenizing source files during compilation and extracting dependencies from lines of code.",
      "description_length": 410,
      "index": 202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Surface.Lexer_fr",
      "library": "catala.surface",
      "description": "This module implements lexing logic for parsing both code and natural language content, using language-specific tokens defined in `Surface.Tokens`. It includes specialized lexers for builtins, code blocks, and law text, along with a context-aware entry point that routes to the appropriate lexer. It supports dependency extraction through a line-based lexer that captures full lines with associated token metadata.",
      "description_length": 414,
      "index": 203,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Surface.Parser_errors",
      "library": "catala.surface",
      "description": "This module maps integer error codes to descriptive strings for parsing errors. It provides a `message` function that takes an integer code and returns the corresponding error message, raising `Not_found` if the code is unknown. It is used to retrieve human-readable explanations of parser-specific error conditions during compilation or analysis phases.",
      "description_length": 354,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Lexer_common",
      "library": "catala.surface",
      "description": "This module maintains mutable state and buffers during lexing, handling transitions between code, law, and directive contexts. It accumulates code into a buffer for literate programming output and maps punctuation to tokens for parsing. Functions support error reporting, token precedence calculation, and processing special line directives like includes and module definitions.",
      "description_length": 378,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface",
      "library": "catala.surface",
      "description": "This module provides core components for parsing and processing Catala source code, including lexing, parsing, and abstract syntax tree manipulation. It works with lexical tokens, AST nodes, and parser checkpoints to support concrete tasks like code transformation, type inference, and error reporting during compilation. Specific use cases include parsing mixed-code documents, extracting dependencies from source lines, and mapping source positions to legislative articles.",
      "description_length": 475,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Clerk_driver",
      "library": "catala.clerk_driver",
      "description": "Handles command-line interface setup and execution for a clerk application. Defines a command structure for parsing CLI arguments and an entry point function to run the application. Useful for implementing administrative tools that interact with a clerk system through terminal commands.",
      "description_length": 287,
      "index": 207,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 225,
    "meaningful_modules": 208,
    "filtered_empty_modules": 17,
    "retention_rate": 0.9244444444444444
  },
  "statistics": {
    "max_description_length": 745,
    "min_description_length": 212,
    "avg_description_length": 446.28365384615387,
    "embedding_file_size_mb": 3.0146665573120117
  }
}