{
  "package": "catala",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 220,
  "creation_timestamp": "2025-07-16T00:00:49.888185",
  "modules": [
    {
      "module_path": "Desugared.Ast.AssertionName.Map",
      "library": "catala.desugared",
      "description": "This module provides associative map operations for key-value associations with keys of type `Desugared.Ast.AssertionName.t`, supporting creation, insertion, deletion, querying, combination (e.g., union, merge), and traversal (e.g., fold, filter). It emphasizes ordered key manipulation, enabling transformations, conditional searches, and structured iteration, while also offering utilities to extract keys/values, construct maps from lists, and format bindings for debugging or output with customizable separators. Use cases include managing AST node metadata, aggregating assertion-related data, and generating human-readable representations of map contents.",
      "description_length": 661,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast.ScopeDef.Map",
      "library": "catala.desugared",
      "description": "This map module supports operations like insertion, deletion, and lookup, along with higher-order functions for transformation and traversal, specifically for associations between scope definitions and arbitrary data. It leverages physical equality optimizations during key updates and provides utilities for ordered key access, splitting, and bidirectional conversion with sequences. It is particularly useful for tracking variable bindings or subscope inputs in desugared AST scopes, enabling efficient querying and structured data processing with customizable pretty-printing for debugging.",
      "description_length": 593,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.ScopeDependencies.E",
      "library": "catala.desugared",
      "description": "This module defines edge structures for a directed graph used in scope dependency analysis. It provides operations to create edges between vertices with labels, retrieve edge labels and endpoints, and compare edges. The module works with vertices and labeled edges to represent directed relationships in a persistent graph structure.",
      "description_length": 333,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.ExceptionsDependencies.E",
      "library": "catala.desugared",
      "description": "This module defines directed edges labeled with exception dependency information, using an ordered type for edge comparison. It provides operations to create edges between vertices with specific labels and to retrieve the source, destination, and label of an edge. Concrete use cases include representing and manipulating exception propagation paths in a control flow graph.",
      "description_length": 374,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.ScopeDependencies.V",
      "library": "catala.desugared",
      "description": "This module defines a vertex type for a persistent graph structure, where vertices are labeled and support comparison, hashing, and equality checks. It provides operations to create vertices from labels and to retrieve vertex labels. Concrete use cases include representing nodes in a dependency graph where each node corresponds to a labeled scope in a desugared program.",
      "description_length": 372,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Desugared.Ast.AssertionName.Set",
      "library": "catala.desugared",
      "description": "This module provides ordered set operations for managing collections of assertion names, supporting transformations like union, intersection, and difference, along with ordered iteration, filtering, and element retrieval (min, max, arbitrary). It works with sets of `AssertionName.t` values, leveraging a comparison function to maintain element ordering and enabling efficient membership checks, predicate-based searches, and conversions to/from lists and sequences. These capabilities are useful for tasks like dependency tracking, name resolution, or static analysis passes over desugared AST nodes where ordered uniqueness and efficient lookups are critical.",
      "description_length": 661,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.ExceptionsDependencies.V",
      "library": "catala.desugared",
      "description": "This module defines a labeled vertex type for a graph where each vertex represents an exception dependency in the desugared OCaml code. It provides operations to create vertices from labels, retrieve labels from vertices, and compare, hash, and check equality of vertices. These vertices are used to build and analyze exception propagation graphs in static code analysis tasks.",
      "description_length": 377,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast.ScopeDef.Set",
      "library": "catala.desugared",
      "description": "This module manipulates collections of `ScopeDef` values using standard set operations like membership testing, union, and intersection, alongside functional transformations such as filtering, mapping, and partitioning. It works with ordered sets of `ScopeDef` elements, leveraging a comparator to maintain order and enable efficient operations like min/max selection or ordered traversal. Common use cases include tracking variable references in scopes, analyzing dependencies between definitions, and converting between sets and sequences for bulk updates or ordered processing.",
      "description_length": 580,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Desugared.Dependency.Edge",
      "library": "catala.desugared",
      "description": "This module represents edges in a dependency graph where each edge label is a source position indicating the expression responsible for a variable use. It provides comparison and default value operations for these edge labels. The module works with directed graphs to track variable dependencies during analysis of scope and usage in a program.",
      "description_length": 344,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.ExceptionsDependencies",
      "library": "catala.desugared",
      "description": "This module manages persistent directed graphs with labeled edges and vertices, specifically designed for analyzing exception dependencies in OCaml code. It supports structural queries, neighborhood traversal, and edge removal while preserving immutability, using a graph type `t` along with vertex (`V`) and edge (`E`) modules. The edge module represents directed exception propagation paths with labeled, ordered edges, while the vertex module models exception dependencies as labeled, comparable entities. You can use it to build a graph of exception flows, query dependencies between code elements, and remove or analyze specific propagation paths without modifying the original graph.",
      "description_length": 689,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Desugared.Dependency.ScopeDependencies",
      "library": "catala.desugared",
      "description": "This module manages directed persistent graphs for modeling scope-based dependencies in static analysis, offering vertex and edge manipulation, graph traversal, and structural transformations. It supports labeled vertices and edges, with operations for creating and comparing nodes, adding and removing directed connections, and querying adjacency to model relationships like variable bindings or call graphs. Concrete functionality includes constructing dependency graphs, validating scope hierarchies, and performing iterative analysis over program structures. Submodules provide labeled edge management and hashable, comparable vertex definitions for precise graph construction and inspection.",
      "description_length": 696,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Desugared.Ast.AssertionName",
      "library": "catala.desugared",
      "description": "This module manages uniquely generated assertion names tied to source location metadata in the desugared AST, offering creation, comparison, hashing, and formatting operations. It supports efficient key-based data association through map operations that enable structured iteration, combination, and transformation of assertion name mappings, such as aggregating metadata or generating debug output with custom formatting. Ordered set operations allow maintaining and manipulating collections of assertion names with efficient membership checks, ordered traversal, and set algebra, useful for dependency tracking and static analysis. Together, these capabilities facilitate precise handling of assertion identifiers during compilation and analysis passes.",
      "description_length": 755,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast.LocationSet",
      "library": "catala.desugared",
      "description": "This module implements an ordered set structure for managing collections of source code location marks, supporting standard set operations like union, intersection, and difference alongside ordered iteration. It works with elements of type `Catala_utils.Mark.pos` and leverages a comparison function to enable efficient membership checks, filtering, and bidirectional conversions with sequences. Typical use cases include tracking and analyzing source position metadata in the desugared AST, such as aggregating error locations or transforming location-based annotations during compilation passes.",
      "description_length": 597,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast.ExprMap",
      "library": "catala.desugared",
      "description": "This module implements map operations for key-value pairs where keys are desugared AST expressions and values are arbitrary data, supporting efficient insertion, deletion, lookup, and merging with physical equality optimizations. It provides ordered traversal, filtering, and transformation capabilities, alongside utilities for converting between maps and lists, computing disjoint unions, and generating customizable pretty-printed representations of bindings. These features enable structured data manipulation, static analysis, and debugging workflows that require precise handling of AST-based keys and human-readable output formatting.",
      "description_length": 641,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast.ScopeDef",
      "library": "catala.desugared",
      "description": "This module structures and manages references to variables and subscope inputs within desugared AST scopes, offering typed representations for definition kinds along with comparison, equality, and formatting operations. Its map submodule enables efficient binding and transformation of scope definitions with physical equality optimizations and ordered key access, while the set submodule supports set-theoretic operations and ordered traversal over collections of definitions. Together, they facilitate tasks like variable tracking, dependency analysis, and structured data processing during AST transformations. Example uses include mapping variables to analysis data, filtering subscope inputs, or computing intersections of definition sets for scope merging.",
      "description_length": 762,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.Vertex",
      "library": "catala.desugared",
      "description": "This module defines operations for working with dependency graph vertices, including formatting, comparing, hashing, and equality checks. It handles two types of vertices: variables with optional state names and assertions. These functions support dependency analysis and graph manipulation tasks in the desugaring process.",
      "description_length": 323,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.EdgeExceptions",
      "library": "catala.desugared",
      "description": "Handles exceptions for dependency edges in scope dependency graphs by storing and comparing lists of positions. Works directly with `Catala_utils.Pos.t` lists to track source code locations associated with dependencies. Used to identify and manage conflicting or special-case dependencies during scope analysis.",
      "description_length": 311,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency.ExceptionVertex",
      "library": "catala.desugared",
      "description": "Handles exceptional cases in dependency graphs by defining vertices that represent error conditions tied to specific rules and labels. Works with OCamlgraph structures to inject or track exceptions during dependency resolution. Useful for reporting precise error sources when rule dependencies cannot be satisfied.",
      "description_length": 314,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast.Rule",
      "library": "catala.desugared",
      "description": "This module defines the structure and comparison logic for desugared rule elements in an abstract syntax tree. It supports operations to determine equality and ordering between rule nodes, which are essential for transformations and analyses requiring structural comparisons. Use cases include rule-based rewriting systems and static analysis passes that depend on canonical forms of AST nodes.",
      "description_length": 394,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Name_resolution",
      "library": "catala.desugared",
      "description": "This module resolves identifiers to unique UIDs within a desugared AST by managing lexical scopes and module hierarchies, handling structured data like structs, enums, and scoped definitions. It ensures precise disambiguation of variables, types, and module references while enforcing scope membership and reporting undefined identifiers during compilation. Key operations include context-aware resolution of parameters, type conversions, and hierarchical module lookups.",
      "description_length": 471,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Linting",
      "library": "catala.desugared",
      "description": "Performs static analysis on desugared AST programs to detect potential issues, displaying actionable warnings. Works directly with desugared program structures to enforce code quality standards. Useful for catching redundant expressions, unused variables, and style inconsistencies during development.",
      "description_length": 301,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.From_surface",
      "library": "catala.desugared",
      "description": "Translates programs from the surface syntax to the desugared abstract syntax tree, resolving syntactic sugars and separating code from legislative constructs. It operates on contexts and programs from the `Surface.Ast` and produces equivalent `Desugared.Ast` programs. This module is used during the early stages of compilation to normalize input code before further analysis or transformation.",
      "description_length": 394,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Ast",
      "library": "catala.desugared",
      "description": "The module processes desugared abstract syntax trees by enabling construction, modification, and analysis of logical rules, expressions, and scopes. It provides core data types like expressions, rules, assertions, locations, and scope definitions, along with operations for variable tracking, free variable collection, and expression traversal. Child modules enhance this functionality with specialized structures: assertion names tied to source locations support metadata handling and dependency tracking, ordered sets manage location marks for error aggregation, maps associate expressions with arbitrary data for analysis and debugging, scope definitions track variables and subscope inputs with typed references, and rule elements enable structural comparisons for canonical transformations. Examples include transforming location-based annotations, mapping variables to analysis data, and rewriting rules based on structural equality.",
      "description_length": 939,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Desugared.Print",
      "library": "catala.desugared",
      "description": "Prints the exception graph of a variable to the terminal, showing how exceptions propagate through the program. It operates on scoped definitions and exception dependency structures from the desugared AST. Useful for debugging exception handling flow in complex programs.",
      "description_length": 271,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Dependency",
      "library": "catala.desugared",
      "description": "This module analyzes dependencies between scope variables and exceptions in a desugared AST using directed graphs. It builds dependency graphs to detect cycles, compute evaluation orderings, and ensure valid compilation of configuration rules. The module works with labeled edges and vertices to track variable uses and exception propagation, supporting operations like graph construction, traversal, edge removal, and adjacency queries. Specific examples include modeling variable bindings, analyzing exception flows, validating scope hierarchies, and reporting errors tied to specific source positions or rule definitions.",
      "description_length": 624,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Desugared.Disambiguate",
      "library": "catala.desugared",
      "description": "Performs local type inference to resolve untyped lambda parameters, function applications, and structure field accesses in the desugared AST. It operates directly on `Desugared.Ast.program`, refining type annotations in `EAbs`, `EApp`, `EAppOp`, and `EDStructAccess` nodes. Used during compilation to ensure type consistency before further analysis or code generation steps.",
      "description_length": 374,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Desugared",
      "library": "catala.desugared",
      "description": "This module processes desugared programs through a series of coordinated operations, starting with parsing and scope resolution, followed by static analysis, type inference, dependency tracking, and transformation capabilities. It centers around the desugared abstract syntax tree, with core data types including expressions, rules, scopes, variables, exceptions, and locations, manipulated through resolution, traversal, analysis, and rewriting operations. Users can perform tasks like resolving identifiers to UIDs, detecting unused variables, inferring lambda parameter types, analyzing exception propagation, rewriting expressions based on structure, and building dependency graphs for validation. These capabilities support robust compilation, analysis, and transformation of programs from surface syntax to typed, optimized forms.",
      "description_length": 836,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Surface.Parser.Make.Incremental",
      "library": "catala.surface",
      "description": "Parses a list of law structures from a given source file position using an incremental parsing strategy. It operates on lexing positions and produces checkpoints for error recovery or partial parsing. This module is useful for implementing interactive or streaming parsers where input is provided incrementally, such as in REPLs or real-time editors.",
      "description_length": 350,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Parser.Make",
      "library": "catala.surface",
      "description": "This module transforms raw input files into structured law representations by parsing token streams generated from lexing buffers. It coordinates with submodules to support both full and incremental parsing strategies, enabling structured data extraction from static files or streaming input sources. The core functionality handles lexing buffers, tokens, and law structures, while the incremental submodule processes input from specific positions and generates checkpoints for error recovery or partial results. Example uses include building static parsers for law documents or implementing interactive editors that parse input in real time.",
      "description_length": 642,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Lexer_common.LocalisedLexer",
      "library": "catala.surface",
      "description": "Implements lexing logic for both code and non-code contexts, switching between `lex_code` and `lex_law` based on the current parsing state. It processes `Sedlexing.lexbuf` input and emits `Surface.Tokens.token` values, supporting language-specific tokenization through `token_list`. Useful for parsing source files where lexical rules change between code blocks and surrounding documentation.",
      "description_length": 392,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Fill_positions",
      "library": "catala.surface",
      "description": "Handles the population of position tags in the AST with metadata about the legislative article they belong to. Operates on `Surface.Ast.program` values, modifying their position tags in place. Used during AST preprocessing to enrich positional information for error reporting or analysis tools.",
      "description_length": 294,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Parser",
      "library": "catala.surface",
      "description": "This module transforms raw input files into structured law representations by parsing token streams from lexing buffers, supporting both full and incremental parsing strategies. It provides core data types such as tokens, lexing buffers, and law structures, along with operations for parsing, checkpointing, and error recovery. Incremental parsing allows processing input from specific positions, making it suitable for real-time applications like interactive editors. Example uses include building static parsers for legal documents or implementing streaming input handlers with partial result generation.",
      "description_length": 606,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Lexer_common",
      "library": "catala.surface",
      "description": "This module manages mutable state and buffers during lexing, handling transitions between code, law, and directive contexts. It provides core operations for updating the code buffer, generating lexer errors, and mapping punctuation to tokens, working with lexing contexts, string buffers, and token lists. The child module implements context-switching lexing logic, alternating between `lex_code` and `lex_law` to process `Sedlexing.lexbuf` input and emit `Surface.Tokens.token` values. Together, they enable lexing of structured documents with mixed code and documentation, supporting literate programming and accurate parsing.",
      "description_length": 628,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Surface.Lexer_pl",
      "library": "catala.surface",
      "description": "This module implements lexing functions for parsing code and documentation blocks, handling language-specific tokens and builtins. It operates on lexing buffers and produces tokens for the surface syntax tree, distinguishing between code and non-code contexts. Concrete use cases include lexing source files during compilation and extracting dependencies from lines of code.",
      "description_length": 374,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Lexer_en",
      "library": "catala.surface",
      "description": "This module implements lexing logic for parsing both code and non-code sections of a document, handling language-specific tokens and builtins. It processes input using `Sedlexing.lexbuf` and produces tokens for further parsing, distinguishing between code blocks and prose contexts. Concrete use cases include lexing inline expressions, extracting dependencies from lines, and identifying language-specific keywords or symbols.",
      "description_length": 427,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Surface.Lexer_fr",
      "library": "catala.surface",
      "description": "This module implements lexing functionality for parsing both code and natural language content. It defines language-specific tokenization rules, handles built-in expressions, and supports different lexing modes for code blocks and non-code (law) sections. It is used to convert raw text input into structured tokens for further processing in the Surface language.",
      "description_length": 363,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Surface.Parser_errors",
      "library": "catala.surface",
      "description": "Maps integer error codes to descriptive error messages for parsing-related issues. Works with integer keys to retrieve corresponding string messages. Useful for translating internal parser error codes into human-readable strings during error handling or logging.",
      "description_length": 262,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Parser_driver",
      "library": "catala.surface",
      "description": "This module provides functions for parsing and processing Catala source files, including raw line extraction, interface loading, and top-level file parsing with support for file includes. It operates on file structures and token sequences, producing parsed program and interface data. Concrete use cases include reading and analyzing Catala code files, extracting metadata declarations, and building program structures for further compilation steps.",
      "description_length": 449,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Surface.Tokens",
      "library": "catala.surface",
      "description": "This module defines a comprehensive set of lexical token types used in parsing a domain-specific language. It includes identifiers, operators, literals, and structural symbols that represent the basic elements of the language syntax. These tokens are used by the lexer and parser to build abstract syntax trees during the compilation process.",
      "description_length": 342,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Ast",
      "library": "catala.surface",
      "description": "The module defines an abstract syntax tree (AST) structure used to represent parsed Catala code, including identifiers and type definitions. It includes functions to convert rules into definitions and infer types from argument lists, supporting direct manipulation of the AST. This structure is primarily used for analysis, transformation, and code generation tasks during language processing.",
      "description_length": 393,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface.Print",
      "library": "catala.surface",
      "description": "Formats primitive type expressions for display, converting internal type representations into human-readable strings using OCaml's formatting library. Works directly with `primitive_typ` values from the `Surface.Ast` module. Useful when generating error messages or documentation that requires type information in a source-readable form.",
      "description_length": 337,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Surface",
      "library": "catala.surface",
      "description": "This module processes structured legal and code documents by parsing raw input into enriched abstract syntax trees, handling mixed contexts with dedicated lexing and parsing logic. It operates on programs, lexing buffers, and token streams to support full and incremental parsing, context switching, and error handling, while providing type formatting and error message mapping. Key data types include tokens, AST nodes, lexing buffers, and primitive types, enabling tasks like static parsing, real-time editing, dependency extraction, and type-aware analysis. Examples include building parsers for Catala source files, implementing streaming input handlers, and generating human-readable type representations for errors or documentation.",
      "description_length": 738,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Runtime_jsoo.Runtime",
      "library": "catala.runtime_jsoo",
      "description": "This module bridges JavaScript and OCaml representations of dates, durations, and errors, enabling seamless interoperability. It converts date strings to OCaml date values and vice versa using ISO8601 format, transforms duration values between JS and OCaml formats, and handles error propagation by translating specific OCaml exceptions into JavaScript errors. It is used to integrate OCaml runtime logic with JavaScript environments, particularly for applications handling date-based computations or error-sensitive operations.",
      "description_length": 528,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Runtime_jsoo",
      "library": "catala.runtime_jsoo",
      "description": "This module enables seamless interoperability between JavaScript and OCaml by converting date, duration, and error values between the two environments. It supports bidirectional conversion of date strings and OCaml date values using ISO8601, translates durations, and maps OCaml exceptions to JavaScript errors. It allows applications to handle date-based computations and error propagation consistently across both languages. For example, it can parse a JavaScript date string into an OCaml value, perform time arithmetic, and return the result in a JavaScript-compatible format.",
      "description_length": 580,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Literate.Pygment_lexers.Internal",
      "library": "catala.literate",
      "description": "This module defines several string values representing configuration or pattern data for lexers used in syntax highlighting. It includes functions to process file content into chunks and provides a list of files, likely for batch processing or analysis. These operations support tasks like parsing source code files according to specific syntax rules and organizing them for further processing or output.",
      "description_length": 404,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Literate.Pygment_lexers",
      "library": "catala.literate",
      "description": "This module manages file-based operations for syntax highlighting lexers, handling tasks like reading file contents, computing hashes, and retrieving file sizes. It provides string-based file path handling and optional return types to manage failures, supporting concrete actions such as loading lexer definitions, validating files via hash checks, and pre-processing size evaluation. Submodules supply lexer configuration data, content parsing functions, and file listing capabilities, enabling batch processing and structured analysis of source files according to syntax rules. Together, they allow loading, validating, and processing code files for syntax highlighting in a structured and efficient manner.",
      "description_length": 709,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Literate.Literate_common",
      "library": "catala.literate",
      "description": "This module provides functions for generating localized strings, running code formatting tools like Pandoc and Pygmentize, and checking line length limits in source files. It operates on strings, file contents, and language-specific configurations through the `Catala_utils.Global.backend_lang` type. Concrete use cases include generating documentation headers, formatting markdown or LaTeX output, and linting source code for style compliance.",
      "description_length": 444,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Literate.Html",
      "library": "catala.literate",
      "description": "This module generates HTML documents that interleave source code with legislative text for legal professionals. It provides `ast_to_html` to convert parsed programs into formatted HTML and `wrap_html` to assemble final documents with metadata. Designed for legal codebases, it ensures alignment between code and law text in the output.",
      "description_length": 335,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Literate.Latex",
      "library": "catala.literate",
      "description": "This module translates Catala source code and legislative text into a formatted LaTeX document for legal professionals. It provides `ast_to_latex` to convert abstract syntax trees into LaTeX output, and `wrap_latex` to enclose generated content within a complete LaTeX document structure. It operates on `Surface.Ast.program` and string lists, targeting legal documentation generation in a specified backend language.",
      "description_length": 417,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Literate.Pygmentize",
      "library": "catala.literate",
      "description": "Executes the Pygmentize binary with support for Catala syntax highlighting, using command-line arguments from `Sys.argv`. Works directly with source code files as input, producing syntax-highlighted output. Useful for integrating Catala code formatting into command-line workflows or documentation generation pipelines.",
      "description_length": 319,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Literate",
      "library": "catala.literate",
      "description": "This module processes and transforms source code and legislative text into formatted output for legal documentation. It provides data types for program ASTs, language configurations, and file metadata, with operations for syntax highlighting, HTML and LaTeX generation, and code formatting. Key functions include converting code to syntax-highlighted HTML or LaTeX, wrapping output in document structures, and validating or linting source files. Examples include generating styled legal code documents, aligning code with law text, and integrating Catala formatting into command-line workflows.",
      "description_length": 594,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python",
      "library": "python",
      "description": "This module provides a command-line interface for running a Python backend plugin for Catala, handling input files and execution options. It works with raw file data and Catala's global options structure to manage compilation and execution workflows. A concrete use case includes invoking the Python backend to process Catala source files and generate corresponding Python code or execute programs directly.",
      "description_length": 407,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.TDependencies.E",
      "library": "catala.scopelang",
      "description": "This module represents directed edges in a dependency graph, where each edge connects two vertices (functions) and carries a label indicating the position in the source code where the dependency occurs. It provides operations to create edges with a source, destination, and label, as well as to retrieve the source, destination, or label of an edge. Concrete use cases include tracking which functions depend on others and identifying the exact source location responsible for each dependency.",
      "description_length": 493,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.SDependencies.V",
      "library": "catala.scopelang",
      "description": "This module represents vertices in a dependency graph where each vertex corresponds to a labeled scope in a Catala program. It provides operations to create vertices from labels, retrieve their labels, and compare, hash, or check equality of vertices based on their labels. It is used to track dependencies between functions or scopes, enabling analysis of usage relationships in the program.",
      "description_length": 392,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.TDependencies.V",
      "library": "catala.scopelang",
      "description": "This module defines a labeled, comparable vertex type for representing nodes in a dependency graph. It supports creating vertices with labels and retrieving or comparing those labels. It is used to model functions and their dependencies in a program analysis context, where vertex labels capture metadata about the functions they represent.",
      "description_length": 340,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.SDependencies.E",
      "library": "catala.scopelang",
      "description": "This module represents directed edges in a dependency graph, where each edge connects two vertices (functions) and carries a label indicating the position in the source code where the dependency occurs. It provides operations to create edges with a source, destination, and label, as well as to retrieve those components. Concrete use cases include tracking which functions depend on others and identifying the exact source location of each dependency in a Catala program.",
      "description_length": 472,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.TVertexSet",
      "library": "catala.scopelang",
      "description": "This module provides ordered set operations for managing collections of dependency vertices in a program scope graph, supporting standard set algebra (union, intersection, difference), filtering, partitioning, and ordered traversal. It works with immutable sets of `TVertex.t` elements, leveraging comparison logic from an external module to maintain sorted structures efficiently. These utilities are particularly useful for analyzing dependencies between scopes, such as determining reachable functions, computing transitive closures, or extracting ordered subsets for evaluation prioritization.",
      "description_length": 597,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.TDependencies",
      "library": "catala.scopelang",
      "description": "This module manages a directed graph where vertices represent functions and edges encode dependencies between them, labeled by the expressions causing the dependency. It supports structural analysis, transformation, and traversal operations, enabling tasks like dependency resolution and static analysis. Vertices are labeled with metadata, and edges include source locations, allowing precise tracking of dependencies. For example, you can add a function vertex, connect it to another with a labeled edge representing an expression, then query its predecessors or fold over its outgoing edges with labels.",
      "description_length": 606,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Ast.LocationSet",
      "library": "catala.scopelang",
      "description": "This module provides standard set operations (union, intersection, difference) and ordered processing capabilities (filtering, partitioning, traversal) for sets of abstract syntax tree (AST) locations annotated with source code markings. It supports conversions between these sets and sequences, enabling ordered iteration and bulk construction from ordered elements. Such functionality is particularly useful in static analysis tasks requiring precise source position tracking, such as error diagnostics, code transformation passes, or optimizations that rely on comparing or aggregating AST node locations.",
      "description_length": 608,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.TVertex",
      "library": "catala.scopelang",
      "description": "This module defines and manipulates vertices in a dependency graph, representing scopes in a Catala program. It supports operations for formatting, comparing, hashing, and equality checking of vertices, which are either struct or enum types. Concrete use cases include tracking dependencies between functions and data structures during program analysis.",
      "description_length": 353,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency.SDependencies",
      "library": "catala.scopelang",
      "description": "This module manages a persistent, labeled directed graph structure where vertices represent functions or scopes and edges capture dependency-causing expressions. It supports querying graph properties like vertex and edge counts, modifying directed acyclic relationships, and traversing dependencies through labeled or unlabeled paths. Vertices are identified by labels and can be compared, hashed, or retrieved based on their associated scope, while edges carry source, destination, and positional metadata from the program. Example uses include analyzing function dependencies in Catala programs, optimizing compilation by inspecting dependency chains, and enforcing acyclic relationships during static analysis.",
      "description_length": 713,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.From_desugared",
      "library": "catala.scopelang",
      "description": "Translates programs from the desugared AST representation to the scopelang AST by building and utilizing exception dependency graphs for scope variables. It processes desugared program structures to infer and map exceptions dependencies across scopes. This module is used during compilation to transform high-level program representations into a form suitable for further analysis and optimization.",
      "description_length": 398,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Dependency",
      "library": "catala.scopelang",
      "description": "This module models dependencies between scopes and types in Catala programs using two directed graphs: one for tracking function and scope relationships, and another for type-level dependencies. It supports cycle detection, topological sorting, and structured resolution of types, while submodules provide set operations over vertices, labeled graph construction with expression metadata, vertex manipulation with comparison and formatting, and persistent graph modifications with positional tracking. You can, for example, compute the transitive closure of function dependencies, extract ordered evaluation sequences, or analyze type dependencies with precise source location tracking. The combination of graph analysis, set algebra, and vertex metadata enables robust static analysis and compilation optimizations for Catala programs.",
      "description_length": 836,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Ast",
      "library": "catala.scopelang",
      "description": "The module represents the abstract syntax tree of the scope language, defining core data types like `expr`, `program`, and `scope_var_ty` to model expressions, programs, and scoped variables with directionality. It includes operations for analyzing expressions by extracting location sets and performing type-checking, while its child module extends location handling with set operations, ordered traversal, and sequence conversions. This enables tasks such as static analysis, error diagnostics, and code transformations that depend on precise source position tracking and manipulation of AST elements. Example uses include extracting all locations referenced in an expression, filtering specific AST nodes during traversal, or transforming programs based on scoped variable usage.",
      "description_length": 782,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang.Print",
      "library": "catala.scopelang",
      "description": "This module provides functions to print scoped declarations and entire programs in a formatted way. It works with abstract syntax trees (ASTs) and scope declarations from the Scopelang module, along with marking and formatting utilities. Use it to generate readable output for debugging or logging purposes directly from AST structures.",
      "description_length": 336,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scopelang",
      "library": "catala.scopelang",
      "description": "This module translates and analyzes program structures through scope and type dependency graphs, enabling advanced static analysis and compilation optimizations. It defines core AST types like `expr`, `program`, and `scope_var_ty`, while supporting operations such as type-checking, location extraction, and topological sorting of dependencies. Graph-based analysis allows for cycle detection, transitive closure computation, and ordered evaluation sequence extraction with precise source tracking. You can transform high-level ASTs into optimized scopelang representations, analyze type dependencies, or generate formatted output for debugging.",
      "description_length": 645,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_web.To_jsoo",
      "library": "api_web",
      "description": "This module defines formatting functions for converting Catala abstract syntax types and expressions into JavaScript identifiers and structures using js_of_ocaml. It operates on data types such as `Shared_ast.StructField.t`, `Shared_ast.EnumName.t`, `Shared_ast.typ`, and various expressions and contexts from the Catala AST. These functions are used to generate correctly named and structured JavaScript output from Catala programs, including struct fields, enums, variables, and entire program scopes.",
      "description_length": 503,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Api_web",
      "library": "api_web",
      "description": "This module processes Catala source files through parsing, type-checking, and execution, working with intermediate representations and global options to support validation, optimization, and output generation. It includes operations for compiling Catala to JavaScript using the To_jsoo submodule, which provides formatting functions that translate Catala AST elements like structs, enums, and expressions into valid JavaScript identifiers and structures. Key data types include Catala's abstract syntax trees and shared AST components, manipulated through transformations and naming conventions tailored for JavaScript output. Examples include converting a Catala struct field to a JavaScript object key or compiling an entire Catala program into an executable JavaScript file.",
      "description_length": 777,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Clerk_driver",
      "library": "catala.clerk_driver",
      "description": "Handles command-line interface setup and execution for a clerk application. Exposes a command definition for the main entry point and a function to run the application. Works with command-line arguments and internal application logic to initialize and start the clerk workflow.",
      "description_length": 277,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Driver.Passes",
      "library": "catala.driver",
      "description": "This module implements compiler passes for processing programs through various stages of translation and optimization. It operates on abstract syntax trees (ASTs) defined in different modules (Surface, Desugared, Scopelang, Dcalc, Lcalc, Scalc) and handles tasks like parsing, desugaring, type checking, optimization, and closure conversion. Concrete use cases include transforming high-level Catala code into lower-level intermediate representations suitable for execution or analysis, while managing dependencies and options across passes.",
      "description_length": 541,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Driver.Commands",
      "library": "catala.driver",
      "description": "This module provides functions for handling command-line outputs, formatting, and identifier resolution in the context of Catala's top-level commands. It works with file options, output channels, formatters, and abstract syntax tree components like scopes and variables. Concrete use cases include opening output files with optional extensions, resolving scope and variable unique identifiers during compilation, and defining the list of built-in subcommands for the CLI interface.",
      "description_length": 481,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Driver.Plugin",
      "library": "catala.driver",
      "description": "Registers command-line plugins with documentation and options handling. Works with command-line arguments and plugin registration interfaces. Used to extend application functionality through pluggable commands with associated help and manual pages.",
      "description_length": 248,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Driver",
      "library": "catala.driver",
      "description": "This module coordinates program execution by parsing command lines and managing plugins, serving as the entry point for structuring compiler or tooling pipelines. It integrates pass definitions for transforming programs across intermediate representations\u2014such as parsing, type checking, and optimization\u2014with utilities for CLI command setup, output formatting, and identifier resolution. The interface supports defining built-in and plugin commands, enabling extensible command sets with custom help, argument parsing, and execution logic. Example usage includes compiling Catala code through multiple stages into an executable form, while allowing third-party extensions to add new compilation passes or CLI subcommands.",
      "description_length": 722,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StructName.Map",
      "library": "catala.shared_ast",
      "description": "This module provides key-based map operations like insertion, deletion, lookup, and filtering, alongside transformations such as merging, splitting, and mapping over values. It handles maps with keys of type `Shared_ast.StructName.t` and arbitrary value types (`'a`), supporting conversions to/from lists/sequences and customizable pretty-printing. Typical applications include managing relationships between AST structures and their properties or aggregating heterogeneous AST data into unified representations.",
      "description_length": 512,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Print.ExprConciseParam",
      "library": "catala.shared_ast",
      "description": "This module provides functions to print concise representations of expressions, variables, literals, and operators in a generic AST structure. It works with marked expressions, literals, and variables defined in `Shared_ast` and supports customizable printing through a bypass function. Concrete use cases include generating readable output for debugging or logging specific nodes in an abstract syntax tree without full traversal.",
      "description_length": 431,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.TopdefName.Map",
      "library": "catala.shared_ast",
      "description": "Implements functional map operations for associations between top definition names and arbitrary values, supporting ordered traversal, value transformations, and map merging. It operates on maps with `Shared_ast.TopdefName.t` keys, providing functions to convert to lists/sequences, format contents, and perform structured iteration. Useful in symbol table management, AST processing pipelines, and debugging contexts where named definitions require organized",
      "description_length": 459,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.EnumConstructor.Set",
      "library": "catala.shared_ast",
      "description": "This module implements a functional set library for manipulating collections of enum constructors, supporting operations like union, intersection, difference, filtering, and subset checks. It works with sets containing `Shared_ast.EnumConstructor.t` elements, providing transformations to and from lists/sequences while ensuring efficient membership testing and predicate-based element retrieval. These capabilities are useful in scenarios requiring precise handling of unique enum variants during AST analysis or transformation tasks.",
      "description_length": 535,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Typing.Env",
      "library": "catala.shared_ast",
      "description": "This module manages typing environments for type inference in a calculus with union-find unification. It supports operations to add variables (local, top-level, and scope-specific), define scopes with variable mappings, and open scopes during typing. It works with naked types annotated with positions and scoped variable maps, primarily used to track type bindings and enforce type consistency during expression typing.",
      "description_length": 420,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.TopdefName.Set",
      "library": "catala.shared_ast",
      "description": "This module provides a functional set abstraction for managing collections of top-level definition names from an abstract syntax tree (AST), supporting operations like membership checks, union/intersection/difference calculations, and element filtering. It works with sets containing unique identifiers of top-level definitions (`Shared_ast.TopdefName.t`) and facilitates conversions between sets, lists, and sequences. Typical use cases include analyzing dependencies between definitions, tracking declared entities, or performing set-theoretic comparisons during AST processing tasks.",
      "description_length": 586,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Print.ExprDebugParam",
      "library": "catala.shared_ast",
      "description": "This module customizes the debugging output of expression nodes in a marked generic AST by allowing conditional bypass of default printing, preprocessing expressions, and defining specific formatting for operators, literals, and variables. It operates on marked expressions, variables, and literals from the shared AST definitions. Concrete use cases include selectively suppressing logging of certain expression subtrees and formatting intermediate AST nodes during debugging.",
      "description_length": 477,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.Print.EXPR_PARAM",
      "library": "catala.shared_ast",
      "description": "This module handles the printing of expression parameters in the shared AST, providing functions to format and output variables, literals, and operators. It works with marked expressions, customizable via a bypass function to control printing behavior for specific nodes. Concrete use cases include generating readable representations of expressions during debugging or logging, and customizing output for specific expression types like variables or literals.",
      "description_length": 459,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.StructName.Set",
      "library": "catala.shared_ast",
      "description": "This module supports operations like union, intersection, difference, and subset checks on collections of structure names, alongside transformations through mapping, folding, and filtering. It works with sets, sequences, and lists, enabling conversions between these structures and iterative manipulation of their elements. Such functionality is useful for managing unique structure name collections in AST analyses or coordinating data across different collection formats during program processing.",
      "description_length": 499,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.RuleName.Map",
      "library": "catala.shared_ast",
      "description": "This module provides functions for creating, transforming, and querying maps that associate rule names with arbitrary values, supporting operations like insertion, filtering, folding, and union. It handles polymorphic data structured around keys of type `Shared_ast.RuleName.t`, enabling safe access, ordered traversal, and customizable formatting for structured output. Typical applications include static analysis of rule-based systems, merging disjoint rule sets, and generating human-readable representations of rule-value mappings.",
      "description_length": 536,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.ScopeName.Map",
      "library": "catala.shared_ast",
      "description": "This module provides ordered map operations for keying arbitrary data with scope names, including insertion, lookup, merging, and transformations. It supports compiler workflows by enabling structured data management across AST scopes, with utilities for sequence conversion, ordered iteration, and customizable pretty-printing of scope-bound values.",
      "description_length": 350,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Expr.Box",
      "library": "catala.shared_ast",
      "description": "This module provides operations for constructing and manipulating boxed expressions with separate annotations, using Bindlib for variable binding. It supports delayed annotation injection and efficient handling of free variables in expressions. Concrete use cases include building annotated abstract syntax trees while managing variable capture and closure checks during term construction.",
      "description_length": 389,
      "index": 84,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.ScopeName.Set",
      "library": "catala.shared_ast",
      "description": "This module provides functions for set operations like union, intersection, difference, filtering, and partitioning over collections of unique scope names used in abstract syntax trees. It supports conversion to and from sequences and lists, enabling efficient iteration and ordered processing of scope name sets. Typical applications include managing scope hierarchies, checking overlaps between name sets, and transforming sequences of identifiers into structured sets.",
      "description_length": 471,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Print.ExprGen",
      "library": "catala.shared_ast",
      "description": "This module provides a function to print marked expressions in a formatted way, using a generic AST structure that includes type and mark information. It works with expressions parameterized by type and mark, as defined in the shared AST definitions. A concrete use case is generating readable output for expressions during debugging or logging in a compiler or interpreter.",
      "description_length": 374,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.EnumName.Map",
      "library": "catala.shared_ast",
      "description": "This module supports standard associative map operations over keys of type `Shared_ast.EnumName.t`, with polymorphic values, enabling creation, modification, traversal, and comparison. It includes utilities for safe value retrieval, key ordering queries (min/max, first/last), sequence conversion, and merging maps with customizable formatting. Designed for scenarios requiring structured manipulation of enum-keyed mappings, such as AST analysis or configuration management where precise key-value associations and pretty-printing are critical.",
      "description_length": 545,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Var.Map",
      "library": "catala.shared_ast",
      "description": "This module implements a polymorphic map specialized for variable bindings in AST-related contexts, using `Shared_ast.Var.var` as keys. It supports standard map operations like `add`, `find`, `mem`, and `fold`, along with utilities for merging, formatting, and extracting keys or values. Concrete use cases include tracking variable definitions, managing expression substitutions, and collecting variable metadata during AST transformations.",
      "description_length": 441,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.ScopeVar.Set",
      "library": "catala.shared_ast",
      "description": "This component provides functional set abstractions for manipulating scoped variables in abstract syntax trees, supporting operations like union, intersection, filtering, and element retrieval with safe access patterns. It operates on sets of scoped variables and facilitates conversions between these sets and sequences, enabling efficient iteration and structural transformation. These utilities are particularly useful in compiler phases requiring precise variable scope tracking, such as name resolution, capture analysis, or optimization passes.",
      "description_length": 550,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.LabelName.Set",
      "library": "catala.shared_ast",
      "description": "This module implements a functional set API for managing immutable collections of label names, supporting operations like union, intersection, and difference alongside ordered set manipulations such as min/max",
      "description_length": 209,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.RuleName.Set",
      "library": "catala.shared_ast",
      "description": "This module supports set operations like union, intersection, and difference for collections of rule names, enabling efficient membership checks, element filtering, and subset analysis. It works with sets of `RuleName` elements and sequences, offering conversions between lists, sequences, and sets while preserving ordering. Typical use cases include tracking rule dependencies, validating unique rule applications, or analyzing hierarchical relationships in ASTs.",
      "description_length": 465,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.ScopeVar.Map",
      "library": "catala.shared_ast",
      "description": "This module implements associative maps for scoped variable environments, offering insertion, lookup, filtering, and ordered traversal operations over key-value pairs where keys are scoped identifiers. It supports polymorphic value types and provides utilities for merging, transforming, and formatting hierarchical bindings with customizable separators. Common applications include managing lexical scope hierarchies in compilers, tracking variable declarations across AST nodes, and serializing structured environment data for debugging.",
      "description_length": 539,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.EnumConstructor.Map",
      "library": "catala.shared_ast",
      "description": "This module implements a polymorphic map structure for binding `Shared_ast.EnumConstructor` keys to arbitrary values, offering operations like lookup, union, transformation, and ordered traversal. It supports conversions to/from lists and sequences, along with customizable pretty-printing of keys, values, and bindings via `Format.formatter`. Such functionality is particularly useful for managing metadata or attributes associated with enum constructors in AST processing tasks, such as type-checking or code generation pipelines.",
      "description_length": 532,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StateName.Set",
      "library": "catala.shared_ast",
      "description": "This module enables functional manipulation of sets containing state names used in ASTs, providing standard operations like union, intersection, and subset comparisons. It supports conversion between sets, lists, and sequences, along with filtering and safe element retrieval, facilitating tasks such as static analysis or transformation of AST-based state representations. The operations are optimized for handling ordered traversals and constructing sets from sequential data during AST processing.",
      "description_length": 500,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StateName.Map",
      "library": "catala.shared_ast",
      "description": "This module implements ordered map manipulation and functional transformations for key-value associations where keys are structured state identifiers from an abstract syntax tree. It supports persistent map structures with operations like insertion, deletion, union, and filtering, alongside conversions to and from sequences, key-value extractions, and pretty-printing capabilities using format specifiers. Typical applications include environment management during AST traversal, merging disjoint state mappings, and debugging visualizations of complex state relationships.",
      "description_length": 575,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.StructField.Map",
      "library": "catala.shared_ast",
      "description": "This module offers operations to manipulate maps with keys representing structural fields from an abstract syntax tree and values of arbitrary types. It supports creating, modifying, and querying these maps through standard associative operations, transforming values with or without key context, and converting between maps and sequences or lists. Such functionality is particularly useful for managing field-level metadata, analyzing hierarchical data structures, or generating formatted representations of AST components in compiler or language processing tools.",
      "description_length": 565,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StructField.Set",
      "library": "catala.shared_ast",
      "description": "This module supports set-theoretic operations on collections of AST structure fields, enabling union, intersection, difference, and subset comparisons alongside element-wise transformations. It works with sets of `Shared_ast.StructField.t` values and their conversions to and from sequences, facilitating bulk processing of structured field data. Typical applications include analyzing field overlaps in composite data structures or normalizing AST fragments during code transformation passes.",
      "description_length": 493,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Qident.Map",
      "library": "catala.shared_ast",
      "description": "This module provides ordered map operations for key-value pairs where keys are hierarchical module identifiers (`Shared_ast.Qident.t`), supporting creation, modification, and traversal with ordered key comparisons. It enables use cases like managing dependencies between compilation units, resolving module paths, or tracking symbol bindings, leveraging ordered iteration and associative operations such as union, filtering, and sequence-based construction. The design emphasizes structured manipulation of hierarchical identifiers through key ordering and collision handling, suitable for compiler or interpreter contexts.",
      "description_length": 623,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Var.Set",
      "library": "catala.shared_ast",
      "description": "This module provides standard set operations like adding, removing, and checking membership of variables, as well as set union, difference, and iteration. It works with sets of variables parameterized by an AST type. Concrete use cases include tracking bound variables in expressions, managing free variable sets during analysis, and handling variable dependencies in transformations.",
      "description_length": 384,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Print.UserFacing",
      "library": "catala.shared_ast",
      "description": "This module provides localized printing functions for primitive values like integers, decimals, dates, and durations, formatting them for end-user readability in a specified backend language. It includes printers for literals, expressions, and values within a marked AST structure, converting these into user-friendly strings or outputting them directly to a formatter. Concrete use cases include displaying evaluation results or intermediate values in a locale-aware format during program execution or debugging.",
      "description_length": 513,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Qident.Set",
      "library": "catala.shared_ast",
      "description": "The module provides set operations such as union, intersection, difference, and membership checks for collections of qualified identifiers, alongside transformations like filtering, mapping, and partitioning. It supports conversions between sets, ordered lists, and sequences, ensuring element uniqueness and consistent ordering. These features are used for managing module dependencies, resolving hierarchical name references, and analyzing relationships between compilation units in multi-file systems.",
      "description_length": 504,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.ScopeName",
      "library": "catala.shared_ast",
      "description": "This module manages scope names in an abstract syntax tree, offering creation, comparison, and formatting operations for the `t` type, which represents a scope name with path and source information. It provides set and map collections for efficient lookup and manipulation, supporting AST transformations and fresh name generation. The map submodule enables keying arbitrary data with scope names, offering insertion, lookup, and ordered iteration, while the set submodule handles union and intersection operations for collections of scope names. Examples include tracking scoped identifiers, managing scope hierarchies, and converting identifier sequences into structured sets for analysis.",
      "description_length": 691,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Typing",
      "library": "catala.shared_ast",
      "description": "This module performs type inference and checking for expressions and programs in the default calculus using the W algorithm with union-find unification. It operates on expressions and programs defined in `Shared_ast__.Definitions`, handling type annotation, unification, and error term resolution. The typing environment submodule supports adding variables, defining and opening scopes, and managing type bindings with position-annotated types and scoped variable maps. Together, they enable inferring types for untyped expressions, verifying expressions against expected types, and performing full-program typing for downstream compilation stages like dcalc or lcalc.",
      "description_length": 668,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.Operator",
      "library": "catala.shared_ast",
      "description": "This module defines a generalized operator type with support for monomorphic, polymorphic, overloaded, and resolved operations used across ASTs. It includes specific operators for arithmetic, comparisons, date manipulations, list transformations, and type conversions, each tagged with their resolution status and typing information. Functions allow resolving overloads, translating operators between compilation stages, and determining operator types based on context.",
      "description_length": 469,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.ScopeVar",
      "library": "catala.shared_ast",
      "description": "This module manages scoped variables with positional information, using a custom type `t` to represent unique variable identifiers with source positions. It supports creation, comparison, and formatting operations for these identifiers, enabling precise tracking of variable declarations and references in ASTs. The set submodule provides functional abstractions for variable set manipulation, supporting union, intersection, and filtering, while the map submodule implements scoped variable environments with polymorphic bindings, allowing insertion, lookup, and ordered traversal. These components together facilitate tasks like name resolution, capture analysis, and lexical scope management in compiler passes.",
      "description_length": 714,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Qident",
      "library": "catala.shared_ast",
      "description": "Qualified identifiers are represented as a combination of a module path and an identifier name, enabling comparison, equality checks, and formatting. The module includes set and map implementations for efficient collection operations, supporting union, intersection, filtering, and ordered traversal based on hierarchical module identifiers. These features facilitate managing dependencies, resolving symbol bindings, and analyzing relationships between compilation units. Example uses include tracking cross-module references and constructing ordered sequences of module paths with associated values.",
      "description_length": 601,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.Op",
      "library": "catala.shared_ast",
      "description": "This module defines a generalized operator type with classifications for monomorphic, polymorphic, overloaded, and resolved variants. It includes specific operations for arithmetic, comparison, date manipulation, type conversion, and collection transformations, with explicit variants for resolved types like integers, rationals, money, and durations. Concrete use cases include modeling typed operators in ASTs for domain-specific languages, enabling precise type handling during expression evaluation and compilation.",
      "description_length": 519,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.Program",
      "library": "catala.shared_ast",
      "description": "This module provides operations to transform and analyze programs in an abstract syntax tree, including mapping expressions, folding over program elements, and extracting scope bodies. It works with program structures containing expressions, types, and scopes, along with associated metadata such as marks and modules. Concrete use cases include rewriting expressions during type checking, extracting the body of a specific scope, and converting a program into a single expression for evaluation.",
      "description_length": 496,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Interpreter",
      "library": "catala.shared_ast",
      "description": "Implements evaluation of expressions and programs in the default calculus, handling operators, thunks, and scope variables. Works with marked expressions, declaration contexts, and programs containing monomorphic and polymorphic terms. Used to execute Catala programs by interpreting function bodies with empty defaults and returning computed scope variable values.",
      "description_length": 365,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StructName",
      "library": "catala.shared_ast",
      "description": "This module manages structured names in ASTs using unique identifiers and positioned strings, providing comparison, hashing, and formatting operations. It supports key-based maps and set-like collections through its submodules, enabling efficient lookups, transformations, and aggregations over structured names and their associated data. You can track variable names with source locations, merge property maps, or compute intersections of name sets during AST analysis. Specific operations include inserting into maps, filtering name collections, and converting between lists, sets, and sequences with custom formatting.",
      "description_length": 621,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.StructField",
      "library": "catala.shared_ast",
      "description": "This module represents structured fields with positional information, enabling the creation, comparison, hashing, and formatting of fields used across abstract syntax trees. It provides core operations for managing labeled data fields and tracking metadata such as source locations, supporting use cases like AST manipulation and structured data consistency. The associated map module allows associating arbitrary data with fields, enabling transformations and queries over AST components, while the set module supports set-theoretic operations for analyzing and processing collections of fields. Together, they facilitate tasks like metadata management, hierarchical data analysis, and normalization of AST fragments in language processing tools.",
      "description_length": 747,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Print",
      "library": "catala.shared_ast",
      "description": "This module formats and prints abstract syntax tree elements with consistent styling for types, operators, and literals, supporting both user-facing and diagnostic output. It works directly with generic AST structures like expressions, scopes, and programs, offering operations to customize formatting through bypass functions and contextual handling. Submodules provide specialized printing for expressions, variables, literals, and primitive values, enabling selective logging, suppression of subtrees, and locale-aware formatting. Examples include generating readable code representations for users, logging intermediate evaluation values, and customizing debug output for specific AST nodes.",
      "description_length": 695,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.Expr",
      "library": "catala.shared_ast",
      "description": "This module handles typed, marked expressions with support for variables, literals, tuples, arrays, function application, and control structures, enabling AST traversal, simplification, free variable analysis, and source position management. It works with generalized expressions parameterized by type and mark information, and includes support for structs, enums, thunks, and let-bindings. The child module extends this by providing boxed expressions with separate annotations, using Bindlib to manage variable binding, delayed annotation injection, and efficient free variable handling. Together, they support building and transforming complex annotated expression trees while ensuring correct variable capture and closure behavior during compilation or optimization.",
      "description_length": 769,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.TopdefName",
      "library": "catala.shared_ast",
      "description": "This module represents top-level definition names in an abstract syntax tree, combining module paths with marked string identifiers to enable precise identification and manipulation of top-level constructs. It provides core operations for comparison, hashing, formatting, and component extraction, while its child modules support functional maps and sets for organizing associations and collections of these names. The map module enables ordered traversal, value transformations, and structured iteration over bindings keyed by definition names, and the set module supports membership checks, set operations, and filtering for managing unique definition identifiers. Together, they facilitate tasks like symbol table construction, dependency analysis, and AST transformation pipelines.",
      "description_length": 785,
      "index": 114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.Var",
      "library": "catala.shared_ast",
      "description": "This module represents variables in generic AST expressions, enabling creation, comparison, hashing, and translation across expression types. It supports variable sets and maps through its submodules, facilitating operations like binding management, substitution, and metadata collection during AST transformations. The `Set` submodule handles variable set operations such as union, difference, and membership checks, while the `Map` submodule provides a polymorphic map for variable-based keying with utilities for merging and formatting. Examples include tracking free variables in expressions, managing substitutions during rewriting, and collecting variable dependencies in analysis passes.",
      "description_length": 694,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.LabelName",
      "library": "catala.shared_ast",
      "description": "This module represents labeled names in an abstract syntax tree with positional information, enabling creation of fresh names, retrieval of source details, and comparison, hashing, and formatting. It provides core operations for managing named entities with metadata in AST processing, such as generating unique identifiers and extracting source positions. The associated set module offers a functional API for immutable collections of label names, supporting union, intersection, difference, and ordered operations like min and max. Together, they facilitate efficient manipulation and analysis of named elements in language processing tasks.",
      "description_length": 643,
      "index": 116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.StateName",
      "library": "catala.shared_ast",
      "description": "This module manages state names with positional annotations, enabling creation, comparison, and formatting of identifiers used in ASTs. It defines core types `t` for state names and `info` for position metadata, supporting direct operations like parsing, pretty-printing, and comparison with submodules for collection handling. The set submodule provides ordered state name sets with efficient union and intersection, useful for static analysis, while the map submodule handles key-value associations over state identifiers, supporting environment tracking and structured state transformations during AST traversal. Examples include extracting state dependencies from AST nodes, merging state environments, and visualizing state relationships with source location context.",
      "description_length": 772,
      "index": 117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.EnumName",
      "library": "catala.shared_ast",
      "description": "This module manages enum names within an abstract syntax tree, offering operations to create fresh names, compare and hash existing names, and extract path and position metadata. It supports enum names composed of module paths and marked identifiers, enabling precise source tracking and uniqueness, with key operations including name generation, comparison, and metadata extraction. The associated map module extends this functionality by providing associative map operations over enum name keys, allowing structured manipulation of key-value mappings with support for safe retrieval, ordered queries, and customizable formatting. Together, they facilitate tasks like AST construction, error reporting with source locations, and configuration management requiring precise enum-keyed associations.",
      "description_length": 797,
      "index": 118,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.Optimizations",
      "library": "catala.shared_ast",
      "description": "This module performs optimization passes on expressions and programs in a typed intermediate representation, specifically targeting reductions and simplifications in default calculus and lambda calculus. It operates on complex generalized expressions and programs that include features like polymorphism, resolution, and assertions, while excluding syntactic names and scope variables. Concrete optimizations include iota reduction tests, which simplify nested conditionals or eliminate redundant constructs in expressions.",
      "description_length": 523,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.EnumConstructor",
      "library": "catala.shared_ast",
      "description": "This module represents named constructors for enumerated types, each annotated with positional information, and supports creation, comparison, hashing, and string conversion. Its main type enables modeling distinct cases in sum types within ASTs, while the `Set` submodule provides efficient set operations like union, intersection, and filtering for collections of constructors. The `Map` submodule offers a polymorphic map for binding enum constructors to arbitrary values, supporting lookups, transformations, and customizable pretty-printing. Together, they facilitate precise manipulation and analysis of enum variants in AST processing tasks such as type-checking and code generation.",
      "description_length": 690,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Type",
      "library": "catala.shared_ast",
      "description": "This module represents and manipulates annotated type expressions with positional information, enabling operations such as formatting, equality, comparison, and unifiability checks. It supports recursive type structures, including arrows and type variables, facilitating pattern-matching and structural analysis for tasks like type checking, inference, and transformation across ASTs. The child modules extend this functionality with utilities for type traversal, substitution, and environment management, allowing manipulation of complex type hierarchies. For example, you can compare two type expressions for structural equivalence, substitute type variables during inference, or analyze function types in recursive contexts.",
      "description_length": 727,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.Scope",
      "library": "catala.shared_ast",
      "description": "This module provides operations for transforming, analyzing, and converting scope-based code structures in the shared AST. It supports mapping and folding over expressions within scopes, extracting type information, and computing free variables. Concrete use cases include rewriting expressions during compilation passes, type checking scope bodies, and analyzing variable dependencies in scoped constructs.",
      "description_length": 407,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Shared_ast.RuleName",
      "library": "catala.shared_ast",
      "description": "This module manages rule names with positional annotations, providing core types `t` for names and `info` for associated source locations. It supports direct operations like comparison, formatting, and rule name construction, while its map and set submodules enable structured collection handling. The map submodule associates rule names with arbitrary values, supporting transformations, unions, and ordered traversal, ideal for static analysis and rule merging. The set submodule enables efficient set operations and membership queries, useful for dependency tracking and rule validation in ASTs.",
      "description_length": 598,
      "index": 123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast.BoundList",
      "library": "catala.shared_ast",
      "description": "This module implements operations for traversing and transforming non-empty, binder-linked lists, where each element introduces a binding scope for the subsequent elements. It provides functions for mapping, folding, iterating, and comparing elements while preserving binding relationships, along with bidirectional traversal and structural equality checks. These lists are used to represent ordered, nested constructs like sequences of let-bindings in an abstract syntax tree.",
      "description_length": 477,
      "index": 124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Shared_ast",
      "library": "catala.shared_ast",
      "description": "This module provides core abstractions for building and manipulating abstract syntax trees with rich structural and semantic information. It defines generalized types for expressions, types, operators, variables, and scopes, supporting operations like type inference, name resolution, transformation, and optimization across multiple compilation stages. Key data structures include scoped variables, qualified identifiers, labeled fields, and typed expressions, enabling tasks such as free variable analysis, expression rewriting, and structured program traversal. Submodules enhance this foundation with scoped name management, type checking via unification, operator resolution, and AST formatting, allowing concrete applications like compiling domain-specific expressions, analyzing variable dependencies, and optimizing typed intermediate representations.",
      "description_length": 859,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lazy_interpreter.Lazy_interp.Env",
      "library": "lazy_interpreter",
      "description": "This module manages variable bindings and environment state during the interpretation of expressions. It supports operations to add variables to an environment, look up existing variables, merge environments, and print their contents. It works with expressions and marked variables in the `Shared_ast` structure, handling scoped evaluations for interpreter workflows.",
      "description_length": 367,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lazy_interpreter.Lazy_interp",
      "library": "lazy_interpreter",
      "description": "This module evaluates expressions lazily within a structured environment, using context and configuration to control evaluation depth and handle errors with precise positional feedback. It processes `gexpr` values from the `Shared_ast`, supporting operations like variable binding, environment merging, and scoped lookups through its environment module. Users can interpret program expressions, execute top-level commands, and manage dynamic scopes with structured logging and error reporting. Specific examples include evaluating conditional expressions, handling default values, and tracing variable resolution across nested environments.",
      "description_length": 640,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lazy_interpreter",
      "library": "lazy_interpreter",
      "description": "This module evaluates expressions lazily using structured environments, allowing control over evaluation depth and providing precise error feedback. It supports variable binding, environment merging, and scoped lookups to interpret program expressions and execute commands. Users can evaluate conditionals, resolve variables across nested scopes, and trace evaluation steps with dynamic scoping and logging. Examples include lazy evaluation of `gexpr` values, handling defaults in expressions, and managing environments during interpretation.",
      "description_length": 542,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.Ast.VarName.Map",
      "library": "catala.scalc",
      "description": "This module implements a polymorphic map structure for associating variable names (`Scalc.Ast.VarName.t`) with arbitrary data, supporting core operations like insertion, deletion, lookup, and traversal alongside advanced transformations such as merging, filtering, and value mapping. It provides utilities for safe key-based queries (e.g., min/max entry retrieval), structural manipulation (splitting, disjoint unions), and bidirectional conversion with lists and sequences. Designed for scenarios requiring efficient variable binding management\u2014such as symbol table construction, AST traversal, or interpreter context handling\u2014it also includes formatting tools for human-readable serialization of keys, values, and entire maps.",
      "description_length": 728,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scalc.Ast.FuncName.Map",
      "library": "catala.scalc",
      "description": "This module implements maps with keys of type `Scalc.Ast.FuncName.t` and polymorphic values, supporting insertion, deletion, combination, and transformation operations. It provides utilities for querying bindings, extracting keys or values as lists, merging maps with disjoint keys, and converting to or from sequences. The module also includes customizable pretty-printing functions for formatting map contents, making it suitable for tasks like managing function symbol tables, processing structured data, or generating human-readable representations of mappings.",
      "description_length": 565,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.Ast.VarName.Set",
      "library": "catala.scalc",
      "description": "This module provides standard set operations for managing collections of variable names from an abstract syntax tree, including membership checks, union/intersection/difference, element selection (min/max), and conversions to lists and sequences. It works with immutable sets of `Scalc.Ast.VarName.t` values, supporting functional workflows for analyzing or transforming AST structures. These operations are particularly useful for tasks like tracking declared variables, computing free variables, or managing dependencies in compiler pipelines.",
      "description_length": 545,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scalc.Ast.FuncName.Set",
      "library": "catala.scalc",
      "description": "This module supports standard set operations like union, intersection, and difference for collections of function names, alongside transformations such as mapping, folding, and filtering. It works with sets of `Scalc.Ast.FuncName.t` values and provides conversions to and from lists and sequences (`Stdlib.Seq.t`). Typical use cases include analyzing or manipulating groups of function names in ASTs, such as tracking dependencies or resolving symbol collisions.",
      "description_length": 462,
      "index": 132,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Scalc.Ast.FuncName",
      "library": "catala.scalc",
      "description": "This module represents named functions in an abstract syntax tree, supporting operations for generating, comparing, and formatting function names with source position tracking for precise error reporting. It provides direct access to name creation, hashing, and string conversion, while its child modules extend functionality to mappings and sets of function names. The maps module enables structured management of function bindings with customizable pretty-printing, suitable for symbol table construction and transformation pipelines. The sets module facilitates analysis and manipulation of function name collections, supporting operations like union and difference for tasks such as dependency tracking and collision resolution.",
      "description_length": 732,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.Ast.VarName",
      "library": "catala.scalc",
      "description": "This module represents variable names with source position metadata, enabling creation, comparison, and formatting of variables during expression parsing and evaluation. It supports direct operations like generating fresh variables, hashing, and string conversion, while its submodules provide structured handling of variable mappings and sets. The polymorphic map module manages associations between variables and data, offering insertion, lookup, and transformation operations ideal for symbol tables and interpreter contexts. The set module implements standard set operations for collections of variables, supporting tasks like free variable computation and dependency tracking in compiler pipelines.",
      "description_length": 703,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.Ast",
      "library": "catala.scalc",
      "description": "This module defines the abstract syntax tree for a calculator language, encompassing expressions, statements, program structure, and core constructs like variables, functions, control flow, and error handling. It directly supports operations such as declaration, definition, and transformation of program elements, while its child modules provide structured handling of function and variable names with source positions, including mappings and sets for symbol table construction and analysis. Function names are tracked with positional metadata and support hashing, comparison, and custom formatting, enabling precise error reporting and transformation pipelines. Variables offer similar operations, with polymorphic maps and sets facilitating interpreter contexts, free variable computation, and dependency tracking in compiler workflows.",
      "description_length": 839,
      "index": 135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scalc.Print",
      "library": "catala.scalc",
      "description": "This module formats abstract syntax trees into human-readable output. It provides functions to print individual code items and entire programs using OCaml's formatting library. Useful for debugging parsers or compilers by visualizing structured program data.",
      "description_length": 258,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Scalc.To_c",
      "library": "catala.scalc",
      "description": "Converts a lambda calculus program into a syntactically correct C89 program using a formatter. It processes an abstract syntax tree along with a list of type dependency vertices to ensure proper ordering and translation. Useful for compiling functional programs to C for execution or integration with C-based systems.",
      "description_length": 317,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.To_r",
      "library": "catala.scalc",
      "description": "Converts a lambda calculus program into executable R code by formatting it according to R syntax rules. Works with abstract syntax trees representing lambda calculus programs and a list of type dependency vertices to manage ordering. Useful for compiling functional programs written in a lambda calculus subset into R scripts that can be directly evaluated.",
      "description_length": 357,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.From_lcalc",
      "library": "catala.scalc",
      "description": "Translates Lcalc programs into Scalc programs, applying transformations controlled by a configuration. Handles higher-order operators, dead value assignments, and struct literal initialization based on target language requirements. Useful for compiling Lcalc code to C or Python, where specific AST structures or variable handling are needed.",
      "description_length": 342,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc.To_python",
      "library": "catala.scalc",
      "description": "Converts a lambda calculus program into executable Python code by formatting it according to Python syntax rules. It takes an abstract syntax tree (AST) of the program and a list of type dependencies, ensuring the generated Python output respects the correct ordering and structure. This module is used when exporting Scalc programs to Python for execution or integration with Python-based tooling.",
      "description_length": 398,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Scalc",
      "library": "catala.scalc",
      "description": "This module provides a comprehensive framework for parsing, transforming, and compiling lambda calculus programs into multiple target languages. It centers around an abstract syntax tree representation that supports expressions, statements, variables, and functions with positional metadata, enabling precise error handling and transformation pipelines. Operations include pretty-printing for debugging, symbol table construction, free variable analysis, and translation to C89, Python, and R. Example uses include compiling functional programs to C for performance, exporting to Python for integration with data science tools, or generating R scripts for statistical evaluation.",
      "description_length": 679,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Json_schema.To_json",
      "library": "json_schema",
      "description": "This module converts Lcalc Catala program representations into JSON schemas for web forms. It provides functions to format structural field names in camel case, print literal and general types, generate struct properties, and output full program schemas. It operates on data types like `Shared_ast.typ`, `Shared_ast.StructField.t`, and `Lcalc.Ast.program`, with concrete use cases in generating form definitions from Catala programs.",
      "description_length": 433,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Json_schema",
      "library": "json_schema",
      "description": "This module processes Catala source files into JSON schemas, supporting formatting options and integration with command-line arguments via `Cmdliner`. It operates on `Catala_utils.Global.raw_file` lists and transforms Lcalc program representations into structured JSON outputs, including web form definitions. Key data types include `Shared_ast.typ`, `Shared_ast.StructField.t`, and `Lcalc.Ast.program`, with operations for type printing, struct property generation, and schema formatting in camel case. Concrete use cases involve converting Catala programs into JSON schemas for validation pipelines or external tool integration.",
      "description_length": 630,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc.Compile_without_exceptions",
      "library": "catala.lcalc",
      "description": "Translates programs from the default calculus to the lambda calculus using an option monad to handle empty default terms. It operates on abstract syntax trees (ASTs) of both the source and target calculi. This transformation enables compilation to legacy languages that lack exception handling.",
      "description_length": 294,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc.Monomorphize",
      "library": "catala.lcalc",
      "description": "This function processes a typed Lcalc program to eliminate polymorphism by generating monomorphic versions of functions based on their type usage. It returns the transformed program along with a list of dependency graph vertices representing the newly created function instances. This is essential for compilation stages that require concrete types, such as code generation or optimization passes.",
      "description_length": 397,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lcalc.Closure_conversion",
      "library": "catala.lcalc",
      "description": "Converts lambda calculus programs into a closure-converted form using environment-passing style, transforming functions to take explicit environments as arguments. Operates on lambda calculus ASTs extended with untyped constructs, producing programs where all closures are hoisted to top level. Useful for compiling higher-order functions into a form suitable for lower-level execution or further optimization passes like code generation or closure analysis.",
      "description_length": 458,
      "index": 146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lcalc.To_ocaml",
      "library": "catala.lcalc",
      "description": "This module translates lambda calculus programs into valid OCaml code by handling naming, formatting, and structural transformations. It operates on lambda calculus ASTs, type definitions, and variable representations, ensuring proper syntax and avoiding OCaml keyword conflicts. Concrete use cases include compiling lambda expressions into executable OCaml modules and generating OCaml type definitions from structured data models.",
      "description_length": 432,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc.Compile_with_exceptions",
      "library": "catala.lcalc",
      "description": "Translates programs from the default calculus to the lambda calculus, using exceptions to manage cases with empty default terms. Operates on abstract syntax trees (ASTs) of programs in both calculi. Useful for compiling or transforming programs that may contain incomplete or empty terms.",
      "description_length": 288,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc.Ast",
      "library": "catala.lcalc",
      "description": "This module defines the structure of lambda calculus expressions, including variables, abstractions, and applications. It provides constructors for building and pattern-matching over abstract syntax trees, enabling operations like substitution and evaluation. Concrete use cases include implementing lambda calculus interpreters, performing alpha conversion, and supporting type inference algorithms.",
      "description_length": 400,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc.From_dcalc",
      "library": "catala.lcalc",
      "description": "This module translates programs from the default calculus to the lambda calculus, handling empty default terms either through exceptions or an option monad. It operates on abstract syntax trees (`program`) from both the default calculus (`Dcalc.Ast`) and lambda calculus (`Lcalc.Ast`). The two translation strategies support compiling to languages with or without exception handling.",
      "description_length": 383,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lcalc",
      "library": "catala.lcalc",
      "description": "This module transforms programs through multiple stages, from an initial calculus into executable OCaml code or optimized lambda calculus forms. It supports translations using exceptions or option monads, polymorphism elimination, closure conversion, and OCaml code generation, operating on ASTs across different calculi. Key data types include lambda expressions, type definitions, and dependency graphs, with operations like substitution, environment passing, and naming resolution. Examples include compiling higher-order functions into top-level closures, generating monomorphic function instances, and producing OCaml modules from lambda calculus ASTs.",
      "description_length": 657,
      "index": 151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Uid.Gen_qualified.Map",
      "library": "catala.catala_utils",
      "description": "This module provides associative map operations for data structures using generative unique identifiers qualified with path information as keys, enabling efficient key-based manipulation, merging, and ordered traversal with physical equality optimizations. It supports structured data processing through transformations, value mapping, and customizable pretty-printing, suitable for managing hierarchical identifiers and generating formatted outputs with path-aware formatting.",
      "description_length": 477,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Cli.Flags.Global",
      "library": "catala.catala_utils",
      "description": "Handles command-line arguments for global configuration, including input source specification and error handling setup. Works with `Cmdliner.Term.t` and `Global.options` to define and parse command-line flags and positional arguments. Used to initialize global state and process input files or standard input in CLI applications.",
      "description_length": 329,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Gen.Map",
      "library": "catala.catala_utils",
      "description": "This module provides ordered map operations for managing collections of unique identifiers (uids) derived from marked strings, serving as keys paired with arbitrary values. It supports efficient insertion, deletion, ordered traversal, and transformation of maps, with utilities for merging, filtering, and structured output formatting using customizable separators. Typical use cases involve maintaining state or configurations where each element requires a distinct, comparable key and ordered access is critical.",
      "description_length": 514,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Module.Set",
      "library": "catala.catala_utils",
      "description": "This module implements set-theoretic operations for managing collections of globally unique identifiers, supporting union, intersection, difference, and subset checks with guaranteed element uniqueness. It works with ordered sets of `Catala_utils.Uid.Module.t` identifiers and provides transformations to sequences or lists, enabling efficient membership testing and ordered traversal. Typical use cases include dependency tracking, identifier set comparisons, and converting between set and sequential data representations for processing pipelines.",
      "description_length": 549,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Gen_qualified.Set",
      "library": "catala.catala_utils",
      "description": "Implements standard immutable set operations (union, intersection, difference, membership) and sequence transformations on ordered collections of globally unique identifiers with hierarchical path metadata. The module supports ordered iteration, element selection (min/max), and conversions between sets and sequences, leveraging a total ordering derived from identifier comparison. This facilitates use cases like managing structured identifiers in compiler pipelines or symbolic data processing where hierarchical uniqueness and ordered traversal are critical.",
      "description_length": 562,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Make.Set",
      "library": "catala.catala_utils",
      "description": "This module provides a comprehensive suite of immutable set operations for managing globally unique identifiers, including standard set-theoretic operations (union, intersection, difference), element-wise transformations, and ordered queries (min, max, filtering). It works with sets of type `t` generated by the `Uid.Make` functor, ensuring type-safe separation between distinct identifier namespaces. These operations are particularly useful for managing disjoint collections of identifiers in contexts like program analysis, transaction tracking, or data provenance, where maintaining strict type boundaries and efficient set operations over unique keys is critical.",
      "description_length": 669,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Gen.Set",
      "library": "catala.catala_utils",
      "description": "This module offers operations for manipulating ordered collections of globally unique identifiers derived from marked strings, supporting set-theoretic operations like union, intersection, and difference, alongside transformations such as filtering, partitioning, and element extraction. It works with polymorphic sets structured via `Set.Make`, leveraging a total ordering for comparisons, and facilitates interconversion with sequences to enable ordered traversal or bulk updates. Typical applications include managing identifier collections where uniqueness constraints, hierarchical relationships, or ordered processing are critical, such as in program analysis or structured data validation.",
      "description_length": 696,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Module.Map",
      "library": "catala.catala_utils",
      "description": "This module implements a functional map structure for key-value associations where keys are unique identifiers generated by a factory. It supports ordered traversal, merging of identifier-based mappings, and transformations that preserve key uniqueness while enabling value manipulation. Typical use cases include managing relationships between program elements with stable identifiers, such as AST node annotations or symbol table entries in compiler implementations.",
      "description_length": 468,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Make.Map",
      "library": "catala.catala_utils",
      "description": "This module implements type-safe maps with keys derived from generative unique identifiers, supporting immutable operations for construction, transformation, and querying while preserving key ordering. It handles maps binding these identifiers to arbitrary values, offering ordered traversal, set-theoretic combinations, and structured serialization with customizable formatting. Such maps are particularly useful for managing distinct identifier namespaces in formal systems while enabling efficient ordered processing and human-readable representations.",
      "description_length": 555,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Path",
      "library": "catala.catala_utils",
      "description": "Handles paths of globally unique identifiers for modules in a structured format. Provides operations to convert paths to strings, format them for output, and compare or check equality between paths. Useful for tracking hierarchical module structures in a type-safe way during compilation or analysis tasks.",
      "description_length": 306,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Map.OrderedType",
      "library": "catala.catala_utils",
      "description": "Defines a key type `t` with a total ordering function `compare` and a formatter `format`. It supports operations requiring ordered keys, such as building and manipulating maps with deterministic traversal or comparison. Used for ensuring consistent key handling in map structures, especially during serialization or ordered iteration.",
      "description_length": 334,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Style",
      "library": "catala.catala_utils",
      "description": "This module defines a specific style for printing unique identifiers (UIDs), ensuring consistent formatting across different kinds of UIDs. It provides a single value `style` of type `Ocolor_types.style`, which specifies the visual presentation when UIDs are rendered. This is particularly useful in contexts like logging, debugging, or user-facing output where distinguishable and stable UID representations are required.",
      "description_length": 422,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Id",
      "library": "catala.catala_utils",
      "description": "This module generates unique identifiers with associated metadata, supporting creation, comparison, and conversion to strings or hashes. It works with abstract identifier types and their associated info, enabling use in sets and maps. Concrete use cases include tracking distinct variables or expressions in a compiler or formal verification system.",
      "description_length": 349,
      "index": 164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Uid.Module",
      "library": "catala.catala_utils",
      "description": "This module generates and manages unique identifiers paired with metadata, offering operations to create fresh identifiers, retrieve metadata, and compare, hash, or format them. It supports abstract identifier values of type `t` and metadata of type `info`, useful for tracking distinct program entities or ensuring referential uniqueness. The set module extends it with union, intersection, and subset operations over identifier collections, enabling efficient dependency tracking and set conversions. The map module provides ordered, identifier-keyed associations, supporting merges and transformations ideal for AST annotations or symbol tables.",
      "description_length": 648,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Gen",
      "library": "catala.catala_utils",
      "description": "This module generates and manages unique identifiers from marked strings, offering operations to create fresh identifiers, access their metadata, and compare, hash, or format them. It includes set and map submodules that support ordered collections, enabling efficient insertion, traversal, and transformation with customizable formatting and interconversion with sequences. You can use it to track distinct entities with attached context in compilers or analysis tools, maintaining state with ordered keys or performing set operations on identifier collections. For example, you might use the map submodule to manage configuration values keyed by unique identifiers, or the set submodule to track and manipulate groups of identifiers with guaranteed uniqueness and ordering.",
      "description_length": 775,
      "index": 166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Uid.Info",
      "library": "catala.catala_utils",
      "description": "This module defines a data type `info` that carries contextual information for global identifiers, including source positions. It provides operations to convert `info` values to strings, format them, and compare them while ignoring positional details. Use cases include tracking and managing metadata for identifiers in a compiler or interpreter.",
      "description_length": 346,
      "index": 167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.File.Tree",
      "library": "catala.catala_utils",
      "description": "Represents a lazy tree structure that mirrors the filesystem, using case-insensitive path comparisons. It supports operations to build a tree from a filesystem path, retrieve subtrees or specific files, and merge trees with conflict resolution. This structure is useful for efficiently managing and querying hierarchical file data, particularly when handling virtual filesystems or layered directory structures.",
      "description_length": 411,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Cli.Flags",
      "library": "catala.catala_utils",
      "description": "This module structures command-line interactions for tools requiring modular type checking, code generation, or filtered dependency resolution, using string-based flags and command-specific options. It directly supports parsing optimization levels, input/output paths, file extensions, and directory filters via Cmdliner, enabling use cases like LaTeX output generation and dependency graph construction. The child module handles global configuration arguments, defining and parsing flags and positional arguments with `Cmdliner.Term.t` and `Global.options`. Together, they facilitate initializing global state, processing input files or standard input, and configuring error handling in CLI applications.",
      "description_length": 705,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Make",
      "library": "catala.catala_utils",
      "description": "This module generates distinct identifier types from a user-defined `info` type, ensuring type-level separation across instantiations to prevent accidental mixing of identifiers. It provides core operations for comparison, equality, and formatting, while its child modules extend functionality to sets and maps, enabling safe and efficient manipulation of identifier collections. The set module supports standard immutable set operations like union and filtering, ideal for tracking disjoint identifier domains in program analysis. The map module implements ordered, immutable maps from these identifiers to arbitrary values, suitable for structured environments requiring type-safe key-value associations and ordered traversal.",
      "description_length": 728,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.String.Map",
      "library": "catala.catala_utils",
      "description": "This module implements ordered maps with string keys and arbitrary value types, supporting operations like insertion, deletion, ordered traversal, and merging. It emphasizes key ordering through functions for min/max retrieval, splitting maps by keys, and sorted binding transformations, while providing safe optional variants for lookups. Use cases include structured data serialization, configuration management, and ordered key-value processing with customizable textual output formatting.",
      "description_length": 492,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.File.Set",
      "library": "catala.catala_utils",
      "description": "This module supports standard set operations like union, intersection, and difference for file objects, while enabling ordered set manipulations such as filtering, partitioning, and ordered traversal. It works with sets of `Catala_utils.File.t` values, leveraging a total ordering for comparisons and sequence-based conversions via `Stdlib.Seq.t`. These features are useful for managing file collections where uniqueness, ordered processing, or predicate-based selection are required.",
      "description_length": 484,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Message.Content",
      "library": "catala.catala_utils",
      "description": "This module constructs and manipulates structured compiler messages that support colored output and formatting through the `Format` module. It handles messages as functions operating on formatters, with support for adding positional information, suggestions, and error context before emission. Concrete use cases include generating diagnostic messages with source positions, wrapping results in context-specific formatting, and conditionally enabling color output based on terminal support.",
      "description_length": 490,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Uid.Id-Set",
      "library": "catala.catala_utils",
      "description": "This module provides immutable set operations for managing collections of globally unique identifiers, supporting structural equality checks, ordered traversal, and transformations like union, intersection, and filtering. It works with polymorphic sets (`Set.t`) and sequences (`Seq.t`), enabling conversions between these structures while preserving element ordering. Typical use cases include maintaining unique identifier collections with ordered iteration, efficiently combining or partitioning sets, and integrating set-based logic with sequence-driven processing pipelines.",
      "description_length": 579,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Id-Map",
      "library": "catala.catala_utils",
      "description": "This module implements persistent, ordered maps using unique identifiers as keys, supporting key-based transformations, set-like operations, and ordered traversal. It provides functions for safe value retrieval, map splitting/joining, and structured data conversion with customizable formatting, while handling edge cases via exceptions or optional returns. Typical use cases involve managing identifier-keyed metadata in compilers, processing ordered unique-key datasets, or generating human-readable map representations with specific layout requirements.",
      "description_length": 556,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.MarkedString",
      "library": "catala.catala_utils",
      "description": "This module represents identifiers annotated with source code positions, providing operations to convert to strings, format, and compare these identifiers while ignoring their positional data. It works with marked strings that carry both the identifier name and its declaration or usage position. Concrete use cases include tracking variable origins in a compiler or static analysis tool, where identifier equality and ordering must ignore source positions while preserving them for debugging or reporting.",
      "description_length": 506,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Map.S",
      "library": "catala.catala_utils",
      "description": "This module supports creation, transformation, and querying of finite maps with ordered keys, offering operations like insertion, deletion, traversal, and merging while preserving functional purity and optimized sharing through physical equality. It enables sorted-order processing via key-based splitting, min/max selection, and conversions to lists or sequences, leveraging the map\u2019s comparator for ordered iteration. Use cases include managing structured key-value data with efficient updates, extracting subsets based on ordering, and generating customizable textual representations of bindings for logging or serialization.",
      "description_length": 628,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.String.Set",
      "library": "catala.catala_utils",
      "description": "This module provides ordered string set manipulation through operations like union, intersection, difference, and ordered element retrieval (min, max). It works with `Catala_utils.String.Set.t` (ordered string sets) and supports conversions to/from sequences for ordered iteration or construction. Use cases include managing sorted unique string collections, deterministic traversal, and integrating with sequence-based processing pipelines.",
      "description_length": 441,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid.Gen_qualified",
      "library": "catala.catala_utils",
      "description": "This module generates unique identifiers paired with path information and metadata, supporting operations to create, compare, hash, and format identifiers while tracking source locations and scoped hierarchies. Its first child module provides associative maps using these identifiers as keys, enabling efficient key-based data manipulation, transformations, and structured output formatting. The second child module implements sets of identifiers with hierarchical metadata, supporting union, intersection, ordered traversal, and sequence conversions. Together, they enable managing complex identifier spaces with path-aware operations in compiler or symbolic processing systems.",
      "description_length": 679,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.File.Map",
      "library": "catala.catala_utils",
      "description": "This module implements key-value mappings where keys are file identifiers, supporting operations like insertion, deletion, and conditional retrieval. It offers transformations through higher-order functions, including merging, filtering, and value mapping, while maintaining consistent key ordering and equality checks. Typical use cases involve aggregating file-associated data, converting between structured formats like sequences or lists, and generating human-readable outputs with custom separators.",
      "description_length": 504,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.String",
      "library": "catala.catala_utils",
      "description": "This module provides comprehensive tools for string manipulation, including creation, transformation, and low-level encoding, operating directly on `string` and `bytes` types. It supports text processing tasks like case conversion and substring extraction, as well as binary data parsing, while its submodules enable ordered string-based collections. The first child module manages ordered maps with string keys, enabling structured data handling and ordered traversal, while the second offers ordered string sets with standard set operations and sequence integration. Examples include parsing encoded messages, normalizing textual input, and managing sorted configuration keys with deterministic output.",
      "description_length": 704,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Uid",
      "library": "catala.catala_utils",
      "description": "This module generates and manages unique identifiers with rich contextual metadata, supporting path tracking, source positions, and customizable formatting. It provides core operations to create, compare, hash, and format identifiers, along with set and map submodules for structured manipulation of identifier collections. You can use it to track distinct program entities in a compiler, manage symbol tables with hierarchical paths, or build traceable data pipelines with ordered keys and typed metadata. Submodules extend identifiers with source positions, scoped hierarchies, and styling rules, enabling use cases like type-safe module path analysis, debuggable AST annotations, and human-readable identifier rendering.",
      "description_length": 723,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Pos",
      "library": "catala.catala_utils",
      "description": "This module handles source code positions with precise line and column information, supporting operations to create positions from lexing data or raw coordinates, retrieve file and law metadata, and join ranges. It provides detailed formatting tools to display positions in human-readable forms, including short and full representations, and can extract contextual text from files. Use cases include error reporting with accurate source locations, tracking law references in legal code, and debugging by inspecting code spans.",
      "description_length": 526,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Suggestions",
      "library": "catala.catala_utils",
      "description": "This module identifies close string matches using Levenshtein distance and formats output. It works with lists of strings to find near-matches for a given keyword and prints formatted suggestions. Useful for spell-checking or command-line auto-completion scenarios.",
      "description_length": 265,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Message",
      "library": "catala.catala_utils",
      "description": "This module provides structured handling of compiler messages with support for colored output and formatting through the `Format` module. It defines a `level` type to represent message severity and offers operations to emit logs, warnings, and errors with contextual information, positional hints, and suggestions. The `Content` submodule enables building and manipulating message content as formatter functions, supporting conditional colorization based on CLI flags and terminal capabilities. Example uses include emitting diagnostic messages with source locations, formatting error contexts, and controlling output channels with custom styling.",
      "description_length": 647,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Map",
      "library": "catala.catala_utils",
      "description": "This module extends OCaml's standard `Map` with higher-level operations like `merge`, `filter_map`, and `of_list`, enabling expressive transformations and bulk construction of maps over ordered keys. It supports polymorphic maps with common key types such as strings and integers, as well as custom comparable types through a dedicated key module that ensures consistent ordering and formatting. The extended map operations allow for tasks like combining multiple maps, safely transforming entries, and efficiently processing data in sorted order via key-based splitting and traversal. Examples include aggregating key-value pairs from multiple sources, filtering and restructuring map contents, and serializing maps using custom key formatting.",
      "description_length": 745,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.File",
      "library": "catala.catala_utils",
      "description": "This module provides comprehensive file handling with resource-safe I/O, temporary file creation, and cross-platform path manipulation, enabling efficient directory scanning, batch processing, and external command execution. It structures hierarchical file data using lazy trees that mirror filesystem layouts, supporting subtree extraction, merging, and case-insensitive path queries. Sets manage collections of files with ordered operations like union and partition, while maps associate files with values, supporting transformations and ordered lookups. Example tasks include building virtual filesystem views, filtering and merging directory contents, and aggregating or converting file metadata into structured formats.",
      "description_length": 724,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Global",
      "library": "catala.catala_utils",
      "description": "This module defines global configuration flags and types used across the compiler, including input sources, backend languages, and output formatting options. It provides functions to set and enforce these global options, primarily initialized from command-line arguments. Use cases include configuring the compiler's behavior for different languages, enabling debug mode, or controlling error message formats.",
      "description_length": 409,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Version",
      "library": "catala.catala_utils",
      "description": "This module defines a single value `v` representing the current version of the software as a static string. It is used to embed version information directly into the application at build time. The version string can be accessed programmatically for logging, diagnostics, or user-facing display purposes.",
      "description_length": 303,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils.Cli",
      "library": "catala.catala_utils",
      "description": "This module orchestrates command-line interface behaviors by mapping language codes to file types, parsing CLI flags, and managing application metadata such as version and plugin sections. It structures interactions for modular operations like type checking and code generation, using `Cmdliner.Term.t` to define and parse optimization levels, input/output paths, and directory filters. The module supports global configuration arguments and command-specific options, enabling use cases such as LaTeX output generation and dependency graph construction. Direct operations include initializing global state, processing input files or standard input, and configuring error handling in CLI applications.",
      "description_length": 700,
      "index": 190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Catala_utils.Mark",
      "library": "catala.catala_utils",
      "description": "This module handles annotations attached to abstract syntax tree (AST) nodes, such as source positions or type information. It provides operations to add, remove, retrieve, and transform both the values and their associated metadata. Use cases include tracking source code locations during parsing or attaching type information during semantic analysis.",
      "description_length": 353,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Catala_utils",
      "library": "catala.catala_utils",
      "description": "This collection provides foundational utilities for text processing, identifier management, source positioning, and structured data handling. Core data types include strings, identifiers, source positions, maps, and compiler messages, with operations for transformation, comparison, and contextual formatting. It enables tasks like parsing and normalizing text, tracking unique entities with metadata, reporting diagnostics with precise locations, and managing hierarchical file data. Specific applications include compiler development with AST annotations and symbol tables, error reporting with source ranges, and building CLI tools with structured configuration and auto-completion.",
      "description_length": 685,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Runtime_ocaml.Runtime.Oper",
      "library": "catala.runtime_ocaml",
      "description": "This module offers unary and binary operations for logical manipulations, type conversions, and arithmetic on numeric and temporal values, alongside array transformations and reductions. It operates on booleans, integers, decimals, money, dates, durations, and arrays, ensuring type-specific computations with strong typing and error tracking for operations like date arithmetic or financial calculations. Key use cases include financial modeling with currency values, temporal data processing with precise date/duration manipulations, and array-based data transformations requiring typed element-wise operations or aggregations.",
      "description_length": 629,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Runtime_ocaml.Runtime.Json",
      "library": "catala.runtime_ocaml",
      "description": "Converts internal runtime data structures like io_log, runtime_value, and event into JSON-formatted strings for serialization and external communication. Works directly with the io_log, runtime_value, and event types defined in the parent Runtime module. Useful for logging runtime state, transmitting execution data externally, or debugging by exporting structured values.",
      "description_length": 373,
      "index": 194,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Runtime_ocaml.Runtime.EventParser",
      "library": "catala.runtime_ocaml",
      "description": "Parses raw event data into structured event formats for analysis. Works with lists of raw_event and event types defined in the runtime module. Used to transform low-level event streams into actionable, typed events during execution tracing.",
      "description_length": 240,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Runtime_ocaml.Runtime",
      "library": "catala.runtime_ocaml",
      "description": "This module orchestrates value manipulation, arithmetic, and temporal calculations using specialized primitives like `money`, `decimal`, `date`, and `duration`, along with structured types such as `runtime_value`, enabling precise financial computations, date arithmetic, and event logging. Its child modules extend this functionality: one performs type-safe logical, arithmetic, and array operations across these primitives, supporting financial modeling and temporal data processing; another serializes runtime structures like `io_log` and `event` into JSON for logging and external communication; a third parses raw event streams into structured events for analysis. Together, they enable comprehensive runtime instrumentation, domain-specific calculations with controlled rounding, and structured data exchange.",
      "description_length": 815,
      "index": 196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Runtime_ocaml",
      "library": "catala.runtime_ocaml",
      "description": "This module enables precise financial and temporal computations using primitives like `money`, `decimal`, `date`, and `duration`, along with structured types such as `runtime_value`. It supports type-safe arithmetic, logical operations, and array manipulations for financial modeling and event processing. It can serialize runtime data like `io_log` and `event` into JSON for logging and external communication, and parse raw event streams into structured formats for analysis. Examples include calculating interest with controlled rounding, logging financial transactions, and transforming event streams into analyzable data.",
      "description_length": 626,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification.Io.BackendIO",
      "library": "catala.verification",
      "description": "This module handles the translation and verification of expressions using a backend solver like Z3. It provides functions to initialize the backend, translate expressions into a solver-compatible form, encode assertions, and check verification conditions. Concrete use cases include proving the validity of program assertions and generating counterexamples when verification fails.",
      "description_length": 381,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification.Z3backend.Io",
      "library": "catala.verification",
      "description": "This module handles the translation of expressions into Z3 solver constraints, manages solver contexts, and performs verification condition checking. It works with types such as `backend_context`, `vc_encoding`, and `model` to represent solver state and encoded expressions. Concrete use cases include encoding and checking verification conditions against a Z3 solver, and printing counterexamples when verification fails.",
      "description_length": 422,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification.Io.Backend",
      "library": "catala.verification",
      "description": "This module implements the core operations for encoding and solving verification conditions using a specific backend. It provides functions to translate expressions into the backend's encoding format, assert expressions, and query the solver to determine if a condition is proven true, false, or unknown, optionally producing a model. It is used to validate program correctness by checking logical assertions during formal verification.",
      "description_length": 436,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification.Io.MakeBackendIO",
      "library": "catala.verification",
      "description": "This module initializes and manages a backend context for proof verification, translating and encoding expressions into a format suitable for backend processing. It supports operations like expression translation, assertion encoding, and verification condition checking, producing success or failure results with associated models. It is used to interface with specific solvers like Z3, handling concrete tasks such as spawning solvers, encoding logical conditions, and generating diagnostic output for failed conditions.",
      "description_length": 521,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification.Solver",
      "library": "catala.verification",
      "description": "Solves verification conditions using external proof backends. It processes a list of verification conditions in the context of a shared declaration environment. This module is used to validate program correctness during static analysis.",
      "description_length": 236,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification.Io",
      "library": "catala.verification",
      "description": "This module orchestrates proof backend interactions by managing input/output operations across channels, strings, and custom data structures. It enables reading and writing proof terms, handling serialization, and logging verification steps, while integrating backend-specific logic for expression translation, assertion encoding, and condition checking. Functions support loading proofs from files, sending commands over sockets, and verifying program assertions using solvers like Z3. Submodules handle solver initialization, logical encoding, and model generation, enabling end-to-end verification workflows with detailed diagnostics for failed conditions.",
      "description_length": 659,
      "index": 203,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Verification.Conditions",
      "library": "catala.verification",
      "description": "This module generates verification conditions from program scopes, producing constraints that ensure definitions do not return empty or conflicting errors. It operates on typed Dcalc expressions and scope definitions, constructing boolean expressions that capture the necessary assertions and guards. Use cases include validating error handling in program transformations and verifying consistency of scope definitions during compilation.",
      "description_length": 438,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification.Globals",
      "library": "catala.verification",
      "description": "This module manages global configuration flags for a verification system using references. It provides operations to set up verification parameters, check if optimizations are enabled, and determine whether counterexamples are disabled. Concrete use cases include configuring verification behavior before analysis and querying global settings during verification runs.",
      "description_length": 368,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Verification.Z3backend",
      "library": "catala.verification",
      "description": "This module provides an interface to the Z3 SMT solver, enabling translation of expressions into solver constraints and managing solver contexts for verification tasks. It supports operations on types like `backend_context` for state management, `vc_encoding` for constraint representation, and `model` for handling counterexamples. Users can encode verification conditions, check their validity against the solver, and extract and print counterexamples when conditions fail. Example usage includes verifying program correctness properties and debugging failed assertions through model inspection.",
      "description_length": 597,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verification",
      "library": "catala.verification",
      "description": "This module coordinates verification workflows by generating and solving verification conditions using external proof backends. It processes typed expressions and scope definitions to construct boolean constraints, which are validated using solver interfaces like Z3, producing counterexamples on failure. Key data types include `backend_context` for solver state, `vc_encoding` for constraints, and `model` for counterexample handling. Users can configure verification settings, encode program properties, and verify assertions end-to-end with detailed diagnostics.",
      "description_length": 566,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain.G.V",
      "library": "explain",
      "description": "This module implements a labeled vertex type for a persistent directed graph, where each vertex holds a label of type `Explain.V.t`. It provides operations to create vertices, retrieve their labels, and compare, hash, or check equality of vertices based on their labels. Concrete use cases include representing nodes in a control flow graph or dependency graph where each node must carry associated data.",
      "description_length": 404,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain.G.E",
      "library": "explain",
      "description": "This module represents directed edges in a persistent graph structure, where each edge has a source and destination vertex along with a labeled value. It provides operations to create edges with specified vertices and labels, and to access the components of existing edges. Concrete use cases include modeling relationships in a control flow graph or dependency tracking between nodes in a static analysis tool.",
      "description_length": 411,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain.V",
      "library": "explain",
      "description": "This module defines and implements operations for comparing, hashing, and formatting expressions annotated with marks, specifically working with generalized expressions and their marked versions. It provides concrete functionality for structural equality, ordering, and pretty-printing of these expressions, which are used to represent and manipulate program constructs in a typed intermediate language. These operations are essential for tasks like optimizing expression evaluation, caching results, and generating human-readable output during compilation or debugging.",
      "description_length": 570,
      "index": 210,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Explain.Env",
      "library": "explain",
      "description": "This module manages a mapping from typed variables to expressions and elements, supporting operations to add, find, and merge entries. It works with annotated expressions and typed variables from the `Shared_ast` module, organizing them in a structured environment. Concrete use cases include tracking variable bindings during evaluation or analysis of expressions in a typed calculus.",
      "description_length": 385,
      "index": 211,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Explain.G",
      "library": "explain",
      "description": "This module provides a persistent representation of directed graphs with labeled vertices and edges, enabling structural queries, functional transformations, and iteration over graph components. It supports key operations such as adding or removing vertices and edges, checking connectivity, and inspecting vertex degrees, all while preserving immutability for use in algorithmic processing and data flow modeling. The vertex submodule manages labeled nodes, allowing creation, comparison, and labeling of nodes\u2014useful for control flow graphs\u2014while the edge submodule handles directed connections with associated labels, enabling precise dependency tracking and relationship modeling. Together, these components form a cohesive API for building and analyzing immutable graph structures with rich, data-carrying nodes and edges.",
      "description_length": 827,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain.E",
      "library": "explain",
      "description": "This module defines a type `t` representing a condition with an optional side (left or right) and a boolean value. It includes a `compare` function for ordering values of type `t` and a `default` value for initialization. Useful for tracking conditional states in logic puzzles or rule-based systems where sides of a comparison matter.",
      "description_length": 335,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain.GTopo",
      "library": "explain",
      "description": "Traverses graph structures by applying functions to each vertex. Works with directed graphs represented as `Explain.G.t` and their vertices of type `Explain.G.V.t`. Useful for analyzing dependencies or performing vertex-based computations in control flow graphs.",
      "description_length": 262,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Explain",
      "library": "explain",
      "description": "This module interprets annotated expression trees for controlled evaluation and error diagnostics, while constructing and manipulating computation graphs derived from program code. It supports metadata-enhanced expressions, evaluation environments, and immutable directed graphs with labeled vertices and edges, enabling conditional execution, graph traversal, simplification, and DOT visualization. Key data types include expressions with marks, variable-to-expression mappings, graph structures with labeled nodes and edges, and condition values for logical state tracking. Examples include optimizing expression evaluation using structural equality, analyzing dependencies in control flow graphs, and generating human-readable output for debugging or visualization.",
      "description_length": 768,
      "index": 215,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dcalc.Invariants",
      "library": "catala.dcalc",
      "description": "This module enforces structural invariants on typed abstract syntax trees by validating properties such as correct variable scoping, consistent type annotations, and well-formed expression nesting. It operates on `Shared_ast.typed Dcalc.Ast.program` data structures, ensuring they conform to expected compiler constraints. Concrete use cases include verifying program correctness during testing and preventing malformed ASTs from proceeding further in the compilation pipeline.",
      "description_length": 477,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dcalc.From_scopelang",
      "library": "catala.dcalc",
      "description": "Translates programs from the scope language into the default calculus representation. Works with abstract syntax trees (ASTs) parameterized over a metadata type `'m`. Useful for converting high-level scope programs into a lower-level intermediate representation for further processing or analysis.",
      "description_length": 297,
      "index": 217,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dcalc.Ast",
      "library": "catala.dcalc",
      "description": "Represents the structure of expressions and statements in the default calculus intermediate representation. Provides constructors for nodes such as variables, constants, function applications, and control structures. Used to build, traverse, and manipulate program representations during compilation or analysis tasks.",
      "description_length": 318,
      "index": 218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dcalc",
      "library": "catala.dcalc",
      "description": "This module ensures structural correctness of typed abstract syntax trees by validating variable scoping, type annotations, and expression nesting, operating on `Shared_ast.typed` program structures to enforce compiler constraints. It translates high-level scope programs into a lower-level calculus representation and provides constructors for building and manipulating expressions like variables, constants, and control structures. Examples include verifying program correctness during testing, converting ASTs for further analysis, and traversing intermediate representations during compilation.",
      "description_length": 598,
      "index": 219,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 236,
    "meaningful_modules": 220,
    "filtered_empty_modules": 16,
    "retention_rate": 0.9322033898305084
  },
  "statistics": {
    "max_description_length": 939,
    "min_description_length": 209,
    "avg_description_length": 515.8863636363636,
    "embedding_file_size_mb": 0.7995815277099609
  }
}