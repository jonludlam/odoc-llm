{
  "package": "ppx_protocol_conv_jsonm",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 4,
  "creation_timestamp": "2025-06-18T16:28:32.203277",
  "modules": [
    {
      "module_path": "Protocol_conv_jsonm.Jsonm.Make",
      "description": "Maps record and variant names using attributes, transforms constructors with no arguments into strings, omits fields with default values, evaluates lazy fields eagerly, and enforces strict deserialization. Operates on OCaml records and variants with custom naming and serialization rules. Used to control JSON or similar format generation from OCaml types with precise naming and structure requirements.",
      "description_length": 403,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol_conv_jsonm.Jsonm",
      "description": "Handles name mapping and transformation for OCaml records and variants, converting empty constructors to strings and omitting fields with default values. Evaluates lazy fields during serialization and enforces strict parsing rules. Supports custom naming conventions and precise control over JSON output structure. Enables generation of clean, predictable JSON from complex OCaml types with specific formatting needs.",
      "description_length": 417,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ppx_protocol_conv_jsonm",
      "description": "Provides functions to generate serialization and deserialization code for custom data types using ppx syntax extensions. Works with OCaml's variant and record types, enabling integration with various binary and textual formats. Used to automatically produce code for protocol buffers, JSON, or custom binary protocols by defining driver-specific rules.",
      "description_length": 352,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol_conv_jsonm",
      "description": "Converts OCaml records and variants to structured JSON by mapping and transforming field names, handling empty constructors as strings, and omitting fields with default values. Evaluates lazy fields during serialization and enforces strict parsing, allowing custom naming conventions and precise control over output. It generates clean, predictable JSON by transforming complex types according to specified rules. For example, it can serialize a record with optional fields into a compact JSON object or convert a variant type into a JSON string with a defined structure.",
      "description_length": 571,
      "index": 3,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 4,
    "meaningful_modules": 4,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 571,
    "min_description_length": 352,
    "avg_description_length": 435.75,
    "embedding_file_size_mb": 0.014962196350097656
  }
}