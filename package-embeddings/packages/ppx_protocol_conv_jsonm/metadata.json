{
  "package": "ppx_protocol_conv_jsonm",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 3,
  "creation_timestamp": "2025-08-14T22:53:49.417163",
  "modules": [
    {
      "module_path": "Protocol_conv_jsonm.Jsonm.Make",
      "library": "ppx_protocol_conv_jsonm",
      "description": "This module provides bidirectional conversion utilities for serializing and deserializing OCaml types to and from JSON values represented by the `Ezjsonm.value` type. It supports structured data transformations for primitives (integers, strings, booleans), containers (arrays, lists, options), and algebraic types (variants, records, tuples), with dedicated handling for error propagation and edge cases like null values or malformed inputs. Typical use cases include parsing JSON API responses into typed OCaml structures, generating JSON payloads from domain models, and validating data schemas during serialization.",
      "description_length": 618,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Protocol_conv_jsonm.Jsonm",
      "library": "ppx_protocol_conv_jsonm",
      "description": "This module facilitates bidirectional serialization between OCaml values and JSON representations, handling primitives (integers, floats, strings), algebraic types (variants, records), and containers (lists, arrays) through type-safe converters. It includes utilities for error-resilient deserialization, human-readable error formatting, and lazy or result-typed value handling, primarily serving applications like API data parsing, configuration validation, and structured data interchange where robust type guarantees are critical. The `Make` submodule autom",
      "description_length": 560,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Protocol_conv_jsonm",
      "library": "ppx_protocol_conv_jsonm",
      "description": "This module converts OCaml values to and from JSON, supporting integers, floats, strings, variants, records, lists, and arrays. It provides type-safe serialization, error-resilient deserialization, and detailed error messages. Use it for parsing API responses, validating configuration files, or handling structured data in a type-safe way.",
      "description_length": 340,
      "index": 2,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 3,
    "meaningful_modules": 3,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 618,
    "min_description_length": 340,
    "avg_description_length": 506.0,
    "embedding_file_size_mb": 0.04388141632080078
  }
}