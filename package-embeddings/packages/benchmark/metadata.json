{
  "package": "benchmark",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 2,
  "creation_timestamp": "2025-07-15T23:03:31.166540",
  "modules": [
    {
      "module_path": "Benchmark.Tree",
      "library": "benchmark",
      "description": "This module organizes and runs latency and throughput benchmarks using a hierarchical tree structure. It supports parametrizing benchmarks over integer inputs, filtering and selecting subsets of benchmarks by path, and printing benchmark results in structured formats. Concrete use cases include measuring performance of functions across varying input sizes, grouping related benchmarks under named paths, and selectively executing benchmarks based on command-line arguments.",
      "description_length": 475,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Benchmark",
      "library": "benchmark",
      "description": "This module measures execution times of functions using latency or throughput tests, organizing benchmarks into a hierarchical tree structure for parametrization, filtering, and structured output. It supports function lists, iteration counts, and time thresholds to generate reports with metrics like wallclock and CPU times. You can compare implementations, measure GC impact, run benchmarks across input sizes, and select subsets by path for execution. For example, run a function with input 5000 for 10 iterations and print CPU times or generate formatted reports for analysis.",
      "description_length": 580,
      "index": 1,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 2,
    "meaningful_modules": 2,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 580,
    "min_description_length": 475,
    "avg_description_length": 527.5,
    "embedding_file_size_mb": 0.007699012756347656
  }
}