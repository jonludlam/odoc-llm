{
  "package": "lutin",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 44,
  "creation_timestamp": "2025-08-15T12:36:38.413996",
  "modules": [
    {
      "module_path": "ExpEval",
      "library": "lutin",
      "description": "Performs simplification of expressions, numeric values, and logical formulas by applying reduction rules. Operates directly on the `Exp.t`, `Exp.num`, and `Exp.formula` types to normalize and minimize complexity. Useful for optimizing intermediate representations in compilers or symbolic manipulation systems.",
      "description_length": 310,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Guard",
      "library": "lutin",
      "description": "This module manages symbolic guards during constraint solving, handling operations like creation, merging, and simplification of guards using a store of current and previous values. It works with algebraic expressions, identifiers, and source information to track and evaluate constraints in a symbolic execution context. Concrete use cases include guard construction from expressions, merging path conditions, and evaluating expressions under a given store to produce concrete values.",
      "description_length": 485,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Glue",
      "library": "lutin",
      "description": "This module converts expressions and types between different representations, handling variables, values, and algebraic expressions. It works with types like `CkTypeEff.t`, `Type.t`, `Exp.t`, `Value.t`, and `CoAlgExp.t`, primarily manipulating expression trees and variable references. Concrete use cases include translating effect types to core types, generating expressions from values or variables, and expanding algebraic expressions using a custom identifier-to-expression function.",
      "description_length": 487,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Var",
      "library": "lutin",
      "description": "This module supports creation and management of variables with modes like input, output, or local, along with properties such as type bounds, aliases, and initialization values. It works with variable identifiers (`'a Var.t`) and environment types (`env`) that map variables to integer indices for efficient context-specific tracking. Useful for scenarios requiring structured variable manipulation, such as constraint systems or scoped variable management.",
      "description_length": 457,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gne",
      "library": "lutin",
      "description": "This module implements guarded normal expressions, where each expression is associated with a Boolean condition (BDD). It supports arithmetic operations like addition, subtraction, multiplication, division, and modulo, as well as construction, folding, and evaluation based on BDD conditions. Use cases include symbolic computation, conditional expression evaluation, and dynamic weight handling in decision models.",
      "description_length": 415,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Formula_to_bdd",
      "library": "lutin",
      "description": "This module encodes logical formulas and arithmetic expressions into binary decision diagrams (BDDs) and generalized non-deterministic expressions (GNEs), using variable environments to track input and state. It provides functions to convert formulas and numeric expressions into BDDs and GNEs, evaluate integer expressions, and manage internal state with cleanup operations. Concrete use cases include symbolic model checking, constraint solving, and translating high-level expressions into compact, manipulable representations for verification tasks.",
      "description_length": 552,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LutParser",
      "library": "lutin",
      "description": "Parses LUT language files into abstract syntax trees representing packages. It processes a stream of lexical tokens to build structured representations of module-level declarations including type definitions, node specifications, and system components. This parser is used during the initial compilation phase to convert source code into an intermediate form for further analysis and code generation.",
      "description_length": 400,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Draw",
      "library": "lutin",
      "description": "Draws points within a bounded solution hull represented by a polyhedron, focusing on interior points, edges, vertices, or retrieving all vertices. It operates on stores and variable substitutions to generate lists of numeric substitutions. Useful for sampling geometric representations of constraints or visualizing solution spaces.",
      "description_length": 332,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ExprUtil",
      "library": "lutin",
      "description": "Extracts and returns an `Expr.t` value from a tuple containing an expression and BDD, using additional BDDD and BDD parameters to guide the extraction process. Works with `Bddd.t`, `Bdd.t`, and `Expr.t` types. Useful in symbolic computation contexts where expressions need to be derived from structured BDD-based representations.",
      "description_length": 329,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Exp",
      "library": "lutin",
      "description": "This module handles boolean formulas, numeric expressions, and flattened lists representing structured data. It provides operations for managing variable tables, adding values to tables, and manipulating expressions with external functions. Use cases include evaluating logical conditions, performing numeric calculations, and transforming structured data representations into flat lists.",
      "description_length": 388,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LutExe",
      "library": "lutin",
      "description": "This module provides operations for symbolic execution of lookup tables, enabling manipulation of execution states composed of symbolic values, environments, and control structures. It supports control flow primitives (e.g., branching, termination), constraint solving over guarded transitions, and extraction of input/output variables, primarily used in symbolic simulation and formal verification. Debugging features include stepwise execution, state introspection, and control flow visualization to analyze complex state transitions and validate behavioral models.",
      "description_length": 567,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FGen",
      "library": "lutin",
      "description": "This module generates and manages logical formulas within a control state. It provides operations to select a single formula and retrieve all generated formulas. Use it to dynamically construct and access a collection of formulas during program analysis or transformation tasks.",
      "description_length": 278,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CoAlgExp",
      "library": "lutin",
      "description": "This module implements operations for constructing and analyzing algebraic expressions in a Lustre-like language, supporting constants, variables, operators, function calls, and conditional expressions. It works with expressions that embed semantic metadata like value types and controllability flags, determined by references to controllable variables (outputs or locals). These features are used for tasks like type checking, control flow analysis, and code generation in compiler pipelines for reactive or synchronous programming languages.",
      "description_length": 543,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LutinUtils",
      "library": "lutin",
      "description": "This module implements mathematical functions for calculating values related to Gaussian distributions and intervals. It operates on integers to compute bounds and thresholds for probabilistic decision-making. These functions are used in scenarios requiring statistical evaluation, such as probabilistic model analysis or constraint solving.",
      "description_length": 341,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Value",
      "library": "lutin",
      "description": "This module defines the internal representation of numeric and boolean values used in Lurette, supporting operations like addition, multiplication, division, modulo, and comparisons against zero. It works with concrete data types `num` (integers and floats) and `t` (boolean or numeric values). These types and functions are used to evaluate expressions and perform arithmetic or logical computations during program execution.",
      "description_length": 426,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Poly_draw",
      "library": "lutin",
      "description": "This module provides functions to generate points within a convex polyhedron using a set of generator points. It supports both uniform and biased sampling, with operations to draw single or multiple points, including distinct point selection. The core data types are `point` (float list) and `poly_wrap` (encapsulating the polyhedron structure), and it is used in scenarios like Monte Carlo simulations or geometric sampling where point distribution within a convex shape is required.",
      "description_length": 484,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LucFGen",
      "library": "lutin",
      "description": "Retrieves a list of FGen.t values based on the current environment and program state. It operates on Var.env_in and Prog.state data structures. Useful for generating or manipulating formal grammar representations during program execution.",
      "description_length": 238,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Solver",
      "library": "lutin",
      "description": "This module provides functions for evaluating and solving Boolean and numeric formulas using BDD-based symbolic computation. It operates on environments representing variable assignments and constraints, supporting operations like satisfiability checks, formula solving with random value assignments, and integer expression evaluation. Concrete use cases include verifying logical conditions over program states and generating satisfying assignments for symbolic execution or constraint solving.",
      "description_length": 495,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Luc2alice",
      "library": "lutin",
      "description": "This module generates Alice-specific C code stubs and headers based on provided configuration arguments, including environment names, variables, and output settings. It serializes data types and variables into string representations suitable for code generation, using functions like `gen_alice_stub`, `gen_alice_stub_c`, and `gen_alice_stub_h`. Concrete use cases include automating the creation of interface code for embedded systems or simulation environments with specific variable mappings and output directories.",
      "description_length": 518,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Prevar",
      "library": "lutin",
      "description": "This module handles string manipulation and analysis for pre-variable identifiers. It provides operations to check if a string is a pre-variable, extract root and referenced variable names, and generate pre-variable encodings. Useful in symbolic computation or compiler passes where variable renaming or tracking is required.",
      "description_length": 325,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Prog",
      "library": "lutin",
      "description": "This module manages control states and memory in a reactive system, providing functions to compute dynamic weights, generate dot representations of control states, and retrieve memory values. It operates on structured data types like `ctrl_state`, `wt`, and `t`, which model program states, weights, and variable environments. Concrete use cases include analyzing program flow through control states, generating visual representations for debugging, and computing variable dependencies during execution.",
      "description_length": 503,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Version",
      "library": "lutin",
      "description": "This module provides direct access to version information through predefined string values and a function that returns the current version. It works with string data types to expose version identifiers such as `str0` and `sha`, which represent static version strings. A concrete use case is retrieving the application's version at runtime for logging or diagnostics.",
      "description_length": 366,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "GenOcamlGlue",
      "library": "lutin",
      "description": "Handles command-line argument parsing and execution flow for the main application. Accepts an array of command-line arguments and a configuration object, then performs the appropriate actions based on the input. Directly used during program startup to initialize and run the core logic.",
      "description_length": 286,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LoopWeights",
      "library": "lutin",
      "description": "This module calculates time intervals and average durations between events. It works with integers representing timestamps or durations. Use it to determine start-end ranges or average splits for timing measurements.",
      "description_length": 216,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Auto2Lucky",
      "library": "lutin",
      "description": "Translates an `AutoGen.t` automaton structure into a Lucky specification. It takes a module name, output file path, the automaton, and writes the generated code to a channel. Useful for compiling custom automata into executable models for verification or simulation tasks.",
      "description_length": 272,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ne",
      "library": "lutin",
      "description": "This module represents and manipulates arithmetic expressions in a normalized form, supporting operations such as addition, subtraction, multiplication, division, and modulo. It works with expressions involving numeric constants and variables, tracking variable substitutions and dimensions. Concrete use cases include symbolic computation, constraint solving, and expression simplification in a theorem prover or program analysis tool.",
      "description_length": 436,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sol_nb",
      "library": "lutin",
      "description": "This module implements arithmetic operations and conversions for a custom numeric type `sol_nb`, including addition, multiplication, division, and equality checks. It provides constants for zero and one, supports exponentiation by an integer power, and enables conversion to and from floating-point numbers and strings. Concrete use cases include precise numerical calculations where standard float operations may lose precision, such as financial computations or scientific simulations requiring exact decimal representation.",
      "description_length": 526,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Store",
      "library": "lutin",
      "description": "This module implements a numeric constraint solver that processes inequalities and equalities over variables by maintaining a range-based store for single-variable constraints and delaying multi-variable constraints until substitution simplifies them. It works with variable domains, substitutions, and polyhedra representations to handle constraint propagation and simplification. Concrete use cases include solving systems of linear inequalities, checking satisfiability of numeric constraints, and preparing constraints for polyhedral analysis in program verification.",
      "description_length": 571,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Verbose",
      "library": "lutin",
      "description": "This module controls and routes output based on verbosity levels and named flags. It allows setting global or scoped verbosity, enabling/disabling specific output channels, and conditionally printing messages or executing functions based on current settings. Use it to manage detailed logging in compilers, interpreters, or batch processing tools where selective tracing is needed.",
      "description_length": 381,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Thickness",
      "library": "lutin",
      "description": "This module defines a data type for specifying the number of test vectors generated at each step, with boolean and numeric configurations. It includes operations to construct and convert these configurations to string representations, supporting precise control over test generation parameters. Use cases include configuring test frameworks where distinct counts for formulas, edges, vertices, and inside points determine test coverage.",
      "description_length": 436,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constraint",
      "library": "lutin",
      "description": "This module represents linear constraints over Boolean, integer, and float variables using types like `t` and `ineq`, supporting operations such as substitution application, negation, and evaluation. It provides functions to inspect constraints, including variable extraction, dimension calculation, and string representation. Use cases include constraint manipulation in formula solving, constraint evaluation under numeric substitutions, and constraint transformation via substitutions.",
      "description_length": 488,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LutinRun",
      "library": "lutin",
      "description": "Creates a plugin instance from command-line arguments, enabling integration with the RdbgPlugin system. Works with string arrays and produces a plugin value. Useful for initializing debugger plugins with runtime parameters.",
      "description_length": 223,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Polyhedron",
      "library": "lutin",
      "description": "This module handles operations on polyhedra, including building polyhedra from constraints, extracting vertices, and checking point inclusion. It works with numeric ranges, points in float space, and substitutions mapping variables to values. Concrete uses include constraint grouping, vertex enumeration, and feasibility checking for numerical analysis tasks.",
      "description_length": 360,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parsers",
      "library": "lutin",
      "description": "This module handles parsing operations for a custom syntax, specifically reading and processing LUT (Look-Up Table) data. It provides functions to parse a list of strings into a structured package, reset the parser state, and convert a string into lexical tokens. Concrete use cases include interpreting configuration files or domain-specific language inputs.",
      "description_length": 359,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Reactive",
      "library": "lutin",
      "description": "This module implements a reactive programming model with stateful computations that process streams of values. It provides a `step` function to execute a program step, transforming input values and returning outputs alongside the updated program state. The module is used for building interactive systems that react to input events, such as user interfaces or simulation engines, where programs maintain internal state and evolve over time in response to external stimuli.",
      "description_length": 472,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bddd",
      "library": "lutin",
      "description": "This module implements drawing and constraint evaluation operations over BDDs (Binary Decision Diagrams), handling variable environments, numeric expressions, and linear constraints. It provides functions to convert formulas to BDDs, perform draws within a BDD structure, and translate between numeric expressions and GNE (Generalized Nonlinear Expressions), while tracking solution counts and constraint indices. Concrete use cases include symbolic execution and constraint solving in program analysis, where BDDs represent Boolean abstractions of program states and numeric constraints are extracted for further analysis.",
      "description_length": 623,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lexeme",
      "library": "lutin",
      "description": "This module tracks and manipulates lexeme information during parsing, including position, line number, and file context. It provides operations to create lexeme records from lexing buffers, retrieve the last created lexeme, and set the current source file. Concrete use cases include error reporting with precise source locations and attaching metadata to parsed values.",
      "description_length": 370,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lucky",
      "library": "lutin",
      "description": "This module implements the `step` and `try` operations for simulating and exploring automaton behavior. It operates on environments (`Var.env_in`, `Var.env_out`, `Var.env_loc`), program states (`Prog.state`), and constraint generators (`FGen.t`). These functions are used to compute transitions and generate multiple potential solutions based on a given step mode or test thickness.",
      "description_length": 382,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "MainArg",
      "library": "lutin",
      "description": "This module supports parsing command-line arguments into a structured configuration (t), enabling control over execution modes, test flags, and code generation settings. It provides functions to access and modify runtime parameters such as memory loading, random seeds, floating-point precision, and event counters, while also handling input file retrieval and usage message display. These capabilities facilitate configuring program behavior through command-line flags, including test execution, simulation limits, and output formatting.",
      "description_length": 538,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Type",
      "library": "lutin",
      "description": "This module defines a type system with support for primitive types and structured types. It provides functions to convert types to data representations, generate string and C-compatible string outputs, and handle structured type formatting. Use cases include type serialization, generating type signatures for code generation, and interfacing with systems requiring structured type descriptions.",
      "description_length": 395,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Luc2c",
      "library": "lutin",
      "description": "This module defines configuration options and execution logic for code generation in different modes such as Lustre or Scade, controlling output behavior, memory handling, and communication settings. It works with variable lists and a mutable configuration record that includes generation targets, step modes, and connection parameters. It is used to drive transformations and execution flows in model-based code generation pipelines.",
      "description_length": 434,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SyntaxeDump",
      "library": "lutin",
      "description": "This module provides functions to output detailed representations of syntax tree elements, such as packages, let bindings, type expressions, and value expressions, using a configurable formatter. It works directly with data structures from the `Syntaxe` module, including `package`, `let_info`, `type_exp`, `val_exp`, and identifier lists with optional type and value annotations. Concrete use cases include debugging by printing intermediate representations of program elements during compilation or analysis.",
      "description_length": 510,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rif",
      "library": "lutin",
      "description": "This module handles reading input values and writing output and interface information in the RIF format. It operates on variables represented as `Exp.var` lists and interacts directly with input and output channels for file or stream-based communication. Concrete use cases include parsing input data from a channel, writing computed outputs to a file, and generating interface metadata for variable declarations.",
      "description_length": 413,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LutProg",
      "library": "lutin",
      "description": "This module creates and initializes program states for a specific configuration, using input files and a main node. It defines a type `t` for representing program configurations and provides functions to construct these configurations with optional libraries and verbosity levels. Concrete use cases include setting up simulation environments or compiling programs from command-line arguments.",
      "description_length": 393,
      "index": 43,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 46,
    "meaningful_modules": 44,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9565217391304348
  },
  "statistics": {
    "max_description_length": 623,
    "min_description_length": 216,
    "avg_description_length": 416.4318181818182,
    "embedding_file_size_mb": 0.6380767822265625
  }
}