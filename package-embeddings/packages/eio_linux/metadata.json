{
  "package": "eio_linux",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 3,
  "creation_timestamp": "2025-08-14T22:50:38.471490",
  "modules": [
    {
      "module_path": "Eio_linux.Low_level.Process",
      "library": "eio_linux",
      "description": "This module provides direct process management using Linux-specific APIs, allowing spawning new processes with a list of fork-time actions and sending signals to them. It works with process identifiers and handles process exit statuses asynchronously. Concrete use cases include executing external commands with precise control over fork-time behavior and managing child processes in low-level system applications.",
      "description_length": 414,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eio_linux.Low_level",
      "library": "eio_linux",
      "description": "This module provides direct access to Linux's io_uring-based I/O operations and system calls for high-throughput applications, including file/socket manipulation (opening, reading, writing, splicing), process management, and directory operations (creation, traversal, deletion). It operates on low-level resources like file descriptors, memory-mapped regions, and socket descriptors, enabling precise control over asynchronous I/O completion and system resource handling. Specific use cases include building custom I/O abstractions, optimizing data transfer pipelines with zero-copy techniques, or leveraging Linux-specific features like `statx` or `openat2` for advanced file management.",
      "description_length": 688,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eio_linux",
      "library": "eio_linux",
      "description": "This module implements an event loop using Linux's io_uring for high-performance asynchronous I/O, supporting operations like file and socket reads/writes, process spawning, and directory manipulation. It works directly with low-level system resources such as file descriptors and memory-mapped buffers, enabling use cases like building custom network servers, optimizing bulk data transfers, or integrating with Linux-specific system calls for fine-grained resource control. The `Low_level` submodule exposes direct access to io_uring operations for advanced users requiring precise I/O scheduling and completion handling.",
      "description_length": 623,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 3,
    "meaningful_modules": 3,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 688,
    "min_description_length": 414,
    "avg_description_length": 575.0,
    "embedding_file_size_mb": 0.043890953063964844
  }
}