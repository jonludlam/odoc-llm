{
  "package": "term-tools",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 25,
  "creation_timestamp": "2025-08-15T12:31:08.075125",
  "modules": [
    {
      "module_path": "Term_tools.Make.Term_graph.Pattern",
      "library": "term-tools",
      "description": "This module enables pattern matching and manipulation on term graphs using zippers to locate and refine subterm matches, supporting operations like matching against primitives, variables, and lists. It works with term graphs, list patterns, and focused annotations, providing utilities for pretty-printing patterns and comparing their unique identifiers, which is useful for term rewriting, symbolic analysis, or program transformation tasks.",
      "description_length": 442,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Make.Term_graph.Zipper",
      "library": "term-tools",
      "description": "This module provides zippers for navigating and modifying first-order terms as graph structures, allowing precise movement through term hierarchies and in-place edits. It supports operations like moving up or to specific positions in a term, replacing subterms, and folding over both terms and variables. Use cases include term rewriting, symbolic manipulation, and implementing transformations on logic or algebraic expressions.",
      "description_length": 429,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Pattern.Make",
      "library": "term-tools",
      "description": "This module enables pattern-based analysis and transformation of terms through operations like matching, traversal, and refinement, leveraging structured patterns composed of primitives, variables, and list constructs. It works with terms, zippers for focused navigation, and list-structured patterns, supporting use cases such as term rewriting, substructure extraction, and list-oriented term manipulation. Key capabilities include constructing list patterns with empty/cons forms, comparing patterns via unique identifiers, and pretty-printing for debugging.",
      "description_length": 561,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Make.Term_graph",
      "library": "term-tools",
      "description": "This module represents and manipulates first-order terms as graph structures, enabling precise navigation and modification through zipper-based operations. It supports concrete tasks such as term rewriting, symbolic manipulation, and transformation of logic or algebraic expressions by allowing movement within term hierarchies and in-place edits. The module works directly with term graphs, patterns, and focused annotations to facilitate matching, replacement, and structural analysis of terms.",
      "description_length": 496,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Make.Pattern",
      "library": "term-tools",
      "description": "This module enables the construction and refinement of patterns over first-order terms, supporting declarative matching of structures like variables, lists, and primitives through zippers for localized term traversal. It operates on `Pattern.t` values and associated term representations, providing structural equality via unique identifiers and human-readable formatting. Applications include term transformation pipelines, symbolic analysis, and rule-based systems requiring precise subterm identification and manipulation.",
      "description_length": 525,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Term.Make_hash_consed",
      "library": "term-tools",
      "description": "This module provides operations for constructing and manipulating hash-consed terms composed of primitives and variables, enabling efficient equality checks and structural transformations. It supports path-based navigation, subterm substitution, and canonicalization with variable renaming, using persistent maps for term storage and traversal. These capabilities are particularly useful in symbolic computation or compiler optimization tasks where term identity and structural equivalence need to be managed efficiently.",
      "description_length": 521,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Pattern.Make_raw",
      "library": "term-tools",
      "description": "This module provides pattern matching and term traversal operations using generalized algebraic data types (GADTs) and zipper-based navigation structures. It works with terms represented as GADT values, pattern lists for sequence matching, and zipper contexts that enable efficient term restructuring and focus management. These tools are particularly useful for implementing compilers, interpreters, or proof assistants where precise term analysis and transformation are required.",
      "description_length": 481,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Make.Subst",
      "library": "term-tools",
      "description": "This module represents and manipulates substitutions, which map integer variables to terms. It supports operations to add, retrieve, and apply mappings, as well as compare and combine substitutions. Use cases include implementing unification algorithms and managing variable bindings during term rewriting or logic inference.",
      "description_length": 325,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Term.Default_map",
      "library": "term-tools",
      "description": "Implements a map with integer keys and support for hash-consing, providing standard operations like insertion, lookup, and equality checks. It handles merging maps, converting to and from sequences of key-value pairs or keys, and ensures correct ordering. Useful for managing term mappings where integer keys represent identifiers in structured data transformations.",
      "description_length": 366,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Subst.Make",
      "library": "term-tools",
      "description": "This module implements substitutions for terms, supporting operations to add, retrieve, and apply variable-to-term mappings. It works with variables represented as integers and terms from the `T` module, handling substitution application and merging. Use it to perform and manage term-level substitutions in symbolic manipulation or logic programming tasks.",
      "description_length": 357,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Zipper.Make",
      "library": "term-tools",
      "description": "This module provides operations to navigate and modify first-order terms using zippers, allowing focused edits and traversal over terms that may include variables referencing other terms via a substitution. It supports concrete actions like moving up or to specific indices in a term structure, replacing focused terms, and folding over subterms or variables. Use cases include term rewriting, symbolic manipulation, and graph-based term traversal where variables act as links to other parts of the structure.",
      "description_length": 509,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Make.Unification",
      "library": "term-tools",
      "description": "This module provides operations for solving unification problems on first-order terms, including term unification, substitution application, and generalization checks. It works with terms and substitutions defined in the `Term` and `Subst` modules, along with a unification state that tracks variable bindings. Concrete use cases include implementing logic programming engines, type inference systems, and automated theorem provers where term equivalence under substitution is required.",
      "description_length": 486,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Zipper.Make_gen",
      "library": "term-tools",
      "description": "This module provides zippers for navigating and modifying first-order terms, allowing precise movement through term structures using operations like `move_up`, `move_at`, and `replace`. It supports editing terms lazily linked to substitutions, enabling access to referenced terms on demand. Use cases include term rewriting, traversal of nested expressions, and manipulation of variable bindings in formal logic or symbolic computation.",
      "description_length": 436,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Make.Term",
      "library": "term-tools",
      "description": "This module provides operations for constructing and manipulating first-order terms composed of primitives from a user-defined signature and integer variables. Key functionalities include term traversal, variable substitution, canonicalization via variable mapping, and equality-sensitive hashing, alongside utilities for subterm analysis and pretty-printing. It is particularly useful in symbolic computation, formal verification, and compiler optimization scenarios where structured term manipulation and efficient term identity tracking are required.",
      "description_length": 553,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Zipper.Make_stateful",
      "library": "term-tools",
      "description": "This module provides zippers for navigating and modifying first-order terms with support for lazy substitution, allowing variables to reference other terms. It enables operations like moving up or down in a term structure, replacing subterms, and folding over terms or variables. Concrete use cases include term rewriting, traversal of symbolic expressions, and manipulation of abstract syntax trees with variable bindings.",
      "description_length": 423,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Pattern.Make_with_hash_consing",
      "library": "term-tools",
      "description": "This module supports pattern-matching operations on terms composed of primitives and lists, enabling checks for match compatibility, identification of matching subterms, and refinement of focused matches. It provides tools to construct and manipulate hash-consed list patterns, offering functions for building list structures, pretty-printing, unique identifier retrieval, and efficient structural comparisons. These capabilities are particularly useful in symbolic computation, compiler optimizations, or abstract syntax tree analysis where precise term manipulation and efficient memory usage are critical.",
      "description_length": 608,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Make.Zipper",
      "library": "term-tools",
      "description": "This module provides zippers for navigating and modifying first-order terms, allowing precise movement through term structures using operations like `move_up`, `move_at`, and `replace`. It supports editing terms in the presence of substitutions, enabling traversal and modification of terms where variables may refer to other terms. Concrete use cases include term rewriting, symbolic manipulation, and implementing transformations on logical or algebraic expressions.",
      "description_length": 468,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Intf",
      "library": "term-tools",
      "description": "This module defines core abstractions for term manipulation, including hash-consing, substitution, unification, and pattern matching. It works with terms represented as algebraic data types, supporting operations like structural comparison, variable binding, and context-aware transformations. Concrete use cases include implementing term rewriting systems, symbolic computation, and formal reasoning tools.",
      "description_length": 407,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Term",
      "library": "term-tools",
      "description": "Implements hash-consed maps with integer keys for efficient term identifier management. Provides insertion, lookup, equality checks, and merging operations tailored for structured data transformations. Useful in scenarios requiring persistent maps for term metadata or transformation state.",
      "description_length": 290,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Zipper",
      "library": "term-tools",
      "description": "Navigates and modifies nested data structures with positional context. Supports tree-like terms using cursors that track parent and sibling nodes. Use to implement transformations or queries on abstract syntax trees during compilation or analysis.",
      "description_length": 247,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Int_option",
      "library": "term-tools",
      "description": "This module represents optional integers using a sentinel value for `none` and provides operations to compare, convert, and pattern-match on these values. It includes functions like `of_int` to wrap integers, `elim` to handle presence or absence, and `is_none` to check for the sentinel. Use cases include handling missing integer data in computations or interfacing with systems that use special values for nulls.",
      "description_length": 414,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Pattern",
      "library": "term-tools",
      "description": "This module defines types and functions for handling pattern focus states in term manipulation. It provides `get_focus` and `get_focus_list` to retrieve the focus tag from a pattern or pattern list, enabling inspection of whether a term is focused or unfocused during pattern matching. Concrete use cases include analyzing or transforming terms based on their focus status in proof assistants or term rewriting systems.",
      "description_length": 419,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Subst",
      "library": "term-tools",
      "description": "Handles term substitution in formal logic expressions, providing functions to replace variables with terms within logical formulas. Works with abstract syntax trees representing logical terms and substitutions maps. Used when implementing theorem provers or logic engines where variable instantiation is required.",
      "description_length": 313,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Make",
      "library": "term-tools",
      "description": "This module provides first-order term construction, manipulation, and analysis through structured traversal, substitution, and unification. It works with terms built from user-defined primitives and integer variables, alongside substitutions, patterns, and term graphs. Concrete use cases include symbolic computation, logic programming, compiler optimizations, and formal verification tasks requiring precise term transformation and equivalence checking.",
      "description_length": 455,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools",
      "library": "term-tools",
      "description": "This module provides term manipulation capabilities including hash-consing, substitution, unification, and pattern matching. It works with algebraic data types representing terms, supporting structural comparison, variable binding, and context-aware transformations. It is used in symbolic computation, theorem proving, term rewriting systems, and formal verification tools where precise term analysis and transformation are required.",
      "description_length": 434,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 25,
    "meaningful_modules": 25,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 608,
    "min_description_length": 247,
    "avg_description_length": 438.6,
    "embedding_file_size_mb": 0.36264801025390625
  }
}