{
  "package": "term-tools",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 34,
  "creation_timestamp": "2025-07-15T23:13:03.874655",
  "modules": [
    {
      "module_path": "Term_tools.Make.Term_graph.Pattern",
      "library": "term-tools",
      "description": "This module supports structural and conditional pattern matching operations on terms and term lists within a graph-based representation, enabling checks for matching, traversal to locate matches, and construction of patterns for primitives, variables, and list structures. It provides utilities to manipulate pattern focus, pretty-print patterns, and compare them using unique identifiers, which aids in debugging and equality verification. These capabilities are particularly useful for analyzing or transforming term graphs through precise structural queries and maintaining equivalence guarantees in graph-based computations.",
      "description_length": 628,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Make.Term_graph.Zipper",
      "library": "term-tools",
      "description": "This module provides zippers for navigating and modifying first-order terms as hierarchical structures, supporting operations like moving up, moving to a specific index, replacing subterms, and folding over terms or variables. It works with terms represented as `Term.t` and tracks a focused position within the term using a zipper structure. Concrete use cases include traversing and editing term graphs with lazy substitutions, such as rewriting specific subterms or extracting and transforming variable nodes in a focused context.",
      "description_length": 533,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Make.Term",
      "library": "term-tools",
      "description": "This module handles first-order terms through operations like construction, substitution, and traversal, supporting both variable and structured term manipulation. It works with an abstract type `Term.t` representing terms as integers (variables) or composite structures built from primitives and subterms. Functions for variable folding, term canonicalization, and unique identifier generation enable normalization, substitution, and traversal in logic programming or symbolic computation contexts.",
      "description_length": 499,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Intf.Zipper",
      "library": "term-tools",
      "description": "This module implements zippers for navigating and modifying first-order terms, allowing focused edits and traversal over terms that may reference other terms through a substitution. It supports operations like moving up or to specific indices in the term structure, replacing the focused term, and folding over subterms or variables. Concrete use cases include term rewriting, symbolic manipulation, and implementing transformations on terms with variable bindings.",
      "description_length": 465,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Intf.Term",
      "library": "term-tools",
      "description": "This module provides operations for constructing, analyzing, and transforming first-order terms, including variable handling, path-based subterm manipulation, substitution, and canonicalization via variable mapping. It operates on a polymorphic term type `t` that represents either primitive values or variables (`var`), supporting case analysis, traversal, and identity tracking through unique term identifiers. These capabilities are particularly useful in symbolic computation, theorem proving, and formal verification scenarios where precise term structure and variable relationships must be maintained.",
      "description_length": 607,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Pattern.Make_with_hash_consing",
      "library": "term-tools",
      "description": "This module supports operations for checking pattern matches, locating matching subterms, and refining focused matches within terms, using hash-consing for efficiency. It works with terms and lists of terms, offering constructors for patterns targeting primitives, variables, arbitrary terms, and list structures, alongside utilities for pretty-printing and unique identifier retrieval. It is particularly useful for tasks like term rewriting, analysis, or transformation workflows where precise subterm targeting and optimized pattern comparisons are critical.",
      "description_length": 561,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Intf.Map",
      "library": "term-tools",
      "description": "This module implements finite maps with operations for adding key-value pairs, checking emptiness, finding values by key, comparing maps for equality, and converting between maps and sequences. It works with a defined key type and arbitrary value types, supporting efficient lookups and transformations. Concrete use cases include managing symbol tables, tracking configurations, or implementing caches where key-based access is required.",
      "description_length": 438,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Zipper.Make_stateful",
      "library": "term-tools",
      "description": "This module provides zippers for navigating and modifying first-order terms with lazy substitution, allowing edits to terms where variables reference other terms via a substitution map. It supports operations like moving up or to specific indices in the term structure, replacing focused terms, and folding over subterms or variables. Concrete use cases include term rewriting, symbolic manipulation, and traversing nested expressions with variable bindings.",
      "description_length": 458,
      "index": 7,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Term_tools.Intf.Pattern",
      "library": "term-tools",
      "description": "This interface supports constructing and modifying patterns using primitives, variables, and list structures, along with matching and refining operations that target specific term components via zippers. It facilitates tasks like compiler optimizations, symbolic computation, and term-based transformations by enabling precise pattern-driven analysis and manipulation of structured data.",
      "description_length": 387,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Make.Subst",
      "library": "term-tools",
      "description": "This module implements substitution operations over terms, represented as mappings from integer variables to terms. It supports creating substitutions from sequences, applying substitutions to terms, and combining substitutions, with utilities for inspecting and modifying substitution contents. Concrete use cases include implementing unification algorithms and managing variable bindings during term rewriting or logic programming tasks.",
      "description_length": 439,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Subst.Make",
      "library": "term-tools",
      "description": "This module implements substitutions for terms, supporting operations like adding or updating variable-term mappings, applying substitutions to terms, and checking equality or emptiness. It works with variables represented as integers and terms from the provided `T` module. Use cases include managing variable bindings during term rewriting or implementing unification algorithms.",
      "description_length": 381,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Intf.Term_core",
      "library": "term-tools",
      "description": "This module defines the core operations for constructing and manipulating first-order terms, including variables, primitive-headed terms, and their subterms. It provides functions for term comparison, hashing, pretty-printing, case analysis, and traversal, as well as checks for variables and ground terms. Use cases include term rewriting, unification, and symbolic manipulation in formal verification or logic programming tasks.",
      "description_length": 430,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Pattern.Make",
      "library": "term-tools",
      "description": "This module offers a pattern-matching framework for analyzing and transforming terms through primitives, variables, and list structures, with operations to build patterns, match them against terms, and traverse subterms using zippers. It handles terms, zipper states, and pattern lists, enabling tasks like term rewriting, syntax analysis, and data extraction where structured patterns identify specific components. Functional construction of immutable patterns, combined with stateful traversal and list utilities, supports precise term manipulation and contextual transformations.",
      "description_length": 582,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Make.Zipper",
      "library": "term-tools",
      "description": "This module provides zippers for navigating and modifying first-order terms, supporting operations like moving up, moving to a specific index, replacing subterms, and folding over subterms or variables. It works with terms represented as `Term.t` and tracks a focus position within the term structure, allowing edits to be made directly at the focused node. Concrete use cases include term rewriting, traversal-based analysis, and incremental term transformations with substitution support.",
      "description_length": 490,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Zipper.Zipper_impl",
      "library": "term-tools",
      "description": "Implements a zipper structure for navigating and modifying terms within a context. It provides direct access to the current focus and context, along with operations to update and retrieve terms at specific positions in the state. Useful for term rewriting and traversal tasks where precise control over term structure is needed.",
      "description_length": 328,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Intf.Unification",
      "library": "term-tools",
      "description": "This module provides operations for solving unification problems on first-order terms, including unifying terms and substitutions, checking generalization relationships, and applying substitutions. It works with terms, substitutions, and unification states, allowing manipulation and querying of term structures under variable bindings. Concrete use cases include implementing logic programming engines, type inference systems, and symbolic reasoning tools where term equivalence under substitution is required.",
      "description_length": 511,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Pattern.Make_raw",
      "library": "term-tools",
      "description": "This module offers operations to construct and analyze term patterns using GADTs, alongside utilities for refining terms and traversing structured data with zippers. It manipulates terms, pattern descriptions, and zipper lists to enable precise matching, transformation, and generation of unique identifiers in contexts like term rewriting or logic-based computation. Key applications include syntax tree traversal, rule-based transformations, and structured term analysis requiring focused modifications.",
      "description_length": 505,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Intf.Subst",
      "library": "term-tools",
      "description": "This module represents substitutions as finite mappings from integer variables to terms, supporting operations like adding bindings, retrieving values, applying substitutions to terms, and combining substitution sets. It works directly with variables (integers), terms, and sequences of variable-term pairs. Concrete use cases include implementing unification algorithms, term rewriting, and managing variable bindings during symbolic computation.",
      "description_length": 447,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Intf.Signature",
      "library": "term-tools",
      "description": "This module defines operations for comparing, hashing, and printing first-order term signatures. It provides functions to check equality, compute a total order, and determine the arity of a signature. These operations are essential for managing term structures in formal logic or symbolic computation tasks.",
      "description_length": 307,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Zipper.Make_gen",
      "library": "term-tools",
      "description": "This module provides zippers for navigating and modifying first-order terms, allowing both traversal and in-place edits of terms with lazy substitution. It supports operations like moving up or to specific indices, replacing subterms, and folding over terms or variables. Concrete use cases include term rewriting, symbolic manipulation, and implementing traversal-based transformations in formal systems.",
      "description_length": 405,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Term.Make_hash_consed",
      "library": "term-tools",
      "description": "This module provides functions for constructing and manipulating hash-consed terms composed of primitives and variables, supporting operations like case analysis, variable substitution, path-based traversal, and canonicalization. The term type leverages structural sharing via persistent maps to ensure efficient equality checks and unique representations, making it suitable for symbolic computation and compiler optimizations where term comparison and shared substructures are critical.",
      "description_length": 488,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Make.Term_graph",
      "library": "term-tools",
      "description": "This module enables structured navigation and transformation of term graphs through pattern matching and zipper-based editing. It supports matching terms against patterns with primitives, variables, and lists, while allowing precise traversal and modification via zippers that track focused positions in the term hierarchy. Operations include checking pattern equivalence, replacing subterms, folding over variables, and constructing or deconstructing term structures. Examples include rewriting specific subterms in a graph, extracting variable contexts, and performing conditional transformations based on term structure.",
      "description_length": 623,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Make.Unification",
      "library": "term-tools",
      "description": "This module implements unification operations for first-order terms, including term and substitution unification, substitution application, and term generalization checks. It operates on terms and substitutions defined in the `Term` and `Subst` modules, managing unification state through the `state` type. Concrete use cases include solving term equality constraints, generating substitutions, and checking if one term generalizes another.",
      "description_length": 440,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Term.Default_map",
      "library": "term-tools",
      "description": "This module implements a map with integer keys that supports efficient operations like insertion, lookup, and equality checks. It provides functions to create, modify, and iterate over maps, including operations to add key-value pairs, find values by key, and compare maps using a custom equality function. Use cases include managing term bindings in a hash-consed environment or tracking associations between identifiers and values in a compiler or interpreter.",
      "description_length": 462,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Intf.Hashed",
      "library": "term-tools",
      "description": "This module defines an interface for types that support comparison, equality checking, hashing, and pretty-printing. It works with any data type `t` that can be ordered, hashed, and converted to a string representation. Concrete use cases include implementing hash tables, sets, or maps where keys require efficient comparison and hashing, such as symbol tables or caches.",
      "description_length": 372,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Zipper.Make",
      "library": "term-tools",
      "description": "This module provides zippers for navigating and modifying first-order terms with support for lazy substitution. It works with terms that may contain variables pointing to other terms, enabling purely functional edits to the term graph. Concrete use cases include term rewriting, symbolic manipulation, and traversal of structured expressions with variable references.",
      "description_length": 367,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Make",
      "library": "term-tools",
      "description": "This library provides a comprehensive framework for constructing, analyzing, and transforming first-order terms using a combination of term manipulation, substitution, zippers, and unification. The core data types include `Term.t` for representing terms, `Subst.t` for variable-to-term mappings, and zipper structures for navigating and modifying focused positions within terms. Operations span term construction and traversal, substitution application and composition, pattern-based matching, and unification with state tracking. Specific capabilities include rewriting subterms, solving equality constraints, performing logic programming tasks, and managing variable bindings during symbolic computation.",
      "description_length": 706,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Subst",
      "library": "term-tools",
      "description": "This module manages substitutions for terms, where variables are represented as integers and terms come from an external module. It supports key operations such as adding or updating variable-term mappings, applying substitutions to terms, and checking substitution equality or emptiness. You can use it to track variable bindings during term rewriting or to implement unification algorithms. For example, you can create a substitution mapping variable `0` to a term, then apply that substitution to another term to replace all occurrences of `0` with the mapped value.",
      "description_length": 569,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Term",
      "library": "term-tools",
      "description": "This module traverses parameterized term structures using a fold operation, enabling size calculations, transformations, and structural analysis through user-defined accumulations. It supports hash-consed terms built from primitives and variables, offering case analysis, substitution, path-based traversal, and canonicalization with efficient equality via structural sharing. An associated integer-keyed map facilitates managing term bindings and identifier-value associations with fast lookups and custom equality checks. Example uses include term rewriting, attribute collection, and optimizing symbolic computations in compilers or interpreters.",
      "description_length": 649,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Intf",
      "library": "term-tools",
      "description": "This module provides the foundation for working with first-order terms, offering core abstractions for hash-consing, signature management, term structures, and substitution mechanisms. It supports advanced operations like pattern matching, unification, and term traversal through zippers, enabling precise manipulation of term structures and variable bindings. The module's direct API allows term construction, comparison, hashing, and pretty-printing, while submodules extend functionality with zippers for focused term editing, unification solvers, pattern refinement, and finite maps for key-based data management. Specific applications include symbolic rewriting, logic engines, compiler transformations, and formal verification tasks that require fine-grained control over term and substitution structures.",
      "description_length": 811,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools.Zipper",
      "library": "term-tools",
      "description": "This module enables navigation and modification of nested, tree-like data structures using zippers that maintain positional context. It supports first-order terms with lazy substitution, allowing operations such as moving focus within the structure, replacing subterms, and folding over terms or variables. Child modules refine this functionality with specialized zippers for term rewriting, symbolic manipulation, and traversal of expressions with variable bindings or references. Examples include editing specific nodes in an AST, applying transformations to subterms, and navigating term graphs with structural awareness.",
      "description_length": 624,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Int_option",
      "library": "term-tools",
      "description": "This module represents optional integers using a distinguished `none` value, supporting operations like equality checks, conversion to and from integers, and safe value extraction with a default. It provides functions to check if a value is `none`, format values for printing, and perform unsafe integer conversion. Concrete use cases include handling optional integer identifiers or flags where the absence of a value must be explicitly represented.",
      "description_length": 450,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term_tools.Pattern",
      "library": "term-tools",
      "description": "This module handles pattern focus states in term manipulation, providing `get_focus` and `get_focus_list` to inspect whether patterns are focused or unfocused during analysis or transformation. Its core functionality integrates with submodules that support pattern matching, subterm location, hash-consing for efficiency, and structured term traversal using zippers. These submodules enable building and matching patterns against primitives, variables, and list structures, with utilities for pretty-printing, identifier retrieval, and immutable pattern construction. Together, they facilitate tasks like term rewriting, syntax analysis, and logic-based computation where precise subterm targeting and contextual transformations are required.",
      "description_length": 742,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term_tools",
      "library": "term-tools",
      "description": "This library provides a framework for manipulating first-order terms with precise control over structure, substitution, and navigation. Core data types include `Term.t` for terms, `Subst.t` for variable mappings, and zipper-based structures for contextual editing. It supports operations like unification, pattern matching, term traversal, and hash-consed equality checks. You can rewrite subterms, solve logic constraints, or transform nested structures while managing variable bindings and optional identifiers efficiently.",
      "description_length": 525,
      "index": 33,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 35,
    "meaningful_modules": 34,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9714285714285714
  },
  "statistics": {
    "max_description_length": 811,
    "min_description_length": 307,
    "avg_description_length": 506.7352941176471,
    "embedding_file_size_mb": 0.12393379211425781
  }
}