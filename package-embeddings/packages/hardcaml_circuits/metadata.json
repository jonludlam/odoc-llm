{
  "package": "hardcaml_circuits",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 699,
  "creation_timestamp": "2025-08-18T20:43:44.435538",
  "modules": [
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width bit vectors in a CORDIC-based cosine and sine computation context. It supports construction, deconstruction, and transformation of bit-level representations, including functions for packing/unpacking, multiplexing, concatenation, and selection. Concrete use cases include implementing hardware circuits for trigonometric function evaluation, signal processing pipelines, and testbench generation for digital design verification.",
      "description_length": 509,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating a CORDIC rotation interface, including packing/unpacking signals into vectors, multiplexing, concatenation, and selection functions like priority and onehot selects. It works with bit vectors and valid signal interfaces, ensuring correct bit widths through validation and width-checking functions. Concrete use cases include building control logic for CORDIC-based vector rotation circuits, such as selecting between multiple rotated outputs or validating signal widths in a pipeline.",
      "description_length": 553,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that sequences monadic actions across a structured interface, transforming a product of monadic values into a monadic product. It operates on data structures composed of tuples or records where each field is wrapped in a monad `M`. A concrete use case is collecting results from multiple concurrent hardware description computations into a single structured result.",
      "description_length": 403,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based hyperbolic cosine and sine circuit. It provides concrete signal identifiers and their bit-widths, used to interface with the circuit's inputs and outputs. These definitions support simulation, testing, and integration with hardware description code.",
      "description_length": 310,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structure containing monadic values into a monadic structure of the same shape, specifically for CORDIC-based `Atan2` operations. It works with data types involving the composition of a monad `M` and the CORDIC interface type `Atan2.Cordic.O.t`. Use this to sequence monadic actions across a CORDIC computation interface, such as collecting results from multiple concurrent CORDIC pipelines.",
      "description_length": 447,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational logic operations for a fixed-structure arithmetic interface, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions like priority and one-hot selects. It operates on a custom type `t` composed of signals defined by the `Comb` module, with each field having a defined bit width. Concrete use cases include building and validating fixed-width arithmetic circuits, routing signals through multiplexers, and converting structured interfaces to flat vectors for transmission or storage.",
      "description_length": 556,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bit vector interfaces used in CORDIC-based multiplication circuits. It supports concrete operations such as packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection via priority or one-hot encoding. These functions are used to build and validate signal interfaces with specific bit widths for use in hardware description and synthesis.",
      "description_length": 449,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unchecked conversions between a structured type and an association list indexed by field names, enabling easy serialization and deserialization of CORDIC division interface values. It operates on types that conform to the `Div.Cordic.O.t` signature, using strings as keys in the association list. These functions are useful when mapping hardware interface signals to named fields for debugging or external tool integration.",
      "description_length": 452,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based multiplier circuit, specifying the inputs and outputs required for its operation. It works with basic string and integer types to represent port names and their bit widths, along with a list of tags for identifying signal roles. It is used to configure and generate correct signal interfaces when instantiating or simulating the CORDIC multiplier circuit.",
      "description_length": 416,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bit vector representations of CORDIC circuit interfaces. It supports concrete tasks like packing and unpacking interface signals into bit vectors, multiplexing between multiple interface configurations, and validating signal widths to ensure correctness in hardware synthesis. Key functions include `pack`, `unpack`, `mux`, and `validate`, which directly facilitate hardware description and transformation workflows.",
      "description_length": 494,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC cosine/sine interfaces using the Always API. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include building and connecting CORDIC-based cosine/sine circuits within an always block.",
      "description_length": 339,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width bit vectors in a CORDIC-based arctangent implementation. It supports construction from integers, packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations with support for valid signals and one-hot encoding. These functions are used to build and manipulate CORDIC circuit interfaces with precise bit-level control.",
      "description_length": 434,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a structured interface type and an association list, using field names as keys. It operates on values of type `'a Atan2.Cordic.I.t` and string-keyed lists of values. These functions are useful for interfacing with systems that require named signal access, such as generating signal mappings for simulation or synthesis from structured data.",
      "description_length": 388,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for a CORDIC-based cosine and sine circuit. It provides concrete signal identifiers and bit-width configurations required for hardware synthesis. Use this to generate or analyze the interface of a CORDIC core implementing trigonometric functions.",
      "description_length": 295,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based arctangent circuit, specifying signal names and bit-widths for inputs and outputs. It works with lists of strings and integers to describe hardware interface properties. Concrete use cases include configuring simulation testbenches and generating synthesis scripts for FPGA or ASIC implementations.",
      "description_length": 359,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that lifts monadic values through a structure, transforming a record of monadic values into a monadic record. It operates on the `Rect_to_polar.Cordic.I.t` type, which represents the input interface of a CORDIC-based rectangular-to-polar conversion circuit. A concrete use case is collecting and sequencing multiple CORDIC computations within a monadic context, such as wiring them together in a hardware description workflow.",
      "description_length": 464,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width bit vectors in a CORDIC-based arctangent computation context. It supports concrete operations such as packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection based on priority or one-hot encoding. These functions are used to build and manipulate hardware circuits for computing arctangent values using CORDIC iterations, ensuring correct bit-width handling and signal routing.",
      "description_length": 494,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structured interface of monadic values into a monadic interface over a structured value, specifically for the CORDIC implementation of hyperbolic arctangent (`Atanh`). It operates on data types involving `Atanh.Cordic.O.t` and a monad `M`, enabling composition of CORDIC-based computations within a monadic context. A concrete use case is aggregating multiple CORDIC-specialized signals into a single monadic structure for evaluation or simulation.",
      "description_length": 504,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for the input signals of a CORDIC-based arctangent (`atan2`) circuit. It provides concrete identifiers and bit-widths for each input port, such as `x`, `y`, and `angle`, ensuring correct signal alignment and interface consistency. These definitions are used directly in circuit instantiation and simulation to map inputs to their respective widths without runtime computation.",
      "description_length": 418,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module enables construction and manipulation of CORDIC-based cosine/sine circuits through signal operations like packing/unpacking, multiplexing, concatenation, and pipeline register creation, operating on record-like signal interfaces. It provides hardware wiring primitives for connecting signals (`<==`), defining named input/output interfaces, and applying hierarchical signal names, all tailored for CORDIC module integration. These capabilities are used to implement pipelined trigonometric function circuits in hardware designs while maintaining structured signal hierarchies.",
      "description_length": 588,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a monadic interface of a CORDIC polar-to-rectangular conversion into a monad wrapping the interface. It operates on data structures involving CORDIC inputs and outputs within a monadic context. A concrete use case is aggregating multiple CORDIC computations, each encapsulated in a monad (e.g., `Result` or `Option`), into a single computation while preserving interface structure.",
      "description_length": 435,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating a structured interface of type `t`, which represents a vector of signals used in CORDIC rotation computations. It supports operations like packing/unpacking signals into vectors, multiplexing, concatenation, and selection based on priority or one-hot encoding, all at the signal level using the `Comb` module. Concrete use cases include building control logic for selecting rotation vectors or managing signal routing in digital circuits implementing trigonometric or hyperbolic functions via CORDIC.",
      "description_length": 569,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that sequences monadic actions across a structured interface, transforming a monadic CORDIC interface into a monad containing a CORDIC interface. It operates on CORDIC input interfaces parameterized by a monad `M`. It is used to compose multiple monadic CORDIC operations into a single lifted computation, enabling sequential execution of CORDIC-based arithmetic in a monadic context.",
      "description_length": 422,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for a CORDIC-based cosine and sine circuit. It provides concrete signal identifiers and bit-width configurations required for hardware synthesis and simulation. Use this module to access the interface specification of a CORDIC core computing trigonometric functions.",
      "description_length": 315,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating a specific interface type, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions. It works with bit vector types and structured interfaces composed of those vectors. Concrete use cases include building control logic for selecting between multiple data paths, assembling or disassembling compound signals, and validating signal widths in a CORDIC-based multiplier circuit.",
      "description_length": 479,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe access to CORDIC cosine and sine circuit ports by name, allowing field values to be retrieved or set via string keys. It operates on association lists mapping field names to values, supporting dynamic inspection and configuration of circuit inputs and outputs. Concrete use cases include debugging signal paths, injecting test values, and mapping external data to circuit fields without type-safe guarantees.",
      "description_length": 444,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based multiplier circuit, specifying signal names and bit widths for inputs and outputs. It works with lists of strings and integers to represent port metadata, alongside a list of tags for signal identification. Concrete use cases include configuring hardware description code generation and ensuring signal consistency in CORDIC multiplier implementations.",
      "description_length": 413,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC cosine/sine interface signals using the Always API. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Concrete use cases include building and configuring CORDIC-based cosine/sine circuits with named, registered, or wired signals in an always block.",
      "description_length": 393,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for converting rectangular coordinates to polar coordinates using CORDIC algorithms, working directly with bit vectors. It supports construction of interfaces from integers, packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations with optional validity signals. Concrete use cases include implementing fixed-point CORDIC-based magnitude and phase calculations in hardware designs.",
      "description_length": 453,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based hyperbolic cosine and sine circuit. It provides concrete signal identifiers and their bit-widths, used to interface with the circuit's inputs and outputs. These values are derived from tagged descriptions that specify the structure of the circuit's interface.",
      "description_length": 320,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structured interface of monadic values into a monadic interface over a structured type, specifically for rectangular-to-polar conversion using CORDIC logic. It operates on types that conform to the `Rect_to_polar.Cordic.O.t` structure with an underlying monad `M`. A concrete use case is aggregating multiple CORDIC-based signal conversions within a monadic context, such as collecting results from asynchronous computations or handling side effects in a structured pipeline.",
      "description_length": 531,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module implements fixed-point CORDIC-based inverse hyperbolic tangent (`atanh`) computations using bit-level representations. It provides operations for packing/unpacking, multiplexing, and validating signal interfaces, along with utilities for constructing constant values and selecting between multiple inputs. Concrete use cases include implementing high-precision arithmetic circuits and signal processing pipelines in hardware description contexts.",
      "description_length": 458,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating a `Rect_to_polar.Cordic.O.t` interface, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection functions such as priority and one-hot selects. It supports data types involving `comb` signals, which represent combinational logic values, and works with structured interfaces containing multiple signal fields. Concrete use cases include building control logic for CORDIC-based polar conversion circuits, routing signal paths based on selection inputs, and validating signal widths during design composition.",
      "description_length": 611,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width signal interfaces in a CORDIC-based hyperbolic arctangent circuit. It supports construction and deconstruction of signal bundles via `pack`, `unpack`, `of_int`, and `of_ints`, along with selection and routing functions like `mux`, `concat`, and priority/onehot selection variants. These operations are used to wire and control data paths in digital circuits implementing the atanh function.",
      "description_length": 471,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating CORDIC-based arctangent circuits using signal interfaces with strict width validation and bit-level control. It supports tasks like constant assignment, signal concatenation/multiplexing, pipeline stage creation, and interface wiring, working with signal-based data structures to enforce hardware correctness. Specific use cases include connecting input/output ports, applying hierarchical naming for clarity, and implementing pipelined architectures in hardware designs.",
      "description_length": 537,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations (constant assignment, multiplexing, concatenation) and sequential elements (registers, pipelines) for constructing CORDIC-based circuits, operating on composite signal types composed of Hardcaml's `Signal.t` values with explicit width management. It supports structural transformations through signal wiring primitives and hierarchical naming controls, enabling precise RTL-level modeling of dataflow and interface connections in hyperbolic function implementations. Key use cases include building pipelined datapaths and creating named signal interfaces for simulation/debugging clarity in arithmetic circuits.",
      "description_length": 663,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module supports combinational and sequential operations for constructing CORDIC-based division circuits, primarily manipulating signal interfaces through packing/unpacking, multiplexing, concatenation, and register control. It enables pipeline construction, signal name propagation, and hierarchy customization, specifically addressing use cases where precise signal wiring and name management are critical for hardware implementation of division logic.",
      "description_length": 458,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module supports wiring, naming, and structural manipulation of fixed-structure interfaces with typed signal fields to implement CORDIC-based `atan2` computations in hardware pipelines. It provides low-level signal operations like concatenation, multiplexing, and pipelining alongside interface connectivity primitives for connecting inputs/outputs and annotating signals with hierarchical names. These capabilities are used to synthesize and integrate `atan2` circuits into larger FPGA/ASIC designs while managing signal routing and timing constraints during hardware compilation.",
      "description_length": 585,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC-generated hyperbolic cosine and sine interfaces using the Always API. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include building and wiring CORDIC-based hyperbolic function circuits within an always block.",
      "description_length": 368,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC interface structures using the Always API. It supports operations like creating register or wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include building and managing hardware description logic for CORDIC-based arctangent computations with named, structured interfaces.",
      "description_length": 395,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal interfaces within an `Always` block, specifically for CORDIC-based division circuits. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include constructing and managing stateful logic for division operations in hardware descriptions using the Always API.",
      "description_length": 400,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a specific CORDIC interface structure. It supports creating register and wire variables, assigning values, and applying naming conventions to interface fields. Use cases include building and managing hardware description logic for CORDIC-based designs with named signal interfaces.",
      "description_length": 372,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bit vector interfaces used in CORDIC-based division circuits. It supports concrete operations such as packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/onehot selection with valid signals. These functions are used to build configurable, synthesizable digital circuits for arithmetic operations with precise bit-level control.",
      "description_length": 445,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating polar-to-rectangular coordinate conversion interfaces in a CORDIC implementation. It supports signal packing, unpacking, multiplexing, concatenation, and selection operations tailored to the bit-level structure of the conversion interface. These functions are used to construct and validate signal pipelines for hardware synthesis targeting polar coordinate transformations.",
      "description_length": 443,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that combines values within a monadic context, transforming a structure containing monadic values into a monadic structure of the same shape. It operates on data types that conform to the `Cosh_sinh.Cordic.I.t` interface parameterized over a monad `M`. A concrete use case is aggregating multiple monadic computations into a single result while preserving the structure of the original data.",
      "description_length": 429,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC rotation vector interface, specifying signal identifiers and their bit widths. It works with lists of strings and integers to represent port configurations. Concrete use cases include generating signal declarations and wiring interfaces in hardware descriptions for CORDIC-based vector rotation circuits.",
      "description_length": 359,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a `Cos_sin.Cordic.I.t` interface and an association list of field names to values. It enables named field access and construction using string keys, specifically for CORDIC cosine and sine input interfaces. Use this when mapping hardware interface signals to dynamic data structures or initializing interfaces from configuration data.",
      "description_length": 382,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC polar-to-rectangular conversion interface. It provides concrete signal identifiers and their bit-widths used in the CORDIC computation pipeline. Useful for generating hardware descriptions with consistent signal naming and sizing in digital circuit implementations.",
      "description_length": 320,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structure containing monadic values into a monadic structure of the same shape, specifically for CORDIC-based `Atan2` input interfaces. It works with data types involving `'a M.t Atan2.Cordic.I.t`, where `M` is a monad, and lifts monadic computations out of CORDIC input records. A concrete use case is collecting and sequencing monadic effects across multiple CORDIC computation inputs, such as signal wires in a hardware description, into a single monadic result.",
      "description_length": 521,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for a CORDIC-based vector rotation circuit. It specifies the interface by listing input and output signal names along with their bit widths, and provides a list of tags identifying the circuit's configuration. Use this module to access the structural metadata required to integrate or instantiate the CORDIC vector rotation circuit in a hardware design flow.",
      "description_length": 407,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC polar-to-rectangular conversion circuit. It provides concrete signal identifiers and their bit-widths needed to interface with the circuit. Use this module when instantiating or connecting the CORDIC core to ensure correct signal mapping and sizing.",
      "description_length": 304,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating fixed-width signal interfaces used in CORDIC-based atanh implementations. It supports operations like packing/unpacking signals into vectors, multiplexing, concatenation, and selection with priority or one-hot encoding, all while validating bit widths. Concrete use cases include building control logic for CORDIC pipelines and managing signal routing in hardware descriptions.",
      "description_length": 463,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating signal interfaces representing CORDIC-based `atan2` computations, including packing/unpacking, multiplexing, concatenation, and pipeline creation. It works with bit-width-specific signal types and wire bundles, adhering to hardware circuit construction patterns. These tools are used to implement efficient trigonometric functions in FPGA or ASIC designs, with support for signal routing and naming conventions to organize complex circuits.",
      "description_length": 506,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating signal-based CORDIC division interfaces, including arithmetic initialization (`of_int`), signal wiring (`assign`), register pipelining (`pipeline`), and multiplexing logic (`mux`). It works with signal structures (`Signal.t`) representing division inputs and outputs, enforcing width constraints and enabling hierarchical naming for clarity. These utilities are used to implement and validate hardware circuits for division algorithms, particularly in scenarios requiring precise control over signal connectivity and structural transformations.",
      "description_length": 610,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides signal-level combinational logic (e.g., multiplexing, packing/unpacking), sequential components (registers, pipelines), and structural validation utilities for constructing CORDIC-based arctangent circuits. It operates on signal interfaces composed of `Hardcaml.Signal.t` elements, enabling hardware description through combinational wiring and synchronized state transitions. These operations are used to implement and verify fixed-function hardware pipelines where precise angular computation and signal routing are required, such as in digital signal processing or FPGA-based mathematical accelerators.",
      "description_length": 626,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and managing signal interfaces, including validation, multiplexing, register and pipeline definitions, and signal wiring via connection primitives and naming conventions. It operates on Hardcaml's `Signal.t` type and structured interface records to facilitate precise control over signal routing and hierarchical organization. These capabilities are critical for implementing CORDIC-based hardware circuits that compute mathematical functions like hyperbolic cosine and sine, where precise signal management and pipeline control are required in FPGA or ASIC designs.",
      "description_length": 615,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe conversions between a structured interface type and an association list, using field names as keys. It operates on values of type `'a Div.Cordic.I.t` and string-keyed lists of key-value pairs. These functions are used to dynamically inspect or construct CORDIC divisor interfaces by mapping field names to corresponding values.",
      "description_length": 363,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating a specific CORDIC interface structure, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with bit vector types (`comb`) and structured records containing integer fields. Concrete use cases include building and validating fixed-width signal interfaces for CORDIC-based polar conversion circuits.",
      "description_length": 405,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating polar-to-rectangular CORDIC interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works directly with `comb` types representing hardware signals and structured `t` types containing CORDIC interface fields. Concrete use cases include building control logic for selecting between multiple CORDIC outputs, validating signal widths during simulation, and converting constant integer values into properly typed interface signals.",
      "description_length": 545,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a monadic polar-to-rectangular conversion interface into a monad containing the converted interface. It operates on data structures involving the `Polar_to_rect.Cordic.O.t` type wrapped in a monad `M`. A concrete use case is combining multiple monadic CORDIC conversion operations into a single monadic result, enabling sequential composition of CORDIC-based polar-to-rectangular transformations.",
      "description_length": 450,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for manipulating fixed-width bit vector interfaces specialized to CORDIC-based cosh/sinh function implementations. It supports construction from integers, packing/unpacking to bit vectors, multiplexing, concatenation, and selection operations with strict width validation. These functions enable hardware description of dataflow circuits performing hyperbolic function computations with precise bit-level control.",
      "description_length": 445,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively sequencing the monadic effects across all fields. It operates specifically on records structured by the `Atan.Cordic.O` module, which represents outputs of CORDIC-based arctangent computations. A concrete use case is collecting and flattening multiple CORDIC computation results that are wrapped in a monadic context, such as error handling or simulation effects.",
      "description_length": 479,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a specific interface type. It supports creating register and wire variables, assigning values, and applying naming conventions to interface fields. Use cases include building and managing hardware description logic for CORDIC-based `atan2` circuits with clear signal assignments and naming.",
      "description_length": 381,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structured interface of monadic values into a monadic interface over a structured value, specifically for the inverse hyperbolic tangent (Atanh) CORDIC implementation. It operates on data types involving `Atanh.Cordic.I.t` and a parameterized monad `M`. A concrete use case is aggregating multiple monadic computations within a CORDIC pipeline into a single monadic result while preserving the interface structure.",
      "description_length": 470,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a CORDIC division interface. It supports creating register and wire variables, assigning values, and applying naming conventions to interface fields. Use cases include building and managing stateful logic for CORDIC-based division circuits in a hardware description context.",
      "description_length": 365,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a CORDIC-based cosh/sinh interface. It supports creating register and wire variables, assigning values, and applying naming conventions to interface fields. Use cases include implementing sequential logic for CORDIC computations and managing signal declarations in a structured way.",
      "description_length": 373,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC interface structures using the Always API. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include building and connecting CORDIC-based arctangent circuits within a hardware description context.",
      "description_length": 351,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for manipulating fixed-width bit vectors in a CORDIC rotation context, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection functions. It works directly with `comb` type signals representing hardware combinational logic and structured `t` type interfaces for CORDIC rotation parameters. Concrete use cases include building configurable vector rotation circuits, implementing control logic for selecting between multiple rotation inputs, and validating signal widths during circuit construction.",
      "description_length": 565,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe conversions between a structured type and an association list indexed by field names, using string keys. It operates on types that conform to the `Atan2.Cordic.O.t` signature, enabling concrete transformations to and from lists of key-value pairs. These functions are useful when interfacing with systems that require named field access, such as configuration parsers or serialization formats.",
      "description_length": 429,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC rectangular-to-polar interfaces using the Always API. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. These functions are used when implementing or simulating CORDIC-based coordinate conversion circuits with named signal interfaces.",
      "description_length": 395,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based division circuit, specifying the inputs and outputs required for its operation. It works with basic hardware description types such as strings for port names and integers for bit widths. Concrete use cases include configuring the interface of a CORDIC divider in a hardware design flow, ensuring correct signal connections and bit-width propagation.",
      "description_length": 410,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational signal manipulation and interface construction capabilities for coordinate conversion logic, focusing on operations like constant assignment, signal multiplexing, register pipeline creation, and interface wiring. It works with `t`-typed structures containing Hardcaml's `comb` signal type to manage combinational logic and signal connectivity. These utilities are specifically used to implement polar-to-rectangular coordinate conversion modules in hardware designs requiring precise signal routing and validation.",
      "description_length": 549,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the signal names and bit-widths for the inputs and outputs of a CORDIC-based rectangular-to-polar conversion circuit. It works with basic string and integer types to specify port configurations, and includes tags that identify each signal's role in the CORDIC computation. Concrete use cases include configuring hardware description code for synthesis and simulation of digital circuits performing coordinate conversion.",
      "description_length": 440,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a structured interface and an association list indexed by field names, enabling named access to interface elements. It operates on tuples of type `'a Rect_to_polar.Cordic.I.t` and string-keyed lists of values. Use this to dynamically inspect or construct CORDIC interfaces by field name without positional dependencies.",
      "description_length": 367,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module implements CORDIC-based division operations using bit-level combinational logic. It provides functions to construct, manipulate, and validate fixed-width signal interfaces for division circuits, including packing/unpacking signals to and from bit vectors, multiplexing, concatenation, and selection operations. Concrete use cases include building configurable division circuits in hardware descriptions, validating signal widths, and generating constant or multiplexed division operands in a hardware compiler flow.",
      "description_length": 527,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate interface values using the Always API, specifically for creating and managing register and wire variables within a CORDIC implementation context. It supports operations like assigning signals to variables, extracting signal values, and applying naming conventions to interface fields. Concrete use cases include constructing and initializing CORDIC-based atanh circuits with named, register-backed or wire-backed signals in a hardware description workflow.",
      "description_length": 501,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe association of list elements with record fields by string keys, specifically for CORDIC atanh interface types. It enables conversion between a structured record and a list of key-value pairs, where keys correspond to field names. This is useful when deserializing or dynamically constructing CORDIC atanh interface values from named data sources.",
      "description_length": 382,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a tuple of monadic values into a monadic value of tuples, effectively lifting the monad outside the structure. It operates on tuples of values wrapped in a monad `M`, specifically within the context of rotation vector CORDIC operations. Use it to sequence multiple CORDIC computations that must complete before further processing.",
      "description_length": 384,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides structured signal manipulation for fixed-point CORDIC-based hyperbolic arctangent circuits, focusing on operations like signal wiring, register/pipeline insertion, multiplexing, and hierarchical naming. It works with `Hardcaml.Signal.t` values and circuit interfaces to manage input/output signal bundles, enabling precise control over hardware description. Specific use cases include implementing hyperbolic function accelerators in FPGAs, where structured signal routing and pipelining are critical for achieving timing closure in high-speed applications like network processing or control systems.",
      "description_length": 621,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating a CORDIC division interface, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with bit vector types and structured interfaces composed of signals, supporting operations like constant assignment, width validation, and priority/one-hot selection. Concrete use cases include building control logic for CORDIC-based dividers, routing signals in data paths, and constructing testbenches with fixed integer values.",
      "description_length": 528,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for packing, unpacking, and multiplexing CORDIC-based `Atan2` function interfaces. It supports data types involving packed bit vectors and structured signal interfaces with validated bit widths. Concrete use cases include constructing priority or one-hot multiplexers for selecting between multiple CORDIC outputs and converting between constant integer values and their bitvector representations.",
      "description_length": 449,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating a specialized interface type `t` that represents CORDIC-based hyperbolic cosine and sine function signals. It supports construction from integers, packing/unpacking to vectors, multiplexing, concatenation, and selection operations with optional branching factors. Concrete use cases include building and validating fixed-width signal interfaces for hardware synthesis of hyperbolic trigonometric functions.",
      "description_length": 475,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that takes a list of monadic values within a CORDIC division context and combines them into a single monadic value containing a list of results. It operates on data structures involving lists of CORDIC division computations wrapped in a monad `M`. A concrete use case is aggregating multiple parallel CORDIC-based division operations into a single result while preserving monadic effects like simulation or hardware generation.",
      "description_length": 465,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width signal interfaces representing CORDIC-computed arctangent values. It supports packing/unpacking signals to vectors, multiplexing, concatenation, and selection operations with optional branching factors. These operations are used to construct and validate hardware circuits for arctangent calculations in digital signal processing pipelines.",
      "description_length": 421,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for a CORDIC-based arctangent circuit interface. It provides concrete signal identifiers and bit-width specifications required to implement or connect the circuit in a hardware description context. Use cases include generating register-transfer level (RTL) code or interfacing with simulation tools where precise signal metadata is necessary.",
      "description_length": 391,
      "index": 84,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe access to fields of a CORDIC interface using string keys, enabling low-level manipulation of signal values by name. It operates on association lists that map field names to signal data, supporting dynamic construction and deconstruction of CORDIC signal interfaces. Use this when interfacing with external systems that require runtime signal resolution or for debugging purposes where field names are not known statically.",
      "description_length": 458,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bitvector representations of inputs to a CORDIC-based inverse hyperbolic tangent (`atanh`) function. It supports concrete operations such as packing/unpacking interface values to/from bit vectors, multiplexing between multiple input interfaces, concatenation, and selection via priority or one-hot encoding. Use cases include hardware synthesis of `atanh` function inputs with precise bit-level control, validation of signal widths, and construction of constant or parameterized input interfaces for simulation or testing.",
      "description_length": 600,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating rectangular-to-polar conversion interfaces using Hardcaml signals, supporting tasks like constant assignment, multiplexing, pipeline creation, and signal wiring. It operates on `Rect_to_polar.Cordic.I.Of_signal.t` values that encapsulate `Signal.t`-based combinational logic, enabling precise control over hardware description constructs. These capabilities are particularly useful in FPGA or ASIC designs implementing CORDIC-based polar conversion circuits, where managing signal interfaces, naming, and register stages is critical for synthesis and verification workflows.",
      "description_length": 640,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC polar-to-rectangular output interfaces using the Always API. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include building and connecting CORDIC circuits in a hardware description context, particularly when integrating with simulation or synthesis flows that require named signals or registered outputs.",
      "description_length": 463,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps fields of a CORDIC polar-to-rectangular conversion interface to and from association lists keyed by field names. It operates on records containing numeric types, typically used for hardware description and simulation in Hardcaml. Use this when converting between structured CORDIC data and string-indexed value lists, such as for serialization or dynamic configuration.",
      "description_length": 395,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe access to fields of a CORDIC interface via string keys, enabling dynamic manipulation of vector rotation parameters. It operates on association lists mapping field names to values, supporting runtime configuration of CORDIC operations. Use cases include programmatically setting or querying specific input fields in a CORDIC circuit without static type checking.",
      "description_length": 398,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC-based atanh interfaces using the Always API. It supports operations like extracting signals from variables, assigning signals to variables, and creating registers or wires with specified properties. Concrete use cases include building and naming signal interfaces for hardware description in CORDIC implementations of hyperbolic arctangent functions.",
      "description_length": 423,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to manipulate fixed-width bit vector interfaces for CORDIC rotation circuits. It supports construction from integers, packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection operations with optional branching factors. These functions are used to build and validate hardware circuits that perform vector rotation using CORDIC algorithms.",
      "description_length": 394,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct mappings between record fields and association list entries, specifically for CORDIC-based hyperbolic sine and cosine operations. It supports converting structured data to and from string-indexed key-value pairs, enabling straightforward serialization and deserialization of signal interfaces. Use this when interfacing with external systems that require named signal mappings or dynamically constructing interfaces from configuration data.",
      "description_length": 468,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides signal manipulation and wiring operations for constructing CORDIC-based polar-to-rectangular conversion circuits. It operates on composite types composed of `Hardcaml.Signal.t` elements, offering utilities for constant assignment, signal routing, pipeline register creation, and structural transformations. Key use cases include implementing hardware datapaths with precise control over signal connectivity and hierarchical naming in FPGA/ASIC workflows.",
      "description_length": 475,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bitvector representations of CORDIC-based hyperbolic cosine and sine function inputs and outputs. It supports concrete operations such as packing/unpacking interfaces to and from bit vectors, multiplexing and selecting between multiple interface values, and setting fields to constant integer values. These functions are used to build digital circuits that implement hyperbolic trigonometric computations in hardware.",
      "description_length": 495,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC-generated polar coordinate interfaces using the Always API. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include building and managing hardware descriptions for coordinate conversion circuits with named, configurable signals.",
      "description_length": 401,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based arctangent circuit implementation. It provides concrete signal identifiers and their bit-widths used in the hardware description of the CORDIC algorithm's output stage. These values are used directly in generating or verifying the circuit's interface signals.",
      "description_length": 320,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively sequencing the effects of each field. It operates on the interface type `Cos_sin.Cordic.I.t` with values wrapped in a monad `M`. A concrete use case is collecting and sequencing hardware description computations that produce CORDIC-based cosine and sine components.",
      "description_length": 381,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC polar-to-rectangular interfaces using the Always API. It supports operations like extracting signals from variables, assigning signals to variables, creating registers and wires for the interface, and applying naming conventions to interface fields. It works directly with `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` types wrapped in the CORDIC interface structure. Use this when implementing or wiring up CORDIC-based polar-to-rectangular conversion logic in a hardware description.",
      "description_length": 565,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides signal manipulation functions for CORDIC-based rectangular-to-polar conversion, including packing/unpacking, multiplexing, concatenation, and selection operations on combinational signal bundles. It supports working with `t` values containing `comb` signals (from `Hardcaml.Signal.t`), enabling combinational and registered signal handling alongside utilities for wiring, naming, and pipeline construction. These features are used in structural hardware design to manage signal interfaces, validate connections, and build modular pipelines.",
      "description_length": 561,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a product of monadic values into a monadic product, effectively lifting the monad outside the product structure. It operates on data types involving monadic values wrapped around product types, specifically `M.t` over `Mul.Cordic.O.t`. A concrete use case is combining multiple monadic computations that produce CORDIC multiplication results into a single monadic result containing all values.",
      "description_length": 447,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based division circuit, specifying the inputs and outputs required for its hardware description. It works with basic hardware description types such as strings for port names and integers for bit widths. Concrete use cases include generating signal declarations and interface definitions in Hardcaml for synthesis and simulation of the division circuit.",
      "description_length": 408,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational and sequential operations for manipulating signal interfaces in CORDIC-based computations, focusing on tasks like constant assignment, signal packing/unpacking, multiplexing, and register pipelining. It operates on record-like structures of `Signal.t` values, enabling hardware-specific operations such as interface wiring (`<==`), input/output port creation, and signal naming. These capabilities are specifically used to implement and validate signal-level logic in CORDIC circuits for functions like `atanh`, ensuring correct bit-widths and structural integrity during hardware synthesis.",
      "description_length": 626,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for a CORDIC-based rectangular-to-polar conversion circuit. It specifies the interface signals required for the circuit's input, including their bit widths and identifiers. Use this module when instantiating or connecting the CORDIC circuit to ensure correct signal mapping and bit-width handling in hardware descriptions.",
      "description_length": 371,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe association list conversions for CORDIC interface values, specifically for the arctangent function. It supports transforming structured data types with string keys and generic values into and from typed interfaces. Use this when mapping named signal ports to values in hardware description contexts where field names correspond to circuit input/output ports.",
      "description_length": 394,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational logic operations for packing, unpacking, multiplexing, and validating fixed-width signal interfaces used in CORDIC-based hyperbolic function circuits. It operates on a custom `t` type representing a structured interface with fields of type `comb`, supporting operations like `pack`, `unpack`, `mux`, and `concat` for vector manipulation and selection logic. Concrete use cases include constructing and verifying signal pipelines for hyperbolic cosine and sine computations in hardware descriptions.",
      "description_length": 535,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating CORDIC-based arctangent function interfaces. It supports data types representing packed signal vectors and structured interfaces with typed fields for fixed-point or integer values. Concrete use cases include building multiplexed input selection, constant initialization, signal packing/unpacking, and validation of port widths in CORDIC hardware circuits.",
      "description_length": 442,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating CORDIC-based arctangent interfaces. It supports data types representing packed signal vectors and structured interfaces with typed fields for angle and coordinate inputs. Concrete use cases include building fixed-function CORDIC pipelines, validating signal widths, and multiplexing or concatenating CORDIC input interfaces in digital signal processing circuits.",
      "description_length": 448,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for packing, unpacking, multiplexing, and selecting fixed-width signal interfaces. It works with bit vector types represented as `comb` and structured data of type `t` containing multiple signal fields. Concrete use cases include building control logic for data paths, implementing priority encoders, and managing signal routing in digital circuits.",
      "description_length": 401,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal values within an always block for a CORDIC multiplication interface. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include implementing and wiring up CORDIC-based multipliers in a hardware description with named signals and structured assignments.",
      "description_length": 396,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and their corresponding bit-widths for a CORDIC-based atanh function implementation. It provides concrete signal identifiers and sizing used in hardware generation for input/output interfaces. These values are used directly in constructing register-transfer level (RTL) descriptions for atanh circuits.",
      "description_length": 333,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bitvector representations of CORDIC-based arctangent interfaces. It supports concrete operations like packing/unpacking interfaces to bitvectors, multiplexing, concatenation, and priority/onehot selection with valid signals. Use cases include building hardware circuits for angle computation pipelines, signal routing in FPGA designs, and testbench validation of CORDIC arithmetic.",
      "description_length": 459,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC rotation interfaces using the Always API. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include building and connecting CORDIC rotation circuits within always blocks, such as implementing vector rotation logic in hardware descriptions.",
      "description_length": 394,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module implements CORDIC-based arctangent computations using bit-level representations. It provides operations to construct, manipulate, and validate CORDIC iteration interfaces with concrete bit vectors, including packing, unpacking, multiplexing, and concatenation. Use cases include hardware-accelerated trigonometric calculations and fixed-point angle computations in digital signal processing pipelines.",
      "description_length": 413,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a structured interface and an association list, where each field is mapped to or from a named string key. It operates on values of type `'a Cosh_sinh.Cordic.I.t` and pairs them with string keys in a list. These functions are useful when interfacing with systems that require named signal access, such as generating signal mappings for simulation or synthesis tools.",
      "description_length": 413,
      "index": 115,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively lifting the monad outside the record type. It operates on records of type `'a Rotate_vector.Cordic.I.t` where each field is wrapped in a monad `M`. A concrete use case is aggregating multiple monadic computations over a fixed record structure, such as collecting results from asynchronous operations or error-handling computations into a single structure.",
      "description_length": 471,
      "index": 116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively lifting the monad outside the record structure. It operates on data types that conform to the `Div.Cordic.I.t` record structure with monadic fields. A concrete use case is combining multiple monadic computations within a CORDIC interface into a single monadic result, enabling sequential composition of CORDIC operations.",
      "description_length": 437,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unchecked conversions between a CORDIC interface type and an association list of field names to values. It supports operations to_alist and of_alist for serializing and reconstructing CORDIC interface instances using string keys. This is useful when mapping hardware interface signals to named values in a structured format for configuration or debugging.",
      "description_length": 384,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe conversions between a structured type and an association list indexed by field names, using string keys. It supports serialization and deserialization of CORDIC atan interface values for dynamic field access or configuration. Use cases include runtime field lookup and partial structure initialization from named data.",
      "description_length": 354,
      "index": 119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for packing, unpacking, and multiplexing fixed-width bit vectors in a CORDIC-based arithmetic context. It supports data types like `comb` (bit vectors) and structured interfaces for CORDIC operations, with functions for validation, concatenation, and selection. Concrete use cases include building and verifying bit-level arithmetic circuits such as multipliers or function approximators using predefined bit widths.",
      "description_length": 448,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for converting polar coordinates to rectangular coordinates using CORDIC algorithms, specifically working with fixed-width bit vectors (`comb`). It includes functions for packing/unpacking interfaces into bit vectors, multiplexing, concatenation, and selection operations with support for one-hot and priority-encoded control signals. Concrete use cases include hardware synthesis for digital signal processing tasks like phase-to-sinusoid conversion in FPGA-based systems.",
      "description_length": 505,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational logic operations for a CORDIC-based cosine/sine interface, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with bit vector types (`comb`) and structured interfaces containing integer-width fields. Concrete use cases include building and validating fixed-point CORDIC circuits for trigonometric computations in hardware design.",
      "description_length": 415,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module implements low-level signal manipulation and interface construction operations for CORDIC-based vector rotation circuits. It operates on fixed-width hardware signals (`comb`) and composite `t` values representing circuit interfaces, supporting transformations like multiplexing, concatenation, priority selection, and pipeline registration. These capabilities are specifically used in FPGA or ASIC design flows to implement high-throughput vector rotation logic with precise control over signal routing, naming, and timing constraints.",
      "description_length": 547,
      "index": 123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to construct and manipulate fixed-width bit vector representations of CORDIC-based cosine and sine function interfaces. It supports constant initialization, packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations with optional validity signals. These functions are used to implement digital circuits for computing trigonometric functions in hardware description workflows.",
      "description_length": 445,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides signal manipulation and wiring operations for constructing CORDIC multiplier circuits, including constant assignment, multiplexing, concatenation, and signal naming. It works with hardware signals represented as `Hardcaml.Signal.t` values, organized into interfaces with combinational and registered logic. These functions are used to define and validate signal connections, manage pipeline stages, and enforce naming conventions in hardware designs.",
      "description_length": 471,
      "index": 125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a structured type and an association list indexed by field names, enabling named access to fields. It operates on tuples or records within the CORDIC implementation, specifically for rectangular-to-polar coordinate transformations. Use this to dynamically inspect or construct CORDIC interface values using field names as keys.",
      "description_length": 375,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for converting rectangular coordinates to polar coordinates using a CORDIC algorithm implemented with bit-level combinational logic. It supports construction of fixed-point CORDIC inputs from integers, packing/unpacking of signal interfaces, multiplexing, concatenation, and validation of bit widths. Concrete use cases include implementing digital signal processing pipelines and FPGA-based arithmetic accelerators where precise control over bit-level representations is required.",
      "description_length": 513,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a CORDIC multiplier interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use cases include constructing and managing hardware description logic for CORDIC-based multiplication circuits with named, configurable signals.",
      "description_length": 385,
      "index": 128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a product of monadic values into a monadic product, specifically for CORDIC multiplication interfaces. It operates on data types structured as `Mul.Cordic.I.t` containing values within a monad `M`. A concrete use case is combining multiple monadic CORDIC multiplication signals into a single signal of combined values, enabling sequential computation over a fixed interface.",
      "description_length": 428,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC rotation interfaces using the Always API. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include building and connecting CORDIC rotation circuits within always blocks, such as implementing vector rotation logic in hardware descriptions.",
      "description_length": 394,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps the fields of a CORDIC polar-to-rectangular interface to and from association lists, using field names as keys. It operates on the `Polar_to_rect.Cordic.I.t` type, converting its structure into a list of string-value pairs and vice versa. This enables easy serialization and dynamic construction of CORDIC interfaces based on named fields.",
      "description_length": 365,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module offers operations for constructing and manipulating signal interfaces in CORDIC circuits, including bit-width management, structural composition, pipeline creation, and signal wiring. It works with `t` values representing hardware signals, enabling tasks like constant assignment, multiplexing, concatenation, and named signal connection (`<==`) for hierarchical design. Specific use cases include building rotation interfaces, managing signal hierarchies, and generating named input/output wires in hardware descriptions.",
      "description_length": 534,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record of values, specifically for the CORDIC cosine and sine interface. It works with the `Cos_sin.Cordic.O.t` type parameterized over a monad `M`. A concrete use case is collecting results from multiple CORDIC computations that are wrapped in a monadic context, such as hardware description monads in Hardcaml.",
      "description_length": 408,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides structural manipulation of hardware signals through operations like packing, multiplexing, concatenation, and pipeline creation, alongside utilities for connecting and naming signal wires. It operates on `Hardcaml.Signal.t` values, enabling precise control over register interfaces and hierarchical signal routing. These capabilities are particularly useful for constructing and validating hardware circuits, managing component interconnections, and enforcing naming conventions during FPGA or ASIC design.",
      "description_length": 527,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe access to fields of a CORDIC multiplier interface using string keys, bypassing type-safe accessors. It supports operations to convert the interface into an association list of field names and values, and to reconstruct the interface from such a list. This is useful when dynamically handling CORDIC multiplier signals, such as during simulation setup or debugging, where field names are known but type-level guarantees are not required.",
      "description_length": 472,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational logic operations for a CORDIC-based cosine/sine interface, supporting value construction, signal packing/unpacking, multiplexing, and selection. It works with bit vector types (`comb`) and structured interfaces containing width-checked fields. Concrete uses include building fixed-angle trigonometric signal generators and validating hardware signal widths during design synthesis.",
      "description_length": 418,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe association list conversions for CORDIC atanh interface values, enabling mapping between field names and values. It operates on tuples of type `'a Atanh.Cordic.I.t` and string-indexed lists of pairs. Use this when building or inspecting CORDIC atanh interfaces from dynamic or untyped field representations, such as during configuration parsing or debugging.",
      "description_length": 394,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for the input interface of a CORDIC-based atanh function implementation. It specifies the signal names and their bit-widths as well as associated tags for identification. Used to configure and connect the input signals of the atanh CORDIC circuit in hardware descriptions.",
      "description_length": 314,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Args.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to construct and manipulate fixed-width bitvector representations of input arguments for a CORDIC-based hyperbolic arctangent (`atanh`) computation. It supports operations such as packing/unpacking interface fields into bit vectors, multiplexing between multiple argument sets, and selecting values based on priority or one-hot encoding. These functions are used to interface with hardware circuits that compute `atanh` using the CORDIC algorithm, ensuring correct signal widths and formatting.",
      "description_length": 525,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based arctangent circuit, specifying signal names and bit widths for inputs and outputs. It works with lists of string-integer pairs to describe hardware ports and includes tags for identifying circuit components. Concrete use cases include configuring hardware description code generation and connecting circuit modules in a type-safe way.",
      "description_length": 395,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width signal interfaces representing arctangent values in a CORDIC implementation. It supports packing/unpacking signals to/from bit vectors, multiplexing, concatenation, and selection operations with optional branching factors. Concrete use cases include constructing and validating hardware circuits for angle computation pipelines, where precise bit-level control and signal routing are required.",
      "description_length": 474,
      "index": 141,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based arctangent circuit implementation. It specifies signal names and bit-widths for inputs, outputs, and internal signals used in the arctangent computation. These definitions support hardware generation and simulation by providing structural metadata for the circuit.",
      "description_length": 325,
      "index": 142,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a rectangular-to-polar conversion interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use cases include building and managing stateful logic for CORDIC-based rectangular-to-polar conversion circuits.",
      "description_length": 367,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module handles bit-level conversions and manipulations for polar-to-rectangular coordinate transformation inputs. It provides functions to pack, unpack, mux, and concatenate signal interfaces, along with validation and width inspection utilities. Use cases include constructing and validating hardware signals for CORDIC-based coordinate conversion circuits.",
      "description_length": 363,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides low-level signal manipulation and register management operations for constructing CORDIC-based multiplier circuits. It works with `Hardcaml.Signal.t` values and structured interfaces (`Mul.O.Of_signal.t`) to implement RTL features like pipelining, wire creation, and register assignment, alongside utility functions for signal naming, input/output generation, and hierarchical composition. These capabilities are used to build and optimize digital circuits requiring precise control over dataflow and timing, such as arithmetic accelerators or signal processing pipelines.",
      "description_length": 593,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Args.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for CORDIC-based cosine and sine function implementations. It specifies the input and output signal names and their bit-widths required for hardware synthesis. Use this module to configure the interface of a CORDIC core computing trigonometric functions.",
      "description_length": 303,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Args.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between `Atanh.Args.t` records and association lists, using field names as keys. It enables working with `Atanh.Args.t` in a format suitable for dynamic access or serialization, such as mapping to and from key-value pairs. Use this when interfacing with systems that require named field access or when flattening structured data for configuration or debugging.",
      "description_length": 400,
      "index": 147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bit vector interfaces specialized for multiplier circuits. It supports concrete operations like packing/unpacking bit vectors, multiplexing, concatenation, and selection logic with validity signals for hardware description. Use cases include implementing control logic for data paths, signal routing, and interface validation in digital circuit designs.",
      "description_length": 431,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating a structured interface with fields specific to hyperbolic cosine and sine function inputs. It supports constant initialization, packing/unpacking to vectors, multiplexing, concatenation, and selection operations with optional branching factors. Concrete use cases include building and validating fixed-width signal interfaces for CORDIC-based hyperbolic function circuits in hardware descriptions.",
      "description_length": 466,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unchecked conversions between a structured interface type `'a Atan2.I.t` and association lists indexed by field names, using string keys. It enables working with heterogeneous data representations commonly needed in hardware description contexts, such as mapping signal names to values. These operations are used when building or inspecting CORDIC-based circuits that require precise control over input/output port mappings.",
      "description_length": 453,
      "index": 150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.O.All",
      "library": "hardcaml_circuits",
      "description": "Lifts monadic values through an interface, transforming a record of monadic values into a monadic record. Works with any monad `M` and records of type `Atanh.O.t`. Useful for handling collections of computations that must be executed in a monadic context, such as hardware description computations in Hardcaml.",
      "description_length": 310,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an `Always` block, specifically for a `Div.O` interface type. It supports creating registers, wires, and named signal assignments, enabling structured hardware description for division operations. Use cases include implementing division logic in hardware designs using CORDIC algorithms with clear signal management.",
      "description_length": 387,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Results.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to CORDIC rotation result interfaces using the Always API. It supports creating registers, wires, and named signals for structured hardware description. Concrete use cases include building and connecting CORDIC rotation circuits in a signal processing pipeline.",
      "description_length": 324,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps the input and output ports of CORDIC cosine and sine circuits to and from association lists, using field names as keys. It operates on `Cos_sin.O.t` values, which represent the interface of a CORDIC circuit computing sine and cosine. Use this module when wiring CORDIC circuits to hierarchical modules or testbenches that require named signal connections.",
      "description_length": 381,
      "index": 154,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Results.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe access to fields of a CORDIC arctangent result interface using string keys. It supports converting structured results to and from association lists where each key corresponds to a specific output port name. This allows dynamic inspection or manipulation of CORDIC computation outputs by name, such as extracting intermediate values or injecting test data.",
      "description_length": 391,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Results.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width integer multiplication results, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions. It works with bit vector types represented by the `comb` module parameter and structured data of type `t` containing multiple result fields. Concrete use cases include building arithmetic pipelines, routing data between functional units, and handling result signals in hardware description workflows.",
      "description_length": 507,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for a CORDIC-based division circuit. It provides concrete signal identifiers and bit-width specifications required for hardware synthesis. Use this module to configure or inspect the interface of a division operation within a CORDIC pipeline.",
      "description_length": 291,
      "index": 157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that lifts monadic values through a record structure, transforming a record of monadic values into a monadic record. It operates on types that conform to the `Rotate_vector.I.t` signature, where each field is wrapped in the monad `M`. A concrete use case is combining multiple signal wires in a CORDIC rotation circuit into a single monadic structure for parallel processing.",
      "description_length": 413,
      "index": 158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Results.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for structural manipulation of fixed-width signal interfaces representing CORDIC rotation results, including packing/unpacking, multiplexing, concatenation, pipeline register creation, and signal wiring. It works with `t` values containing combinational signals (`comb`) and structured signal interfaces, enforcing width validation and naming conventions during hardware description assembly. These functions are used to implement and integrate CORDIC-based vector rotation logic into hardware compilation flows, enabling precise control over signal connectivity and structural transformations.",
      "description_length": 626,
      "index": 159,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based hyperbolic cosine and sine circuit. It specifies the input and output signal names along with their bit widths, used directly in hardware generation and simulation. The data structures include lists of string-name and integer-width pairs, alongside a list of tags for input selection.",
      "description_length": 345,
      "index": 160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This implementation provides operations for manipulating `comb` signals and structured `t` interfaces through constant assignment, multiplexing, concatenation, and priority/onehot selection, alongside functions to assign signals, generate input/output wires, and apply naming conventions. It targets use cases involving control logic synthesis, bus-level signal routing, and register pipeline construction in hardware modules implementing division via CORDIC algorithms.",
      "description_length": 470,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that takes a list of monadic values within a specific interface structure and combines them into a single monadic value containing the list of results. It operates on data structured as `'a M.t Div.I.t`, where `M` is a monad and `Div.I` represents an interface type. A concrete use case is aggregating multiple asynchronous or effectful computations into a unified result while preserving the interface structure.",
      "description_length": 451,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.O",
      "library": "hardcaml_circuits",
      "description": "This module provides functions for structural manipulation of CORDIC interface values used in rectangular-to-polar coordinate transformations, including n-ary mapping, zipping, folding, and conversions between association lists and typed records. It operates on tuples or records containing combinational logic signals, monadic values, and metadata such as port names and bit-widths. These utilities enable hardware-oriented dataflow pipelines, signal processing chains, and configurable CORDIC circuit generation via dynamic field access and Always API-driven signal management.",
      "description_length": 579,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an `Always` block, specifically for a `Mul.O` interface. It supports creating registers, wires, and named signal assignments, easing integration with hardware description workflows. Concrete use cases include building pipelined multipliers and managing signal propagation in CORDIC-based designs.",
      "description_length": 367,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module implements specialized CORDIC-based operations for computing arctangent functions over bit vectors. It provides combinational logic for packing, unpacking, multiplexing, and validating bit-widths of input/output signals, specifically tailored for hardware circuits. Concrete use cases include implementing fixed-point `atan2` calculations and managing signal routing in digital designs.",
      "description_length": 398,
      "index": 165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based inverse hyperbolic tangent (`atanh`) computations using fixed-width bit vectors. Works with `Bits.t` signals and structured interfaces for input/output ports. Useful for hardware acceleration of mathematical functions in digital signal processing or scientific computing pipelines.",
      "description_length": 305,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to construct and manipulate fixed-point cosine and sine signal interfaces using bit vectors. It supports constant initialization, packing/unpacking signals to/from bit vectors, multiplexing, concatenation, and selection operations with validity signals. These functions are used to implement CORDIC-based trigonometric computations in hardware descriptions.",
      "description_length": 389,
      "index": 167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module suite enables efficient manipulation of rectangular-to-polar conversion interfaces in hardware circuits, focusing on signal-level operations like packing/unpacking, multiplexing, concatenation, and pipeline construction. It operates on `Rect_to_polar.O.Of_signal.comb` types representing combinational signals, while providing utilities to wire, name, and validate signal interfaces with configurable prefixes/suffixes. These tools are particularly useful in CORDIC-based designs for tasks like phase and magnitude computation, where structured signal management and hierarchical interface naming are critical for maintainable, large-scale circuit integration.",
      "description_length": 672,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Results.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe access to fields of a CORDIC `atan2` result interface using string keys. It supports converting structured results to and from association lists where each key is a field name and the value is the corresponding result. Use this when dynamically inspecting or reconstructing CORDIC results by port name, such as in simulation or debugging tools.",
      "description_length": 380,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Results.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the names and widths of output ports for a CORDIC-based `atan2` circuit, providing direct access to signal identifiers and their bit-widths. It works with lists of strings and integers to represent port metadata, alongside a list of tags for result categorization. Concrete use cases include configuring hardware signal interfaces and validating expected output dimensions in digital design workflows.",
      "description_length": 421,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.O",
      "library": "hardcaml_circuits",
      "description": "This module implements structural transformations and configuration-driven construction of hardware signal interfaces for CORDIC-based hyperbolic function circuits. It supports operations like mapping, zipping, and converting between structured signal representations (`t`) composed of fixed-width bit vectors, while providing metadata access for port names and widths. These capabilities enable tasks such as synthesizing combinational logic, wiring register stages via the Always API, and generating testbenches with precise signal annotations.",
      "description_length": 546,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Results.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for converting and manipulating rectangular-to-polar coordinate results in CORDIC implementations. It supports data types including packed vectors and structured interfaces with typed fields, enabling operations like packing/unpacking, multiplexing, concatenation, and selection. Concrete use cases include building control logic for coordinate transformations, validating signal widths in hardware pipelines, and constructing constant or dynamic polar coordinate outputs from rectangular inputs.",
      "description_length": 548,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports operations on `Div.I.t` structures containing `Always.Variable.t` and `Signal.t` types, enabling creation of registers, wires, and named signal assignments. Concrete use cases include building and connecting interface components in digital circuit descriptions, such as initializing wires to zero or registering interface fields with enable signals.",
      "description_length": 481,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Args.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bitvector representations of hyperbolic cosine and sine function arguments in a CORDIC-based pipeline. It supports concrete operations such as packing/unpacking argument interfaces to/from bit vectors, multiplexing and concatenating argument values, and validating bit widths. Use cases include configuring CORDIC hardware blocks with precise bit-level control and building arithmetic circuits that require compile-time width checks and constant initialization.",
      "description_length": 539,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Args.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module handles fixed-width bit vector representations of input arguments for a CORDIC-based arctangent function. It provides operations to construct, validate, pack, unpack, and multiplex these argument interfaces, ensuring correct signal widths for hardware synthesis. Concrete use cases include assembling input signals for angle computation circuits and validating bit-width consistency in digital signal processing pipelines.",
      "description_length": 434,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Results.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides bit-level operations for converting between rectangular and polar coordinates, specifically handling signal packing, unpacking, multiplexing, and validation. It works with `Bits.t` types organized in a structured interface representing CORDIC computation results. Use this module to implement hardware circuits that require coordinate transformations with precise bit-width control and signal routing.",
      "description_length": 422,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Args.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate `Rect_to_polar.Args` interfaces using the Always API, including variable assignment, register and wire creation, and signal naming. It operates on `Always.Variable.t` and `Signal.t` types wrapped in the `Rect_to_polar.Args` interface. Concrete use cases include building and wiring up CORDIC-based rectangular-to-polar conversion circuits within always blocks.",
      "description_length": 405,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for implementing CORDIC-based hyperbolic cosine and sine functions in hardware circuits. It works with strings, integers, and tag types to specify interface parameters for circuit generation. Concrete use cases include configuring signal widths and identifiers in FPGA or ASIC designs that require hyperbolic function computation.",
      "description_length": 379,
      "index": 178,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Args.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structure of monadic values into a monadic structure of values, specifically for the `Atan2.Args` type. It works with monadic types `M` and values of type `'a M.t Atan2.Args.t`, lifting the monad outside the `Atan2.Args` structure. A concrete use case is aggregating multiple monadic computations over `Atan2.Args` fields into a single monadic result, enabling sequential composition of effects within that interface.",
      "description_length": 473,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational logic operations for an arctangent (atan) interface within a CORDIC circuit. It provides functions to construct, validate, and manipulate fixed-width signal interfaces, including packing/unpacking, multiplexing, concatenation, and selection operations. Concrete use cases include building and verifying hardware circuits for atan computations with specific bit-width constraints.",
      "description_length": 416,
      "index": 180,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Results.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "Converts between structured results of rectangular-to-polar conversions and association lists indexed by field names. Works directly with lists of string-value pairs and the `Rect_to_polar.Results.t` type. Useful for serializing or deserializing result data when interfacing with external systems or debugging signal outputs.",
      "description_length": 325,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for a division circuit implemented using the CORDIC algorithm. It specifies the interface of the division circuit, including input and output signal names and their bit widths. This information is used to generate hardware descriptions and connect the division circuit to other components in a design.",
      "description_length": 350,
      "index": 182,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Args.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between `Cos_sin.Args.t` records and association lists indexed by field names. It supports operations to_alist and of_alist for mapping record fields to named values and vice versa. Use this when interfacing with systems that require named signal access, such as simulation environments or configuration interfaces.",
      "description_length": 355,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Args.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating polar-to-rectangular conversion interfaces. It supports signal validation, packing/unpacking, multiplexing, concatenation, and selection operations on `t` values. These operations are used to construct and verify digital circuits for CORDIC-based polar-to-rectangular conversions.",
      "description_length": 349,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Results.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that sequences monadic actions across a structured collection of values, specifically transforming a monad-wrapped record into a record-wrapped monad. It operates on data types that conform to the `Atan2.Results.t` signature, which represents the outputs of an ATAN2 computation. A concrete use case is collecting and processing results from multiple concurrent ATAN2 calculations within a monadic context, such as signal processing pipelines or hardware simulation workflows.",
      "description_length": 514,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a rectangular-to-polar interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use cases include building and managing stateful logic for CORDIC-based rectangular-to-polar conversions.",
      "description_length": 348,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Results.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the result structure for CORDIC-based cosine and sine computations, specifying port names and their bit-widths as a list of string-integer pairs. It provides direct access to the output signal names, their widths, and associated tags for result interpretation. Use this module when instantiating or analyzing CORDIC circuits that compute trigonometric functions to map and handle their output ports programmatically.",
      "description_length": 436,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module supports operations for constructing and manipulating fixed-width signal interfaces tailored for CORDIC multiplier circuits, including signal packing, multiplexing, concatenation, and pipeline registration. It works with structured interface types that wrap `Hardcaml.Signal.t` values, ensuring strict bit-width correctness and enabling hardware synthesis. Key use cases include wiring signal connections, defining input/output ports, and applying hierarchical naming conventions to signals during the design of pipelined CORDIC-based multiplication circuits.",
      "description_length": 571,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational logic operations for manipulating fixed-width signal interfaces representing hyperbolic cosine and sine function outputs. It provides functions for packing/unpacking signals to vectors, multiplexing, concatenation, and priority/onehot selection with valid signals, along with validation and width inspection utilities. Concrete use cases include building control logic for selecting between multiple CORDIC-generated hyperbolic function results and constructing constant signal interfaces for simulation or initialization.",
      "description_length": 559,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. It works with `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` types within a `Mul.I.t` interface structure. Use this when building or modifying digital circuits with structured interfaces in an always block, such as connecting multiplier inputs or naming internal signals for debugging.",
      "description_length": 549,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Results.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width signal interfaces representing CORDIC arctangent results. It supports packing/unpacking to bit vectors, multiplexing, concatenation, and selection operations with optional branching factors. Concrete use cases include building control logic for routing or selecting between multiple CORDIC output streams in hardware pipelines.",
      "description_length": 408,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.I",
      "library": "hardcaml_circuits",
      "description": "This module provides structural transformations and signal manipulation utilities for CORDIC-based division interfaces, enabling operations like mapping, zipping, folding, and conversion to association lists. It works with typed interface values (`'a Div.Cordic.I.t`), signals, ports, and bit vectors, emphasizing bit-level control and stateful logic synthesis. Key use cases include constructing combinational logic, managing hardware interface declarations, and implementing division circuits with precise port naming and width definitions.",
      "description_length": 542,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module supports constructing and manipulating fixed-width signal interfaces for rectangular-to-polar conversion in hardware circuits. It operates on structured interfaces composed of `Hardcaml.Signal.t` values, providing operations like signal packing/unpacking, multiplexing, concatenation, pipeline registration, and connectivity validation, alongside utilities for wiring and hierarchical signal naming. These capabilities are specifically applied in CORDIC-based trigonometric function implementations for FPGA/ASIC designs requiring precise angle and magnitude computations.",
      "description_length": 584,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Args.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that combines monadic values within a specific argument structure, lifting the monad outside the interface. It operates on data types involving monads and argument tuples, specifically structured for CORDIC-based arctangent computations. A concrete use case is aggregating multiple monadic results into a single monadic structure while preserving the argument layout required for downstream processing.",
      "description_length": 440,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Args.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides structural transformations and signal interface manipulations for rectangular-to-polar conversion circuits, operating on `comb` and `t` types representing hardware signal bundles. It supports operations like packing/unpacking, multiplexing, concatenation, and pipeline register creation, alongside wiring primitives for connecting and naming signal interfaces. These capabilities enable efficient implementation of CORDIC-based arithmetic pipelines where structured signal routing and type-safe interface transformations are critical.",
      "description_length": 555,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the input port names and their bit-widths for a CORDIC-based arctangent circuit. It works with string and integer data types to specify signal names and widths, and provides a list of tags associated with the input ports. It is used to configure the interface of a CORDIC arctangent computation circuit in hardware design.",
      "description_length": 342,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based arctangent (`atan2`) circuit implementation. It specifies the input and output signal names along with their bit-widths, tailored for the `atan2` function's interface. These definitions are used directly in constructing the circuit's hardware description with precise signal sizing and naming conventions.",
      "description_length": 366,
      "index": 197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Args.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "Converts between record values and association lists indexed by field names, enabling direct mapping of record fields to named values in a list. Works with polymorphic record types and string-keyed association lists. Useful for serializing or dynamically accessing record fields by name without runtime type information.",
      "description_length": 320,
      "index": 198,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a structured interface and an association list indexed by field names, enabling easy mapping of interface fields to named values. It operates on the `Atanh.I.t` type, which represents the input interface for a CORDIC-based inverse hyperbolic tangent function. Use this to dynamically construct or inspect interfaces using string-labeled data, such as when integrating with external data formats or debugging signal values.",
      "description_length": 470,
      "index": 199,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module supports signal manipulation and interface wiring operations for CORDIC-based division circuits, focusing on tasks like concatenation, multiplexing, pipelining, and hierarchical signal naming. It operates on `Hardcaml.Signal.t` values and structured interface types (`Div.I.Of_signal.t`) to manage input/output port connections, width validation, and register instantiation. These capabilities are specifically applied in FPGA/ASIC hardware description workflows to model and simulate division operations within digital circuits.",
      "description_length": 541,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Args.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating `Atan2.Args` interfaces, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with bit vector types (`comb`) and structured interfaces containing integer fields. Concrete use cases include building hardware circuits for coordinate transformations and validating signal widths in CORDIC-based designs.",
      "description_length": 433,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an Always block for a cosine/sine interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use cases include building and managing hardware descriptions for CORDIC-based cosine/sine circuits with clear signal assignments and naming.",
      "description_length": 375,
      "index": 202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Results.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module supports constructing and managing signal interfaces for CORDIC-based hyperbolic cosine/sine computations, focusing on combinational logic (packing/unpacking, multiplexing, concatenation) and sequential pipeline stages via register insertion. It operates on structured signal interfaces (`t`) built from `Hardcaml.Signal.t`, enabling hardware description tasks like input/output wiring, signal naming, and interface connectivity. Key use cases include RTL-level design of arithmetic pipelines and structured signal manipulation in FPGA/ASIC synthesis flows.",
      "description_length": 569,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to convert rectangular coordinates to polar coordinates using CORDIC algorithms, working with fixed-width bit vectors. It supports construction from integers, packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations with validity signals. Use this module to implement coordinate transformations in hardware circuits where precise control over bit widths and combinational logic is required.",
      "description_length": 462,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Results.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the result structure for a multiplier circuit, specifying the names and widths of output ports along with associated tags. It provides direct access to lists of port names, their corresponding bit widths, and a list of tags that identify result types. Concrete use cases include configuring and interpreting the outputs of a CORDIC-based multiplier circuit in hardware description workflows.",
      "description_length": 411,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module implements CORDIC-based hyperbolic cosine and sine operations using bit-level combinational logic. It provides functions to construct, manipulate, and validate fixed-width signal interfaces for these operations, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection primitives. Concrete use cases include implementing and composing digital circuits for hyperbolic function evaluation in hardware description and verification workflows.",
      "description_length": 485,
      "index": 206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based cosine and sine circuit implementation. It provides concrete signal identifiers and their bit-widths, such as \"angle\" and \"cos_out\", along with their respective integer widths. These values are used directly in circuit construction and simulation to ensure correct signal routing and precision.",
      "description_length": 355,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Results.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational and sequential signal-level operations for manipulating CORDIC cosine/sine results, including constant assignment, packing/unpacking, multiplexing, and pipeline registration. It operates on structured signal vectors validated for bit-width correctness, enabling hardware synthesis with Hardcaml. These capabilities are used to implement register pipelines and interface wiring for trigonometric function circuits in synchronous digital designs.",
      "description_length": 479,
      "index": 208,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Results.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bit vector representations of inverse hyperbolic tangent function results. It supports constant initialization, packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations with valid signals. These functions are used to implement digital circuits that process or generate atanh results in hardware description contexts.",
      "description_length": 434,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides signal-level combinational and sequential logic operations for polar-to-rectangular coordinate conversion in CORDIC implementations. It operates on `Hardcaml.Signal.t` values and structured interfaces (`Polar_to_rect.I.Of_signal.t`), supporting tasks like packing/unpacking, multiplexing, register control, and signal concatenation. These operations are used to wire and name input/output signals in hardware description flows, enabling structured interface management with features like prefix/suffix-based signal naming and register-aware connectivity.",
      "description_length": 575,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that lifts monadic values through a vector rotation interface, transforming a vector of monadic rotation values into a monadic vector of rotation values. It operates on data structures produced by the `Rotate_vector.O` module, which represent vector rotations in a CORDIC implementation. A concrete use case is combining multiple concurrent CORDIC rotation computations into a single monadic result, enabling structured control flow over vector operations in hardware description code.",
      "description_length": 523,
      "index": 211,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bitvector interfaces for division circuits. It supports constant initialization, packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations with validity signals. These functions are used to build and verify hardware circuits for division in a CORDIC-based pipeline.",
      "description_length": 382,
      "index": 212,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module enables manipulation of fixed-width signal interfaces through operations like constant assignment, multiplexing, concatenation, and structural validation, while providing utilities for wiring and naming signals with prefix/suffix conventions. It works with hardware signal types and interface structures, focusing on precise bit-level control and hierarchical organization. These capabilities are particularly useful in synthesizing complex arithmetic circuits like CORDIC-based hyperbolic function implementations where signal integrity and naming clarity are critical.",
      "description_length": 582,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Results.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that combines monadic values within a specific result structure, effectively lifting the monad outside the result type. It operates on data types involving monads and result structures defined by the `Cosh_sinh.Results` module. A concrete use case is aggregating multiple monadic computations that produce results of type `Cosh_sinh.Results.t`, allowing for sequential composition and handling of effects in a structured way.",
      "description_length": 463,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Args.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for the inputs and outputs of a CORDIC-based arctangent function. It works with string and integer data types to specify signal names and their bit widths in hardware descriptions. Concrete use cases include configuring the interface of a hardware circuit that computes the angle from the origin to a point (x, y) in fixed-point arithmetic.",
      "description_length": 382,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Results.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module handles bit-level manipulation and routing of CORDIC atan2 computation results. It provides operations for packing/unpacking, multiplexing, and validating bit-widths of CORDIC output signals. Concrete use cases include constructing hardware multiplexers for CORDIC pipelines and verifying signal integrity in fixed-point arithmetic circuits.",
      "description_length": 353,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.O.All",
      "library": "hardcaml_circuits",
      "description": "Lifts monadic values through a division operator structure, allowing monadic effects to be composed within the division interface. Works with monadic types that support applicative or monad operations. Useful for sequencing computations that involve division while preserving the monadic context, such as handling errors or state during arithmetic operations.",
      "description_length": 359,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a vector rotation interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use cases include constructing and managing hardware descriptions for vector rotation logic in a CORDIC implementation.",
      "description_length": 357,
      "index": 218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Args.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating signal interfaces representing division arguments in hardware circuits, focusing on tasks like packing/unpacking, multiplexing, concatenation, and register pipelining. It operates on `Div.Args.Of_signal.t` structures composed of `Hardcaml.Signal.t` values, enabling precise control over signal routing and synchronization. These utilities are used to implement division logic within CORDIC-based hardware designs, where signal interface validation and hierarchical naming conventions ensure correctness in complex pipelines.",
      "description_length": 590,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width signal interfaces representing arctangent outputs. It supports packing/unpacking signals to vectors, multiplexing, concatenation, and priority/one-hot selection with valid signals. These operations are used to build digital circuits that process angle data from CORDIC computations.",
      "description_length": 363,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Args.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal values within an `Always` block for a multiplier interface. It supports creating register and wire variables, assigning signals to variables, extracting signal values, and applying naming conventions to interface fields. Concrete use cases include building and wiring multiplier circuits with named signals, enabling simulation and synthesis workflows in hardware design.",
      "description_length": 434,
      "index": 221,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides signal interface manipulation capabilities for CORDIC rotation circuits, including vector packing/unpacking, multiplexing, concatenation, and priority/onehot selection operations. It works with structured hardware signal interfaces (`t`) and `comb` signals, enabling precise width handling and RTL naming/registration during circuit construction. Specific use cases include building and validating signal routing logic for vector rotation implementations, where proper interface alignment and signal provenance tracking are critical.",
      "description_length": 554,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Args.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an `Always` block, specifically for a `Div.Args` interface. It supports creating registers, wires, and named signal assignments, enabling structured hardware description for division operations. Use cases include building synchronous logic and testbenches where signal interfaces need to be dynamically assigned or named.",
      "description_length": 392,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps fields of a CORDIC atanh interface to and from association lists, using port names as keys. It operates on tuples and lists of signals paired with string identifiers. Use this to serialize or deserialize CORDIC atanh circuit interfaces for debugging or configuration purposes.",
      "description_length": 302,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Args.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for creating and manipulating fixed-width signal interfaces for multipliers, including packing/unpacking, multiplexing, concatenation, and register pipeline construction. It works with combinatorial signal structures (`Hardcaml.Signal.t`) and named interface types (`Mul.Args.Of_signal.t`) to manage hardware signal wiring and hierarchical naming. These capabilities are particularly useful in hardware implementations requiring precise signal routing and structured naming conventions, such as CORDIC-based arithmetic pipelines or register-transfer level designs.",
      "description_length": 596,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Args.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating a structured interface of type `Cosh_sinh.Args.t`, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions. It works directly with bit-width validated signal interfaces, supporting operations like constant assignment, width validation, and conditional signal routing. Concrete use cases include building and validating fixed-point control paths and data routing logic for CORDIC-based hyperbolic function implementations.",
      "description_length": 527,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structure containing monadic values into a monadic structure of the same shape, specifically for the `Atanh.I.t` interface. It works with data types involving monads (`M.t`) and fixed-width signal interfaces (`Atanh.I.t`). A concrete use case is combining multiple monadic computations over hardware signals into a single monadic value, enabling sequential composition in hardware description workflows.",
      "description_length": 459,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Args.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to construct and manipulate fixed-width bit vector interfaces for polar-to-rectangular coordinate conversion. It supports packing/unpacking, multiplexing, concatenation, and selection operations on `t` values, which represent structured combinations of bit vectors. Concrete use cases include building configurable CORDIC pipelines with explicit signal widths and validating interface consistency in hardware descriptions.",
      "description_length": 454,
      "index": 228,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Args.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bitvector representations of CORDIC arctangent function arguments. It supports data types involving packed bit vectors and structured argument interfaces, enabling direct hardware synthesis. Key functions include packing/unpacking, multiplexing, concatenation, and selection operations tailored for digital circuit design tasks like FPGA implementation.",
      "description_length": 431,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Args.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for the CORDIC arctangent function implementation. It specifies signal names and bit-widths for inputs, outputs, and internal tags used in the circuit. This allows direct mapping of signals in hardware description and simulation contexts.",
      "description_length": 280,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a polar-to-rectangular interface. It supports creating register and wire variables, assigning values, and applying naming conventions to interface fields. Use cases include building and managing CORDIC polar-to-rectangular conversion circuits with named, configurable signal interfaces.",
      "description_length": 377,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an Always block for a specific interface type. It supports creating register and wire variables, assigning values, and applying naming conventions to interface fields. Concrete use cases include building and managing hardware description logic for CORDIC-based atanh functions with clear signal assignments and naming.",
      "description_length": 389,
      "index": 232,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based arctangent computations using fixed-point bit representations. It provides operations to construct, manipulate, and validate fixed-width signal interfaces for CORDIC iterations, including packing/unpacking, multiplexing, and selection functions tailored for hardware description. This module is used to synthesize arctangent circuits in Hardcaml by mapping mathematical operations directly to bit-level combinational logic.",
      "description_length": 447,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Results.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to manipulate fixed-width bit vector representations of cosine and sine results in a CORDIC implementation. It supports construction from integers, packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations with support for one-hot and priority-encoded control signals. These functions are used to build and verify digital circuits that process or generate cosine and sine values as part of hardware-accelerated mathematical computations.",
      "description_length": 508,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Results.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal values within an Always block for cosine and sine result interfaces. It supports operations like extracting signal values, assigning to variables, creating registers or wires, and applying naming conventions to signals. These functions are used when implementing or simulating CORDIC-based cosine and sine computation circuits.",
      "description_length": 390,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to manipulate fixed-width bit vector interfaces for CORDIC rotation circuits, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection functions. It works with types representing bit vectors and their structured interfaces, ensuring correct signal widths during synthesis. Concrete use cases include building control logic for vector rotation circuits and managing signal routing in hardware descriptions.",
      "description_length": 472,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Args.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for implementing CORDIC-based cosh and sinh functions in hardware circuits. It specifies the interface for signal inputs and outputs, including their bit widths, to support fixed-point arithmetic operations. Concrete use cases include configuring circuit ports for cosh/sinh computation blocks in FPGA or ASIC designs.",
      "description_length": 367,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Results.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the names and widths of ports for a CORDIC vector rotation circuit, providing direct access to signal identifiers and their bit-widths. It works with lists of string-width pairs, strings, integers, and predefined CORDIC result tags. Concrete use cases include configuring hardware signal interfaces and validating expected output ports in a CORDIC-based rotation implementation.",
      "description_length": 398,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides structural composition and signal routing capabilities for CORDIC-based trigonometric circuits, including combinational logic, pipelining, and hierarchical naming operations. It operates on field-structured signal interfaces composed of `Hardcaml.Signal.t` values, supporting transformations like width adjustment, multiplexing, and register insertion. These utilities are specifically used to implement high-throughput sine/cosine pipelines and dynamically reconfigurable CORDIC architectures in FPGA or ASIC designs.",
      "description_length": 539,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Results.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe access to fields of an `Atanh.Results.t` interface using port names as keys. It supports operations to convert structured results into string-indexed association lists and reconstruct them from such lists. Use this when interfacing with external systems that require named field access or when dynamically manipulating signal values by name.",
      "description_length": 377,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Results.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal values within an always block for a CORDIC-based hyperbolic cosine and sine result interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signals. Use this when implementing or testing CORDIC circuits that compute cosh and sinh, particularly in simulation or synthesis contexts.",
      "description_length": 400,
      "index": 241,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides signal manipulation and interface wiring operations for implementing hyperbolic arctangent functions in CORDIC hardware pipelines. It operates on structured signal bundles (`Hardcaml.Signal.t`) conforming to the `Atanh.O` interface, offering combinational logic primitives (multiplexing, concatenation) and sequential elements (registers) alongside port management utilities. These capabilities enable constructing testbenches, connecting pipeline stages, and annotating signal hierarchies with custom naming for improved hardware debuggability.",
      "description_length": 566,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational and sequential operations for implementing polar-to-rectangular coordinate conversion using CORDIC algorithms, including signal wiring, register pipeline construction, and bit-width management. It operates on structured hardware signal types (`Hardcaml.Signal.t` and `Polar_to_rect.O.Of_signal.t`) to enable RTL-level transformations and module interconnects. The functionality is particularly useful in FPGA/ASIC pipelines requiring precise trigonometric computations, such as digital signal processing or coordinate transformations in embedded systems.",
      "description_length": 589,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Results.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module handles bit-level manipulation and routing of polar-to-rectangular conversion results in CORDIC implementations. It provides operations for packing/unpacking, multiplexing, concatenation, and selection of fixed-width bit vectors representing CORDIC outputs. Concrete use cases include constructing and validating bit-level interfaces for hardware circuits that process polar coordinates, ensuring correct signal widths and routing logic in digital designs.",
      "description_length": 468,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.I",
      "library": "hardcaml_circuits",
      "description": "This module provides functional operations for manipulating structured hardware interfaces (`'a t`) representing CORDIC-based `atan2` circuits, including mapping, zipping, folding, and conversions to association lists or signal lists. It works with typed field-based interface descriptions, signals, and fixed-width ports, enabling tasks like packing/unpacking signal data, monadic sequencing of hardware effects, and generating register/wire connections in RTL design. Specific use cases include transforming input/output interfaces for CORDIC pipelines, defining port mappings with static bit-widths, and managing signal relationships within always blocks or combinatorial logic.",
      "description_length": 681,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly associates fields of a `Cos_sin.I.t` interface with values by port name using unsafe operations. It provides `to_alist` and `of_alist` functions to convert between the interface and a list of key-value pairs, where keys are field names and values correspond to port values. Use this when mapping interface signals to and from named port representations, such as during simulation or interface introspection.",
      "description_length": 428,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Args.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to construct and manipulate interfaces for converting rectangular coordinates to polar coordinates using bit vectors. It supports operations like packing/unpacking fields into vectors, multiplexing, concatenation, and selection with customizable branching factors. Concrete use cases include implementing CORDIC-based coordinate transformations in hardware circuits, where precise bit-level control and signal routing are required.",
      "description_length": 462,
      "index": 247,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Results.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that combines monadic values across a structured interface, specifically transforming a monad-containing interface into an interface-containing monad. It operates on data types that conform to the `Atan.Results.t` structure with embedded monadic values. A concrete use case is aggregating multiple monadic computations over a fixed interface shape into a single monadic result preserving that structure.",
      "description_length": 441,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unchecked conversions between a structured type and an association list indexed by field names, using port names as keys. It operates on values of type `'a Atan2.O.t` and pairs them with strings in a list-based dictionary structure. These functions are useful for low-level interface manipulation, such as when generating or parsing hardware descriptions where field access must be dynamic but performance is critical.",
      "description_length": 447,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a rotate vector interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use cases include constructing and managing hardware descriptions for CORDIC rotation logic with named, zero-initialized wires or registers.",
      "description_length": 376,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating `Atan2` input interfaces in a CORDIC implementation. It supports signal packing/unpacking, multiplexing, concatenation, and selection operations, working directly with bit vectors and valid signals. Concrete use cases include building control paths for angle computation, routing data between pipeline stages, and assembling test stimuli for hardware verification.",
      "description_length": 450,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.O",
      "library": "hardcaml_circuits",
      "description": "This module provides structured manipulation of CORDIC-based cosine/sine interfaces through operations like mapping, zipping, and conversion to/from lists and association lists, working with typed records that encapsulate signal values, port metadata (names, widths), and combinators for circuit transformations. It supports combinational logic, monadic traversal (via `All` and `or_error_all`), and bit-level manipulation (`Of_bits`) alongside signal wiring (`Of_signal`), enabling use cases such as circuit construction, register management (`Of_always`), and synthesis configuration (`Names_and_widths`) for trigonometric function implementations in hardware design.",
      "description_length": 669,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Args.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module offers operations for constructing and managing signal interfaces for a CORDIC-based arctangent module, focusing on tasks like signal packing/unpacking, multiplexing, concatenation, and pipeline insertion. It works with a structured collection of signals with defined bit widths, enabling precise connectivity control via operators like `<==`, interface creation, and hierarchical signal naming. These capabilities are critical in hardware design for implementing and verifying specialized arithmetic circuits in digital systems.",
      "description_length": 541,
      "index": 253,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Results.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating polar-to-rectangular conversion results. It supports data types involving packed vectors and structured interfaces with fields for angle, magnitude, and valid signals. Concrete use cases include multiplexing, concatenation, and validation of polar-to-rectangular conversion outputs in hardware description contexts.",
      "description_length": 384,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an Always block for a cosine-sine interface. It supports creating register and wire variables, assigning values to them, and applying naming conventions. It is used to implement and wire up CORDIC-based cosine and sine computations in a hardware description context.",
      "description_length": 337,
      "index": 255,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Results.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal interfaces within an `Always` block context. It supports creating register and wire variables, assigning values to variable interfaces, and applying naming conventions to signals. Concrete use cases include building and managing hardware description logic for CORDIC-based `Atanh` function implementations.",
      "description_length": 369,
      "index": 256,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Args.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides functions for constructing and manipulating signal interfaces in hardware circuits, including packing/unpacking, multiplexing, concatenation, and pipeline/register instantiation. It operates on `comb` and `t` types representing hardware signals and their structured interfaces. These operations are used to wire and name signal connections, validate interface consistency, and build input/output structures for CORDIC-based vector rotation implementations in digital design workflows.",
      "description_length": 505,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Results.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for manipulating fixed-width signal interfaces representing division results, including structural transformations like packing/unpacking, multiplexing, concatenation, and pipeline register creation. It operates on `Div.Results.Of_signal.t` interfaces composed of `Hardcaml.Signal.t` values, enabling value assignment, signal routing, and hierarchical name management with customizable prefixes/suffixes. These capabilities are specifically used in hardware description workflows to implement and optimize division operations within CORDIC-based circuits.",
      "description_length": 587,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.O",
      "library": "hardcaml_circuits",
      "description": "This module provides structural transformations and serialization for CORDIC hyperbolic arctangent interfaces, operating on `'a Atanh.Cordic.O.t` records that encapsulate port metadata like names, widths, and tags. It supports combinational logic and fixed-point signal manipulation via combinators (`map`, `fold`, `zip`) and utilities for packing/unpacking, list conversion, and monadic aggregation. These capabilities facilitate RTL design of circuits implementing the hyperbolic arctangent function using CORDIC algorithms, particularly for hardware signal processing pipelines.",
      "description_length": 581,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Results.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational and sequential signal manipulation capabilities for CORDIC-based arctangent calculations, operating on signal structures representing hardware connections. It enables tasks like pipeline stage insertion, multiplexer generation, and bit-width validated concatenation of signals, with explicit support for RTL-level wiring, interface creation, and signal naming conventions. These operations are specifically applied to implement hardware circuits requiring precise angular computation and data path management.",
      "description_length": 544,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Results.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal values within an always block for the `Atan2.Results` interface. It supports creating registers, wires, and named signals, and includes operations to assign and extract values from variable containers. Concrete use cases include implementing logic for atan2 result signals in hardware description code, such as initializing registers with `reg`, connecting signals with `assign`, or creating named wires with default values using `wire`.",
      "description_length": 500,
      "index": 261,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Args.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an Always block for a vector rotation interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use it to implement and manage stateful logic for vector rotation in hardware descriptions.",
      "description_length": 329,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Results.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal interfaces within an `Always` block, specifically for division result types. It supports creating register and wire variables, assigning values, and applying naming conventions to signals. Use it to implement and manage division operations in CORDIC circuits with clear signal handling.",
      "description_length": 349,
      "index": 263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Results.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and managing signal interfaces representing results of hyperbolic arctangent (`atanh`) computations via CORDIC algorithms. It works with `Hardcaml.Signal.t` values and structured `Atanh.Results.Of_signal.t` interfaces to enable packing/unpacking, multiplexing, concatenation, register pipelining, and naming conventions. These capabilities are used to wire computation outputs into larger circuits, validate signal integrity, and maintain readable hardware descriptions through consistent naming.",
      "description_length": 545,
      "index": 264,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Args.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe conversions between `Div.Args.t` and association lists indexed by field names. It operates on values of type `'a Div.Args.t` and `(string * 'a) list`. Use this module to inspect or construct division argument interfaces by explicitly mapping field names to values, for example when generating debug representations or interfacing with external configurations.",
      "description_length": 395,
      "index": 265,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Args.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a specific interface type. It supports creating register and wire variables, assigning values, and applying naming conventions to interface fields. Use cases include building and managing hardware description logic for CORDIC-based arctangent computations with clear signal assignments and naming.",
      "description_length": 388,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Args.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating CORDIC cosine/sine function interfaces. It supports packing/unpacking of signal interfaces into vectors, multiplexing, concatenation, and selection operations with optional branching factors. Concrete use cases include building hardware circuits for trigonometric computations and managing signal routing in digital designs.",
      "description_length": 410,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Results.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the names and widths of output ports for CORDIC-based cosh and sinh function implementations. It provides concrete identifiers and bit-widths for result signals, ensuring correct interface configuration in hardware descriptions. Useful for generating signal declarations or verifying output dimensions in a CORDIC pipeline.",
      "description_length": 343,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations (multiplexing, concatenation, packing/unpacking) and sequential circuit constructs (registers, pipelines) for manipulating composite signal types representing CORDIC cosine/sine interfaces. It specifically handles hierarchical signal wiring, interface connection, and name assignment for the `Cos_sin.I.Of_signal.t` type structure in hardware synthesis contexts. These operations enable the construction of pipelined CORDIC circuits for trigonometric function computation while maintaining signal hierarchy integrity.",
      "description_length": 569,
      "index": 269,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based cosine and sine circuit interface. It provides concrete signal identifiers and their bit-widths, along with a list of tags associated with the interface. These values are used to specify input/output connections when instantiating or wiring the circuit in a hardware description.",
      "description_length": 340,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module supports combinational logic operations on `comb` signals and `t` interface types, including bit-level manipulation, signal assignment, and hierarchical naming. It enables hardware description tasks such as vector rotation, signal validation, and structured wiring through functions like concatenation, multiplexing, and custom signal labeling. These capabilities are specifically applied in CORDIC-based circuits for tasks like coordinate transformation and iterative function computation.",
      "description_length": 502,
      "index": 271,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Results.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module handles bit-level manipulation and routing of division result signals in a CORDIC-based circuit. It provides operations for packing, unpacking, multiplexing, and concatenating these signals, as well as validating their bit widths. Concrete uses include constructing and verifying constant division result interfaces and routing multiple division outputs through control logic.",
      "description_length": 388,
      "index": 272,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Args.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for handling fixed-width signal interfaces used in CORDIC-based atanh function implementations. It supports packing/unpacking of signal vectors, multiplexing, concatenation, and selection operations with validation of bit widths. Concrete use cases include constructing and manipulating hardware signals for atanh computation pipelines.",
      "description_length": 388,
      "index": 273,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic.I",
      "library": "hardcaml_circuits",
      "description": "Supports structural manipulation and transformation of typed CORDIC interfaces through operations like mapping, zipping, folding, and conversion to association lists, alongside bit-level signal processing for combinational logic and pipelined designs. Works with structured interface values (`t`) that encapsulate port names, bit widths, and tags, enabling precise type- and width-enforced hardware descriptions. Used to implement arctangent computations in CORDIC pipelines, facilitating tasks like signal routing, interface alignment, and RTL metadata generation for simulation and synthesis.",
      "description_length": 594,
      "index": 274,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an Always block for a specific interface type. It supports creating register and wire variables, assigning signal values, and applying naming conventions to interface fields. These operations are used to implement and integrate CORDIC-based atanh functionality in a hardware description context.",
      "description_length": 366,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Args.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that takes a record of monadic values and returns a monadic record of values, effectively flipping the structure of the input. It operates on data types that conform to the `Div.Args.t` signature, which represents a specific record-like structure. A concrete use case is combining multiple monadic computations into a single monadic result when working with CORDIC-based division arguments.",
      "description_length": 428,
      "index": 276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Args.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a polar-to-rectangular interface containing monadic values into a monadic interface of a polar-to-rectangular value. It operates on data structures of type `'a M.t Polar_to_rect.Args.t`, lifting the monad `M` to wrap the entire interface rather than individual fields. A concrete use case is aggregating multiple monadic computations over polar coordinates into a single monadic result, such as collecting simulation signals or hardware descriptions into a unified context.",
      "description_length": 527,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an Always block for a polar-to-rectangular conversion interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use cases include building and managing CORDIC-based polar-to-rectangular conversion circuits with clear signal handling and naming.",
      "description_length": 386,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Results.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that combines a record of monadic values into a monadic record, effectively lifting the monad outside the record structure. It operates on data types that conform to the `Div.Results.t` signature, wrapping each field in a monadic context. A concrete use case is aggregating multiple signal computations in a circuit description, where each field represents a signal and the monad captures circuit construction effects.",
      "description_length": 456,
      "index": 279,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to manipulate fixed-width bit vector interfaces for CORDIC rotation circuits, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection functions. It works with `comb` type bit vectors and structured `t` type interfaces containing multiple bit vector fields. Concrete use cases include building control logic for vector rotation circuits, validating signal widths, and constructing constant or dynamic inputs for hardware simulation and synthesis.",
      "description_length": 513,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width bit vectors in a CORDIC-based arctangent computation context. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection primitives such as priority and one-hot selects. These functions are used to construct and manipulate hardware circuits where each field has a defined bit width, typically in dataflow pipelines or signal routing logic.",
      "description_length": 482,
      "index": 281,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Args.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides utilities for constructing and manipulating signal interfaces representing cosine/sine arguments in CORDIC-based hardware designs. It operates on `Cos_sin.Args.Of_signal.t` structures, offering operations like signal packing/unpacking, multiplexing, concatenation, register insertion, and width validation, alongside input/output connection and naming conventions. These tools are used in hardware description workflows to implement trigonometric function pipelines with structured signal management.",
      "description_length": 521,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Results.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an Always block for a polar-to-rectangular conversion result interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use cases include building and managing hardware descriptions for CORDIC polar-to-rectangular conversion outputs in a structured and readable way.",
      "description_length": 407,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating a structured interface representing cosine and sine values. It supports construction from integers, packing/unpacking to bit vectors, multiplexing, concatenation, and selection operations with optional branching factors. Concrete use cases include building and validating fixed-width signal interfaces for CORDIC-based trigonometric computations in hardware descriptions.",
      "description_length": 440,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Results.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module defines operations for manipulating fixed-width combinatorial signals representing the results of an inverse hyperbolic tangent (atanh) computation. It supports packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations with optional branching factors. Concrete use cases include building control logic for selecting between multiple atanh result signals and converting constant values into appropriately typed signals.",
      "description_length": 469,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Results.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe conversions between a `Rotate_vector.Results.t` record and an association list mapping field names to values. It supports operations to_alist and of_alist, enabling dynamic access to result fields by string keys. Use this when interfacing with systems that require named field lookups or serialization formats that rely on key-value pairs.",
      "description_length": 375,
      "index": 286,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC rotation vector interface, specifying signal identifiers and their bit widths. It works with lists of strings and integers to describe hardware interface properties. Concrete use cases include configuring CORDIC hardware blocks for vector rotation in FPGA designs.",
      "description_length": 319,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Args.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a record type and an association list, using field names as keys. It operates on `Cosh_sinh.Args.t` records and string-keyed lists of values. Use this to dynamically inspect or construct argument values by field name, such as for serialization or configuration purposes.",
      "description_length": 318,
      "index": 288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unchecked conversions between a structured interface type and association lists keyed by field names, enabling efficient serialization and deserialization of CORDIC atan input data. It operates specifically on `Atan.I.t` values and string-indexed lists of arbitrary values. Use this to interface CORDIC logic with external data representations, such as parsing input configurations or generating labeled signal mappings.",
      "description_length": 449,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structure of monadic values into a monadic structure of values, specifically for the `Cosh_sinh.I.t` type. It works with data types involving monads (`M.t`) and CORDIC-based hyperbolic cosine and sine input interfaces. A concrete use case is aggregating multiple monadic computations over CORDIC hyperbolic function inputs into a single monadic result, enabling sequential execution of dependent hardware description logic.",
      "description_length": 479,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to manipulate fixed-width vector interfaces for CORDIC rotation logic, including packing/unpacking to vectors, multiplexing, concatenation, and priority/one-hot selection. It works with types involving `comb` signals wrapped in a `Rotate_vector.O.t` interface, ensuring correct bit widths via validation and width inspection functions. Concrete use cases include building control logic for vector rotation circuits, selecting between multiple vector inputs based on control signals, and assembling/disassembling vector data for signal processing pipelines.",
      "description_length": 588,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Args.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for the inverse hyperbolic tangent (atanh) function implementation using CORDIC. It specifies the input and output signal names along with their bit-widths, used in hardware description for circuit generation. The data includes lists of strings and integers for port configuration, and associated tags for signal identification.",
      "description_length": 370,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Results.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that takes a record of monadic values and returns a monadic record of values, effectively flipping the structure. It operates on the `Rect_to_polar.Results.t` type, which contains the results of converting rectangular coordinates to polar form. A concrete use case is combining multiple monadic computations, such as hardware signals or deferred values, into a single structure for further processing in a CORDIC-based circuit.",
      "description_length": 465,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for an `Atan2.I.t` interface, specifically using `Always.Variable.t` types. It supports creating register and wire variables, assigning values, and applying naming conventions to interface fields. Use cases include implementing CORDIC-based `atan2` logic with structured signal assignments and named variable declarations in hardware description code.",
      "description_length": 438,
      "index": 294,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a structured type and an association list, where each field is mapped to a named string key. It works with tuples or records containing hyperbolic cosine and sine values, represented as a keyed list of pairs. Use this to serialize or deserialize CORDIC-generated results for debugging, logging, or external interface mapping.",
      "description_length": 373,
      "index": 295,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Args.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating structured signal interfaces used in implementing CORDIC-based hyperbolic arctangent (`atanh`) computations. It works with the `Atanh.Args.Of_signal.t` type, representing hardware signal interfaces, and supports tasks like signal packing/unpacking, multiplexing, pipeline generation, and register creation. These capabilities are particularly useful for synthesizing synchronized mathematical functions in FPGA or ASIC designs where precise control over signal routing and timing is required.",
      "description_length": 558,
      "index": 296,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width bit vectors in a CORDIC-based division circuit. It supports construction and deconstruction of bit vectors via packing, unpacking, and concatenation, along with selection mechanisms like multiplexing and priority/onehot selection. Concrete use cases include building control logic for dividers and managing signal routing in bit-level arithmetic pipelines.",
      "description_length": 437,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and associated tags for a multiplier circuit implementation. It provides concrete signal identifiers and bit-width specifications required for hardware synthesis and simulation. Use cases include connecting multiplier components in CORDIC pipelines and generating register-transfer level (RTL) descriptions with correct signal dimensions.",
      "description_length": 378,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Args.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively sequencing the effects of each field. It operates on the `Rect_to_polar.Args.t` record structure, lifting monadic computations from individual fields to the entire record. A concrete use case is collecting and sequencing hardware description computations across multiple signal inputs in a CORDIC-based circuit design.",
      "description_length": 434,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Results.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the result structure for converting rectangular coordinates to polar form using the CORDIC algorithm. It specifies the names and widths of output ports, such as magnitude and angle, along with associated tags for identification. It is used to configure and generate hardware interfaces for CORDIC-based polar conversion circuits.",
      "description_length": 349,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Args.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a specific interface type. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use this when implementing or testing CORDIC-based hyperbolic arctangent logic with structured signal interfaces.",
      "description_length": 349,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "Implements combinational logic operations for an inverse hyperbolic tangent (atanh) function interface using a parameterized combinatorial module. It supports signal packing/unpacking, constant assignment, multiplexing, concatenation, and selection operations on atanh function inputs and outputs. This module is used to construct and manipulate fixed-width signal interfaces for atanh function evaluation in digital circuits.",
      "description_length": 426,
      "index": 302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Results.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that takes a record of monadic values and returns a monadic record of values, effectively flipping the structure of monads within a multiplication results interface. It operates on data types that conform to the `Mul.Results.t` signature, which represents multiplication results in a structured form. A concrete use case is combining multiple monadic computations of multiplication results into a single monadic value, enabling sequential composition of operations that depend on those results.",
      "description_length": 532,
      "index": 303,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for converting polar coordinates to rectangular coordinates, including packing/unpacking interfaces into vectors, multiplexing, concatenation, and selection functions. It works with fixed-width signal types represented by the `comb` parameter and structured as `Polar_to_rect.O.t` records containing `x` and `y` components. Concrete use cases include implementing coordinate transformations in digital signal processing pipelines and FPGA-based math accelerators where precise control over bit widths and combinational logic is required.",
      "description_length": 589,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Args.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module handles bit-level manipulation and routing of multiplier argument interfaces, providing operations like packing, unpacking, multiplexing, and concatenation. It works with fixed-width bit vectors and structured interfaces composed of these vectors. Concrete use cases include assembling and disassembling multiplier inputs for hardware circuits, selecting between multiple input configurations using priority or one-hot encoders, and validating signal widths during design elaboration.",
      "description_length": 496,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Results.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate fixed-width bitvector representations of rotation results in CORDIC computations. It supports operations like packing/unpacking bitvectors, multiplexing, concatenation, and selection, with validation of bit widths and construction from integer values. Use cases include implementing hardware circuits for coordinate rotation and vector magnitude calculation using CORDIC algorithms.",
      "description_length": 427,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module enables structural wiring and transformation of fixed-point signal interfaces for CORDIC-based `atan2` computation, offering combinational logic for multiplexing, concatenation, and register insertion alongside sequential pipeline control. It operates on `Atan2.I.Of_signal.t` values\u2014representing hardware signal bundles with defined bit widths\u2014and supports naming, validation, and interface derivation through assertion-driven constraints. Its utilities are specifically applied in FPGA/ASIC workflows to construct validated, clock-cycle-accurate hardware pipelines for trigonometric angle calculations.",
      "description_length": 616,
      "index": 307,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a product of monadic values into a monad over a product, effectively sequencing monadic actions across a structure. It operates on data types that are instances of a monad and a product type. A concrete use case is combining multiple monadic computations within a structured data type, such as collecting results of effectful operations in a consistent shape.",
      "description_length": 413,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a product type and an association list, using field names as keys. It operates on types that follow the `Mul.I.t` signature, which represents hardware circuit interfaces. These functions enable easy serialization and deserialization of interface values for debugging or configuration purposes.",
      "description_length": 341,
      "index": 309,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic.I",
      "library": "hardcaml_circuits",
      "description": "This module provides structured manipulation of CORDIC-based multiplier interfaces through operations like mapping, zipping, and conversion between interface structures and lists or association lists. It works with typed representations of port names, bit-width specifications, and signal values (`'a t`), enabling precise wiring and transformation of hardware signals in combinational logic. Specific use cases include constructing bit vector arithmetic pipelines, dynamically configuring register or wire assignments in always blocks, and handling unsafe runtime access to interface ports during circuit synthesis.",
      "description_length": 616,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps fields of a `Rotate_vector.O.t` interface to and from an association list of string-keyed values. It enables converting structured hardware signal data to and from a list representation, where each field name corresponds to a signal. This is particularly useful for serialization, debugging, or dynamic configuration of hardware interfaces based on named signals.",
      "description_length": 389,
      "index": 311,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Results.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe access to fields of a CORDIC result interface using string keys, bypassing type safety. It works with association lists mapping string names to values of arbitrary type `'a`, and is used to construct or deconstruct CORDIC result structures by field name. Concrete use cases include dynamic field access when interfacing with external systems or generating testbenches where field names are known but type-level guarantees are not required.",
      "description_length": 475,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Results.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for transforming and managing structured signal data, including packing, unpacking, multiplexing, and register control, alongside interface utilities for connecting, naming, and wiring signals. It operates on typed interfaces composed of `Hardcaml.Signal.t` values with fixed field widths, specifically tailored for handling polar-to-rectangular conversion results in CORDIC implementations. These capabilities are used in hardware design to integrate polar-coordinate computations into digital circuits, ensuring precise signal handling and traceable interface management.",
      "description_length": 605,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "Implements hyperbolic cosine and sine functions using CORDIC iteration on fixed-point bit vectors. Works with `Bits.t` signals arranged in a structured interface containing `cosh` and `sinh` fields. Directly used to compute `cosh(x)` and `sinh(x)` in digital signal processing pipelines where fixed-point arithmetic is required.",
      "description_length": 328,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Args.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module defines operations for constructing and manipulating fixed-width signal interfaces used in CORDIC-based arctangent computations. It provides utilities for packing/unpacking signals, multiplexing, concatenation, and selection logic with support for validity signals. The module works with a combinatorial signal type `comb` and structured interfaces containing integer constants or signals of specified bit widths.",
      "description_length": 425,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Args.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal interfaces within an `Always` block, specifically for CORDIC cosine and sine argument types. It supports creating register and wire variables, assigning values to these variables, and applying naming conventions to signal fields. Use cases include constructing and managing hardware signal interfaces with structured naming and initialization when implementing CORDIC-based trigonometric circuits.",
      "description_length": 460,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "Converts records to and from association lists indexed by field names, enabling direct mapping between structured data and named value pairs. Works with polymorphic record types and string-keyed lists. Useful for serializing or deserializing interface values using field names as keys, such as in configuration parsing or signal routing.",
      "description_length": 337,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to convert rectangular coordinates to polar coordinates using CORDIC algorithms, operating on fixed-width bit vectors. It supports operations like packing/unpacking interfaces into vectors, multiplexing, concatenation, and selection with priority or one-hot encoding. Use cases include hardware implementations of coordinate transformations, signal processing, and control systems requiring polar representation from Cartesian inputs.",
      "description_length": 465,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Results.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe conversions between `Cos_sin.Results.t` values and association lists indexed by field names. It supports operations `to_alist` and `of_alist` for serializing and deserializing result data using string keys corresponding to port names. This is useful when interfacing with external systems that require named field access, such as configuration files or dynamic test frameworks.",
      "description_length": 413,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Results.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unchecked access to fields of a CORDIC polar-to-rectangular conversion result by port name using association lists. It supports operations to convert structured results to and from string-indexed key-value pairs, enabling dynamic field lookup and injection without runtime safety checks. This is useful when interfacing with external systems or generating dynamic test vectors for simulation and verification.",
      "description_length": 438,
      "index": 320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Results.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the names and widths of output ports for a CORDIC arctangent circuit, providing direct access to port metadata as lists of strings, integers, and associated tags. It works with basic list and integer types to specify hardware interface details. Concrete use cases include configuring signal widths and identifiers in hardware description code for synthesis or simulation.",
      "description_length": 391,
      "index": 321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Results.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational logic operations for manipulating CORDIC atan2 result interfaces. It provides functions to pack, unpack, multiplex, and validate signal widths, along with utilities for constant initialization and concatenation. These operations support hardware construction tasks such as signal routing, data path selection, and interface validation in digital circuit design.",
      "description_length": 398,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Args.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating CORDIC rotation vector interfaces using combinational logic. It supports packing/unpacking of signal interfaces to/from bit vectors, multiplexing and selection between multiple interfaces, and validation of signal widths. Concrete use cases include building control logic for vector rotation circuits, managing multiplexed data paths, and ensuring signal integrity in fixed-point CORDIC implementations.",
      "description_length": 469,
      "index": 323,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structure of monadic values into a monadic structure of values, specifically for the `Atan2.I.t` type. It works with data types involving monads (`M.t`) and CORDIC input interfaces (`Atan2.I.t`). A concrete use case is combining multiple monadic computations over CORDIC inputs into a single monadic result, enabling sequential execution of dependent operations.",
      "description_length": 418,
      "index": 324,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Results.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module handles bit-level representations of arctangent results in a CORDIC implementation. It provides operations to pack, unpack, multiplex, and validate bit vectors, ensuring correct widths and enabling selection logic like priority or onehot. Use cases include constructing and manipulating fixed-point arctangent outputs in hardware description contexts.",
      "description_length": 363,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Results.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating division result interfaces in a CORDIC-based circuit. It supports packing/unpacking of signals to vectors, multiplexing, concatenation, and selection operations with optional branching factors. Concrete use cases include constructing and validating division result signals in hardware description workflows.",
      "description_length": 376,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Args.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational and sequential signal manipulation operations for CORDIC-based hyperbolic function implementations, including packing/unpacking, multiplexing, concatenation, and register control. It operates on structured signal interfaces (`Cosh_sinh.Args.Of_signal.t`) with utilities for wiring, naming, and validating signal widths. These capabilities are used to construct and manage hardware circuits that compute sinh and cosh functions while ensuring proper signal connectivity and debuggable naming conventions.",
      "description_length": 538,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "Converts polar coordinates to rectangular coordinates using CORDIC rotation. Works with input records containing magnitude and angle fields. Directly used for signal processing tasks like converting frequency domain representations to time domain waveforms.",
      "description_length": 257,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic.O",
      "library": "hardcaml_circuits",
      "description": "This module enables the manipulation of structured hardware interfaces representing CORDIC-based `atan2` computations through operations like mapping, zipping, and conversion to association lists. It operates on interface values that encapsulate hardware ports with metadata such as names, widths, and tags, while supporting combinational logic synthesis and signal-level transformations. Its utilities are tailored for FPGA/ASIC implementation tasks, including port configuration, signal assignment in always blocks, and bitvector-level circuit construction.",
      "description_length": 559,
      "index": 329,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for manipulating fixed-width combinatorial signals representing vector rotation interfaces. It supports construction from integers, packing/unpacking to bit vectors, multiplexing, concatenation, and selection operations with support for validity signals. These functions are used to build hardware circuits for vector rotation logic in CORDIC implementations.",
      "description_length": 391,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a specific interface type. It supports creating register and wire variables, assigning values, and applying naming conventions to interface fields. Use cases include building and managing hardware description logic for CORDIC-based designs with clear signal assignments and naming.",
      "description_length": 372,
      "index": 331,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Args.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width integer multiplier interfaces in a hardware description context. It supports data types involving packed bit vectors and structured interfaces with fields of specified bit widths. Key use cases include packing/unpacking interfaces to/from bit vectors, multiplexing between multiple interfaces, validating signal widths, and creating constant-valued interfaces for hardware simulation or synthesis.",
      "description_length": 475,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Results.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the names and widths of output ports for the CORDIC implementation of the hyperbolic arctangent (`atanh`) function. It provides concrete identifiers and bit-widths used in the hardware description of the `atanh` result signals. These values are used during circuit generation to ensure correct signal naming and sizing in the resulting RTL.",
      "description_length": 360,
      "index": 333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic.I",
      "library": "hardcaml_circuits",
      "description": "This module supports functional transformations\u2014such as mapping, zipping, folding, and scanning\u2014over CORDIC-based cosine/sine interfaces, alongside hardware-specific operations like bit packing, signal manipulation, and monadic sequencing. It operates on fixed-point trigonometric data structures, enabling precise configuration of digital circuits for sine/cosine computation, synthesis-time signal connection management, and bit-width optimization in register-transfer-level designs. Use cases include implementing pipelined CORDIC cores, integrating with hardware description workflows via Always blocks, and generating synthesizable RTL for FPGA or ASIC targets.",
      "description_length": 666,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a CORDIC-based cosine/sine computation interface with monadic values into a monadic interface containing CORDIC results. It operates on data structures representing CORDIC computations for trigonometric functions, specifically cosine and sine. A concrete use case is aggregating multiple monadic CORDIC results into a single computation for hardware description in Hardcaml.",
      "description_length": 428,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that lifts monadic values through a rect-to-polar interface, transforming a structure containing monadic fields into a monadic structure of rect-to-polar values. It operates specifically on types that conform to the `Rect_to_polar.I.t` signature with monadic field values. A concrete use case is combining multiple monadic computations that produce rect-to-polar components into a single monadic value representing the full interface.",
      "description_length": 472,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Args.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that combines monadic values within a specific argument structure, lifting the monad outside the interface. It operates on data types involving a monad `M` and argument structures of type `Cosh_sinh.Args.t`. A concrete use case is aggregating multiple monadic computations over hyperbolic cosine and sine function arguments into a single monadic result.",
      "description_length": 391,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Args.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines argument configurations for converting rectangular coordinates to polar form in a CORDIC implementation. It specifies port names and widths as lists of string-integer pairs, and includes tags for identifying inputs and outputs. It is used to generate hardware circuits that compute magnitude and phase from Cartesian coordinates.",
      "description_length": 349,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structure containing monadic values into a monadic structure of the same shape, specifically for the CORDIC implementation of arctangent (`Atan.I.t`). It works with data types that conform to the `Atan.I.t` interface and are wrapped in a monad `M`. A concrete use case is combining multiple monadic CORDIC arctangent computations into a single monadic value for sequential execution.",
      "description_length": 439,
      "index": 339,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for a multiplier circuit interface. It provides concrete signal identifiers and their bit-widths required for implementing CORDIC-specialized multiplication operations. Use this module to standardize signal naming and sizing when integrating multiplier circuits into hardware descriptions.",
      "description_length": 338,
      "index": 340,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating CORDIC-derived cosine and sine data structures, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions. It works with fixed-width bit vector types represented by the `comb` parameter and structured as `Cos_sin.O.t` records. Concrete use cases include building hardware circuits for trigonometric function evaluation, signal routing, and bit-level manipulation of CORDIC outputs in FPGA or ASIC designs.",
      "description_length": 509,
      "index": 341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic.I",
      "library": "hardcaml_circuits",
      "description": "This module supports structural transformations of typed CORDIC interface values through mapping, zipping, folding, and scanning operations, along with conversion between bitvector and interface list representations. It operates on fixed-width signal interfaces (`Hardcaml.Signal.t`) and tagged data structures, enabling precise control over combinational logic and pipelining in FPGA-targeted inverse hyperbolic tangent circuits, while also facilitating configuration via port name and bit-width definitions.",
      "description_length": 509,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Results.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the result signals for a CORDIC-based division circuit, specifying the names and bit widths of output ports. It provides concrete identifiers and widths for signals like quotient and remainder, enabling direct integration with hardware description generators. Use this to map simulation outputs to hardware signals or verify signal widths in testbenches.",
      "description_length": 374,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Args.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively sequencing the effects of each field. It operates on the `Rotate_vector.Args` record structure, lifting monadic computations from individual fields to the entire record. A concrete use case is collecting results from multiple concurrent hardware description computations into a single structured result.",
      "description_length": 419,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Args.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bitvector representations of CORDIC rotation arguments. It supports packing/unpacking of vector interfaces, multiplexing and selection between multiple argument sets, and validation of signal widths. Concrete use cases include implementing hardware circuits for coordinate rotation and vector magnitude calculations using CORDIC algorithms.",
      "description_length": 418,
      "index": 345,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Results.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating CORDIC-generated hyperbolic cosine and sine results. It supports data types composed of signal interfaces with specified bit widths, enabling operations like packing/unpacking, multiplexing, concatenation, and selection. Concrete use cases include building hardware circuits that require precise control over signal routing and transformation in digital signal processing or mathematical function evaluation.",
      "description_length": 477,
      "index": 346,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a monadic polar-to-rectangular conversion into a monad containing the conversion result. It operates on values of type `'a M.t Polar_to_rect.O.t`, where `M` is a monad, lifting the monadic structure outside the polar-to-rectangular interface. A concrete use case is combining multiple monadic signals in hardware description code, where each signal represents a polar coordinate input to be converted into rectangular form within a monadic context.",
      "description_length": 502,
      "index": 347,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Args.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bit vector representations of division function arguments. It supports creating constants from integers, packing/unpacking signals into vectors, multiplexing and concatenating argument interfaces, and selecting between values using priority or one-hot encoding. These operations are used to build and validate digital circuit interfaces for division logic in hardware designs.",
      "description_length": 454,
      "index": 348,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Results.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for packing, unpacking, multiplexing, and validating fixed-width signal interfaces representing cosine and sine results. It works with bit vectors and structured interfaces containing integer-valued fields of defined widths. Concrete uses include assembling and disassembling signal buses, selecting between multiple result channels, and ensuring signal width consistency in hardware descriptions.",
      "description_length": 449,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Args.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for converting polar coordinates to rectangular coordinates in a CORDIC implementation. It specifies the interface for signals used in the coordinate transformation, such as angle and magnitude inputs and the resulting x and y outputs. Concrete use cases include configuring hardware circuits for trigonometric computations in FPGA-based signal processing.",
      "description_length": 405,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating polar-to-rectangular coordinate conversion interfaces. It supports signal packing, unpacking, multiplexing, concatenation, and selection operations tailored to fixed-width bitvector signals. Concrete use cases include building control logic for coordinate conversion circuits and assembling complex signal routing structures in digital signal processing pipelines.",
      "description_length": 433,
      "index": 351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width signal interfaces, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with `comb Atanh.I.t` interfaces, which represent hardware signals with specific bit widths. Concrete use cases include constructing and validating signal routing logic in digital circuits, such as selecting between multiple input signals or converting structured interfaces to flat bit vectors.",
      "description_length": 487,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational and sequential operations for structured signal interfaces, including wiring, multiplexing, concatenation, and pipeline instantiation, while enforcing width correctness. It operates on typed interface bundles (`t`) composed of `Hardcaml.Signal.t` values, with specialized support for CORDIC `atan2` circuitry through named signal connections and hierarchical interface manipulation. These capabilities enable implementing pipelined, type-safe hardware pipelines for trigonometric computations where signal naming and structural transformations are critical for RTL clarity and synthesis.",
      "description_length": 622,
      "index": 353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unchecked conversions between a structured interface type and an association list, using field names as keys. It operates on values of type `'a Div.I.t` and string-keyed lists of pairs. These functions are useful for debugging or dynamic manipulation of interface fields, where type safety is ensured externally.",
      "description_length": 341,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Args.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module handles the construction and manipulation of division argument interfaces for a CORDIC-based circuit implementation. It provides functions to pack, unpack, multiplex, and validate signal widths, as well as create constant and one-hot selected inputs. Use cases include configuring division operations in hardware circuits and managing signal routing in CORDIC pipelines.",
      "description_length": 382,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC vector rotation circuit, specifying signal names and bit-widths for inputs and outputs. It works with lists of string-integer pairs to describe hardware ports and lists of tags to identify signals. It is used to configure and generate correct signal interfaces for CORDIC-based vector rotation hardware.",
      "description_length": 358,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Args.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an Always block for a CORDIC-based cosh/sinh interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use cases include constructing and managing hardware descriptions for CORDIC computations with named, configurable signal interfaces.",
      "description_length": 378,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module implements CORDIC-based cosine and sine function evaluation using fixed-point arithmetic on bit vectors. It provides operations for constructing, validating, and manipulating `t` values, which represent the interface signals for CORDIC computations, including functions like packing/unpacking, multiplexing, and concatenation. Concrete use cases include hardware synthesis of trigonometric functions for digital signal processing and FPGA-based numerical computations.",
      "description_length": 480,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an Always block for a CORDIC-based cosh/sinh interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use cases include implementing hardware logic for hyperbolic function computations using the Always API.",
      "description_length": 349,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that takes a product of monadic values and returns a monad wrapping a product of the original values, effectively sequencing monadic actions across a product structure. It operates on data types that conform to the `Mul.I.t` product interface with monadic elements parameterized by `M`. A concrete use case is combining multiple monadic hardware description computations into a single monadic block while preserving their structured layout.",
      "description_length": 478,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bitvector interfaces for inverse hyperbolic tangent (atanh) computations using CORDIC algorithms. It supports data types representing bit-level signals (`comb`) and structured interfaces (`t`) with functions for packing, unpacking, multiplexing, and validating signal widths. Concrete use cases include implementing digital circuits for atanh function approximation in hardware description and verification workflows.",
      "description_length": 495,
      "index": 361,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating an interface with bit vector fields, including packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection functions like priority and one-hot encoding. It works directly with types involving `Hardcaml.Bits.t` and structured interfaces defined by `Atan2.I.t`. Concrete use cases include building and validating fixed-width signal interfaces, selecting between multiple signal sources, and converting constant integer values into appropriately sized bit vectors for hardware synthesis.",
      "description_length": 579,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a specific interface type. It supports creating registers, wires, and naming signals with optional prefixes or suffixes. Concrete use cases include building and connecting CORDIC-based arctangent circuits in a hardware description context.",
      "description_length": 330,
      "index": 363,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Args.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for configuring a multiplier circuit in a CORDIC implementation. It works with lists of strings and integers to specify signal names and bit widths, along with a list of tags for additional metadata. It is used to configure hardware ports when generating or simulating digital circuits involving multiplication.",
      "description_length": 360,
      "index": 364,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.O.All",
      "library": "hardcaml_circuits",
      "description": "Lifts monadic values through an Atan2 interface, transforming a structure containing monadic results into a monadic structure of results. Works with any monad `M` and the `Atan2.O.t` interface. Useful for handling computations that produce Atan2 values within a monadic context, such as error handling or stateful operations.",
      "description_length": 325,
      "index": 365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Args.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an Always block for a polar-to-rectangular conversion interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use cases include building and managing CORDIC polar-to-rectangular conversion logic in hardware descriptions with clear signal handling and naming.",
      "description_length": 402,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Results.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for signal manipulation, interface construction, and structural validation in CORDIC-based arctangent computations. It works with signal interfaces (`t`) representing hardware signals in a computation graph, supporting tasks like constant assignment, multiplexing, packing/unpacking, and creating input/output ports with explicit naming. Specific use cases include validating bit-widths, building pipelines, and implementing multiplexers during hardware synthesis.",
      "description_length": 496,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for converting rectangular coordinates to polar representations in a CORDIC-based implementation. It defines interfaces for signal manipulation, including packing/unpacking, multiplexing, and validation of bit widths, specifically for coordinate conversion circuits. Concrete use cases include implementing digital signal processing pipelines where Cartesian coordinates must be transformed into magnitude and angle representations using fixed-point arithmetic.",
      "description_length": 513,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Results.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that takes a record of monadic values and returns a monadic record of values, effectively flipping the structure. It operates on the `Cos_sin.Results.t` record type, which contains sine and cosine results, within a monadic context `M`. Use this to sequence multiple monadic computations that produce result records into a single computation that produces a record of sequenced results.",
      "description_length": 423,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Args.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating `Rect_to_polar.Args` interfaces as bit vectors. It supports packing, unpacking, multiplexing, concatenation, and selection operations, working directly with `comb`-typed signals. These functions are used to build and validate fixed-width signal interfaces for converting rectangular coordinates to polar in CORDIC circuits.",
      "description_length": 409,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly associates the field names of a polar-to-rectangular conversion interface with values, using unsafe operations based on port names. It works with records containing numeric types, typically used in hardware description contexts. It enables direct mapping between signal names and their corresponding values in CORDIC-based circuit implementations.",
      "description_length": 368,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating a structured interface of type `Div.I.t`, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions. It works directly with bit-width validated signal interfaces and supports concrete use cases like building arithmetic pipelines or control logic where fixed-width signal routing is required. Functions like `mux`, `concat`, and `priority_select` enable composing complex signal paths from simpler components.",
      "description_length": 529,
      "index": 372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Results.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate `Rect_to_polar.Results.t` interfaces using the Always API, including extracting signals, assigning values, and creating registers or wires. It supports operations like signal extraction, interface assignment, and naming customization for hardware description. Concrete use cases include building and connecting CORDIC-based rectangular-to-polar conversion circuits within an always block context.",
      "description_length": 441,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Results.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the result structure for a polar-to-rectangular conversion, specifying the names and widths of output ports. It provides direct access to signal identifiers and their bit-widths, used in generating hardware descriptions. This supports constructing and verifying CORDIC-based circuits that convert polar coordinates to rectangular form.",
      "description_length": 355,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Args.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides utilities for constructing, manipulating, and validating signal interfaces representing inputs to a CORDIC-based `atan2` function, including operations for packing/unpacking, multiplexing, concatenation, and register pipelining. It operates on `Atan2.Args.Of_signal.t` interface values, enabling hardware description tasks like signal wiring, port creation, and naming conventions in circuits implementing `atan2` with CORDIC algorithms. Specific use cases include building validated input interfaces with pipelined registers and structured signal hierarchies for hardware acceleration of trigonometric computations.",
      "description_length": 637,
      "index": 375,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Results.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating signal interfaces representing rectangular-to-polar conversion results, including signal assignment, wiring, naming, and structural transformations like packing, concatenation, and pipeline creation. It operates on signal structures modeling hardware interfaces, enabling precise control over dataflow and register stages in circuit designs. These capabilities are applied in HDL workflows to implement coordinate conversion pipelines for applications such as digital signal processing and FPGA-based arithmetic units.",
      "description_length": 584,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that takes a record of monadic values and returns a monadic record of values, effectively flipping the structure of a Cosh_sinh interface with monadic fields. It operates on data types that conform to the `Cosh_sinh.O.t` signature, where each field is wrapped in a monad `M`. A concrete use case is collecting results from multiple concurrent hardware simulation computations into a single structured result.",
      "description_length": 446,
      "index": 377,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the port names and widths for a CORDIC rectangular-to-polar conversion circuit. It specifies the input and output signal names along with their bit-widths, used directly in circuit instantiation and simulation. The data structures include lists of string-width pairs and separate lists for names and widt",
      "description_length": 324,
      "index": 378,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides `to_alist` and `of_alist` functions for converting a `Div.O.t` interface to and from a list of field name-value pairs. It enables direct mapping between structured circuit interfaces and associative lists keyed by port names. This is useful when dynamically constructing or inspecting circuits based on named signal mappings, such as in automated testbench generation or configuration-driven design assembly.",
      "description_length": 429,
      "index": 379,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Args.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for the `Atan2.Args` interface. It supports creating register and wire variables, assigning values, and applying naming conventions to interface fields. Use cases include constructing and managing hardware signals for CORDIC-based `atan2` computations using the Always API.",
      "description_length": 360,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Args.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a product of monadic values into a monadic product, effectively sequencing the monadic effects across a structure of arguments. It operates on data types involving monadic values wrapped in a `Mul.Args.t` structure. A concrete use case is combining multiple monadic computations that each produce a `Mul.Args.t` value, lifting the monadic context outside the argument structure to enable composition within a monadic workflow.",
      "description_length": 480,
      "index": 381,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Args.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to construct and manipulate fixed-width bit vector representations of cosine and sine arguments for CORDIC computations. It supports operations like packing/unpacking bit vectors, multiplexing, concatenation, and selection from lists of interfaces, all working with `comb` type signals. Concrete use cases include building hardware circuits for trigonometric function evaluation, signal processing pipelines, and FPGA-based arithmetic accelerators.",
      "description_length": 479,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Results.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal values within an always block for a CORDIC arctangent result interface. It supports creating register and wire variables, assigning values, and applying naming conventions to signals. Use it to implement hardware logic that processes or routes CORDIC arctangent computation outputs in a Hardcaml design.",
      "description_length": 366,
      "index": 383,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Args.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing, validating, and transforming signal interfaces for polar-to-rectangular conversion in CORDIC circuits, focusing on signal width correctness and RTL-level manipulation. It works with `comb` type signal structures and hardware interface representations, supporting tasks like packing/unpacking, multiplexing, register pipeline creation, and hierarchical signal naming. These capabilities are used in hardware design flows to implement verified, synthesisable interfaces for mathematical acceleration circuits.",
      "description_length": 557,
      "index": 384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic.I",
      "library": "hardcaml_circuits",
      "description": "This module supports transformations and metadata operations on structured interface tuples, enabling mapping, zipping, and conversion to or from association lists while preserving field-specific attributes like port names and widths. It operates on typed interface structures (`'a t`) that encapsulate CORDIC circuit metadata, facilitating both static and dynamic field access through name- or tag-based resolution. These utilities are applied in hardware description and simulation workflows for constructing validated CORDIC-based rectangular-to-polar conversion circuits, where precise signal mapping and naming conventions are critical.",
      "description_length": 641,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC-based inverse hyperbolic tangent (atanh) function implementation. It specifies the input and output signal names and their bit-widths, along with associated tags for hardware description. It is used to configure and generate the atanh function's interface in a hardware design context.",
      "description_length": 340,
      "index": 386,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational and sequential operations for constructing CORDIC-based cosh/sinh circuits, including signal manipulation, register creation, and pipeline construction. It works with `comb` signals and structured interface types to manage hardware connections and naming. Specific use cases include building and validating hardware modules by connecting signal bundles, applying naming conventions, and creating hierarchical designs through register pipelines.",
      "description_length": 479,
      "index": 387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a CORDIC polar-to-rectangular conversion interface. It provides concrete signal identifiers and their bit-widths needed to implement the conversion logic in hardware. Use this module to generate or connect signals in a CORDIC-based polar-to-rectangular coordinate transformation circuit.",
      "description_length": 333,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Args.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "Converts between record values and association lists indexed by field names, specifically for interfacing with CORDIC rectangular-to-polar conversion arguments. Works directly with tuples of numeric values and string-keyed lists. Useful for dynamically constructing or inspecting CORDIC input/output data at runtime without static type checking.",
      "description_length": 345,
      "index": 389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to convert polar coordinates to rectangular coordinates using CORDIC algorithms, working with fixed-width bit vectors. It supports construction of interfaces from integers, packing/unpacking to/from bit vectors, multiplexing, and selection operations with optional validity signals. Use cases include hardware synthesis for digital signal processing tasks like phase rotation and vector magnitude calculations.",
      "description_length": 442,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Args.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for configuring a CORDIC rotation vector operation. It specifies the interface for input and output signals used in the rotation vector circuit, including their bit widths. It is used to construct hardware circuits that perform coordinate rotations using the CORDIC algorithm.",
      "description_length": 325,
      "index": 391,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bit vector interfaces for multiplier inputs, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with `comb` type bit vectors and structured interfaces of type `t`, which define signal ports with specified widths. Concrete use cases include building configurable multiplexers, validating signal widths in hardware descriptions, and assembling bit-level representations of multiplier operands for synthesis.",
      "description_length": 524,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width integer multiplier interfaces using a combinational logic representation. It supports concrete operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs, all while ensuring correct bit-widths via validation functions. Typical use cases include building arithmetic pipelines or control logic where precise bit-level manipulation and routing of multiplier inputs are required.",
      "description_length": 534,
      "index": 393,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Args.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between `Atan2.Args.t` records and association lists, using field names as keys. It enables working with CORDIC input/output data in a flexible, name-based format, particularly useful for debugging or dynamic configuration. The operations are optimized for performance by bypassing port name safety checks.",
      "description_length": 346,
      "index": 394,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a structured interface and an association list, where each field is mapped to or from a named entry in the list. It operates on the `Cosh_sinh.I.t` type, which represents the input interface for CORDIC-based hyperbolic cosine and sine functions. Use this to dynamically construct or inspect interfaces using string-labeled values, such as when integrating with external data formats or debugging signal mappings.",
      "description_length": 460,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Results.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for manipulating fixed-width vector results from a CORDIC rotation circuit, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and validation of signal widths. It works with combinatorial signals (`comb`) structured as records of integer values representing CORDIC computation outputs. Concrete use cases include assembling or disassembling CORDIC result signals for routing, comparing or validating signal widths during simulation, and selecting between multiple result vectors using priority or one-hot encoded selectors.",
      "description_length": 582,
      "index": 396,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Results.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for manipulating hardware signal interfaces, including packing/unpacking, multiplexing, concatenation, and pipeline creation, primarily working with structured signal groupings represented by `t` and `comb` types. It supports tasks like connecting signals via assignment operators, defining input/output ports, and applying naming conventions to enhance signal organization in circuit designs. These capabilities are particularly useful in hardware synthesis workflows where structured signal handling and interface management are critical for implementing complex digital circuits.",
      "description_length": 614,
      "index": 397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic.I",
      "library": "hardcaml_circuits",
      "description": "This module implements functional combinators for composing and transforming structured hardware interfaces and signals representing CORDIC-based hyperbolic function circuits. It operates on typed interface values (`'a t`) with support for mapping, zipping, folding, and port-aware signal manipulations, enabling precise control over combinational and sequential logic synthesis. These tools are specifically applied to implement and verify hyperbolic cosine/sine circuits in hardware designs, handling tasks like signal routing, port width definitions, and monadic aggregation during circuit construction.",
      "description_length": 606,
      "index": 398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Args.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a product type and an association list, using field names as keys. It operates on types that follow the `Mul.Args.t` structure, which represents fixed-field records. These functions enable straightforward serialization and deserialization of circuit argument data, particularly useful when interfacing with external representations like JSON or netlists.",
      "description_length": 402,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Args.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that takes a record of monadic values and returns a monadic record, effectively sequencing the monadic effects across all fields of the input. It operates on the `Atanh.Args.t` record type, lifting monadic computations from individual fields to the whole structure. A concrete use case is collecting results from multiple concurrent hardware description computations into a single structured result.",
      "description_length": 437,
      "index": 400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic.I",
      "library": "hardcaml_circuits",
      "description": "This module provides polymorphic and functional combinators for manipulating CORDIC interface structures, including mapping, zipping, folding over tuples, and converting between lists and typed hardware signal interfaces (`'a t`). It operates on circuit configurations defined by port names, bit widths, and runtime tags, enabling dynamic introspection, combinational logic synthesis, and bit-level transformations. Use cases include constructing and validating vector rotation circuits, defining register/wire variables with the Always API, and unsafe runtime signal manipulation for low-level hardware optimization.",
      "description_length": 617,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Results.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to manipulate fixed-width bit vector representations of multiplier results, supporting construction from integers, packing/unpacking to vectors, multiplexing, concatenation, and selection operations. It works with data types representing bit vectors (`comb`) and structured multiplier outputs (`t`). Concrete use cases include building and validating hardware circuits that process or route fixed-point multiplication results using combinational logic.",
      "description_length": 484,
      "index": 402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for a polar-to-rectangular conversion circuit. It provides concrete signal identifiers and bit-width configurations used in the CORDIC implementation. These values specify input and output signal layouts for synthesis and simulation purposes.",
      "description_length": 291,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides `to_alist` and `of_alist` functions for converting `Atan.O.t` values to and from association lists indexed by field names. It operates on records with string keys and arbitrary values, enabling direct mapping between record fields and named entries in a list. Use this to serialize or deserialize CORDIC atan interfaces for external consumption, such as configuration files or debugging output.",
      "description_length": 415,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for the input signals of a CORDIC-based inverse hyperbolic tangent (atanh) function implementation. It works with basic string and integer types to specify signal interfaces, and is used to configure hardware signal mappings in a circuit description. Concrete use cases include setting up input port definitions for simulation or synthesis of the atanh function in a CORDIC pipeline.",
      "description_length": 425,
      "index": 405,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating fixed-width integer division interfaces. It supports data types involving packed vectors and structured division signals, enabling operations like packing/unpacking, multiplexing, concatenation, and priority/onehot selection. Concrete use cases include building control logic for division pipelines, managing signal routing in data paths, and validating interface widths in combinational circuits.",
      "description_length": 483,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Args.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps CORDIC atan function arguments to and from association lists using field names as keys. It operates on records containing numeric or signal types, enabling straightforward argument passing in hardware description contexts. Use it to convert between structured interfaces and key-value representations when instantiating or testing CORDIC-based circuits.",
      "description_length": 379,
      "index": 407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the interface for converting rectangular coordinates to polar coordinates using CORDIC algorithms. It specifies port names and widths for input and output signals, including angle and magnitude tags. Concrete use cases include implementing hardware circuits for signal processing and coordinate transformations in FPGAs.",
      "description_length": 340,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Results.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe access to fields of a CORDIC multiplication result by port name using string keys. It supports operations to convert structured multiplication outputs to and from association lists, enabling dynamic field lookup and injection. Use this when interfacing with external systems that require named signal access or when dynamically constructing testbenches with named ports.",
      "description_length": 406,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal values within an always block for a CORDIC-based cosh/sinh interface. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include implementing hardware logic for hyperbolic function computations using the CORDIC algorithm in a structured and readable way.",
      "description_length": 398,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an Always block for a specific interface type. It supports creating register and wire variables, assigning values, and applying naming conventions to signal fields. Use cases include building and managing hardware description logic in a structured interface container.",
      "description_length": 339,
      "index": 411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Results.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating fixed-width bitvector representations of hyperbolic cosine and sine results in a CORDIC implementation. It supports data types involving packed bit vectors and structured result types with fields for cosh and sinh outputs. Concrete use cases include packing and unpacking result interfaces, multiplexing between multiple result sets, validating signal widths, and creating constant result values from integers.",
      "description_length": 476,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for converting rectangular coordinates to polar representations using CORDIC algorithms. It works with fixed-point vector types to represent coordinates and angles, supporting operations like packing/unpacking interfaces, multiplexing, concatenation, and selection. Concrete use cases include implementing coordinate transformations in digital signal processing, robotics, and FPGA-based control systems where polar coordinates are derived from Cartesian inputs.",
      "description_length": 514,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Args.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that takes a record of monadic values and returns a monadic record of values, effectively flipping the structure of the input. It operates on the `Cos_sin.Args.t` record type where each field is wrapped in a monad `M`. This is useful for combining multiple monadic computations that produce parts of a `Cos_sin.Args.t` record into a single monadic computation that produces the full record.",
      "description_length": 428,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Results.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that combines a record of monadic values into a monadic record, preserving the structure of the input. It operates on records of type `'a M.t Rotate_vector.Results.t`, where `M` is a monad, and lifts the monad to wrap the entire record. A concrete use case is aggregating multiple monadic computations over a result structure into a single monadic value for sequential processing.",
      "description_length": 418,
      "index": 415,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a polar-to-rectangular interface wrapped in a monad into a monad wrapping the entire interface. It operates on data types involving monadic values within the `Polar_to_rect.I.t` structure. A concrete use case is combining multiple monadic computations over polar-to-rectangular conversion signals into a single monadic result.",
      "description_length": 380,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Args.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps input/output ports of a CORDIC rotation vector interface to and from association lists, using field names as keys. It operates on tuples of field names and values, enabling direct construction or extraction of port-based data structures. Use this when converting between structured CORDIC interfaces and string-indexed port mappings, such as during simulation or testbench setup.",
      "description_length": 405,
      "index": 417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Args.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and tags for configuring a CORDIC-based division circuit. It specifies the interface signals required for the division operation, including inputs like dividend and divisor, and outputs like quotient and remainder. The data structures are used directly in constructing the circuit's signal processing logic.",
      "description_length": 347,
      "index": 418,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations (e.g., multiplexing, concatenation) and sequential logic (e.g., register control) for manipulating CORDIC-based arctangent interfaces (`Atan.O.t`) using Hardcaml signals. It supports wiring operations, signal naming, and interface construction through functions like `<==`, `inputs`, `outputs`, and `apply_names`, while validating signal widths and structures. These capabilities are used to implement hardware circuits requiring precise trigonometric computations, such as angle estimation or vector rotation pipelines in FPGA/ASIC designs.",
      "description_length": 593,
      "index": 419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structured interface of monadic values into a monadic interface over a structured value, specifically for CORDIC-based arctangent computations. It operates on data types involving nested monads and CORDIC interfaces, enabling composition of circuits that compute multiple arctangent values in parallel. A concrete use case is lifting monadic signal representations into a unified circuit structure for hardware description in Hardcaml.",
      "description_length": 491,
      "index": 420,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a product type and an association list, using field names as keys. It operates on types that represent hardware interfaces, specifically those conforming to the `Mul.O.t` signature. These functions enable easy mapping between structured hardware signals and string-indexed value lists, useful for debugging, serialization, or dynamic signal routing.",
      "description_length": 397,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides structural signal manipulation and interface construction operations for CORDIC-based hyperbolic function implementations. It works with signal interfaces composed of `Hardcaml.Signal.t` values, enabling transformations like concatenation, multiplexing, and bit-width validation, along with wiring primitives for connecting and naming signal bundles. These operations are used to synthesize and validate circuit designs for hyperbolic cosine/sine computations in hardware description workflows.",
      "description_length": 515,
      "index": 422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Results.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a structured result type and an association list keyed by string field names. It operates on tuples or records containing numeric or signal types, typically used to map hardware interface signals to named ports. Use it to dynamically construct or deconstruct signal bundles by name without static type enforcement.",
      "description_length": 362,
      "index": 423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a `Rotate_vector.I.t` record and an association list mapping field names to values. It enables working with vector rotation interfaces using string-indexed key-value pairs. Use this when mapping hardware interface fields to dynamic data structures or parsing configuration inputs into circuit inputs by name.",
      "description_length": 356,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "Converts rectangular coordinates to polar representations using CORDIC algorithms. It operates on tuples of signals representing Cartesian coordinates and returns polar forms with magnitude and angle. This module directly supports hardware description by mapping input and output ports via association lists keyed by field names.",
      "description_length": 329,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Results.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that combines monadic values within a specific result structure, lifting the monad outside the interface. It operates on data types that conform to the `Polar_to_rect.Results.t` structure, parameterized by a monad `M`. A concrete use case involves aggregating multiple monadic computations that produce results in a structured format, enabling sequential composition of effects while preserving result structure.",
      "description_length": 450,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic.O",
      "library": "hardcaml_circuits",
      "description": "This module provides polymorphic operations for transforming CORDIC polar-to-rectangular conversion interfaces, including mapping, zipping, and conversion to/from associative structures. It works with record-based data structures representing hardware ports, where fields are typed and identified by tags or strings, enabling introspection and serialization. These utilities support hardware construction tasks like signal packing/unpacking, register insertion, and circuit instantiation, particularly for coordinate conversion logic integrated with simulation or synthesis workflows.",
      "description_length": 584,
      "index": 427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating fixed-width integer interfaces, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions with support for valid signals. It works with bit vector types represented by the `comb` type and structured data of type `t` defined by the `Mul.O` interface. Concrete use cases include building arithmetic pipelines, signal routing in digital circuits, and constructing conditional data paths in hardware designs.",
      "description_length": 508,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic.O",
      "library": "hardcaml_circuits",
      "description": "This module provides functional combinators for manipulating structured CORDIC division interfaces, including mapping, zipping, folding, and scanning operations over typed signal tuples. It operates on structured signal interfaces (`Div.Cordic.O.t`) and hardware",
      "description_length": 262,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Results.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that takes a record of monadic values and returns a monadic record of values, effectively flipping the structure. It operates on the `Atanh.Results.t` record type, lifting monadic values to the top level. A concrete use case is combining multiple monadic computations into a single result when working with CORDIC-based atanh function outputs.",
      "description_length": 381,
      "index": 430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Results.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal values within an `Always` block for a multiplication results interface. It supports creating register and wire variables, assigning values to them, and applying naming conventions to signals. Use cases include building and managing hardware description logic for multiplication circuits using the Always API.",
      "description_length": 371,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.I.All",
      "library": "hardcaml_circuits",
      "description": "Lifts monadic values within a cosine-sine interface to a monad containing the interface. Works with any monad `M` and values structured as `Cos_sin.I.t` containing monadic elements. Useful for collecting and sequencing computations that produce cosine and sine components in a monadic context.",
      "description_length": 293,
      "index": 432,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively lifting the monad outside the record structure. It operates on data types that conform to the `Rect_to_polar.O.t` signature, wrapping each field in a monadic type `M`. A concrete use case is aggregating multiple computations in a monadic context, such as collecting results from asynchronous operations into a structured format.",
      "description_length": 444,
      "index": 433,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps input fields of a register interface to and from an association list, using field names as keys. It operates on `I.t` types, which represent register interfaces with named ports. Use this to dynamically inspect or construct register interfaces by name, such as for debugging, serialization, or configuration based on port names.",
      "description_length": 354,
      "index": 434,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides `to_alist` and `of_alist` functions for converting between an interface type `'a I.t` and an association list of field names paired with values. It enables direct mapping of interface fields to named entries in a list, supporting structured data interchange and configuration. Use cases include serializing circuit interfaces for debugging, configuration, or external processing, and reconstructing interfaces from named value lists.",
      "description_length": 454,
      "index": 435,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational logic operations for packing, unpacking, multiplexing, and selecting fixed-width bitvector interfaces. It works directly with `comb` typed signals and structured interface types (`t`) composed of named fields with defined bit widths. Concrete uses include building control logic for data paths, implementing priority encoders, or constructing multiplexed data routing in hardware designs without using arithmetic operators.",
      "description_length": 460,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Sim",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based arctangent calculations with configurable algorithm versions and simulation parameters. Works with bitvector inputs and outputs, using Cyclesim for behavioral simulation. Useful for FPGA-based trigonometric computations where high-throughput angle calculations are needed from Cartesian coordinates.",
      "description_length": 323,
      "index": 437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.State.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines and exposes the port names, widths, and associated tags for a divider circuit state. It provides direct access to these properties as lists, enabling straightforward introspection and configuration of the circuit's interface. Use this module when generating or analyzing divider circuits where explicit port information is required for synthesis or debugging.",
      "description_length": 379,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational logic operations for manipulating structured data interfaces with fixed bit-width fields. It supports construction of multiplexers, priority and onehot selectors, packing/unpacking to bit vectors, and validation of signal widths. Concrete use cases include building register file datapaths, control logic for pipeline stages, and hardware structures requiring precise bit-level manipulation.",
      "description_length": 428,
      "index": 439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating counter interfaces with quotient and remainder outputs. It works with bit vector types (`comb`) and structured interfaces (`t`) to support operations like packing/unpacking, multiplexing, concatenation, and priority/onehot selection. Concrete use cases include building custom counter circuits with precise width validation, setting constant values, and routing signals in hardware designs where division and modulo behavior must be explicitly controlled.",
      "description_length": 541,
      "index": 440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.I.All",
      "library": "hardcaml_circuits",
      "description": "Lifts monadic values within an interface to the outer monad, combining them into a single monadic interface. Works with any monad `M` and interface types `'a M.t I.t`. Useful for sequencing multiple monadic computations that produce interfaces, ensuring each computation completes before combining their results into a single interface.",
      "description_length": 336,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module supports combinational and sequential logic operations on hardware signal interfaces, including multiplexing, concatenation, register pipelining, and signal packing/unpacking. It operates on `comb` and `t` types representing digital signals, enabling precise manipulation of signal flow and structure. These capabilities are specifically used to implement CORDIC algorithm pipelines for iterative trigonometric and hyperbolic function computation, where signal routing, gain compensation, and mode-specific iteration control are critical.",
      "description_length": 550,
      "index": 442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the interface for a synchronous stack by specifying the names and widths of its ports as lists of string-integer pairs, individual port names, port widths, and associated tags. It works with basic list and integer data types to describe hardware port configurations. Concrete use cases include defining the input/output structure of a hardware stack in a Hardcaml design, enabling consistent signal handling and component composition.",
      "description_length": 454,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.I",
      "library": "hardcaml_circuits",
      "description": "This module supports transforming and validating structured CORDIC interfaces for hyperbolic cosine and sine operations through mapping, zipping, folding, and converting between lists and hardware-specific representations. It works with typed, named, and width-specified port interfaces (`t`), association lists, and signal-based combinational logic to enable circuit design tasks like port configuration, signal assignment, and bit-level hardware generation. Key use cases include synthesizing validated interface definitions, structuring signal pipelines, and ensuring correct width propagation in arithmetic circuits.",
      "description_length": 620,
      "index": 444,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.O",
      "library": "hardcaml_circuits",
      "description": "This module provides functional combinators for transforming structured interface bundles containing typed hardware signals and ports, supporting operations like mapping, zipping, folding, scanning, and converting between interface lists. It facilitates constructing combinational logic, pipelines, and error handling in CORDIC-based arctangent circuits, with utilities for managing always-block signal assignments and type-safe port configurations via explicit naming and width definitions.",
      "description_length": 491,
      "index": 445,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to construct and manipulate hardware interfaces using the Always API, specifically for working with CORDIC circuits. It supports operations like assigning signals to variables, creating registers and wires with specified properties, and applying naming conventions to interface fields. The module works with interface containers (`O.t`) and signal types, enabling precise control over signal assignments and variable declarations in hardware descriptions. Use cases include building structured CORDIC pipelines with named registers and wires, and assigning signals in always blocks while ensuring correct signal propagation and naming.",
      "description_length": 666,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Test",
      "library": "hardcaml_circuits",
      "description": "Implements conversion from rectangular to polar coordinates using CORDIC algorithms in combinational, pipelined, or iterative forms. Operates on floating-point inputs representing Cartesian coordinates (x, y) and returns polar coordinates (r, \u03b8). Useful for signal processing applications requiring real-time coordinate transformations, such as in radar systems or motor control algorithms.",
      "description_length": 390,
      "index": 447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively flipping the structure. It operates on data types that conform to the `I.t` interface, which represents hardware description interfaces in Hardcaml. A concrete use case is when building hardware circuits where each field of a record represents a signal in a monadic context, and the goal is to combine these signals into a single monadic interface for further processing or simulation.",
      "description_length": 501,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.I.All",
      "library": "hardcaml_circuits",
      "description": "Lifts monadic values within an interface to the outer monad, combining them into a single monadic interface. Works with any monad `M` and interface types `'a M.t I.t`. Useful for aggregating register stages with validated control signals into a unified monadic structure.",
      "description_length": 271,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.I",
      "library": "hardcaml_circuits",
      "description": "This module provides structural and introspective operations for manipulating CORDIC-based arctangent interfaces, including mapping over fields, converting to association lists, zipping interfaces, and inspecting port names and widths. It supports combinational logic transformations on fixed-width signal interfaces through mapping, folding, scanning, and bit-level operations, while enabling hardware construction via always blocks and named port configurations. These utilities are used for circuit validation, signal routing, interface serialization, and sequential monadic composition in hardware design workflows.",
      "description_length": 619,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structure of monadic values into a monadic structure of values, effectively flipping the layers of the monad and the structure. It operates on data types involving nested monadic and structural layers, specifically `'a M.t O.t` and `'a O.t M.t`. A concrete use case is when combining multiple signals or computations that are both structured (e.g., hardware registers) and effectful (e.g., within a monad like `Hardcaml.Circuit.Builder.Monad`).",
      "description_length": 500,
      "index": 451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Sim",
      "library": "hardcaml_circuits",
      "description": "Implements fixed-point hyperbolic arctangent (atanh) computations using CORDIC iterations in simulation. Works with `Bits.t` signals for input and output, and manages internal state through simulation references. Useful for high-precision mathematical computations in digital signal processing or scientific computing pipelines where atanh is required.",
      "description_length": 352,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Cordic",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based cosine and sine computation with configurable iteration counts and fixed-point precision. Works on `Signal.t` inputs and outputs encapsulated in `I` and `O` record types, representing angle inputs and computed sine/cosine outputs. Used to generate synthesizable RTL for FPGA or ASIC implementations of trigonometric functions, supporting pipelining and bit-width optimization.",
      "description_length": 400,
      "index": 453,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating counter interfaces with quotient and remainder fields. It supports constant assignment, packing/unpacking, multiplexing, concatenation, and selection operations on counter values represented as bit vectors. Use cases include building hardware counters with custom divisors and ranges, and implementing control logic that requires precise division-based state tracking.",
      "description_length": 454,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.IO.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to hardware interfaces within always blocks. It works with `Always.Variable.t` and `Signal.t` types, enabling register and wire creation, signal assignment, and naming customization. Concrete use cases include building register stages with enable control, connecting interface signals in sequential logic, and applying consistent signal names for debugging or synthesis.",
      "description_length": 433,
      "index": 455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides functions for structuring and manipulating signal interfaces in hardware circuits, including operations like packing/unpacking, multiplexing, concatenation, and pipeline register creation. It works with fixed-width bit vectors and structured data types to manage signal connectivity and naming, particularly in iterative arithmetic circuits such as CORDIC for trigonometric or hyperbolic function computation. These tools are essential for organizing data paths, handling gain compensation, and ensuring convergence in hyperbolic mode through precise pipeline control and interface alignment.",
      "description_length": 613,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.State.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational logic operations for manipulating structured state interfaces, such as packing/unpacking to vectors, multiplexing, concatenation, and selection functions like priority and one-hot decoding. It works directly with `comb State.t` values, representing hardware signals with defined field widths. Use this module to build complex signal routing and transformation logic in a hardware description context, such as decoding control signals, assembling/disassembling data buses, or managing multiplexed inputs.",
      "description_length": 540,
      "index": 457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.O.All",
      "library": "hardcaml_circuits",
      "description": "Lifts monadic values from inside an interface to the outside, combining them into a single monadic result. Works with any module `M` that provides monadic structure and an applicative interface `O`. Useful for sequencing operations that depend on both the interface structure and the monadic effects, such as building hardware circuits with embedded computations.",
      "description_length": 363,
      "index": 458,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Test",
      "library": "hardcaml_circuits",
      "description": "Implements test cases for polar-to-rectangular coordinate conversion using CORDIC algorithms. Validates correctness of combinational, pipelined, and iterative implementations by comparing output against expected float values for given input arguments. Uses simulation environments and input/output structures defined in Polar_to_rect modules.",
      "description_length": 342,
      "index": 459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps named ports of a circuit interface to values in an association list, enabling straightforward construction and deconstruction of circuit interfaces. It operates on OCaml records (`O.t`) and string-keyed lists of values, specifically for use in ROM-accumulator circuits that compute weighted sums using distributed arithmetic. Use cases include assembling input signals from named fields or extracting results from a circuit interface into a labeled list for further processing or debugging.",
      "description_length": 516,
      "index": 460,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the interface for a synchronous stack by specifying port names and their corresponding widths. It provides direct access to lists of port names, port widths, and associated tags for stack operations. Concrete use cases include configuring hardware stack interfaces and generating signal declarations with precise bit-widths for synthesis or simulation.",
      "description_length": 372,
      "index": 461,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to construct and manipulate CORDIC circuits using bit-level representations. It supports operations like packing/unpacking interfaces into vectors, multiplexing, concatenation, and selection logic with specific bit-width handling. Concrete use cases include implementing trigonometric and hyperbolic function computations in hardware with precise control over signal widths and constants.",
      "description_length": 419,
      "index": 462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinatorial logic operations for packing/unpacking signal interfaces, multiplexing, concatenation, and selection primitives like priority and one-hot encoders. It operates on `comb` types representing hardware signals, and structured `t` values composed of multiple signal fields. Use cases include building control logic, data routing circuits, and signal manipulation in register-transfer level designs.",
      "description_length": 430,
      "index": 463,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Sim",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based vector rotation simulations with configurable circuit parameters. Works with `Rotate_vector.I` and `Rotate_vector.O` interface types, using `Hardcaml.Bits.t` for signal representation. Useful for verifying fixed-point vector rotation behavior in hardware designs with specific cycle-accurate configurations.",
      "description_length": 331,
      "index": 464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Args",
      "library": "hardcaml_circuits",
      "description": "This module enables transformations and combinations of structured division arguments through mapping, folding, and list conversions, alongside unsafe direct port name associations and higher-order operations. It operates on typed hardware port interfaces (`Div.Args.t`) and signal-level representations of division components (dividend, divisor, quotient, remainder), supporting bit-level manipulations and synchronous logic pipelines. Key use cases include RTL interface synthesis, pipeline control signal generation, and port configuration via named width specifications or synchronous assignment blocks.",
      "description_length": 607,
      "index": 465,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.I",
      "library": "hardcaml_circuits",
      "description": "This module supports structured manipulation of multiplier interfaces in CORDIC-specialized circuits through operations like mapping, zipping, and folding over product types, as well as conversions between interface lists and hierarchical structures. It works with typed hardware description data types (`Mul.I.t`), named and width-indexed ports, and signal variables, emphasizing bit-width correctness and combinational logic. These utilities are used to define, route, and verify signal connections in multiplier circuits while enabling error-aware transformations and structural equality checks during hardware synthesis.",
      "description_length": 624,
      "index": 466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.I",
      "library": "hardcaml_circuits",
      "description": "This module provides structured manipulation of hardware interfaces for coordinate transformations using polymorphic record-like operations and functional combinators, such as mapping, zipping, and folding over signal tuples. It operates on interfaces composed of named ports with fixed bit widths, signals, and bit vectors, enabling both combinational logic and stateful register management in RTL designs. These tools are specifically applied to implement CORDIC-based rectangular-to-polar conversions with fixed-point arithmetic in digital circuits.",
      "description_length": 552,
      "index": 467,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.M_with_valid.All",
      "library": "hardcaml_circuits",
      "description": "This module provides the `all` function, which transforms a list of monadic values with validity into a monadic value of lists with validity, preserving the structure of the input. It operates on data types involving `M_with_valid.t`, typically wrapping computations that carry a validity signal in a synchronous context. A concrete use case is aggregating multiple validatable signals into a single validatable collection, such as combining results from parallel computations in a circuit.",
      "description_length": 490,
      "index": 468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Sim",
      "library": "hardcaml_circuits",
      "description": "Implements a CORDIC-based division circuit simulation with support for configuring simulation behavior through parameters like implementation version and cycle-accurate timing. Works directly with bitvector (`Bits.t`) inputs and outputs, structured as named signals in a simulation environment. Useful for verifying fixed-point division logic in hardware designs using CORDIC algorithms, particularly in contexts requiring precise control over simulation configuration and signal tracing.",
      "description_length": 488,
      "index": 469,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate hardware description interfaces using the Always API. It supports creating and assigning register and wire variables, extracting signal values, and applying naming conventions to interface fields. Use cases include building and connecting hardware modules with named signals, initializing registers, and managing signal assignments within always blocks.",
      "description_length": 398,
      "index": 470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.State.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a list of monadic state computations into a single monadic computation of a combined state result. It operates on values of type `'a M.t State.t`, where `M` is a monad, and lifts the monad outside the state interface. A concrete use case is aggregating multiple stateful computations that return values within a monad, such as handling effectful state transitions in a circuit description.",
      "description_length": 443,
      "index": 471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.IO.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and connecting structured hardware interfaces composed of signal vectors and control signals, enabling tasks like multiplexing, register insertion, and data transformation through packing/unpacking or concatenation. It supports control logic patterns such as priority selection and pipelining while offering utilities to name and connect signal wires with customizable naming conventions. Specific use cases include building data path components with valid/ready handshaking, managing hierarchical signal connectivity, and synthesizing register-staged circuits with precise timing control.",
      "description_length": 638,
      "index": 472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.O",
      "library": "hardcaml_circuits",
      "description": "This module provides higher-order functions for mapping, folding, and zipping over CORDIC-derived cosine/sine interfaces (`Cos_sin.O.t`), enabling structured wiring and conversion to/from association lists and lists. It operates on signals, bit vectors, and tagged interface fields with fixed port names and widths, supporting combinational logic, fixed-point arithmetic, and monadic aggregation. These operations are specifically used for hardware synthesis of trigonometric functions and simulation of CORDIC circuits with precise signal routing and register allocation.",
      "description_length": 572,
      "index": 473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic value of records, effectively combining and lifting the monadic structure. It operates on data types involving interfaces (`I.t`) and monadic types (`M.t`). A concrete use case is aggregating multiple signal generators within a hardware description into a single structured result, simplifying the management of concurrent stateful computations.",
      "description_length": 441,
      "index": 474,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational logic operations for constructing and manipulating hardware interfaces with fixed field widths. It supports operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and priority/one-hot selection, all working directly on signal vectors. Concrete use cases include building register file multiplexing logic, instruction decoding circuits, and hardware state machine outputs.",
      "description_length": 439,
      "index": 475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating hardware interfaces with fixed bit-width fields. It supports operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and priority/onehot selection, all while ensuring correct signal widths via validation functions. It is used to build low-latency FIFOs and other hardware structures where precise control over signal routing and width consistency is required.",
      "description_length": 475,
      "index": 476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating hardware interfaces. It supports data types involving packed vectors and structured interfaces with typed fields, enabling operations like packing/unpacking, multiplexing, concatenation, and priority/onehot selection. Concrete use cases include building custom digital circuits, implementing control logic, and managing signal routing in hardware designs.",
      "description_length": 441,
      "index": 477,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps interface fields to values using string keys, enabling unchecked associations between signal names and their corresponding values. It operates on interfaces with named ports, allowing conversion to and from association lists that pair port names with arbitrary data. Use this when dynamically connecting or inspecting interface signals by name, such as in testbenches or configuration systems.",
      "description_length": 419,
      "index": 478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.O",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for structured manipulation of hardware interfaces in vector rotation circuits, including mapping, zipping, folding, and converting between lists and signal representations. It works with typed field-based structures (`t`) and supports dynamic configuration through association lists or tags, enabling fixed-width signal processing and monadic value handling. These utilities are particularly used in CORDIC-based vector rotation implementations for tasks like register and wire management, interface transformation, and control flow specification within always blocks.",
      "description_length": 601,
      "index": 479,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Test",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational, pipelined, and iterative CORDIC algorithms for computing cosine and sine functions. It operates on floating-point input angles and produces corresponding cosine and sine values as outputs. It is used in digital signal processing and hardware acceleration contexts where trigonometric computations are required with configurable performance and resource trade-offs.",
      "description_length": 402,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module implements a counter that tracks a value `n` indirectly by maintaining its quotient and remainder with respect to a given divisor. It supports operations like incrementing, setting to specific values, and wrapping based on maximum quotient and remainder constraints, with optimized behavior for power-of-two divisors and aligned maxima. The counter operates on bit vectors (`Bits.t`) and structured interfaces (`t`), enabling hardware-friendly arithmetic and control logic in digital circuit design.",
      "description_length": 511,
      "index": 481,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating bit-level interfaces, primarily through packing, unpacking, multiplexing, and concatenation. It works with fixed-width bit vectors and structured interfaces composed of these vectors, enabling precise control over signal routing and selection in hardware descriptions. Concrete use cases include implementing data path logic, handling bus interfaces, and building custom digital circuits with well-defined input/output ports.",
      "description_length": 491,
      "index": 482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Cordic",
      "library": "hardcaml_circuits",
      "description": "This module implements CORDIC-based computation of hyperbolic cosine and sine functions using fixed-point arithmetic, operating on structured hardware interfaces composed of typed signals and fixed-width bit vectors. It provides a `create` function that synthesizes the circuit from a configuration and input interface, producing an output interface with computed signals and port metadata. Concrete use cases include implementing high-throughput hyperbolic function units in FPGA-based digital signal processing pipelines and generating testbenches with annotated signal traces for verification.",
      "description_length": 596,
      "index": 483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.IO.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to manipulate register interfaces with bit-level signals, including packing/unpacking to vectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. It works with `IO.Of_bits.comb` values, representing register fields as bit vectors. Concrete use cases include constructing and validating control logic for register stages with precise bit-width constraints, such as in CPU pipelines or hardware state machines.",
      "description_length": 476,
      "index": 484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a list of monadic values into a monadic value of a list, effectively combining and lifting the monad outside the list structure. It operates on lists of values wrapped in a monadic type, enabling sequential composition of effects across multiple values. A typical use case involves collecting results from multiple CORDIC operations, each returning a monadic type, into a single result list within the same monad.",
      "description_length": 467,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a counter that computes quotient and remainder based on a divisor, with wrapping behavior determined by `max_quotient` and `max_remainder`. It works with integer values and supports setting the counter through explicit quotient and remainder inputs. Concrete use cases include implementing hardware counters with custom division parameters and controlled overflow behavior.",
      "description_length": 419,
      "index": 486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.O.All",
      "library": "hardcaml_circuits",
      "description": "Lifts monadic values from within a structure to the outside, combining them into a single monadic result. Works with any monadic type that supports the `M` interface. Useful for aggregating results from multiple concurrent computations into a unified output.",
      "description_length": 258,
      "index": 487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module implements register stages with control signals for pipelined data paths, operating on bit vectors. It provides operations for packing/unpacking interfaces to and from bit vectors, multiplexing and concatenating register interfaces, and validating signal widths. Use cases include constructing pipeline stages with precise bit-level control, managing data flow between hardware components, and ensuring signal integrity in register transfers.",
      "description_length": 454,
      "index": 488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Results",
      "library": "hardcaml_circuits",
      "description": "This module provides structured manipulation of CORDIC rotation circuit outputs through functional combinators like `map`, `zip`, and `fold`, alongside conversions to and from lists and association lists. It operates on typed records representing fixed-width signal interfaces (`'a Rotate_vector.Results.t`), where each field is associated with hardware metadata such as RTL port names and bit widths. These utilities enable precise hardware construction workflows for tasks like signal aggregation, register wiring, and port configuration in vector rotation implementations.",
      "description_length": 575,
      "index": 489,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.I",
      "library": "hardcaml_circuits",
      "description": "This module provides structured manipulation of RTL interfaces for CORDIC-based division circuits, supporting operations like mapping, zipping, and converting between interface values and association lists while preserving port metadata such as names, bit widths, and synthesis tags. It works with hardware signal interfaces (`'a Div.I.t`) and bitvector representations, enabling combinational logic construction, register creation, and CORDIC-specific division circuit assembly. Key use cases include defining synthesis-friendly port configurations, wiring complex signal hierarchies, and implementing division algorithms through CORDIC iterations.",
      "description_length": 649,
      "index": 490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for CORDIC circuit instances, providing direct access to signal identifiers and their bit-widths as lists. It works with string and integer data types to represent port metadata, used in generating or analyzing CORDIC hardware descriptions. Concrete use cases include connecting CORDIC modules in larger circuits or inspecting interface requirements for synthesis.",
      "description_length": 406,
      "index": 491,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Results",
      "library": "hardcaml_circuits",
      "description": "This module supports transformations, validations, and conversions of CORDIC `atan2` result interfaces, structured as tagged records of hardware signals, through operations like zipping, folding, and dynamic field access. It works with signal-level representations (`t` type), port metadata (names and widths), and list-based interface descriptions, enabling tasks such as signal routing, simulation/debugging tool integration, and RTL implementation of angular computation pipelines. Specific use cases include validating hardware-generated results, converting between structured and flattened signal representations, and dynamically inspecting computation outputs during simulation.",
      "description_length": 684,
      "index": 492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for CORDIC circuit interfaces, providing direct access to signal identifiers and their bit-widths as lists. It works with string and integer lists to represent port metadata, alongside a list of tags for additional signal annotations. Concrete use cases include generating signal declarations, configuring interface connections, and supporting automated testbench or netlist generation based on CORDIC iteration parameters.",
      "description_length": 465,
      "index": 493,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.M_with_valid.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the interface for a synchronous stack with valid signal by specifying port names, their corresponding widths, and associated tags. It provides concrete values for port configurations used in hardware description, such as `\"data\"`, `\"valid\"`, and `\"ready\"` with defined bit widths. These values are directly used to generate hardware signals and interfaces in Hardcaml-based designs.",
      "description_length": 402,
      "index": 494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to manipulate fixed-width bitvector interfaces, including packing/unpacking to and from vectors, multiplexing between multiple interfaces, concatenation, and selection from one-hot or priority-encoded inputs. It works with types like `O.Of_bits.comb O.t` for structured bitvector signals and `O.Of_bits.comb` for flat vectors. Concrete use cases include building and validating control signals, routing data paths, and implementing register banks or configuration interfaces in hardware designs.",
      "description_length": 527,
      "index": 495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module constructs a counter that computes quotient and remainder outputs based on a divisor, wrapping when both reach their maximums. It supports setting initial values for quotient and remainder and optimizes hardware generation for power-of-two divisors and specific max value conditions. The counter's interface is built from field names like \"quotient\" and \"remainder,\" enabling direct mapping to and from association lists.",
      "description_length": 433,
      "index": 496,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Test",
      "library": "hardcaml_circuits",
      "description": "Implements combinational, pipelined, and iterative CORDIC algorithms to compute hyperbolic cosine and sine functions on floating-point inputs. Works with simulation environments and input/output structures defined in `Cosh_sinh`. Directly used for hardware-accelerated evaluation of cosh and sinh in digital signal processing or scientific computing contexts.",
      "description_length": 359,
      "index": 497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating hardware interfaces with fixed field widths. It supports operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and priority/one-hot selection, ensuring correct signal widths via validation functions. Concrete use cases include building fast FIFO control logic, routing data paths, and managing register interfaces in hardware designs.",
      "description_length": 452,
      "index": 498,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module implements combinational logic operations for constructing and manipulating hardware interfaces with fixed field widths. It supports operations like packing/unpacking interfaces to vectors, multiplexing, concatenation, and priority/onehot selection, all working directly on signal vectors. Typical use cases include building control logic, data path multiplexers, or interface adapters where precise bit-level manipulation and selection between multiple data sources is required.",
      "description_length": 491,
      "index": 499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.M_with_valid.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module implements dataflow control, signal routing, and validity management for hardware circuits using structured signal bundles that track validity indicators. It supports constructing synchronous pipelines, multiplexed data paths with dynamic width validation, and hierarchical designs through bit-level packing/unpacking and interface naming conventions. Key operations include conditional routing (mux, priority_select), pipelining, and signal assignment with validity-aware transformations.",
      "description_length": 501,
      "index": 500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Sim",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based arctangent calculations for fixed-point inputs using simulation models. Works with `t` type representing internal state and interface signals. Useful for FPGA-based signal processing where precise angle computation from Cartesian coordinates is required.",
      "description_length": 278,
      "index": 501,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating hardware interfaces with fixed bit-width fields. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/onehot selection, along with validation and width inspection. Concrete use cases include building control logic, data path multiplexers, and register interfaces where precise bit-level manipulation and selection are required.",
      "description_length": 480,
      "index": 502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "Implements a ROM-accumulator circuit that computes weighted sums of input bits using distributed arithmetic without multipliers. It operates on fixed-width bit vectors, where each bit of the input selects a precomputed constant from a ROM, which is then added to a shifted accumulator. This module is ideal for implementing efficient digital signal processing algorithms like FIR filters, where constant coefficients are multiplied by binary inputs and summed.",
      "description_length": 460,
      "index": 503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module implements a synchronous stack interface using bit vectors, providing operations to pack, unpack, concatenate, and multiplex stack elements. It supports fixed-width bit-level manipulation with functions like `of_int`, `assert_widths`, and `validate` to ensure correct signal handling. Concrete use cases include building register stacks, implementing priority or one-hot multiplexing, and managing bit-packed configurations in hardware designs.",
      "description_length": 456,
      "index": 504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.M_with_valid.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to synchronous interfaces using the Always API. It works with `Always.Variable.t` and `Signal.t` values wrapped in a `M_with_valid` interface container, which includes valid signals. Concrete use cases include creating register and wire interfaces, assigning signals within always blocks, and applying naming conventions to signal fields.",
      "description_length": 401,
      "index": 505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Test",
      "library": "hardcaml_circuits",
      "description": "Implements combinational, pipelined, and iterative multipliers for floating-point arithmetic in CORDIC-based circuits. Works with simulation environments and input/output data structured as `Base.float Mul.Args.t` and `Base.float Mul.Results.t`. Used to test multiplier behavior under different execution strategies in hardware simulations.",
      "description_length": 340,
      "index": 506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.IO.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a nested monadic structure of input/output interfaces into a single monadic interface, effectively flattening the hierarchy. It operates on types involving `'a M.t IO.t`, where `M` is a monad, to enable working with collections of monadic interface values as if they were a single interface. A concrete use case is aggregating multiple register stages with independent control signals into a unified interface for synchronous data flow.",
      "description_length": 490,
      "index": 507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a counter circuit that computes quotient and remainder based on a divisor and configurable max values. It works with integer and modular arithmetic structures to support hardware-efficient counter design. Concrete use cases include implementing clock dividers or cycle counters in hardware descriptions where precise control over counter wrapping and output widths is required.",
      "description_length": 423,
      "index": 508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Args",
      "library": "hardcaml_circuits",
      "description": "This module provides utilities for structured manipulation of port-based hardware interfaces in CORDIC-based arctangent circuits, supporting operations like mapping, zipping, and equality checks on `Atan2.Args.t` records. It works with association lists keyed by port names or tags, enabling dynamic configuration and conversion to bit vectors, signals, or always-block logic for synthesis. Specific use cases include defining fixed-point input/output widths, wiring signals in hardware description code, and optimizing register assignments during circuit generation.",
      "description_length": 567,
      "index": 509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Cordic",
      "library": "hardcaml_circuits",
      "description": "Implements a CORDIC-based arctangent computation circuit using typed signal interfaces for input and output. It performs fixed-point arctangent calculations through iterative CORDIC rotation, operating on signals defined by port names, bit widths, and tags. Designed for integration into pipelined data paths where precise angle computation is required, such as in digital signal processing or coordinate transformation pipelines.",
      "description_length": 430,
      "index": 510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Test",
      "library": "hardcaml_circuits",
      "description": "Implements test cases for a CORDIC rotation circuit that validates combinational, pipelined, and iterative execution modes. It works with floating-point vector inputs and rotation angles, structured through the `Rotate_vector.Args` and `Results` types. This module is used to verify correctness of vector rotation computations in simulation environments with varying iteration counts and pipeline stages.",
      "description_length": 404,
      "index": 511,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Args",
      "library": "hardcaml_circuits",
      "description": "This module supports structural manipulation and transformation of CORDIC arctangent argument interfaces through mapping, zipping, and combinator-based operations. It operates on fixed-width signal and bitvector representations, along with association lists for port naming and width definitions, to enable hardware synthesis tasks like circuit design and signal handling. Specific use cases include defining and testing digital logic interfaces, register/wire creation, and structured signal manipulation in synthesizable hardware descriptions.",
      "description_length": 545,
      "index": 512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.IO.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps input/output fields of a register interface to an association list using port names as keys. It provides `to_alist` and `of_alist` functions to convert between the register interface and a list of named values. Use this when interfacing with external systems that require named signal access, such as testbenches or configuration tools.",
      "description_length": 362,
      "index": 513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.I.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a product of monadic values into a monadic product, effectively combining multiple monadic computations into a single computation. It operates on data structures that are both applicative functors and products, such as tuples or records with monadic components. A concrete use case is collecting results from multiple hardware description computations into a single result structure while preserving the monadic effects.",
      "description_length": 474,
      "index": 514,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Cordic",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based multiplication circuits with structured input/output interfaces. It operates on signal vectors and bit-width configurations to perform scalable fixed-point multiplication in combinational logic. Used for building arithmetic units, signal processing pipelines, and FPGA-based accelerators requiring iterative multiplication with controlled precision.",
      "description_length": 373,
      "index": 515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines register stage port names, widths, and tags for control signals in a hardware description. It works with lists of strings and integers to represent signal metadata. Concrete use cases include configuring register interfaces with specific signal names and bit widths for valid/ready control protocols.",
      "description_length": 320,
      "index": 516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signal values within an `Always` block using an interface-based structure. It supports creating registers and wires with specified properties, assigning signals to interface fields, and applying naming conventions to signals. Concrete use cases include building synchronous logic circuits and managing signal routing in hardware descriptions with clear field associations.",
      "description_length": 428,
      "index": 517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports operations on `Always.Variable.t` and `Signal.t` types, enabling direct signal assignment, register creation, and wire initialization. Concrete use cases include building and naming registers and wires within hardware description blocks, particularly for FIFO implementations.",
      "description_length": 408,
      "index": 518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Concrete use cases include building synchronous stack interfaces with named signals, initializing wires to specific values, and structuring always blocks for register transfers.",
      "description_length": 435,
      "index": 519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Args",
      "library": "hardcaml_circuits",
      "description": "This module provides utilities for constructing, transforming, and interfacing hardware signal records representing CORDIC-based cosine/sine circuit parameters. It supports operations like mapping, zipping, and associative list conversions over strongly-typed port records with named fields, bit-widths, and direction tags. These abstractions enable structured configuration of combinational logic interfaces and signal processing pipelines in hardware description code.",
      "description_length": 470,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.Sim",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based cosine and sine function evaluation in simulation with configurable algorithm versions and circuit parameters. Works with `t` type representing simulation instances, using input/output interfaces for signal handling. Useful for verifying trigonometric computations in digital signal processing or FPGA simulation workflows.",
      "description_length": 347,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Results",
      "library": "hardcaml_circuits",
      "description": "This module supports operations for transforming and analyzing structured circuit outputs from rectangular-to-polar coordinate conversions, including mapping, zipping, folding, and serialization to hardware interface signals. It works with record-like data structures representing CORDIC computation results, where fields encode signal metadata like port names, bit widths, and register tags for FPGA synthesis. These capabilities enable building arithmetic circuits and DSP pipelines that require precise control over polar coordinate transformations and signal routing in hardware descriptions.",
      "description_length": 596,
      "index": 522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.State.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module handles bit-level state manipulation for hardware circuits, providing operations to pack, unpack, and multiplex state interfaces. It works with bit vectors and state records to manage signal widths, constants, and selections. Use cases include constructing and validating fixed-width signal interfaces, selecting between multiple state vectors using priority or one-hot encoding, and converting between integers and bit representations.",
      "description_length": 448,
      "index": 523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Cordic",
      "library": "hardcaml_circuits",
      "description": "This module implements a CORDIC-based rectangular-to-polar coordinate conversion circuit using a parameterized configuration. It transforms input signals representing Cartesian coordinates (x, y) into polar coordinates (r, \u03b8) through iterative CORDIC rotation stages. The module is used to generate hardware circuits for applications such as digital signal processing, vector magnitude calculation, and phase angle determination in FPGA-based systems.",
      "description_length": 451,
      "index": 524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.M_with_valid.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe access to stack fields by port name through association lists. It supports converting structured stack data to and from lists of string-keyed value pairs, enabling dynamic field manipulation and inspection. Use cases include runtime introspection of stack interfaces and dynamic configuration based on port names.",
      "description_length": 349,
      "index": 525,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Cordic",
      "library": "hardcaml_circuits",
      "description": "This module implements a CORDIC-based polar-to-rectangular coordinate conversion circuit. It transforms magnitude and angle inputs into their corresponding Cartesian x and y components using iterative CORDIC rotation. The module operates on signal interfaces defined by the `I` and `O` submodules, which represent input and output port records with typed fields for each signal.",
      "description_length": 378,
      "index": 526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.O.All",
      "library": "hardcaml_circuits",
      "description": "Lifts monadic values within a list structure, transforming a list of monadic values into a monadic list. Works with lists of monadic values, combining them into a single monadic result. Useful for sequencing multiple monadic actions and collecting their results in a list.",
      "description_length": 272,
      "index": 527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to construct and manipulate a counter interface using bit vectors. It supports creating constant values, packing/unpacking interfaces to/from bit vectors, multiplexing and selecting between interfaces, and validating signal widths. Concrete use cases include implementing counters with custom divisors and ranges in hardware descriptions, where quotient and remainder outputs are derived from a wrapped count value.",
      "description_length": 447,
      "index": 528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating bit-level hardware interfaces, primarily through functions like `pack`, `unpack`, `mux`, and `concat`. It works with fixed-width bit vectors and structured interfaces composed of these vectors, enabling precise control over signal routing and dataflow in hardware designs. Concrete use cases include implementing arithmetic logic units, managing bus signals, and building custom control logic in digital circuits.",
      "description_length": 479,
      "index": 529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to convert a record of signals into an association list mapping field names to signals, and to construct such a record from an association list. It operates on data structures representing hardware interfaces with named ports. These functions are used to dynamically inspect or build hardware modules by name-based port association, such as connecting or analyzing CORDIC circuit components.",
      "description_length": 422,
      "index": 530,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Results",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for mapping, folding, and combinational manipulation of structured multiplication results\u2014tuples of up to five fixed-width integer values\u2014alongside utilities to convert between lists and hardware signal interfaces. It enables precise control over multiplier circuits via port configuration, register/wire creation, and dynamic field access, targeting hardware implementations requiring fixed-width arithmetic and signal processing. Use cases include synthesizing CORDIC-based multipliers with register-staged outputs and managing complex signal assignments in `Always` blocks for FPGA or ASIC pipelines.",
      "description_length": 635,
      "index": 531,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and managing FIFOs with low-latency data paths, including signal routing, width validation, and pipeline stage insertion. It operates on structured signal collections (`O.Of_signal.comb O.t`) to model register transfers and hardware interfaces, supporting tasks like multiplexing, concatenation, and constant assignment. Specific use cases include implementing high-speed buffering circuits, validating signal width consistency in data paths, and automating hierarchical naming conventions for inputs/outputs in register-transfer level designs.",
      "description_length": 613,
      "index": 532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and transforming structured signal interfaces in synchronous hardware circuits, focusing on signal packing, multiplexing, concatenation, and pipeline/register creation. It works with `Hardcaml.Signal.t` values and structured interface types (`O.Of_signal.comb O.t`) to enable precise signal routing, validation, and hierarchical naming. Specific use cases include building synchronous data paths, managing signal hierarchies with named fields, and implementing pipeline stages or register blocks with controlled input/output interfaces.",
      "description_length": 585,
      "index": 533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.I.All",
      "library": "hardcaml_circuits",
      "description": "Lifts monadic values within an interface structure, transforming a collection of monadic values into a monadic interface. Works with any monad `M` and interface type `'a I.t`. Useful for aggregating multiple signal computations into a single monadic interface in hardware description circuits.",
      "description_length": 293,
      "index": 534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and associated tags for a circuit interface. It provides direct access to lists of port names, port widths, and custom tags, all derived from the `I` module parameter. It is used to describe the input/output structure of a circuit, particularly in contexts like circuit simulation or hardware description where signal names and bit widths are required.",
      "description_length": 392,
      "index": 535,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.State.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct conversions between a state value and an association list indexed by field names. It operates on values of type `'a State.t` and string-keyed lists of pairs. These functions enable serialization and deserialization of state values for inspection or storage, using field names as keys.",
      "description_length": 312,
      "index": 536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.O",
      "library": "hardcaml_circuits",
      "description": "This module provides structured transformations and composition of division interfaces for CORDIC-based circuits, including mapping, zipping, and folding operations over typed signal and register data. It supports conversions between interface representations, port name and width specifications, and combinational logic manipulation, primarily for hardware implementations of division operations. Key use cases involve constructing and managing division circuits in hardware designs, where precise signal handling and interface composition are critical.",
      "description_length": 554,
      "index": 537,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.M_with_valid.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for manipulating structured data interfaces with validity signals, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions like priority and one-hot encoding. It works with composite data types represented as records or tuples of signals combined with validity bits. Concrete use cases include building and validating complex control logic in synchronous circuits, such as instruction decoders or state machines with multiple input sources.",
      "description_length": 509,
      "index": 538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module supports operations such as packing/unpacking hardware interfaces to/from bit vectors, multiplexing between interface values, creating registers and wires, and validating signal widths. It works with structured hardware interfaces represented as `I.Of_signal.t` values, which encapsulate both combinational and sequential signal elements. These capabilities are used to build and connect digital circuit components like arithmetic units, control logic, and state machines while ensuring signal width consistency.",
      "description_length": 524,
      "index": 539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names, widths, and associated tags for a circuit interface. It provides direct access to lists of port names, port widths, and predefined tags used in circuit construction. Concrete use cases include configuring circuit inputs/outputs with specific naming and sizing, and generating structured circuit metadata for tooling or documentation.",
      "description_length": 365,
      "index": 540,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to interface containers within an `Always` block. It supports operations like creating registers, wires, and assigning signals to variables, while enabling name customization for interface fields. Use it to build and manage structured hardware descriptions with named interfaces in synchronous logic.",
      "description_length": 363,
      "index": 541,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Args",
      "library": "hardcaml_circuits",
      "description": "This module provides utilities for transforming and inspecting hardware interface definitions in CORDIC-based hyperbolic function circuits, including mapping, zipping, and converting structured port records to association lists or signal interfaces. It operates on tagged port definitions (`Cosh_sinh.Args.t`) with associated names, widths, and bitvector representations, enforcing strict width validation and combinational logic constraints. These tools are specifically used for configuring fixed-point arithmetic circuits in FPGA/ASIC designs by enabling port configuration, signal wiring, and monadic aggregation of interface components.",
      "description_length": 641,
      "index": 542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module implements a synchronous stack interface using bit vectors, providing operations to pack, unpack, and multiplex stack elements. It supports fixed-width bit-level manipulation, including constant initialization, field concatenation, and priority/one-hot selection with validity signals. Concrete use cases include hardware circuit design for data path control and register stack management in digital logic systems.",
      "description_length": 426,
      "index": 543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps stack fields to and from association lists, using port names as keys. It operates on `'a O.t` structures, converting them to or from `(string * 'a) list` representations. Use this when interfacing with external systems that require named signal mappings, such as generating Verilog or connecting to simulation environments.",
      "description_length": 349,
      "index": 544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Sim",
      "library": "hardcaml_circuits",
      "description": "Implements a CORDIC-based rectangular-to-polar coordinate conversion circuit in simulation. Works with `t` type representing the circuit instance, using `Bits.t` for fixed-point input/output signals. Useful for FPGA-based signal processing applications requiring runtime-efficient angle and magnitude computation from Cartesian coordinates.",
      "description_length": 340,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "Converts between interface values and association lists indexed by field names. Works with polymorphic interface types and string-labeled data. Useful for serializing or dynamically constructing interfaces from named field-value pairs.",
      "description_length": 235,
      "index": 546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports operations on interfaces containing registers and wires, enabling direct signal assignment and naming conventions. Use cases include constructing synchronous logic blocks with named signals, initializing register interfaces, and wiring default-valued signals within an always block.",
      "description_length": 414,
      "index": 547,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to hardware interfaces using the Always API. It supports operations on `Always.Variable.t` and `Signal.t` types, enabling tasks like registering signals, creating wire variables, and assigning values within always blocks. Concrete use cases include building and naming hardware components such as FIFOs, registers, and signal wires directly in a hardware description.",
      "description_length": 430,
      "index": 548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and transforming structured signal interfaces in synchronous circuits, including signal packing/unpacking, multiplexing, concatenation, and pipeline/register creation. It works with `I.Of_signal.t` and `I.Of_signal.comb I.t` types to manage signal-level interface validation, naming, and connectivity through operators like `<==`. These capabilities are used to implement control logic, manage state elements, and wire hierarchical interfaces in hardware designs requiring precise signal manipulation.",
      "description_length": 550,
      "index": 549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides low-level operations for constructing and transforming hardware signal interfaces, including packing/unpacking into vectors, multiplexing/selecting between interfaces, register/pipeline creation, and signal width validation. It works with combinational logic representations (`comb`) and structured signal interfaces (`t`), enabling precise control over hardware circuit composition. These capabilities are used for implementing FIFO circuits, managing signal connectivity, and applying naming conventions to enhance signal traceability in hardware designs.",
      "description_length": 578,
      "index": 550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Test",
      "library": "hardcaml_circuits",
      "description": "Implements combinational, pipelined, and iterative CORDIC-based arctangent calculations for floating-point inputs. Works with `Atan2.Args.t` and `Atan2.Results.t` data types to compute 2D vector angles in simulation environments. Useful for FPGA-based signal processing and robotics applications requiring high-precision angle computations.",
      "description_length": 340,
      "index": 551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Args",
      "library": "hardcaml_circuits",
      "description": "This module provides utilities for manipulating fixed-field records representing multiplier circuit ports, supporting operations like mapping, folding, zipping, and conversion between signal and bit-level representations. It works with tagged structures that encode port names, widths, and associations, enabling tasks such as unsafe name-indexed transformations, equality checks, and list-based conversions. These tools are used in CORDIC implementations for configuring multiplier interfaces, routing signals, and managing register/wire declarations in hardware designs with fixed-width integer arithmetic.",
      "description_length": 608,
      "index": 552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.Sim",
      "library": "hardcaml_circuits",
      "description": "Implements fixed-point multiplication using CORDIC-based logic in simulation. Works with `t` values representing circuit inputs and outputs, along with associated signal references. Useful for simulating multiplication circuits within larger digital designs where precise arithmetic behavior is required.",
      "description_length": 304,
      "index": 553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of signals, such as constant assignment, multiplexing, concatenation, and register creation. It operates on structured signal types represented by `O.Of_signal.comb O.t` and `O.Of_signal.t`, enabling precise control over digital circuit components. These capabilities are utilized in tasks like building pipelined data paths, signal routing logic, and register transfer systems within Hardcaml-based designs.",
      "description_length": 503,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module implements a ROM-accumulator for computing weighted sums of bit vectors using distributed arithmetic without multipliers. It operates on fixed-width bit vectors (`comb`), performing operations like packing/unpacking, multiplexing, concatenation, and priority/one-hot selection on lists of interfaces. Concrete use cases include efficient hardware implementations of dot products and sum-of-products computations in digital signal processing or machine learning accelerators.",
      "description_length": 486,
      "index": 555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Cordic",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based division circuits with configurable parameters, transforming input interfaces into output interfaces using signal-level operations. Works with typed signal tuples, ports, and bit vectors to enable precise control over division logic synthesis. Used to build division circuits with configurable width, port naming, and stateful behavior in hardware descriptions.",
      "description_length": 385,
      "index": 556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps FIFO interface fields to named ports using association lists. It provides `to_alist` and `of_alist` functions that convert between FIFO interfaces and string-keyed value lists, enabling dynamic port manipulation. Use cases include runtime configuration of FIFO signals and introspection of port connections by name.",
      "description_length": 341,
      "index": 557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.I.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to manipulate fixed-width bitvector interfaces, including packing/unpacking to and from vectors, multiplexing, concatenation, and selection functions like priority and onehot selects. It works with types like `I.Of_bits.comb I.t` and `I.Of_bits.comb`, supporting concrete use cases such as building and validating FIFO control logic, routing data paths, and constructing constant or dynamic bitvector signals. Functions like `of_int`, `assert_widths`, and `validate` enable precise bit-level configuration and correctness checks.",
      "description_length": 561,
      "index": 558,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Args",
      "library": "hardcaml_circuits",
      "description": "The module provides higher-order functions for mapping, folding, zipping, and converting CORDIC rotation vector interfaces and argument records, alongside bit-level manipulation, signal wiring, and monadic",
      "description_length": 205,
      "index": 559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Test",
      "library": "hardcaml_circuits",
      "description": "Implements combinational, pipelined, and iterative CORDIC-based arctangent calculations using a provided simulation context. Works with floating-point input and output values structured through the Atan.Args and Atan.Results types. Useful for hardware-accelerated trigonometric computations in digital signal processing or FPGA-based numerical applications.",
      "description_length": 357,
      "index": 560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Sim",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based hyperbolic cosine and sine function evaluation with simulation capabilities. Works with fixed-point bit vectors and simulation state tracking. Used for hardware simulation of math functions in digital signal processing pipelines.",
      "description_length": 253,
      "index": 561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "Converts between a structured interface and an association list mapping field names to values. Works with any type `'a O.t` that represents a hardware circuit interface. Useful for serializing or deserializing circuit configurations using field names as keys.",
      "description_length": 259,
      "index": 562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.O.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively lifting the monad outside the structure. It operates on records of type `'a M.t O.t`, where `O` is a module defining an interface, and `M` is a monad. A concrete use case is combining multiple signal wires wrapped in a monad (e.g., `Signal.t option`) into a single monadic structure representing the whole interface.",
      "description_length": 432,
      "index": 563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector.Cordic",
      "library": "hardcaml_circuits",
      "description": "Implements vector rotation using the CORDIC algorithm, operating on fixed-point signal tuples representing Cartesian coordinates and rotation angles. Provides the `create` function to synthesize rotated x/y outputs from input vectors and angle specifications. Used to generate hardware circuits for coordinate transformations in digital signal processing and FPGA-based control systems.",
      "description_length": 386,
      "index": 564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module provides direct, unsafe access to stack interface fields by name, allowing conversion between interface values and association lists. It operates on interface types (`'a I.t`) and string-keyed lists of values. Use cases include dynamic field manipulation and debugging, where named access to stack interface components is required without compile-time safety guarantees.",
      "description_length": 382,
      "index": 565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to construct and manipulate hardware interfaces using the Always API, enabling direct assignment, registration, and wiring of signals within an interface. It works with interface types parameterized over `Hardcaml.Always.Variable.t`, allowing structured signal handling in hardware descriptions. Concrete use cases include building register interfaces with optional enables, assigning values within always blocks, and applying naming conventions to signals for clarity and integration.",
      "description_length": 516,
      "index": 566,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a ROM-accumulator circuit that evaluates linear combinations of inputs using distributed arithmetic. It works with lists of string-int pairs representing port names and their bit widths, along with lists of tags for circuit configuration. Concrete use cases include generating hardware descriptions for DSP blocks that compute weighted sums without multipliers, such as FIR filters or custom arithmetic units.",
      "description_length": 455,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh.Results",
      "library": "hardcaml_circuits",
      "description": "This module offers operations to transform and combine structured CORDIC results through mapping, zipping, folding, and scanning, along with dynamic field access and list conversions. It works with tagged collections of ports (with names and bit-widths) and signal interfaces derived from `Hardcaml.Signal.t`, enabling RTL design tasks like combinational logic, pipelining, and output port configuration for hyperbolic cosine/sine computations. These tools support aggregating and manipulating multiple result sets while maintaining safe or unsafe access to named fields in CORDIC pipelines.",
      "description_length": 591,
      "index": 568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.IO.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines register stage input/output ports with explicit names and widths, supporting the creation of structured datapath interfaces. It works with string and integer lists to represent port names and their bit widths, alongside a list of IO tags for control signals. Concrete use cases include specifying register inputs and outputs in hardware pipelines where named, typed signals are required for synthesis and simulation.",
      "description_length": 436,
      "index": 569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.State.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign values to hardware description interfaces using the Always API. It supports operations like creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Concrete use cases include building and managing synchronous logic blocks, connecting interface signals in an always block, and generating named signal identifiers for clarity in hardware designs.",
      "description_length": 454,
      "index": 570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.I.All",
      "library": "hardcaml_circuits",
      "description": "Lifts monadic values within an interface to a monadic interface, combining them into a single monadic result. Works with `'a M.t I.t`, where `I` is an interface type and `M` is a monad. Useful for aggregating multiple monadic computations across interface elements into a single computation.",
      "description_length": 291,
      "index": 571,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.M_with_valid.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for manipulating a synchronous stack interface with valid signals using bit vectors. It supports packing/unpacking interfaces to/from bit vectors, multiplexing and concatenation of interfaces, and selection operations like priority and onehot selects with optional defaults. Concrete use cases include building register files, FIFOs, and control logic units where field-level signal manipulation and selection are required.",
      "description_length": 455,
      "index": 572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Results",
      "library": "hardcaml_circuits",
      "description": "This module suite provides functional transformations and structural manipulations for interfacing with CORDIC-based division circuits. It operates on structured result types representing hardware signals with named ports and fixed bit widths, supporting conversions between association lists, tuples, and monadic representations. These operations facilitate tasks like circuit simulation, signal mapping, and register assignment in division-specific hardware implementations.",
      "description_length": 476,
      "index": 573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.IO.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module handles combinational logic operations on register interfaces with valid/ready control, supporting operations like multiplexing, concatenation, and priority/one-hot selection. It works with `comb IO.t` types representing structured register interfaces and provides functions to pack, unpack, validate, and manipulate signal widths. Concrete use cases include building and verifying complex register-based control logic, routing data paths based on selection signals, and ensuring correct signal width alignment in hardware designs.",
      "description_length": 543,
      "index": 574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block for a counter interface. It supports operations like assigning signals, creating registers with optional enable, and applying naming conventions to signals. Use cases include building hardware counters with division and modulo outputs, where signals need to be registered or wired with specific naming.",
      "description_length": 409,
      "index": 575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.I.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating a structured interface of signals, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with bit vectors and structured data types defined by the `comb` module, supporting operations like priority and one-hot selection, constant initialization, and width validation. Concrete use cases include building control logic, routing data paths, and constructing fixed-function arithmetic circuits with validated bit-widths.",
      "description_length": 524,
      "index": 576,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational and sequential logic operations for implementing counters that compute quotient and remainder values based on configurable divisors and wraparound thresholds. It operates on signal and register types (`comb` and `t`) to enable hardware synthesis, supporting bit-width management, signal concatenation/multiplexing, and pipeline/register creation. The design optimizes for power-of-two divisors and aligned thresholds, making it suitable for clock dividers, modulo-based state machines, or other hardware circuits requiring precise division tracking with controlled overflow behavior.",
      "description_length": 618,
      "index": 577,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps interface fields to string keys in an association list, enabling quick conversion between record-like structures and lists of named values. It operates on `I.t` types, which represent hardware interface signals, using `to_alist` to extract field names and values and `of_alist` to reconstruct interfaces from named value lists. Use this when dynamically inspecting or reconstructing hardware interfaces by name, such as in simulation or debugging tools.",
      "description_length": 479,
      "index": 578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.State.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module's functionality centers around constructing and manipulating structured hardware signal interfaces through operations like signal assignment, concatenation, multiplexing, register pipeline creation, and interface construction. It works with `State.Of_signal.t` values representing structured signals, supporting named wire interfaces and hierarchical naming conventions. Specific use cases include designing pipelined hardware components and managing complex signal hierarchies with consistent naming schemes.",
      "description_length": 521,
      "index": 579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Results",
      "library": "hardcaml_circuits",
      "description": "This module provides polymorphic transformations and hardware-oriented utilities for processing structured polar-to-rectangular conversion results, including mapping, zipping, folding, and conversions to lists or bit representations. It operates on typed signal interfaces composed of named ports and `Hardcaml.Signal.t` values, enabling both functional data manipulation and RTL-level operations like register assignment, port introspection, and bit-width specification. These capabilities are particularly useful for hardware generation workflows requiring structured signal processing or combinatorial logic synthesis.",
      "description_length": 621,
      "index": 580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.I",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations\u2014such as mapping, zipping, and folding over interface fields\u2014alongside bit-level manipulation and signal wiring capabilities. It works with structured hardware interfaces featuring named ports and defined widths, supporting RTL-level circuit construction for fixed-point `atan2` implementations in FPGA and ASIC design flows. Key utilities include monadic composition for error handling, port configuration, and structured signal assignment within always blocks, enabling precise hardware description and verification.",
      "description_length": 569,
      "index": 581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.Args",
      "library": "hardcaml_circuits",
      "description": "This module provides functional combinators and transformations for manipulating structured hardware interfaces (`Rect_to_polar.Args.t`) in CORDIC-based rectangular-to-polar conversion circuits, supporting operations like mapping, zipping, and monadic sequencing over typed input/output ports. It includes utilities for bit-level interface construction, dynamic inspection, and metadata configuration (e.g., signal names and widths), enabling the generation of coordinate transformation circuits using combinational logic and Always API workflows. These tools are critical for defining port-level behavior, simulating signal interactions, and synthesizing hardware for Cartesian-to-polar coordinate conversion.",
      "description_length": 710,
      "index": 582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Cordic",
      "library": "hardcaml_circuits",
      "description": "Implements a CORDIC-based inverse hyperbolic tangent function with fixed-point arithmetic, operating on typed signal interfaces and tagged port structures. It provides a `create` function that synthesizes the atanh circuit from a configuration and input interface, producing an output interface with mapped port metadata and signal logic. Designed for FPGA signal processing pipelines requiring precise hyperbolic arctangent computation with configurable bit-widths and pipeline stages.",
      "description_length": 486,
      "index": 583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.O",
      "library": "hardcaml_circuits",
      "description": "This module enables typed field manipulation, association list conversion, and structural composition of CORDIC arctangent interfaces, focusing on port metadata transformations and zipped record operations. It operates on fixed-precision signal representations, combining combinational logic with sequential register management to enforce bit-width constraints and port naming conventions. These utilities directly support FPGA/ASIC implementations of fixed-point trigonometric pipelines, including circuit validation, signal serialization, and hierarchical module composition with precise timing control.",
      "description_length": 605,
      "index": 584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module enables the construction of hardware circuits through bit-level operations, multiplexing, and register pipelines using signal and register interfaces. It operates on types representing hardware signals and supports structured naming conventions for signal wires, facilitating the implementation of arithmetic circuits that compute linear combinations via distributed arithmetic techniques, such as ROM-based accumulation with add/shift operations and precomputed constants. These circuits are particularly suited for applications requiring efficient multiplier-free computation of expressions like `a0.x0 + a1.x1 + ... + an.xn`.",
      "description_length": 640,
      "index": 585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the names and widths of ports for a fast FIFO circuit, providing direct access to port metadata as lists of strings and integers. It works with basic string and integer types to describe hardware interface properties. Use this to inspect or generate signal names and sizes when integrating the FIFO with other hardware components or testbenches.",
      "description_length": 365,
      "index": 586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Sim",
      "library": "hardcaml_circuits",
      "description": "Implements polar-to-rectangular coordinate conversion using CORDIC algorithms in simulation. Works with `t` type representing simulation state, and interfaces via input/output ports for angle and magnitude signals. Used to model and simulate CORDIC-based trigonometric conversions in digital circuit designs.",
      "description_length": 308,
      "index": 587,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.O.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block, specifically for a counter interface. It supports assigning signals, extracting values, and applying naming conventions to signals with optional prefixes and suffixes. Concrete use cases include building configurable counters with division and remainder outputs, where registers track the counter state and wires carry the quotient and remainder signals.",
      "description_length": 462,
      "index": 588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block for a specific interface type `I`. It supports operations like assigning signals, creating registers with optional enable, and applying names to interface fields. Concrete use cases include building synchronous datapath elements with named signals and connecting interface-based logic in an always block.",
      "description_length": 411,
      "index": 589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.O.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines the interface for a fast FIFO circuit by specifying port names and their corresponding widths. It provides concrete values for port names, widths, and tags used in the FIFO implementation. Use this to configure and instantiate FIFOs with precise signal naming and bit-width definitions for hardware synthesis.",
      "description_length": 329,
      "index": 590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.I",
      "library": "hardcaml_circuits",
      "description": "This interface provides structural and introspective operations for manipulating fixed-width signal interfaces in CORDIC-based inverse hyperbolic tangent circuits, including mapping, zipping, equality checks, and metadata access. It works with typed hardware signal representations (`Atanh.I.t`), association lists, and bitvector combinators, while supporting transformations across combinational logic and sequential blocks. These tools enable precise circuit construction, verification, and signal routing in digital designs requiring hyperbolic function approximations.",
      "description_length": 572,
      "index": 591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.Args",
      "library": "hardcaml_circuits",
      "description": "This module provides structured transformations and validation for hardware interface descriptions used in CORDIC-based polar-to-rectangular conversion circuits. It operates on typed records representing signal ports with named fields, widths, and tags, enabling operations like mapping, zipping, and bit-level manipulation alongside conversions to association lists or combinational logic. Key use cases include FPGA signal aggregation, RTL-level correctness verification, and structured handling of trigonometric function interfaces in hardware description languages.",
      "description_length": 569,
      "index": 592,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.I.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to construct and manipulate hardware interfaces using the Always API, specifically for register and wire variables. It supports operations like assigning signals to variables, creating registers with optional enable, and naming interface fields. Use cases include building structured hardware descriptions with named signals and managing state in synchronous logic circuits.",
      "description_length": 405,
      "index": 593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan.Results",
      "library": "hardcaml_circuits",
      "description": "This module provides functional transformations and low-level manipulation operations for structured CORDIC arctangent computation outputs, primarily working with tagged tuples and association lists that map port names to bit vectors or signals. It supports use cases like hardware pipeline construction, fixed-point arctangent result aggregation, and dynamic port-level signal routing through combinational logic and bit-level operations. Key data structures include structured result interfaces (`t` type), port metadata descriptions, and signal representations for digital design implementation.",
      "description_length": 598,
      "index": 594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul.O",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to manipulate structured hardware interfaces composed of tagged ports with named fields and bit widths, supporting combinational logic transformations. It includes mapping, zipping, folding, and scanning over tuples and lists of these interfaces, along with conversions to and from association lists for introspection or serialization. These utilities are used to build multiplier circuits and CORDIC-based designs, enabling RTL synthesis, pipelined signal routing, and simulation of digital systems with precise control over port configurations and combinational signal flows.",
      "description_length": 609,
      "index": 595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div.Test",
      "library": "hardcaml_circuits",
      "description": "Implements division using CORDIC algorithms in combinational, pipelined, and iterative forms. Works with floating-point numbers and simulation contexts defined by the Div module. Useful for hardware simulation and high-throughput division operations in digital circuit design.",
      "description_length": 276,
      "index": 596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect.I",
      "library": "hardcaml_circuits",
      "description": "This module provides structured transformations for polar-to-rectangular coordinate conversion interfaces, supporting operations like mapping, zipping, and folding over tagged signal groups with named ports and bit-widths. It works with polymorphic records and lists of hardware signals to enable precise routing, packing/unpacking, and validation in CORDIC-based coordinate transformations. Specific use cases include configuring signal interfaces for coordinate conversion logic and managing dataflow in hardware circuits implementing trigonometric or vector transformations.",
      "description_length": 577,
      "index": 597,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.O.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to construct and manipulate fixed-width bitvector interfaces for CORDIC computations, including packing/unpacking, multiplexing, and concatenation. It works with `t` values representing CORDIC input/output interfaces and `comb` values for combinational logic signals. Concrete use cases include building CORDIC pipelines with muxing between multiple instances, validating signal widths, and converting between integer constants and bitvector representations for trigonometric or hyperbolic function evaluation.",
      "description_length": 542,
      "index": 598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module enables combinational and sequential circuit construction through signal assignment, multiplexing, and register insertion, operating on structured hardware interfaces and signal networks. It supports hierarchical design via named signal routing and pipeline creation, particularly useful for implementing bit-level arithmetic data paths or integrating with precomputed ROM tables in distributed arithmetic computations.",
      "description_length": 431,
      "index": 599,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar.O",
      "library": "hardcaml_circuits",
      "description": "This module supports constructing and transforming rectangular-to-polar conversion interfaces in CORDIC circuits through field-wise operations, zipping, folding, and conversions between structured signal tuples and list-based representations. It operates on hardware port interfaces represented as tagged signal tuples with associated names and bit-widths, alongside fixed-point coordinate and angle data. These capabilities enable applications in FPGA-based digital signal processing, circuit simulation, and register assignment workflows for hardware description.",
      "description_length": 565,
      "index": 600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.O.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for constructing and manipulating fixed-width signal interfaces. It supports operations like packing/unpacking signals to vectors, multiplexing, concatenation, and priority/onehot selection, working with types like `comb` and `t` that represent hardware signals. Concrete use cases include building control logic, routing data paths, and assembling complex signal structures from individual bits or fields.",
      "description_length": 458,
      "index": 601,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh.Test",
      "library": "hardcaml_circuits",
      "description": "Implements fixed-precision atanh(x) using CORDIC rotation methods. Works with floating-point inputs and produces floating-point outputs. Useful for hardware-accelerated hyperbolic tangent inverse calculations in signal processing and neural network applications.",
      "description_length": 262,
      "index": 602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.O.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for constructing and manipulating counter circuits that compute quotient and remainder values based on a configurable divisor, supporting signal packing/unpacking, multiplexing, register pipelines, and selection logic. It operates on hardware signals (`Signal.t`) within structured interfaces, enabling direct specification of `max_quotient`, `max_remainder`, and initialization values for wrapped counters. It is particularly useful for hardware optimization scenarios where divisors are powers of two, or when `max_remainder` equals `divisor - 1`, allowing simplified logic for clock dividers, state machines, or modulo-based control logic.",
      "description_length": 674,
      "index": 603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.I.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module supports structured composition of signal interfaces through multiplexing, concatenation, and priority/onehot selection, alongside creating registers and pipelines with control signals. It operates on signal interfaces and register types, enabling precise manipulation of hardware descriptions. Typical applications include building pipelined data paths, connecting modules with named signal hierarchies, and implementing control logic with valid/ready handshaking.",
      "description_length": 477,
      "index": 604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2.Cordic",
      "library": "hardcaml_circuits",
      "description": "This module implements a CORDIC-based `atan2` circuit generator that computes the arctangent of two input signals using iterative rotation. It operates on typed hardware interfaces with fixed-point signal representations, supporting configurable precision and iteration counts. Concrete use cases include synthesizing trigonometric computation units for FPGA-based DSP pipelines and robotics control systems requiring real-time angle calculations from Cartesian coordinates.",
      "description_length": 474,
      "index": 605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin.I",
      "library": "hardcaml_circuits",
      "description": "This module provides structured transformations and combinators for hardware interface descriptions involving tagged cosine-sine signal ports with defined bit-widths. It supports operations like mapping, zipping, and converting between interface lists and hierarchical structures, alongside utilities for bit-level construction, monadic composition, and unsafe name-based port association. These capabilities enable CORDIC-based trigonometric circuit synthesis, particularly for managing register/wire logic in sequential blocks and defining port configurations for cosine-sine computations.",
      "description_length": 591,
      "index": 606,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.I.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a ROM-accumulator circuit that computes weighted sums using distributed arithmetic. It works with lists of string-int pairs representing signal names and bit widths, and lists of tags for circuit configuration. Concrete use cases include specifying input/output interfaces for hardware blocks that perform multiplication-free arithmetic operations based on precomputed ROM values.",
      "description_length": 426,
      "index": 607,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module directly maps CORDIC interface fields to and from association lists, using port names as keys. It supports converting structured CORDIC data to string-keyed lists and reconstructing interfaces from such lists. Use this when serializing CORDIC configurations or dynamically wiring circuits based on named port mappings.",
      "description_length": 330,
      "index": 608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cosh_sinh",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based computation of hyperbolic cosine and sine functions with fixed-point arithmetic, using structured hardware interfaces and typed signals. It provides circuit creation, input/output configuration, and simulation for FPGA-based digital signal processing pipelines. Concrete use cases include synthesizing high-throughput hyperbolic function units and generating verified testbenches with annotated signal traces.",
      "description_length": 433,
      "index": 609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Arbiters.Round_robin_with_priority.Count_zeros",
      "library": "hardcaml_circuits",
      "description": "Implements a round-robin arbiter using a trailing zeros counter and bit masking to select the next active requester relative to a given index. Operates on bit vectors and integer indices, wrapping around when reaching the end. Useful for hardware scheduling tasks where requesters must be selected in a fair, prioritized order with wrap-around behavior.",
      "description_length": 353,
      "index": 610,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Arbiters.Round_robin_with_priority.Onehot_cleaner",
      "library": "hardcaml_circuits",
      "description": "This module implements a round-robin arbiter that converts a priority vector into a one-hot selection signal. It provides combinational and sequential functions to select the first active requester starting from a given index, wrapping around as needed. It operates on bit vectors representing request sources and is used in arbitration logic where priority and fairness are required.",
      "description_length": 384,
      "index": 611,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.IO",
      "library": "hardcaml_circuits",
      "description": "This module enables structured manipulation and serialization of hardware register interfaces through operations like mapping, zipping, and converting between association lists, S-expressions, and signal representations. It operates on register ports with named access, explicit bit widths, and tag-based indexing, while supporting monadic combinators for tasks like folding, scanning, and flattening nested control logic. Key use cases include pipeline control, multiplexing, synthesis-friendly signal routing, and register staging with valid/ready handshaking.",
      "description_length": 562,
      "index": 612,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.O",
      "library": "hardcaml_circuits",
      "description": "This module enables structural manipulation of hardware interface descriptions through operations like mapping, zipping, and converting between stack interfaces (`'a O.t`), association lists, and signal lists, with specialized handling for port names, bit-widths, and tags. It supports combinational logic and synchronous circuit design via functions for signal folding, multiplexing, and interface adaptation, along with bit-level operations and monadic value lifting. Use cases include RTL generation, simulation integration, and constructing hardware stacks with structured naming and register/wire declarations using the Always API.",
      "description_length": 636,
      "index": 613,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.O",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for manipulating structured FIFO interfaces with named and typed ports, supporting tasks like multi-input mapping, folding, and conversion between signal lists and bitvectors. It operates on structured signal types (`O.t`) that include metadata for dynamic configuration, introspection, and serialization via port names, widths, and tags. Specific use cases include constructing low-latency FIFO circuits, routing signals, aggregating data paths, and implementing control logic in hardware designs requiring precise metadata-driven configuration.",
      "description_length": 598,
      "index": 614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan",
      "library": "hardcaml_circuits",
      "description": "This module implements fixed-point arctangent computation using CORDIC rotation, operating on typed signal interfaces with defined port names and bit widths. It provides functions to configure inputs and outputs for CORDIC-based angle calculations, supporting use cases like FPGA-accelerated trigonometric pipelines and coordinate transformations. Key operations include circuit creation, interface mapping, and structured signal routing for digital signal processing and hardware synthesis tasks.",
      "description_length": 497,
      "index": 615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make.I",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for manipulating register interfaces using port names or tags, enabling conversions between structured data and association lists, equality checks, and dynamic interface construction. It works with fixed-bit-width interface types (`I.t`), signals, and always blocks, supporting combinational logic, bit-level operations, and monadic aggregation. These utilities are used to define hardware datapaths with control signals (valid/ready), manage register stages, and specify signal metadata (names, widths) in synchronous circuit design.",
      "description_length": 566,
      "index": 616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.O",
      "library": "hardcaml_circuits",
      "description": "The module provides functions for mapping, zipping, folding, and converting between structured tuples, lists, and association lists of circuit interfaces (`O.t`), which represent tagged ports with associated names and bit widths. It supports combinatorial logic, ROM-based arithmetic operations, and signal manipulation through higher-order combinators, enabling tasks like composing distributed arithmetic circuits, transforming bit-level representations, and defining register interfaces or DSP blocks using precomputed ROM values. Specific use cases include synthesizing multiplier-free dot-product computations, optimizing hardware pipelines via structured signal assignment, and converting between hierarchical port configurations and flat signal lists.",
      "description_length": 758,
      "index": 617,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Div",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based division circuits with configurable parameters, transforming input interfaces into output interfaces using signal-level operations. Works with typed signal tuples, ports, and bit vectors to enable precise control over division logic synthesis. Used to build division circuits with configurable width, port naming, and stateful behavior in hardware descriptions.",
      "description_length": 385,
      "index": 618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Cos_sin",
      "library": "hardcaml_circuits",
      "description": "This module implements CORDIC-based cosine and sine computation with configurable iteration counts and fixed-point precision. It operates on `Signal.t` inputs and outputs encapsulated in `I` and `O` record types, representing angle inputs and computed sine/cosine outputs. It is used to generate synthesizable RTL for FPGA or ASIC implementations of trigonometric functions, supporting pipelining and bit-width optimization.",
      "description_length": 424,
      "index": 619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.I",
      "library": "hardcaml_circuits",
      "description": "This module implements structural transformations and combinational logic for hardware interfaces in CORDIC circuits, supporting operations like multi-input mapping, folding, zipping, and bit-level manipulation. It works with signal interfaces (`I.t`), port metadata (names, widths, tags), and validated bit vectors to enable circuit construction, configuration, and signal assignment. Key use cases include building hyperbolic/trigonometric function generators, managing CORDIC gain scaling through precompensated constants, and ensuring convergence in iterative rotation schemes via fixed-iteration hyperbolic mode adjustments.",
      "description_length": 629,
      "index": 620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.O",
      "library": "hardcaml_circuits",
      "description": "This module enables structured manipulation of hardware interfaces through operations like mapping, zipping, and folding over port names, tags, and widths, while supporting transformations between lists of interfaces and interfaces of lists. It facilitates combinational logic design, bit-level routing, and synchronous circuit construction with registers and wires, alongside metadata-driven configuration for port naming and signal widths.",
      "description_length": 441,
      "index": 621,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atanh",
      "library": "hardcaml_circuits",
      "description": "Implements a CORDIC-based inverse hyperbolic tangent function with fixed-point arithmetic, operating on typed signal interfaces and tagged port structures. It provides a `create` function that synthesizes the atanh circuit from a configuration and input interface, producing an output interface with mapped port metadata and signal logic. Designed for FPGA signal processing pipelines requiring precise hyperbolic arctangent computation with configurable bit-widths and pipeline stages.",
      "description_length": 486,
      "index": 622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.I",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for creating and manipulating counters that compute quotient and remainder values with configurable maximums, supporting wrap-around behavior when thresholds are reached. It works with bit vectors, signals, and combinational logic to enable hardware synthesis tasks like custom divisor-based counters, multiplexing, and signal packing/unpacking. Specific use cases include optimizing counters with power-of-two divisors, configuring signal port widths/names, and managing register/wire interactions in always blocks for precise arithmetic behavior.",
      "description_length": 580,
      "index": 623,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Arbiters.Round_robin_with_priority.Log_shift",
      "library": "hardcaml_circuits",
      "description": "Implements a round-robin arbiter with priority selection by rotating input signals based on a given index and selecting the highest-priority active input. Works with arrays of signals and integer indices to determine selection order. Useful for hardware scheduling tasks where fairness and dynamic priority adjustment are required, such as resource allocation in digital circuits.",
      "description_length": 380,
      "index": 624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.M_with_valid",
      "library": "hardcaml_circuits",
      "description": "This module supports operations for manipulating structured interface data with associated validity signals in synchronous hardware circuits. It works with `Signal.t` and interface containers to enable tasks like multiplexing, priority selection, and metadata-driven configuration through combinators for mapping, conversion between lists/S-expressions, and control logic. Key use cases include dynamic interface packing/unpacking, RTL introspection, and routing signals with validity-aware pipelines.",
      "description_length": 501,
      "index": 625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make.I",
      "library": "hardcaml_circuits",
      "description": "This module supports the composition, transformation, and inspection of structured hardware interfaces with named, typed ports using list-like operations (map, zip, iter), combinational logic patterns (folding, scanning, priority encoding), and bitvector manipulations. It operates on fixed-width bitvectors and monadic interface structures (`I.t`) to enable register insertion, ROM-based computation, and dynamic signal routing. Key applications include synthesizing multiplier-free linear accumulators via distributed arithmetic\u2014where constants and input bits form ROM addresses to compute weighted sums\u2014and building hierarchical circuits with structured port configurations.",
      "description_length": 677,
      "index": 626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make.O",
      "library": "hardcaml_circuits",
      "description": "This module provides structural transformations and functional combinators for hardware interfaces, enabling precise manipulation of signal and port data structures through operations like mapping, zipping, and association list conversions. It supports dynamic module assembly and analysis by handling named port metadata, iterative transformations, and combinational logic construction. Key use cases include implementing CORDIC pipelines with fixed iteration counts, managing convergence requirements in hyperbolic mode, and integrating register pipelining with signal routing for bitvector-centric hardware designs.",
      "description_length": 618,
      "index": 627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rotate_vector",
      "library": "hardcaml_circuits",
      "description": "Implements vector rotation using the CORDIC algorithm, providing `create`, `configure_input`, and `configure_output` to synthesize and wire fixed-point coordinate transformations. Works with structured signal interfaces (`I.t`, `O.t`) representing Cartesian vectors and rotation angles, enabling precise control over hardware generation for coordinate transformations. Used in FPGA-based systems for digital signal processing and control, where accurate vector rotation and signal aggregation are required.",
      "description_length": 506,
      "index": 628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.I",
      "library": "hardcaml_circuits",
      "description": "This module provides operations for structured hardware interfaces with named ports and bit widths, including multi-input mapping (`map3`\u2013`map5`), folding (`fold`, `fold2`), scanning (`scan`,",
      "description_length": 191,
      "index": 629,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make.O",
      "library": "hardcaml_circuits",
      "description": "This module supports operations for composing and transforming structured hardware interfaces representing quotient-remainder counters, including mapping, zipping, folding, and converting between signal lists and port metadata. It operates on bit vectors, signals, and counter configurations with divisor/max quotient-remainder parameters, enabling combinational logic and counter synthesis with wrap-around behavior. Specific use cases include building optimized hardware counters for power-of-two divisors, configurable modulus circuits, and finite state machines requiring precise division-based control logic.",
      "description_length": 613,
      "index": 630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make.State",
      "library": "hardcaml_circuits",
      "description": "This module provides functional transformations and combinators for manipulating typed state values representing hardware interface ports, including mapping, zipping, folding, and monadic operations over `State.t` structures. It supports circuit design workflows through synchronous logic construction (via Always API integrations) and port metadata introspection for configuration tasks. Additional utilities enable serialization, signal assignment, and structured combinations of stateful computations for hardware synthesis.",
      "description_length": 527,
      "index": 631,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Rect_to_polar",
      "library": "hardcaml_circuits",
      "description": "This module implements rectangular-to-polar coordinate conversion using CORDIC algorithms, operating on fixed-point signal types for hardware synthesis. It provides functions to configure inputs and outputs for CORDIC stages, and to create and simulate circuits that convert Cartesian coordinates (x, y) into polar form (magnitude r, angle \u03b8). Concrete applications include FPGA-based motor control, radar signal processing, and real-time vector magnitude computation in DSP pipelines.",
      "description_length": 485,
      "index": 632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Atan2",
      "library": "hardcaml_circuits",
      "description": "This module implements a CORDIC-based arctangent circuit for computing angles from Cartesian coordinates, operating on fixed-point signal interfaces with configurable precision. It provides functions to transform input/output interfaces, wire signals, and generate RTL or simulation models suitable for FPGA synthesis and verification. Concrete use cases include real-time angle calculation in robotics control systems and DSP pipelines where Cartesian-to-polar conversion is required.",
      "description_length": 485,
      "index": 633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make.I",
      "library": "hardcaml_circuits",
      "description": "This module offers functional transformations for structured hardware interfaces, including mapping, zipping, and folding operations, alongside conversions between interfaces and lists, tag-based field indexing, and unsafe named port access. It operates on fixed-width signals, registers, and wires encapsulated in interface types, supporting equality checks, port naming, and width tracking. These utilities are used in synchronous circuit design to manipulate signal hierarchies, implement combinational logic, and configure port signals within always blocks.",
      "description_length": 561,
      "index": 634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Polar_to_rect",
      "library": "hardcaml_circuits",
      "description": "This module implements CORDIC-based polar-to-rectangular coordinate conversion with specialized functions for hardware signal transformation. It operates on structured signal interfaces with typed fields for magnitude and angle inputs, producing Cartesian x and y outputs as `Hardcaml.Signal.t` values. Concrete use cases include FPGA-based trigonometric computation, vector rotation synthesis, and RTL-level coordinate conversion in digital signal processing pipelines.",
      "description_length": 470,
      "index": 635,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make.I",
      "library": "hardcaml_circuits",
      "description": "This module implements structural manipulation and dynamic inspection of hardware interfaces through mapping, zipping, and list conversions, while exposing combinators for stream processing with folding and scanning operations. It operates on hardware interface streams (`I.t`), FIFO port metadata, and bitvector signals, enabling precise signal-width control and combinational logic design for FIFO circuits. Specific utilities include Always block-based signal assignment, runtime introspection of port names/widths, and bitvector transformations, targeting hardware simulation, synthesis, and integration workflows.",
      "description_length": 618,
      "index": 636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make.Mul",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC-based fixed-point multiplication circuits with structured input/output interfaces. It transforms multiplier port configurations into combinational logic, supporting synthesis of scalable arithmetic units and signal processing pipelines. Works with fixed-width signal vectors and structured port definitions to enable FPGA or ASIC implementations requiring iterative multiplication with controlled precision.",
      "description_length": 425,
      "index": 637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions.Make",
      "library": "hardcaml_circuits",
      "description": "This module provides CORDIC-based implementations of mathematical functions including sine, cosine, arctangent, hyperbolic functions, vector rotation, and coordinate conversions. It operates on fixed-point signal interfaces with structured input/output records, supporting FPGA synthesis and simulation through functions that wire signals, configure ports, and generate RTL. Concrete use cases include hardware-accelerated DSP pipelines, robotics control systems, and FPGA-based trigonometric computation for digital signal processing.",
      "description_length": 535,
      "index": 638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Config",
      "library": "hardcaml_circuits",
      "description": "This module defines configuration parameters for a CORDIC core, specifying the architecture type and number of iterations. It works with integer and architecture description data types to customize the CORDIC algorithm's behavior for trigonometric or hyperbolic computations. Use this to set up fixed iteration counts and select between rotation or vectoring modes in hardware implementations.",
      "description_length": 393,
      "index": 639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Mode",
      "library": "hardcaml_circuits",
      "description": "This module defines the operational modes for a CORDIC algorithm implementation, supporting rotation, vectoring, and inverse hyperbolic functions. It provides functions to list all modes, convert a mode to an S-expression, and map a mode to a hardware signal representation. These operations are used to configure and control the behavior of the CORDIC hardware module during circuit synthesis and simulation.",
      "description_length": 409,
      "index": 640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Divider.Make",
      "library": "hardcaml_circuits",
      "description": "Implements a parameterized divider circuit with support for hierarchical instantiation and signal routing. Works with hardware interfaces defined by the `I` and `O` modules, using `Signal.t` values for input and output ports. Designed for use in synchronous digital design flows to perform division operations in hardware, with configurable instance names and integration into larger circuit topologies.",
      "description_length": 403,
      "index": 641,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Index_vec.Make_tagged",
      "library": "hardcaml_circuits",
      "description": "This module implements a hardware circuit for managing a dynamic vector of indices with associated tags, supporting insertions, deletions, and lookups. It provides signals for current indexes and tags, insertion/deletion positions, and length status flags like full and empty. Use cases include managing dynamic buffer allocations or tracking active slots in a pipeline with metadata.",
      "description_length": 384,
      "index": 642,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.System",
      "library": "hardcaml_circuits",
      "description": "Represents CORDIC computation modes (circular, linear, hyperbolic) with direct mapping to signal values for hardware configuration. Converts mode values to signals and serializes them for debugging or configuration purposes. Used to select and control the operational behavior of a CORDIC circuit in hardware descriptions.",
      "description_length": 322,
      "index": 643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Make",
      "library": "hardcaml_circuits",
      "description": "This module implements CORDIC circuits for computing trigonometric and hyperbolic functions via iterative shift-add operations, supporting both rotation and vectoring modes. It works with fixed-point numeric representations and signal interfaces to manage barrel shifting, adder stages, and lookup tables for angle constants. Concrete use cases include synthesizing sine/cosine generators, implementing arctangent calculators, and configuring hyperbolic mode iterations with adjusted index sequences to ensure convergence.",
      "description_length": 522,
      "index": 644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Onehot_clean.All",
      "library": "hardcaml_circuits",
      "description": "This module provides a function `all` that transforms a structure containing monadic values into a monadic value containing the structure, specifically for one-hot encoded data. It operates on one-hot vectors, ensuring correct monadic lifting while preserving the one-hot property. Concrete use cases include composing circuits that handle encoded control signals or state representations where only one bit is active at a time.",
      "description_length": 428,
      "index": 645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Lfsr.Op",
      "library": "hardcaml_circuits",
      "description": "This module defines operations for constructing linear feedback shift registers (LFSRs), specifically providing `Xor` and `Xnor` as feedback types. It includes functions to list all available operations and convert them to S-expressions. These operations determine the feedback logic used in LFSR circuits to generate pseudo-random sequences.",
      "description_length": 342,
      "index": 646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Mul.Config",
      "library": "hardcaml_circuits",
      "description": "This module defines configuration options for multiplier implementations, specifically supporting Dadda and Wallace tree reduction strategies. It provides a list of all available configurations and S-expression serialization for the configuration type. Useful for selecting and persisting multiplier architectures during circuit design and synthesis.",
      "description_length": 350,
      "index": 647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Onehot_clean.Make_comb",
      "library": "hardcaml_circuits",
      "description": "This module provides combinational logic operations for converting and manipulating one-hot encoded vectors. It supports operations like packing/unpacking interfaces into vectors, multiplexing, concatenation, and priority or one-hot selection with optional branching factors. The module works with one-hot encoded data types structured as `comb` signals, ensuring correct bit widths and validation for use cases such as hardware signal routing and control logic design.",
      "description_length": 469,
      "index": 648,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo.Make",
      "library": "hardcaml_circuits",
      "description": "This module implements a low-latency, combinational FIFO circuit with support for cut-through behavior and configurable capacity. It operates on hardware signal interfaces (`I.t` and `O.t`) to manage data flow, enabling direct instantiation within scoped hardware designs. Concrete use cases include building high-performance FIFOs for data buffering, stream processing pipelines, and control logic in FPGA or ASIC designs where minimal latency and precise signal timing are critical.",
      "description_length": 484,
      "index": 649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Sorting_network.Config",
      "library": "hardcaml_circuits",
      "description": "This module defines the configuration types for sorting networks, specifically supporting `Bitonic_sort` and `Odd_even_merge_sort`. It provides a list of all available configurations and S-expression serialization for the configuration type. Use cases include selecting and serializing the sorting network algorithm in hardware descriptions.",
      "description_length": 341,
      "index": 650,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Onehot_clean.Unsafe_assoc_by_port_name",
      "library": "hardcaml_circuits",
      "description": "This module maps between onehot-encoded signals and named ports by converting records to and from association lists. It operates on tuples of signals paired with string identifiers, producing a structured interface where each field corresponds to a named port. Use this when synthesizing hardware circuits that require onehot encoding with explicit port naming, such as state machine encoders or multiplexer control logic.",
      "description_length": 422,
      "index": 651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register.Make",
      "library": "hardcaml_circuits",
      "description": "This module implements register stages with control flow handshaking for hardware datapaths. It provides functions to create and manage register interfaces with named ports and bit-level signals, supporting operations like mapping, zipping, and converting between structured data and signal representations. Used for pipeline control, signal routing, and register staging with valid/ready synchronization in synchronous circuit design.",
      "description_length": 435,
      "index": 652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Index_vec.Make",
      "library": "hardcaml_circuits",
      "description": "This module implements a hardware circuit for managing a dynamic vector of indexes, supporting insertions, deletions, and lookups at arbitrary positions. It tracks indexes for external data storage (e.g., RAM) and optionally associates movable tags with each index, allowing tag updates synchronized with index movement. Use cases include managing active slots in a queue or stack structure, or tracking dynamic allocations in hardware-accelerated systems.",
      "description_length": 456,
      "index": 653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack.Make",
      "library": "hardcaml_circuits",
      "description": "This module implements a synchronous stack with write-before-read semantics, supporting configurable read latency. It operates on hardware interfaces composed of fixed-width signals, registers, and wires, using validity-aware data structures for synchronous circuit design. Concrete use cases include RTL generation for memory stacks, simulation integration with named port access, and constructing pipelined hardware structures with structured signal hierarchies.",
      "description_length": 464,
      "index": 654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Pipelined_adder.Short_latency",
      "library": "hardcaml_circuits",
      "description": "Implements a pipelined adder with a fixed 2-cycle latency for high-performance addition on FPGAs. Operates on wide bitvector signals partitioned into segments of a specified width, reducing critical path delay. Useful for applications requiring low-latency arithmetic in hardware pipelines, such as digital signal processing or high-speed data filtering.",
      "description_length": 354,
      "index": 655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Make",
      "library": "hardcaml_circuits",
      "description": "Implements a ROM-accumulator circuit that computes weighted sums of input bits and constants using distributed arithmetic without multipliers. It operates on fixed-width bitvectors and structured signal interfaces, forming addresses from input bits to index into precomputed ROM values representing combinations of coefficients. Used to synthesize multiplier-free linear accumulators and dot-product circuits by leveraging ROM lookups and shift-add operations.",
      "description_length": 460,
      "index": 656,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Sorting_network.Min_or_max",
      "library": "hardcaml_circuits",
      "description": "This module defines a type `t` with variants `Min` and `Max` to specify whether a sorting network should sort in ascending or descending order. It provides a single function `sexp_of_t` for serializing the `t` values into S-expressions. This module is used to configure sorting network implementations like `Bitonic_sort` or `Odd_even_merge_sort` to determine the sort direction.",
      "description_length": 379,
      "index": 657,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Prefix_sum.Config",
      "library": "hardcaml_circuits",
      "description": "This module defines configuration options for parallel prefix sum network implementations, including serial, Sklansky, Brent-Kung, and Kogge-Stone structures. It works with the `t` enumerated type representing different network configurations and provides operations to list all configurations and serialize them to S-expressions. Concrete use cases include selecting and configuring prefix sum network types for hardware synthesis and testing.",
      "description_length": 444,
      "index": 658,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fixnum.Make",
      "library": "hardcaml_circuits",
      "description": "This module implements fixed-point arithmetic operations with a specified precision, converting between floating-point numbers and scaled integer representations. It supports creation of hardware signals and bit vectors from floats, arithmetic operations like multiplication, and constants generation. Useful for FPGA-based digital signal processing where precise fractional bit-widths are required.",
      "description_length": 399,
      "index": 659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Arbiters.Index",
      "library": "hardcaml_circuits",
      "description": "Implements priority arbitration logic using a configurable mask to determine the next requester to grant. Works with `Signal.t` values representing request lines and priority masks. Used to dynamically adjust arbitration priority in hardware designs, such as in round-robin or masked priority scheduling scenarios.",
      "description_length": 314,
      "index": 660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Lfsr.Config",
      "library": "hardcaml_circuits",
      "description": "This module defines configuration types for linear feedback shift registers (LFSRs), specifically distinguishing between Galois and Fibonacci configurations. It provides a list of all available configurations and a function to convert configuration values to S-expressions. Use cases include selecting and serializing LFSR configurations for circuit generation or testing.",
      "description_length": 372,
      "index": 661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Onehot_clean.Names_and_widths",
      "library": "hardcaml_circuits",
      "description": "This module defines port names and widths for a onehot conversion circuit with logarithmic delay. It provides concrete values for port names, widths, and tags used in the onehot cleaning logic. Useful for instantiating or inspecting the structure of onehot conversion circuits with known bit-widths and signal names.",
      "description_length": 316,
      "index": 662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Onehot_clean.Of_always",
      "library": "hardcaml_circuits",
      "description": "This module provides functions to manipulate and assign signals within an always block for a onehot interface. It supports creating registers, wires, and named signal assignments for a onehot-encoded structure. Use cases include building state machines or priority encoders with guaranteed onehot outputs in a synchronous design.",
      "description_length": 329,
      "index": 663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Onehot_clean.Of_signal",
      "library": "hardcaml_circuits",
      "description": "This module provides operations to convert arbitrary input vectors into onehot-encoded outputs by retaining only the first set bit (from MSB/LSB) with logarithmic-delay priority encoding. It manipulates `Hardcaml.Signal.t` values through structured interfaces, supporting signal packing/unpacking, multiplexing, register pipelining, and validation, while enabling explicit signal wiring and hierarchical naming with prefixes/suffixes. It is particularly useful in control logic design, priority encoders, or state machines where precise bit prioritization and signal organization are critical for timing and readability.",
      "description_length": 620,
      "index": 664,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Rac.Mode",
      "library": "hardcaml_circuits",
      "description": "This module defines the computation mode for a ROM-accumulator circuit, supporting two calculation strategies: fixed-point and integer arithmetic. It works with the `t` type, which represents the operation mode, and includes a function to serialize the mode to an S-expression. Use this module to configure how the accumulator interprets input values and performs arithmetic operations in distributed arithmetic circuits.",
      "description_length": 421,
      "index": 665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_reference.System",
      "library": "hardcaml_circuits",
      "description": "Represents coordinate system types for CORDIC algorithm configurations, including circular, linear, and hyperbolic. Provides a list of all system types and S-expression serialization for debugging or configuration purposes. Used to select and serialize the mathematical system during CORDIC computation setup.",
      "description_length": 309,
      "index": 666,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod.Make",
      "library": "hardcaml_circuits",
      "description": "This module implements a counter that computes quotient and remainder outputs based on a divisor, wrapping when reaching specified max quotient and remainder values. It supports direct setting of quotient and remainder values, and optimizes hardware generation for power-of-two divisors and aligned max values. It works with signals and bit vectors to enable synthesis of custom counters, modulus circuits, and division-based control logic in hardware designs.",
      "description_length": 460,
      "index": 667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_reference.Mode",
      "library": "hardcaml_circuits",
      "description": "This module defines the operational modes for the CORDIC algorithm, including rotation, vectoring, and inverse operations. It works with floating-point numbers via `Float.t` and is used to configure the behavior of the CORDIC computation. Concrete use cases include selecting the mode when performing trigonometric calculations, coordinate transformations, or inverse function evaluations in a CORDIC-based circuit.",
      "description_length": 415,
      "index": 668,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Onehot_clean.Of_bits",
      "library": "hardcaml_circuits",
      "description": "This module converts an arbitrary input bit vector into a onehot representation, ensuring only the first set bit (from MSB or LSB) is active. It operates on `Bits.t` types, providing functions like `pack`, `unpack`, `mux`, and `priority_select` for manipulating onehot-encoded signals. Use cases include priority encoding, signal multiplexing, and converting integer indices to onehot vectors for control logic.",
      "description_length": 411,
      "index": 669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic.Architecture",
      "library": "hardcaml_circuits",
      "description": "This module defines the architectural variants for implementing CORDIC algorithms, specifically supporting combinational, pipelined, and iterative designs. It works with the `t` enumerated type to represent each architecture and provides functions for serialization and listing all variants. Concrete use cases include selecting and configuring the appropriate CORDIC architecture for hardware synthesis based on performance and resource constraints.",
      "description_length": 450,
      "index": 670,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Sorting_network.Min_max",
      "library": "hardcaml_circuits",
      "description": "This module defines a data type `t` that holds a pair of values representing the minimum and maximum of two elements. It provides functions to construct and deconstruct these pairs, along with S-expression conversion for serialization. The module is used within sorting network implementations to abstract compare-and-swap operations on arbitrary data types.",
      "description_length": 358,
      "index": 671,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Vec.Make",
      "library": "hardcaml_circuits",
      "description": "Implements a vector structure with dynamic insert and delete operations at arbitrary positions using hardware signals. Works with `Hardcaml.Signal.t` values structured through the `Arg.Interface` module to represent vector elements. Useful for building configurable register files or data buffers where elements can be inserted or removed at runtime-controlled positions.",
      "description_length": 371,
      "index": 672,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Arbiters.Round_robin_with_priority",
      "library": "hardcaml_circuits",
      "description": "Implements round-robin arbitration with priority selection using configurable strategies like log-shift rotation, trailing zero counting, and one-hot encoding. Operates on lists of valid/ready signal pairs and integer indices to determine the next active requester, wrapping around from the highest index to the lowest. Directly supports hardware scheduling scenarios such as fair resource allocation in FPGAs or ASICs where dynamic priority and request tracking are required.",
      "description_length": 476,
      "index": 673,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Rac",
      "library": "hardcaml_circuits",
      "description": "Implements a ROM-accumulator circuit that computes weighted sums of input bits and constants using distributed arithmetic without multipliers. It operates on fixed-width bitvectors and structured signal interfaces, forming addresses from input bits to index into precomputed ROM values representing combinations of coefficients. Used to synthesize multiplier-free linear accumulators and dot-product circuits by leveraging ROM lookups and shift-add operations.",
      "description_length": 460,
      "index": 674,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Pipelined_tree_reduce",
      "library": "hardcaml_circuits",
      "description": "Implements a pipelined tree reduction circuit that reduces a list of signals using a user-defined function, with propagation delay proportional to the ceiling of the logarithm of the input size. Uses signals and registers to pipeline the reduction, supporting arbitrary reduction operations like addition or bitwise combining. Useful for high-performance reductions of large input sets in hardware designs.",
      "description_length": 406,
      "index": 675,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Datapath_register",
      "library": "hardcaml_circuits",
      "description": "This module implements register stages with control flow handshaking for hardware datapaths. It provides operations to create and manipulate register interfaces with named ports and bit-level signals, including mapping, zipping, and converting structured data to signals. It is used for pipeline control, signal routing, and register staging with valid/ready synchronization in synchronous circuit design.",
      "description_length": 405,
      "index": 676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Stack",
      "library": "hardcaml_circuits",
      "description": "Implements a synchronous stack with write-before-read semantics and configurable read latency, operating on hardware interfaces composed of fixed-width signals, registers, and wires. Uses validity-aware data structures for synchronous circuit design. Enables RTL generation for memory stacks, simulation integration with named port access, and construction of pipelined hardware structures with structured signal hierarchies.",
      "description_length": 425,
      "index": 677,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Mul",
      "library": "hardcaml_circuits",
      "description": "Implements high-performance integer multiplication circuits using Wallace and Dadda tree reduction algorithms. Works directly with bitvector types to construct parallel multipliers through partial product generation and reduction stages. Useful for FPGA synthesis tasks requiring area-optimized or delay-optimized arithmetic units.",
      "description_length": 331,
      "index": 678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_special_functions",
      "library": "hardcaml_circuits",
      "description": "This module implements CORDIC algorithms for computing trigonometric functions like sine, cosine, and arctangent, as well as hyperbolic functions and vector rotation operations. It works with fixed-point signal interfaces, using structured records for input and output signals to support hardware description and simulation. It is used in FPGA-based digital signal processing, robotics control systems, and hardware-accelerated computation pipelines where precise, efficient mathematical operations are required.",
      "description_length": 512,
      "index": 679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fixnum",
      "library": "hardcaml_circuits",
      "description": "This module implements fixed-point arithmetic with configurable precision, providing operations to convert floating-point numbers to scaled integers, perform multiplication, and generate constants. It works with hardware signals and bit vectors to enable precise control over fractional bit-widths. It is used in FPGA-based digital signal processing applications requiring exact fixed-point representations.",
      "description_length": 407,
      "index": 680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Fast_fifo",
      "library": "hardcaml_circuits",
      "description": "This module implements a low-latency, combinational FIFO circuit with support for cut-through behavior and configurable capacity. It operates on hardware signal interfaces (`I.t` and `O.t`) to manage data flow, enabling direct instantiation within scoped hardware designs. Concrete use cases include building high-performance FIFOs for data buffering, stream processing pipelines, and control logic in FPGA or ASIC designs where minimal latency and precise signal timing are critical.",
      "description_length": 484,
      "index": 681,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Index_vec",
      "library": "hardcaml_circuits",
      "description": "This module implements hardware circuits for managing dynamic index vectors with optional tags, supporting insertions, deletions, and lookups at arbitrary positions. It works with signals representing indexes, tags, and control flags such as full or empty, enabling synchronization with external storage like RAM. Concrete use cases include tracking active slots in a queue or stack, managing dynamic buffer allocations, and handling tagged metadata in pipelined hardware systems.",
      "description_length": 480,
      "index": 682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Sorting_network",
      "library": "hardcaml_circuits",
      "description": "This module implements sorting networks using fixed configurations of compare-and-swap operations, supporting bitonic sort and odd-even merge sort algorithms. It works with lists of arbitrary data types, using user-defined compare-and-swap functions, and includes configuration options for sort direction (min or max) and algorithm selection. Concrete use cases include generating hardware-efficient sorting logic in digital circuit design where static network structures are required.",
      "description_length": 485,
      "index": 683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Vec",
      "library": "hardcaml_circuits",
      "description": "Implements a vector structure with dynamic insert and delete operations at arbitrary positions using hardware signals. Works with `Hardcaml.Signal.t` values structured through the `Arg.Interface` module to represent vector elements. Useful for building configurable register files or data buffers where elements can be inserted or removed at runtime-controlled positions.",
      "description_length": 371,
      "index": 684,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Divider",
      "library": "hardcaml_circuits",
      "description": "Implements a parameterized divider circuit for performing division operations in synchronous digital designs. Uses `Signal.t` values for input and output ports, supporting hierarchical instantiation and custom instance naming. Designed for integration into larger circuit topologies where division is required, such as arithmetic logic units or control circuits.",
      "description_length": 362,
      "index": 685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Counter_div_mod",
      "library": "hardcaml_circuits",
      "description": "Implements a counter that computes quotient and remainder outputs based on a divisor, wrapping when reaching specified max quotient and remainder values. It supports direct setting of quotient and remainder and optimizes hardware generation for power-of-two divisors and aligned max values. Works with signals and bit vectors to enable synthesis of custom counters, modulus circuits, and division-based control logic in hardware designs.",
      "description_length": 437,
      "index": 686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Prefix_sum",
      "library": "hardcaml_circuits",
      "description": "Implements parallel prefix sum networks using associative operators, supporting configurations like Sklansky, Brent-Kung, and Kogge-Stone. Works with lists of arbitrary types and combinational logic types from Hardcaml. Used to build efficient hardware circuits for prefix sums and carry propagation in arithmetic logic units.",
      "description_length": 326,
      "index": 687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Pipelined_incrementer",
      "library": "hardcaml_circuits",
      "description": "Implements a pipelined incrementer that splits addition into configurable-width stages. It takes a clock, clear, set, and increment signal, producing a pipelined output with reduced critical path delay. Useful for high-speed counters or\u6d41\u6c34\u7ebfed arithmetic in FPGA designs where timing closure is challenging.",
      "description_length": 305,
      "index": 688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Arbiters",
      "library": "hardcaml_circuits",
      "description": "This module implements arbitration logic for selecting among multiple requesters in hardware designs. It provides functions to rotate and select requester indices based on priority masks and round-robin strategies, operating on signal values and lists of valid/ready pairs. Concrete use cases include dynamic priority scheduling in FPGAs and fair resource allocation in ASICs, where requesters are granted access based on configurable rules and current requester states.",
      "description_length": 470,
      "index": 689,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml_circuits.Pipelined_tree_mux",
      "library": "hardcaml_circuits",
      "description": "Implements pipelined tree multiplexing and priority selection for signals with configurable register stages. Operates on lists of signals and with-valid tagged signals, using a selector or priority-encoded inputs to choose outputs. Useful for building high-performance data path selection logic in hardware designs where latency and throughput are critical.",
      "description_length": 357,
      "index": 690,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Stages",
      "library": "hardcaml_circuits",
      "description": "This module implements pipelined register stages for signal processing, allowing the construction of multi-stage pipelines with optional enable signals. It operates on arrays of stage data, handling inputs and outputs at each stage, and supports customizable stage functions for transforming data as it progresses through the pipeline. Concrete use cases include building synchronous data paths with staged computation, such as in CPU pipelines or streaming data processors.",
      "description_length": 474,
      "index": 691,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic",
      "library": "hardcaml_circuits",
      "description": "Implements CORDIC algorithms for computing trigonometric and hyperbolic functions using iterative shift-add operations with fixed-point arithmetic. Supports rotation, vectoring, and hyperbolic modes, managing barrel shifting, adder stages, and angle constant lookup tables. Used to synthesize circuits for sine/cosine generation, arctangent calculation, and hyperbolic function evaluation with configurable iteration counts and architectural variants.",
      "description_length": 451,
      "index": 692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Modulo",
      "library": "hardcaml_circuits",
      "description": "Implements efficient modulo operations for unsigned values, using optimized logic when the divisor is a power of two. Works directly with combinational logic types to compute remainders in hardware descriptions. Useful for implementing counters, cyclic buffers, or resource indexing in hardware designs.",
      "description_length": 303,
      "index": 693,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Pipelined_adder",
      "library": "hardcaml_circuits",
      "description": "Implements pipelined addition for very wide bitvector signals by partitioning them into segments of a specified width, reducing critical path delay. Provides a `create` function to build adders with configurable pipeline stages and optional clear/carry-in signals, and a `Short_latency` submodule for fixed 2-cycle latency addition optimized for FPGAs. Useful for high-speed arithmetic in digital signal processing and hardware pipelines where low-latency addition of wide signals is required.",
      "description_length": 493,
      "index": 694,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Lfsr",
      "library": "hardcaml_circuits",
      "description": "Implements linear feedback shift register (LFSR) logic with configurable Galois or Fibonacci structures and XOR/XNOR feedback operations. Works with bit vectors and registers to generate pseudo-random sequences for circuit testing and cryptographic applications. Provides functions to define LFSR update rules based on specified configurations and feedback types.",
      "description_length": 363,
      "index": 695,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_circuits.Cordic_reference",
      "library": "hardcaml_circuits",
      "description": "Implements the CORDIC algorithm using floating-point arithmetic for trigonometric, hyperbolic, and linear computations. It supports operations such as rotation, vectoring, coordinate conversion, and inverse functions with configurable coordinate systems and modes. Concrete use cases include calculating sine/cosine, converting between polar and rectangular coordinates, computing arctangent and inverse hyperbolic functions, and performing multiplication and division through iterative CORDIC steps.",
      "description_length": 500,
      "index": 696,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits.Onehot_clean",
      "library": "hardcaml_circuits",
      "description": "This module converts arbitrary bit vectors into one-hot encoded signals by preserving the first set bit when scanned from a specified direction, using a logarithmic-delay architecture. It supports structured hardware interfaces with operations like mapping, folding, and zipping to implement priority selection, multiplexer control logic, and state machine encoders. The functions work on one-hot vectors and tagged tuples of signals, enabling synthesis of circuits where explicit port naming and priority resolution are critical.",
      "description_length": 530,
      "index": 697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_circuits",
      "library": "hardcaml_circuits",
      "description": "This module provides circuits for arithmetic operations (CORDIC, division, counting), signal routing (arbiters, FIFOs, registers), and optimized logic structures (prefix sums, sorting networks, pipelined stages) operating on hardware signals, bitvectors, and synchronous interfaces. It supports configurable RTL generation for FPGAs/ASICs with use cases like dynamic vector manipulation, synchronous stack implementation, and pipelined data path transformations. Key applications include high-performance digital logic synthesis, timing-critical control structures, and area-efficient computational blocks.",
      "description_length": 606,
      "index": 698,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 712,
    "meaningful_modules": 699,
    "filtered_empty_modules": 13,
    "retention_rate": 0.9817415730337079
  },
  "statistics": {
    "max_description_length": 758,
    "min_description_length": 191,
    "avg_description_length": 448.0214592274678,
    "embedding_file_size_mb": 10.130769729614258
  }
}