{
  "package": "landmarks",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 3,
  "creation_timestamp": "2025-07-15T23:05:26.343671",
  "modules": [
    {
      "module_path": "Landmark.Graph",
      "library": "landmarks",
      "description": "This module builds and manipulates callgraphs from profiling data, where each node represents a landmark instance with metrics like time, memory, and call counts. It supports traversal, filtering, and transformation operations such as depth-first search, subgraph extraction, and merging nodes by landmark identity. Concrete use cases include analyzing performance profiles to identify hotspots, generating JSON or textual reports, and pruning unreachable nodes for simplified visualization.",
      "description_length": 491,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Landmark",
      "library": "landmarks",
      "description": "This module provides profiling and data collection tools, enabling landmark registration, counters, and samplers with configurable output formats for metrics like time and memory. It manages internal state and graph structures to support performance monitoring, resource analysis, and merging distributed data. The callgraph module builds and processes graphs from profiling data, allowing traversal, filtering, and transformation operations such as depth-first search and node merging. Together, they enable concrete workflows like identifying performance hotspots, generating structured reports, and simplifying callgraphs by removing unreachable nodes.",
      "description_length": 655,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Landmark_threads",
      "library": "landmarks.threads",
      "description": "This module provides synchronization mechanisms to ensure exclusive access to profiling operations like landmark registration, counter updates, and graph management in concurrent environments. It works with profiling state objects, graph structures, and metric primitives (counters, samplers) to safely aggregate execution data across threads. Designed for multi-threaded applications where only one thread should actively collect benchmarks at a time, preventing race conditions during performance monitoring.",
      "description_length": 510,
      "index": 2,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 3,
    "meaningful_modules": 3,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 655,
    "min_description_length": 491,
    "avg_description_length": 552.0,
    "embedding_file_size_mb": 0.011323928833007812
  }
}