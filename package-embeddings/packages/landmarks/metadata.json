{
  "package": "landmarks",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 3,
  "creation_timestamp": "2025-08-14T22:58:00.317344",
  "modules": [
    {
      "module_path": "Landmark.Graph",
      "library": "landmarks",
      "description": "This module represents and manipulates call graphs generated from profiling data, where nodes correspond to instrumented code regions with timing, memory, and call statistics. It supports traversal, subgraph extraction, aggregation by landmark identity, and pruning of unreachable nodes, enabling detailed performance analysis and visualization. Concrete use cases include generating human-readable or JSON output of profiling results, analyzing call paths, and computing metrics like total calls or node intensity.",
      "description_length": 515,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Landmark",
      "library": "landmarks",
      "description": "This module provides profiling operations for tracking performance metrics like execution time, memory usage, and call frequencies within scoped code regions. It works with graph structures to manage hierarchical profiling data, using counters, samplers, and configurable output formats to analyze and aggregate metrics. Typical use cases include identifying performance bottlenecks, comparing profiling results across runs, and integrating metric collection with graph-based workflows.",
      "description_length": 486,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Landmark_threads",
      "library": "landmarks.threads",
      "description": "This module provides synchronized profiling primitives that enforce exclusive access to landmarks, counters, and samplers in concurrent programs, using internal state management to serialize measurements and graph updates. It operates on thread-protected data structures representing profiling graphs and execution contexts, ensuring atomic modifications while ignoring non-coordinator thread activity. Designed for multi-threaded applications using the Thread module, it ensures safe benchmarking coordination where only the initiating thread captures metrics, preventing race conditions during distributed profiling tasks.",
      "description_length": 624,
      "index": 2,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 3,
    "meaningful_modules": 3,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 624,
    "min_description_length": 486,
    "avg_description_length": 541.6666666666666,
    "embedding_file_size_mb": 0.04390525817871094
  }
}