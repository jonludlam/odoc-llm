{
  "package": "msat",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 49,
  "creation_timestamp": "2025-08-15T15:20:01.201120",
  "modules": [
    {
      "module_path": "Msat_sat.Proof.Tbl",
      "library": "msat.sat",
      "description": "This module implements a hash table for mapping resolution proof objects to arbitrary values, supporting imperative operations like insertion, lookup, iteration, and bulk initialization from sequences of key-value pairs. It works with keys representing logical proofs generated during SAT solving and polymorphic values, enabling efficient storage and retrieval of associated data. Typical use cases include caching intermediate proof results, tracking dependencies between clauses, or managing mappings during proof reconstruction in SAT-based verification tasks.",
      "description_length": 564,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_sat.Clause.Tbl",
      "library": "msat.sat",
      "description": "This module enables efficient storage and retrieval of polymorphic values keyed by clauses, which are represented as integers in the SAT solver. It supports imperative hash table operations like insertion, lookup, and iteration, along with bulk modification via sequences for initializing or updating large sets of clause-value bindings. Typical use cases include tracking metadata (e.g., clause weights, learned clause status) during SAT solving where fast access and batch updates are required.",
      "description_length": 496,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_sat.Term",
      "library": "msat.sat",
      "description": "This module defines operations for manipulating propositional terms in a SAT solver, including equality checking, hashing, and pretty-printing. It works directly with the abstract type `t` representing logical terms. These functions support tasks like term comparison, efficient storage in hash tables, and debugging output generation.",
      "description_length": 335,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_sat.Formula",
      "library": "msat.sat",
      "description": "This module represents propositional formulas using integers to encode atomic propositions. It provides operations for negation, normalization, equality checking, hashing, and debugging output. It is used internally by the SAT solver to manipulate logical expressions in a canonical form.",
      "description_length": 288,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_sat.Clause",
      "library": "msat.sat",
      "description": "This module represents clauses in a SAT solver using integers to encode atomic propositions. It provides operations to access clause atoms as arrays or lists, compare clauses for equality, retrieve clause names, and format clauses for printing. Concrete use cases include managing and analyzing individual clauses during SAT solving, such as tracking learned clauses or performing clause elimination based on structural properties.",
      "description_length": 431,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_sat.Atom",
      "library": "msat.sat",
      "description": "This module represents atomic propositions as integers in a SAT solver, providing operations to manipulate and compare these atoms. It supports negation, sign extraction, absolute value computation, and conversion to formulas, along with standard equality, comparison, and hashing functions. Concrete use cases include building and solving propositional logic formulas where atoms are efficiently handled as integers.",
      "description_length": 417,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_sat.Value",
      "library": "msat.sat",
      "description": "Represents truth values of atomic propositions in a SAT solver using integers. Provides a printer function `pp` for converting these integer-based truth values to human-readable string representations, primarily for debugging purposes. Useful when inspecting solver states or logging intermediate results during formula evaluation.",
      "description_length": 331,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_sat.Proof",
      "library": "msat.sat",
      "description": "This module implements a resolution proof system for SAT solving, providing functions to construct and manipulate proofs derived from conflict analysis. It works with clauses, atoms, and proof nodes to build resolution steps, extract unsat cores, and validate proof structures. Concrete use cases include reconstructing unsatisfiability proofs from solving traces, extracting minimal unsat cores for debugging, and verifying resolution steps during proof replay.",
      "description_length": 462,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Msat_sat.Int_lit",
      "library": "msat.sat",
      "description": "This module represents atomic propositions as integers for a SAT solver, providing operations to create, negate, normalize, and compare formulas. It includes functions to convert between integers and formula terms, track signs, and apply or set negation. Use cases include efficient manipulation of propositional variables during clause solving and backtracking in a SAT solver.",
      "description_length": 378,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_sat",
      "library": "msat.sat",
      "description": "This module provides operations for constructing and manipulating propositional logic formulas using integer-based atomic propositions, supporting negation, normalization, clause resolution, and proof generation. It works with literals, terms, clauses, and atoms to enable low-level SAT solving tasks like clause addition, truth evaluation at specific decision levels, and exporting clause sets. These capabilities are applicable to formal verification, automated reasoning, and constraint solving scenarios where efficient logical formula manipulation is required.",
      "description_length": 565,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Msat.Make_pure_sat.Proof.Tbl",
      "library": "msat",
      "description": "This module offers imperative hash table operations optimized for keys of type `Proof.t`, supporting standard manipulations like insertion, lookup, and iteration, alongside batch processing via sequences for bulk operations. It manages associations between proof objects and arbitrary values, enabling efficient traversal, filtering, and in-place transformations over proof-centric data. Such functionality is useful for tracking proof dependencies, aggregating proof metadata, or stream-processing proof traces during SAT solver analysis.",
      "description_length": 539,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Msat.Make_cdcl_t.Clause.Tbl",
      "library": "msat",
      "description": "This module implements a hash table for mapping logical clauses (`Clause.t`) to arbitrary values, offering imperative operations like insertion, lookup, removal, iteration, folding, and in-place filtering. It supports bulk construction and updates via sequences of key-value pairs, enabling efficient management of clause-indexed data. Such functionality is particularly useful in SAT solvers for tasks like caching clause-derived metadata, tracking clause dependencies, or dynamically reorganizing clause sets during conflict-driven clause learning.",
      "description_length": 550,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Msat.Make_cdcl_t.Proof.Tbl",
      "library": "msat",
      "description": "This module implements a mutable hash table with `Proof.t` keys and polymorphic values, supporting imperative operations like `add`, `remove`, `find`, and `fold`, as well as bulk sequence-based manipulations via `add_seq` and `of_seq`. It is designed for efficiently managing and transforming collections of proof objects during SAT solving, enabling use cases such as tracking proof-derived metadata or aggregating resolution steps. The inclusion of specialized operations like `filter_map_inplace` and sequence-driven updates facilitates optimized workflows for proof analysis and transformation tasks.",
      "description_length": 604,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_pure_sat.Clause.Tbl",
      "library": "msat",
      "description": "This module offers imperative hash table operations optimized for keys of type `Clause.t`, supporting additions, removals, bulk updates via sequences, and transformations through folding or filtering. It manages mappings from `Clause.t` to arbitrary values (`'a`), enabling efficient lookups and in-place modifications. Such functionality is particularly useful in SAT solving workflows where clauses are dynamically managed, such as tracking learned clauses or resolving conflicts through batched updates and iterative processing.",
      "description_length": 531,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_mcsat.Proof.Tbl",
      "library": "msat",
      "description": "This module provides imperative hash table operations for mapping proof terms (`Proof.t`) to arbitrary data, supporting standard manipulations like insertion, lookup, and iteration alongside bulk updates from sequences. It specializes in managing associations between proofs and auxiliary metadata, enabling efficient tracking of annotations, dependencies, or intermediate results during resolution-based proof construction. Use cases include storing proof-specific context or validation artifacts while maintaining structural integrity of the underlying proof system.",
      "description_length": 568,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_pure_sat.Term",
      "library": "msat",
      "description": "Implements equality, hashing, and pretty-printing for propositional terms in a SAT solver. Works directly with the `Term.t` type representing logical terms. Enables comparison and display of terms for solver operations and debugging.",
      "description_length": 233,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_cdcl_t.Term",
      "library": "msat",
      "description": "Implements term manipulation and comparison operations for a CDCL-based SMT solver. Provides equality checking, hashing, and pretty-printing for term values. Used to manage and compare logical expressions during constraint solving.",
      "description_length": 231,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_cdcl_t.Value",
      "library": "msat",
      "description": "Implements a CDCL (Conflict-Driven Clause Learning) SAT solver with support for incremental solving and backtracking. It provides operations for asserting literals, checking satisfiability, and extracting model values. Works with propositional logic formulas represented as clauses over integer-indexed variables. Useful for applications like formal verification, constraint solving, and automated reasoning where efficient SAT solving is required.",
      "description_length": 448,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_cdcl_t.Clause",
      "library": "msat",
      "description": "This module represents logical clauses in a SAT solver, providing operations to access their constituent atoms as arrays or lists, compare clauses for equality, retrieve clause names, and format clauses for printing. It works with the `Clause.t` type, which encapsulates logical clauses, and is used in conjunction with the `Tbl` submodule to map clauses to arbitrary values using a hash table. Concrete use cases include managing clause metadata during conflict-driven clause learning, caching derived results per clause, and tracking dependencies between clauses in a solver's internal state.",
      "description_length": 594,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_cdcl_t.Proof",
      "library": "msat",
      "description": "This module provides operations for constructing and manipulating resolution proofs derived from SAT solving traces. It supports building proofs from clauses, atoms, and hyper-resolution steps, and allows inspecting and traversing proof structures through functions like `parents`, `conclusion`, and `fold`. Concrete use cases include extracting unsatisfiability cores, validating proof steps, and tracking proof metadata using the `Tbl` submodule during proof analysis or transformation tasks.",
      "description_length": 494,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_pure_sat.Clause",
      "library": "msat",
      "description": "This module represents clauses in a SAT solver, providing operations to access their atoms as arrays or lists, compare clauses for equality, retrieve clause names, and format clauses for printing. It works with the `Clause.t` type, which encapsulates logical clauses composed of atoms. Use cases include managing and manipulating individual clauses during SAT solving, such as for conflict analysis, clause learning, and resolution steps.",
      "description_length": 438,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_mcsat.Atom",
      "library": "msat",
      "description": "This module represents and manipulates propositional atoms in a SAT solver. It provides operations for negating atoms, extracting their sign and absolute value, comparing and hashing atoms, and converting atoms to formulas. Use cases include managing atomic propositions in logical expressions and implementing decision procedures based on propositional logic.",
      "description_length": 360,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_cdcl_t.Atom",
      "library": "msat",
      "description": "This module represents propositional atoms in a SAT solver, providing operations to manipulate and query their logical properties. It supports data types including atoms, their negations, and associated formulas. Concrete use cases include managing atomic propositions during clause learning and backtracking in CDCL-based SAT solving.",
      "description_length": 335,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Msat.Make_pure_sat.Atom",
      "library": "msat",
      "description": "This module represents propositional atoms and provides operations for manipulating their truth values, including negation, sign extraction, and absolute value. It works with the `atom` type and supports comparisons, hashing, and conversion to logical formulas. Concrete use cases include managing atomic propositions in SAT solvers and performing logical transformations on boolean expressions.",
      "description_length": 395,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_pure_sat.Value",
      "library": "msat",
      "description": "Handles boolean value assignments and evaluations within a SAT solver. It provides functions to create, manipulate, and query truth values, supporting operations like negation, conjunction, and disjunction. This module is used to represent and compute logical expressions during constraint solving.",
      "description_length": 298,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_mcsat.Proof",
      "library": "msat",
      "description": "This module builds and manipulates resolution proofs derived from SAT solving traces, working with formulas, atoms, lemmas, and clauses. It supports proof construction via resolution steps, unsat core extraction, and traversal with guaranteed parent-first ordering. Concrete use cases include validating conflict clauses, generating minimal unsatisfiable cores, and tracking proof steps for debugging or certificate generation.",
      "description_length": 427,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_mcsat.Value",
      "library": "msat",
      "description": "Handles value representation and manipulation within the MCSAT solver, providing operations for creating, comparing, and printing values. Works directly with the `t` type, which represents logical values in the solver context. Used during constraint solving to manage and debug value assignments.",
      "description_length": 296,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Msat.Make_mcsat.Clause",
      "library": "msat",
      "description": "This module represents and manipulates logical clauses, providing operations to access constituent atoms, compare clauses, and retrieve clause names. It works with the `Clause.t` type, which encapsulates clauses in a solver context, along with submodules like `Tbl` for efficient clause storage and lookup. Concrete use cases include managing clauses during SAT solving, tracking clause atoms, and implementing conflict analysis mechanisms.",
      "description_length": 440,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_pure_sat.Proof",
      "library": "msat",
      "description": "This module provides operations for constructing and analyzing resolution proofs derived from SAT solving traces. It supports creating proofs from clauses or atoms, expanding proof nodes, extracting unsatisfiable cores, and folding over proof structures. Concrete use cases include validating SAT solver outputs, generating minimal unsatisfiable subsets, and post-processing resolution steps for proof optimization or transformation.",
      "description_length": 433,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Solver_intf",
      "library": "msat",
      "description": "This module defines the core interface for SAT solvers, including fundamental types like `lbool`, `negated`, and `void`, along with module types that specify solver components and plugins. It provides operations for formula manipulation, expression handling, and proof construction, enabling concrete solver implementations via functors. Use cases include building and solving propositional logic formulas, managing atomic valuations, and integrating custom plugins for CDCL or MCSAT solving strategies.",
      "description_length": 503,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_pure_sat",
      "library": "msat",
      "description": "The module provides operations for propositional logic manipulation, including clause addition, formula solving with conflict callbacks and assumptions, atom evaluation, and proof verification. It works with terms, atoms, clauses, and resolution proofs to construct logical models or derive unsatisfiability certificates. This supports use cases like formal verification, constraint solving, and incremental reasoning over boolean formulas.",
      "description_length": 440,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_mcsat",
      "library": "msat",
      "description": "This module implements a constraint-solving engine for propositional and SMT problems, offering operations to manage solver states, manipulate logical terms and atoms, and derive resolution proofs. It works with data structures representing solver contexts (`t`), truth values, logical formulas, and clauses, supporting tasks like conflict analysis, theory propagation, and model construction. Key use cases include verifying logical constraints, generating unsatisfiability proofs, and exporting learned clauses for incremental solving or external validation.",
      "description_length": 560,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat.Make_cdcl_t",
      "library": "msat",
      "description": "This module implements a CDCL-based SAT solver with operations for clause management, logical inference, and model construction. It works with terms, atoms, clauses, and formulas, supporting tasks like satisfiability checking, conflict-driven learning, and proof generation. This is useful in formal verification and automated reasoning systems where efficient solving of logical constraints is required.",
      "description_length": 404,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Msat",
      "library": "msat",
      "description": "This module provides core types like `lbool` and `negated` for representing logical truth values and sign manipulations, along with printers for these types. It includes functors to build SAT and SMT solvers supporting operations such as formula construction, clause management, conflict analysis, and proof derivation. Concrete use cases include implementing CDCL or MCSAT-based solvers, verifying logical constraints, and generating unsatisfiability proofs for formal verification tasks.",
      "description_length": 489,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_tseitin.Make",
      "library": "msat.tseitin",
      "description": "This module provides functions to construct and manipulate boolean formulas using atomic propositions from module `F`. It supports logical operations such as negation, conjunction, disjunction, XOR, implication, and equivalence, and converts formulas into equi-satisfiable conjunctive normal form (CNF). The resulting CNF can be used directly with SAT solvers, and formulas can be printed using standard OCaml formatting.",
      "description_length": 421,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Msat_tseitin",
      "library": "msat.tseitin",
      "description": "Transforms boolean formulas into equi-satisfiable CNF using Tseitin's algorithm, supporting logical operations like negation, conjunction, disjunction, XOR, implication, and equivalence. Works with atomic propositions and formulas built from them. Directly enables feeding output to SAT, SMT, or McSat solvers while providing printing capabilities for formulas.",
      "description_length": 361,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_backtrack.Ref",
      "library": "msat.backtrack",
      "description": "This module implements backtrackable references that support setting, getting, and updating values with the ability to save and restore states through backtracking levels. It works with any data type `'a`, allowing controlled state management with explicit level-based undo functionality. Use cases include implementing algorithms that require state rollback, such as constraint solvers or transactional memory systems.",
      "description_length": 419,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_backtrack",
      "library": "msat.backtrack",
      "description": "This module implements backtrackable references that support setting, getting, and updating values while allowing state to be saved and restored through backtracking levels. It works with values of any type `'a`, enabling controlled state management where changes can be undone at specific levels. It is useful for implementing algorithms requiring state rollback, such as constraint solvers or transactional memory systems.",
      "description_length": 424,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_backend.Dot.Make",
      "library": "msat.backend",
      "description": "This module generates DOT format output for visualizing proofs as graphs, using the `pp` function to print proof structures to a formatter. It operates on proof data from the `S` module and uses the `A` module for atomic elements. A concrete use case is creating visual representations of logical proofs for analysis or presentation using Graphviz.",
      "description_length": 348,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_backend.Dot.Simple",
      "library": "msat.backend",
      "description": "This module generates DOT-formatted representations of proofs, enabling visualization via Graphviz. It works with proof structures defined by the `S` module and uses the `A` module for atomic propositions. Concrete use cases include exporting proof graphs for debugging or documentation, where each node and edge in the DOT output corresponds to logical steps and dependencies in the proof.",
      "description_length": 390,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_backend.Dot.Default",
      "library": "msat.backend",
      "description": "This module provides functions to customize the display of atomic formulas and clauses when exporting proofs to the DOT graph format. It works with atomic formulas and clauses from the parameter module `S`, generating labels and metadata for nodes in the graph. Concrete use cases include defining how hypotheses, lemmas, and assumptions are visually represented in generated proof graphs, such as setting node colors and labels for better readability in tools like Graphviz.",
      "description_length": 475,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_backend.Coq.Simple",
      "library": "msat.backend",
      "description": "This module implements a simple Coq proof printer for resolution proofs generated by a SAT solver. It takes proof structures defined by the `S` module and formats them into Coq scripts using the `pp` function. It is used to generate human-readable and machine-checkable proofs in Coq from SAT solver outputs.",
      "description_length": 308,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_backend.Dedukti.Make",
      "library": "msat.backend",
      "description": "This module generates a backend for exporting proofs in a format compatible with the Dedukti type checker. It provides a `pp` function to print proof terms using a user-defined format, enabling concrete use cases like generating `.dk` files for proof checking or proof interchange. It operates on proof structures defined by the `S` and `A` modules, which specify the proof format and atomic terms.",
      "description_length": 398,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_backend.Coq.Make",
      "library": "msat.backend",
      "description": "This module defines a function `pp` that formats and outputs resolution proofs to a file using a specified format. It operates on proof data structures provided by the `S` module and uses formatting rules from the `A` module. It supports generating Coq scripts that represent SAT solver proofs for formal verification tasks.",
      "description_length": 324,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_backend.Backend_intf",
      "library": "msat.backend",
      "description": "This module defines the interface for proof export backends. It specifies the required operations to serialize and export proofs in various formats. Concrete use cases include generating proof certificates for theorem provers or exporting proof traces for external verification tools.",
      "description_length": 284,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_backend.Coq",
      "library": "msat.backend",
      "description": "This module generates Coq scripts from SAT solver resolution proofs, translating logical derivations into formal Coq assertions. It works with proof structures produced by the SAT solver, converting them into Coq terms and tactics. A concrete use case is verifying the correctness of SAT-based logic transformations within the Coq proof assistant.",
      "description_length": 347,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Msat_backend.Dedukti",
      "library": "msat.backend",
      "description": "This module implements a Dedukti backend for encoding and verifying proofs, focusing on translating logical statements and proof terms into Dedukti's logical framework. It operates on proof structures and logical expressions, enabling concrete use cases such as exporting proofs to external proof checkers or integrating with Dedukti-based verification pipelines. The module supports proof interoperability through a well-defined interface for constructing and serializing proof objects.",
      "description_length": 487,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Msat_backend.Dot",
      "library": "msat.backend",
      "description": "This module exports proof structures to the DOT graph format, generating labeled nodes and edges for visualizing proof steps. It works with atomic formulas and clauses to define node metadata, such as labels and colors, during graph generation. Use it to produce input files for Graphviz that illustrate proof dependencies and logical flow, with customizable visual annotations for hypotheses and conclusions.",
      "description_length": 409,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Msat_backend",
      "library": "msat.backend",
      "description": "This module implements proof export backends for SAT solver outputs, providing functions to serialize and transform logical derivations into various formats. It works with proof structures, clauses, and logical expressions to generate Coq scripts, Dedukti encodings, and DOT graphs. Concrete use cases include producing verifiable proof certificates, integrating with Dedukti-based checkers, and visualizing proof dependencies using Graphviz.",
      "description_length": 442,
      "index": 48,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 50,
    "meaningful_modules": 49,
    "filtered_empty_modules": 1,
    "retention_rate": 0.98
  },
  "statistics": {
    "max_description_length": 604,
    "min_description_length": 231,
    "avg_description_length": 422.734693877551,
    "embedding_file_size_mb": 0.7107143402099609
  }
}