{
  "package": "hardcaml_verify",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 55,
  "creation_timestamp": "2025-06-18T16:43:56.075313",
  "modules": [
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for fluent manipulation of wrapped values. It is particularly useful for simplifying code that involves optionals, results, or other monadic types.",
      "description_length": 403,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons, with results extended to prevent overflow. Works with the `v` type, representing unsigned binary values of arbitrary width. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 354,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise control over signed integer operations in hardware description or low-level numeric processing.",
      "description_length": 317,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over bit-width and extension. Resizes vectors to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 352,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or verification contexts.",
      "description_length": 335,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that support binding and lifting. Enables chaining of effectful operations and value transformations in a concise manner.",
      "description_length": 237,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of wrapped values through constructs like `let%bind` and `let%map`. Supports fluent composition of computations involving optionals, results, and other monadic types. Allows for more readable and structured code when chaining sequential or transformative operations. Example: binding a series of optional values without nested match expressions.",
      "description_length": 420,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Is_one_hot.Make.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 272,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Is_one_hot.Make.Signed",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing signed binary vectors. Resizes vectors to specified widths while preserving sign during conversion.",
      "description_length": 276,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Is_one_hot.Make.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise width management. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 331,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Is_one_hot.Make.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during calculations. Operates on custom numeric types representing bits or signals, ensuring overflow handling through widened results. Enables precise manipulation of fixed-width integers in hardware description or digital logic contexts.",
      "description_length": 338,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a generic type 'a wrapped in a custom record structure. Used to serialize and deserialize data based on named fields in network protocol parsing.",
      "description_length": 269,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.All",
      "description": "Combines monadic sequencing and custom syntax to streamline effectful computations and value transformations. Supports operations like bind and map on monadic types, including optionals and results, enabling clean, readable code. Allows chaining of sequential operations using `let%bind` and `let%map` to avoid nested expressions. Example: safely extracting and transforming values from a chain of optional computations.",
      "description_length": 420,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks, with automatic bit-width extension and resizing. Supports conversion between `v` and `Comb.t` for interfacing with hardware description components. Used to manipulate signed or unsigned binary values in digital circuit designs.",
      "description_length": 368,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface structures with fixed field widths. Used to pack signals into a single bit vector for output, unpack them for processing, and select between multiple interface configurations.",
      "description_length": 356,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.Of_signal",
      "description": "This module offers signal manipulation capabilities, including packing, unpacking, multiplexing, and renaming, along with interface management through combinational logic types and signal structures. It works with `comb t` for hardware logic interfaces and `Hardcaml.Signal.t` to handle bit-width and routing tasks. Use cases include hardware synthesis, signal field customization, and interface alignment with naming conventions for design clarity.",
      "description_length": 449,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.Of_always",
      "description": "Provides functions to create and manage interface containers for hardware description, including registers, wires, and signal assignments. Works with signal and variable types from the Hardcaml library to construct always blocks. Used to define clocked registers with enable signals and name interface fields with customizable prefixes and suffixes.",
      "description_length": 349,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type elements. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process hardware description data for signal mapping and validation.",
      "description_length": 328,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify.Nusmv.Counter_example_trace",
      "description": "Provides operations to convert a trace structure into a list of signal-value pairs and a waveform representation. Works with signal names and bit vectors to represent digital circuit behavior. Used to generate visualizable waveforms from simulation traces.",
      "description_length": 256,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Cnf.Literal",
      "description": "Provides functions to construct literals from labels or strings, with options for width and hidden status. Operates on arrays of literal values and supports conversion to S-expressions and strings. Used to define input variables in logical expressions, particularly within disjunctions.",
      "description_length": 286,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Cnf.Disjunction",
      "description": "Provides operations to construct and manipulate a set of logical literals combined with OR semantics. Works with the `t` type representing a disjunction and `Literal.t` for individual logical components. Supports building from a list, iterating over literals, and folding over them for custom processing.",
      "description_length": 304,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Cnf.Conjunction",
      "description": "Provides operations to combine and manipulate disjunctions using logical AND, including creating an empty conjunction, adding a disjunction, building from a list, and concatenating multiple conjunctions. Works with the `t` type representing a collection of disjunctions and `Disjunction.t` for individual disjunctions. Used to construct complex logical conditions by merging multiple disjunctive expressions into a single conjunctive structure.",
      "description_length": 444,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Cnf.Model_with_bits",
      "description": "Provides functions to convert input data to S-expressions, retrieve filtered input lists based on flags, and print input results to a channel. Works with custom input records, boolean flags, and lists of inputs wrapped in a result type. Used to serialize data for logging, filter visible inputs during processing, and output structured results to files.",
      "description_length": 353,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Cnf.Model_with_vectors",
      "description": "Provides functions to convert input data to S-expressions, retrieve filtered input lists based on boolean flags, and print input results to an output channel. Works with custom input records, integer lists, and result types wrapped in Or_error. Used to serialize data for logging, filter visible inputs during processing, and output structured results to files.",
      "description_length": 361,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Sec.Instantiation_ports_match",
      "description": "Controls comparison of design ports, ensuring inputs and outputs are either equal or the left is a subset of the right. Works with port sets represented as a custom type, enabling verification of compatibility between circuit interfaces. Used to validate sub-circuit connections when converting Verilog designs to Hardcaml, accommodating missing ports that may arise during conversion.",
      "description_length": 385,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Sec.Proposition",
      "description": "Provides serialization of logical expressions to S-expressions. Works with a custom type representing boolean logic formulas derived from circuit comparisons. Used to generate human-readable and machine-parsable representations for debugging and verification purposes.",
      "description_length": 268,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Sec.Equivalence_result",
      "description": "Provides operations to convert a list of CNF models with vectors and SAT results into S-expression format. Works with nested data structures combining base values, vectors, and SAT status. Used to serialize verification outcomes for logging or external processing.",
      "description_length": 264,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Basic_gates.Uid",
      "description": "This module handles generation and manipulation of unique identifiers through arithmetic and ordering operations on integer seeds, producing values of type `t` with staged computation for delayed execution. It supports serialization, comparison, and string conversion for `t`, along with range validation and clamping to ensure safe usage. Use cases include scenarios requiring deterministic unique IDs with structured representation and constraints, such as distributed systems or data serialization pipelines.",
      "description_length": 511,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Label.Uid",
      "description": "This module offers serialization, comparison, and string conversion for a type `t`, along with range-based operations like clamping and checking. It works with integer values to generate opaque unique identifiers (uids) through a staged computation approach, deferring their creation until execution. Use cases include managing unique identifier lifecycles and enforcing range constraints in systems requiring deterministic or lazy ID generation.",
      "description_length": 446,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Is_one_hot.Make",
      "description": "Converts between a custom type and a Comb.t, performs arithmetic and comparison operations on values with automatic bit-width extension, and resizes values to specified widths. Operates on a type v representing signed or unsigned binary values. Used for constructing and manipulating digital logic signals in hardware description workflows.",
      "description_length": 340,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Tseitin.Make",
      "description": "Performs element-wise negation on a custom type `t`, supporting arithmetic inversion operations. Operates on instances of `t` that represent numerical or boolean values. Used to invert the sign of a value or toggle a boolean state in mathematical or logical expressions.",
      "description_length": 270,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Comb_gates.Unsigned",
      "description": "Converts between signed and unsigned vector representations, performs arithmetic and comparison operations on vectors with automatic bit-width extension, and resizes vectors to specified widths while preserving value integrity. Operates on `v` type, which represents unsigned bit vectors. Used for hardware description tasks requiring precise control over binary arithmetic and signal conversion.",
      "description_length": 396,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Comb_gates.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Used for implementing precise arithmetic in hardware description or fixed-point calculations.",
      "description_length": 299,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Comb_gates.Uop",
      "description": "Performs arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Operates on custom types representing bit vectors or signals, supporting width adjustments through resizing. Enables precise manipulation of binary data in hardware description or low-level numeric computations.",
      "description_length": 352,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Comb_gates.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing signals or bits, ensuring results are widened to prevent overflow. Enables precise manipulation of binary values in hardware description or digital logic contexts.",
      "description_length": 323,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.Counter_example_trace",
      "description": "Provides functions to convert a counter example trace into an S-expression and to extract a list of signal-value pairs per cycle. Works with a custom type representing a counter example, containing sequential data. Used to inspect and debug digital circuit simulations by mapping signal changes over time.",
      "description_length": 305,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.Proof_result",
      "description": "Provides serialization of proof states to S-expressions using a custom `t` type that represents the outcome of theorem proving processes. Works with structured data capturing success, failure, or intermediate states of proofs. Used to generate human-readable and machine-parsable logs during automated theorem proving workflows.",
      "description_length": 328,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.Output_parser",
      "description": "Parses a string into a bit vector and processes a list of strings into a list of proof results. It converts textual representations of words into hardware-compatible bit structures. Used to interpret output from verification tools and translate them into structured data for further analysis.",
      "description_length": 292,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.Circuit_properties",
      "description": "Returns the input and output ports of a circuit configuration, where inputs extract the input type 'i and outputs extract the output type 'o. Operates on a parameterized type ('i, 'o) t that represents the structure of a circuit. Used to inspect and route signals in hardware description or simulation workflows.",
      "description_length": 312,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface",
      "description": "Converts interface values to S-expressions, validates port widths, and packs/unpacks interfaces into vectors. Performs multiplexing, concatenation, and selection operations on interface data. Constructs interfaces from integer constants and retrieves field width information.",
      "description_length": 275,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify.Nusmv",
      "description": "Provides operations to transform trace data into signal-value lists and waveform representations, using signal names and bit vectors to model digital circuit behavior. Supports visualization by converting simulation results into structured formats. Enables analysis of circuit states through detailed signal tracking. Can generate waveforms for debugging or simulation verification.",
      "description_length": 382,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Basic_gates",
      "description": "Generates and manages unique identifiers using integer seeds, supporting arithmetic, ordering, and staged computation to produce values of type `t`. Provides serialization, comparison, string conversion, and range validation to ensure safe and structured usage. It enables deterministic ID creation with constraints, suitable for distributed systems or data pipelines. Examples include generating unique keys, enforcing value limits, and converting identifiers to human-readable formats.",
      "description_length": 487,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Cnf",
      "description": "Provides functions to convert input to S-expression format, filter inputs with optional hidden flag, and print results to an output channel. Works with input type and lists of SAT problems. Used to process and output logical formula data in a structured format.",
      "description_length": 261,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Comb_gates",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and bitwise comparisons with automatic width extension. Supports conversion between `v` and `t` types, and allows resizing of `v` values to specified widths. Used for constructing and manipulating digital logic signals in hardware description contexts.",
      "description_length": 370,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Dimacs",
      "description": "Writes DIMACS CNF files for SAT solvers, parses SAT solver outputs from strings or files, and handles results from multiple solver formats including Minisat, Picosat, and Z3. Operates on CNF formulas and SAT result lists, using OCaml's standard I/O and error handling. Used to interface with external SAT solvers and process their output for further analysis or validation.",
      "description_length": 373,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Is_one_hot",
      "description": "Provides operations to analyze and verify the one-hot property of binary vectors, including checks for exactly one bit set, no bits set, or multiple bits set. Supports arithmetic, comparison, and bit-width management on a custom binary value type, enabling precise manipulation of digital signals. Examples include validating that a control signal is one-hot or ensuring a register has no active bits. Designed for use in formal verification and hardware modeling tasks.",
      "description_length": 470,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Label",
      "description": "manages labeled variables with unique identifiers and bit positions, enabling precise tracking and comparison. it provides operations for generating and manipulating uids, along with range constraints and string conversions. users can create labels, clamp values within ranges, and convert labels to strings for debugging or logging. examples include generating deterministic IDs for system variables and ensuring bit positions stay within valid bounds.",
      "description_length": 453,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv",
      "description": "Encapsulates tools for handling digital circuit and proof data through custom types and structured transformations. Supports parsing and serializing bit vectors, traces, and proof states, while enabling port inspection, interface validation, and data manipulation. Allows conversion of simulation outputs to structured formats, extraction of signal relationships, and construction of hardware interfaces from abstract values. Facilitates debugging, verification, and analysis by bridging textual representations with internal data models.",
      "description_length": 538,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Sat",
      "description": "Converts a model's internal representation to an S-expression using a provided conversion function. Operates on a polymorphic type parameterized by a model, enabling serialization tailored to specific data structures. Used to generate S-expressions for debugging or configuration output in domain-specific contexts.",
      "description_length": 315,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Sec",
      "description": "This module performs sequential equivalence checking between two circuits by analyzing their combinational logic through SAT solving. It includes operations to compare port sets, serialize logical expressions to S-expressions, and convert CNF models into structured output formats. It ensures interface compatibility, aids in debugging with readable representations, and supports verification result logging. For example, it can validate port mappings during Verilog-to-Hardcaml conversion or generate debug logs from SAT solver outputs.",
      "description_length": 537,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Solver",
      "description": "Provides functions to execute SAT solvers like Minisat, Picosat, and Z3, and process their results. Works with CNF formulas and model outputs, enabling the extraction of satisfying assignments. Supports running solvers with custom configurations and converting results to S-expressions for serialization.",
      "description_length": 304,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Tseitin",
      "description": "Generates and manipulates logical formulas in conjunctive normal form using a set of transformation rules. Operates on abstract syntax trees representing propositional logic expressions. Converts complex formulas into equivalent, simplified forms suitable for SAT solving.",
      "description_length": 272,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "hardcaml_verify",
      "description": "Provides functions to interface with SAT solvers for solving combinational logic constraints and generate NuSMV code for sequential circuit verification. Works with circuit representations, boolean formulas, and state transition graphs. Used to validate digital designs by checking satisfiability and property compliance.",
      "description_length": 321,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify",
      "description": "Provides operations to convert trace data into signal-value lists and waveform representations, using signal names and bit vectors to model digital circuit behavior. Supports visualization and analysis by structuring simulation results and tracking circuit states. Enables waveform generation for debugging and verification. Examples include converting simulation outputs to visual waveforms and extracting signal values for state analysis.",
      "description_length": 440,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel",
      "description": "Encapsulates tools for managing identifiers, logical formulas, and digital signals, with operations for arithmetic, comparison, and conversion between types. Supports SAT solving, CNF file generation, and verification tasks like one-hot checking and sequential equivalence. Provides serialization, parsing, and structured output for debugging and analysis. Enables deterministic ID creation, formula manipulation, and interface validation in hardware and formal verification workflows.",
      "description_length": 485,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 70,
    "meaningful_modules": 55,
    "filtered_empty_modules": 15,
    "retention_rate": 0.7857142857142857
  },
  "statistics": {
    "max_description_length": 538,
    "min_description_length": 237,
    "avg_description_length": 355.4909090909091,
    "embedding_file_size_mb": 0.20022201538085938
  }
}