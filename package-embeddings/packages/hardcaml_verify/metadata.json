{
  "package": "hardcaml_verify",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 36,
  "creation_timestamp": "2025-08-15T12:34:37.694042",
  "modules": [
    {
      "module_path": "Hardcaml_verify.Nusmv.Counter_example_trace",
      "library": "hardcaml_verify",
      "description": "Converts counterexample traces from NuSMV into structured waveforms or value traces. It processes traces containing signal-value pairs at each time step, extracting them into lists or visual waveforms. Useful for debugging hardware designs by inspecting signal behavior over time in a formal verification context.",
      "description_length": 313,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify.Nusmv",
      "library": "hardcaml_verify",
      "description": "This module translates hardware designs into NuSMV models for formal verification, supporting temporal logic properties like LTL and CTL. It generates circuits from specifications, writes models to files, and runs verification checks, producing proof results or counterexamples. The `Counter_example_trace` submodule converts NuSMV counterexamples into structured signal traces for debugging design flaws step-by-step.",
      "description_length": 418,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify",
      "library": "hardcaml_verify",
      "description": "Translates hardware designs into NuSMV models for formal verification, supporting LTL and CTL properties. Generates circuits from specifications, writes models to files, and runs verification checks, producing proof results or counterexamples. Converts NuSMV counterexamples into structured signal traces for step-by-step debugging of design flaws.",
      "description_length": 348,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Comb_gates.Uop",
      "library": "hardcaml_verify.kernel",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors, working directly with `Bits.t` or `Signal.t` types. It provides functions for addition, subtraction, multiplication, and comparisons like less than or equal, supporting variable-width operands with automatic sign extension. Use cases include building and verifying combinational logic circuits that perform numeric computations or comparisons on binary data.",
      "description_length": 444,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Cnf.Model_with_bits",
      "library": "hardcaml_verify.kernel",
      "description": "This module constructs and manipulates models for CNF formulae using bit-level inputs, mapping literals to integer indices for DIMACS compatibility. It provides functions to retrieve and print input values derived from SAT solver outputs. Use it to interpret SAT solver results as concrete bit assignments for circuit verification tasks.",
      "description_length": 337,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Sec.Instantiation_ports_match",
      "library": "hardcaml_verify.kernel",
      "description": "This module defines how instantiation port connections are compared during sequential equivalence checking. It supports two modes: exact matching or allowing the left side to be a subset of the right side, which accommodates Verilog designs where ports may be declared but not driven. This is used when verifying circuits where combinational logic may differ but state elements must match exactly.",
      "description_length": 397,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Sec.Proposition",
      "library": "hardcaml_verify.kernel",
      "description": "Represents a logical proposition used in sequential equivalence checking to compare two circuits. It captures the differences in their combinational logic as a SAT problem. Used to determine if two circuits are functionally equivalent under all possible input conditions.",
      "description_length": 271,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.With_interface",
      "library": "hardcaml_verify.kernel",
      "description": "This module constructs and verifies formal specifications for hardware circuits using temporal logic. It maps input and output interfaces to LTL and CTL properties, enabling precise assertions about signal sequences and state transitions. Use it to generate model-checking specifications for synchronous circuit verification.",
      "description_length": 325,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.Counter_example_trace",
      "library": "hardcaml_verify.kernel",
      "description": "This module represents counterexample traces generated by NuSMV during formal verification. It provides a way to convert counterexample data into a structured trace format, mapping signal names to bit values across simulation steps. Use this module to analyze or visualize the sequence of signal changes that lead to a failed assertion in a hardware design.",
      "description_length": 357,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Cnf.Literal",
      "library": "hardcaml_verify.kernel",
      "description": "This module represents individual literals within a CNF formula, mapping them to integer indexes for DIMACS format compatibility. It provides operations to create single literals or vectors of literals, assign labels, and convert literals to strings or S-expressions. These literals are used when constructing disjunctions for SAT solving, enabling direct correspondence with solver inputs and output models.",
      "description_length": 408,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Comb_gates.Signed",
      "library": "hardcaml_verify.kernel",
      "description": "This module implements arithmetic and comparison operations for signed binary vectors represented as lists of basic gates. It supports addition, subtraction, multiplication, and comparisons like less than or equal, operating on signed values with automatic sign extension and width management. These operations are used to build combinational circuits for arithmetic logic units or digital signal processing where signed number handling is required.",
      "description_length": 449,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Comb_gates.Sop",
      "library": "hardcaml_verify.kernel",
      "description": "This module implements arithmetic and comparison operations for combinational logic signals, working directly with `Bits.t` or `Signal.t` types. It provides addition, subtraction, multiplication, and comparisons (less than, greater than, equal, etc.), with automatic bit-width extension to prevent truncation. These operations are used to build and verify digital circuits that perform numerical computations or conditional logic in hardware designs.",
      "description_length": 450,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Sec.Equivalence_result",
      "library": "hardcaml_verify.kernel",
      "description": "This module represents the result of a SAT check performed during sequential equivalence checking. It returns `Unsat` if the combinational logic of two circuits is equivalent, or `Sat` with a counterexample input if not. The result includes input vectors that demonstrate the inequivalence, aiding in debugging mismatches during circuit optimization or translation from Verilog.",
      "description_length": 378,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.Proof_result",
      "library": "hardcaml_verify.kernel",
      "description": "This module represents the result of a proof attempt, either confirming a tautology or providing a counterexample trace. It works with the `t` variant type that distinguishes between a proven tautology and a counterexample. Concrete use cases include reporting the outcome of model checking a hardware design property.",
      "description_length": 318,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Cnf.Disjunction",
      "library": "hardcaml_verify.kernel",
      "description": "This module represents a disjunction of literals, supporting operations to create, add to, and fold over a collection of literals. It works with CNF literals mapped to integer indexes for efficient conversion to DIMACS format. Use this to build individual clauses for CNF formulas that can be processed by SAT solvers.",
      "description_length": 318,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Label.Uid",
      "library": "hardcaml_verify.kernel",
      "description": "This module manages unique identifiers for hardware verification labels, focusing on deterministic creation, string conversion, and precise comparison of `(uid, bit_pos)` pairs to distinguish single-bit variables within vector representations. It operates on a custom `Uid.t` type alongside integer bit positions, enabling use cases like formal verification where reproducible identifier generation and exact label differentiation are critical. Key operations include seed-based UID creation, bidirectional string encoding, and ordering primitives that ensure stable comparisons for verification workflows.",
      "description_length": 606,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Is_one_hot.Make",
      "library": "hardcaml_verify.kernel",
      "description": "This module creates a one-hot checker for a given bit vector, returning a record with signals indicating whether no bits, exactly one bit, or multiple bits are set. It operates on `Comb.t` values, which represent combinational logic signals. Use this to efficiently verify one-hot conditions in hardware descriptions, particularly for proving SAT properties where compact and predictable logic depth is preferred over optimized `popcount` implementations.",
      "description_length": 455,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Basic_gates.Uid",
      "library": "hardcaml_verify.kernel",
      "description": "This module provides functions for comparing, ordering, and constraining unique identifiers with precise bounds, along with serialization and deserialization capabilities. It operates on a unique identifier type (`Uid.t`), strings, and integers, enabling use cases like hardware signal identification, circuit component tagging, and safe range-based validation in verification workflows. Key utilities include clamping values to intervals, generating identifiers from integers, and maintaining ordered collections through comparator witnesses.",
      "description_length": 543,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.Output_parser",
      "library": "hardcaml_verify.kernel",
      "description": "Parses word constants and proof results from strings, converting them into hardware description types. Works with string lists and bits to extract formal verification outcomes. Used to interpret NuSMV model checker outputs in hardware verification workflows.",
      "description_length": 258,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Tseitin.Make",
      "library": "hardcaml_verify.kernel",
      "description": "This module converts boolean gate expressions into Tseitin-form CNF by introducing new SAT literals for each gate output. It operates on boolean terms represented by the `B.t` type, supporting operations like logical connectives (AND, OR, XOR, NAND, NOR) and constants. Use it to encode digital circuit logic into CNF for SAT solving, such as verifying circuit equivalence or solving constraint satisfaction problems.",
      "description_length": 417,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Cnf.Conjunction",
      "library": "hardcaml_verify.kernel",
      "description": "Represents a conjunction of disjunctions in a CNF formula, where each disjunction is a collection of literals. It provides operations to create, combine, and manipulate CNF expressions, specifically supporting the addition of disjunctions, conversion from and to lists, and concatenation of multiple conjunctions. This structure is used to build complex logical constraints for SAT solving, such as encoding circuit behavior or verification conditions in DIMACS format.",
      "description_length": 469,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Comb_gates.Unsigned",
      "library": "hardcaml_verify.kernel",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors using combinational logic gates. It supports addition, subtraction, multiplication, and comparisons like less than or equal, directly on vector values. These operations are used to build digital circuits for tasks like arithmetic computation or control logic in hardware designs.",
      "description_length": 364,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Cnf.Model_with_vectors",
      "library": "hardcaml_verify.kernel",
      "description": "This module evaluates and extracts input values from CNF models generated by SAT solvers, mapping literal results to named input variables. It works with CNF structures and SAT solver outputs to produce lists of input records containing names and boolean values. It is used to interpret SAT solver results in terms of original circuit inputs, particularly for verification tasks like checking signal assignments in digital designs.",
      "description_length": 431,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv.Circuit_properties",
      "library": "hardcaml_verify.kernel",
      "description": "This module provides access to input and output signals of a circuit representation used in formal verification. It works with a polymorphic circuit type that captures signal relationships. Concrete use cases include extracting signal lists for model checking or analysis tasks.",
      "description_length": 278,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Label",
      "library": "hardcaml_verify.kernel",
      "description": "This module manages labeled single-bit variables for hardware verification, using unique `(uid, bit_pos)` pairs to distinguish bits within vectors. It provides comparison operations, ordering utilities, and S-expression serialization for deterministic workflows, alongside functions to construct and inspect labeled bits with visibility flags. The design supports scenarios requiring precise identification and manipulation of individual bits in vector signals during formal verification.",
      "description_length": 488,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Nusmv",
      "library": "hardcaml_verify.kernel",
      "description": "This module generates and manipulates NuSMV models for formal verification of hardware circuits. It supports creating models from signal lists and properties expressed in LTL or CTL, writing models to files, and running model checking to obtain proof results. The module includes submodules for handling counterexample traces, parsing outputs, and accessing circuit properties, enabling concrete use cases such as verifying correctness of digital designs and debugging failed assertions.",
      "description_length": 487,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Tseitin",
      "library": "hardcaml_verify.kernel",
      "description": "This module converts boolean gate expressions into Tseitin-form CNF using new SAT literals for each gate output. It works with boolean terms of type `B.t`, handling logical operations like AND, OR, XOR, NAND, NOR, and constants. Use it to encode digital circuit logic into CNF for tasks like circuit equivalence verification or constraint solving.",
      "description_length": 347,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Solver",
      "library": "hardcaml_verify.kernel",
      "description": "This module provides functions to run SAT solvers on DIMACS-formatted CNF formulas, supporting Minisat, Picosat, and Z3. It includes utilities to execute solvers, parse results, and optionally return satisfying models. Use cases include verifying circuit correctness by solving constraint satisfaction problems derived from digital designs.",
      "description_length": 340,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Basic_gates",
      "library": "hardcaml_verify.kernel",
      "description": "This module provides boolean logic operations (AND, OR, XOR, NOT), comparison primitives (equality, relational operators), and circuit analysis tools (dependency traversal, CNF generation) for manipulating hardware signal representations. It operates on gate structures with unique identifiers, enabling formal verification tasks like SAT solving, constraint checking, and combinatorial circuit analysis through symbolic manipulation and range-bound value generation. Key applications include hardware equivalence checking, logic optimization, and safety-critical system validation.",
      "description_length": 582,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Sec",
      "library": "hardcaml_verify.kernel",
      "description": "This module performs sequential equivalence checking between two circuits using SAT solving to verify their combinational logic equivalence. It operates on `Circuit.t` inputs, generating logical propositions that capture output, register, and instantiation input mismatches. Concrete use cases include validating combinational optimizations or ensuring functional parity after translating Verilog designs to Hardcaml.",
      "description_length": 417,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Dimacs",
      "library": "hardcaml_verify.kernel",
      "description": "Handles reading and writing files in DIMACS format for SAT solving. It writes CNF formulas to output channels and parses or reads SAT solver results from strings or input channels. Used to interface with external SAT solvers like minisat, picosat, and z3 by producing input files and interpreting their output.",
      "description_length": 310,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Cnf",
      "library": "hardcaml_verify.kernel",
      "description": "This module provides operations to construct and manipulate CNF formulas using literals mapped to integer indexes for DIMACS format compatibility. It supports creating and combining disjunctions and conjunctions of literals, converting formulas to solver-friendly formats, and extracting models from SAT solver outputs. Concrete use cases include encoding digital circuit behavior for formal verification and generating test inputs from SAT results.",
      "description_length": 449,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Sat",
      "library": "hardcaml_verify.kernel",
      "description": "Converts a model and its associated SAT solver state into an S-expression representation. Works with generic model types and SAT solver instances. Useful for serializing solver states or models to disk for debugging or later restoration.",
      "description_length": 237,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_verify_kernel.Is_one_hot",
      "library": "hardcaml_verify.kernel",
      "description": "This module creates a one-hot checker for bit vectors, returning signals that indicate whether no bits, exactly one bit, or multiple bits are set. It operates on `Comb.t` values representing combinational logic signals. Use it to efficiently verify one-hot conditions in hardware descriptions, particularly for proving SAT properties with compact, predictable logic depth.",
      "description_length": 372,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel.Comb_gates",
      "library": "hardcaml_verify.kernel",
      "description": "This module provides combinational logic primitives for constructing and manipulating bit vectors using low-level gate representations, supporting arithmetic operations (addition, multiplication), bitwise logic (AND, XOR), comparisons (signed/unsigned), and bit-level transformations (shifting, resizing, priority selection). It operates on fixed-width signals encoded as lists of basic gates (`Comb_gates.t`), enabling both constant and variable-width circuit construction with explicit control over bit ordering and sign semantics. Specific use cases include digital circuit verification, hardware simulation, and formal methods like CNF generation for logical equivalence checking.",
      "description_length": 684,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_verify_kernel",
      "library": "hardcaml_verify.kernel",
      "description": "This module provides formal verification capabilities for digital circuits through SAT solving, CNF manipulation, and sequential equivalence checking. It works with hardware signal representations, labeled bit vectors, and NuSMV models to enable concrete tasks such as logic optimization validation, one-hot condition checking, and interfacing with external solvers for constraint satisfaction. Key applications include verifying combinational and sequential circuit equivalence, generating test inputs from SAT results, and encoding digital logic for model checking.",
      "description_length": 567,
      "index": 35,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 36,
    "meaningful_modules": 36,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 684,
    "min_description_length": 237,
    "avg_description_length": 406.44444444444446,
    "embedding_file_size_mb": 0.5222702026367188
  }
}