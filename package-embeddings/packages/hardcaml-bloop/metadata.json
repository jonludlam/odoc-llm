{
  "package": "hardcaml-bloop",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 57,
  "creation_timestamp": "2025-06-18T16:43:30.758187",
  "modules": [
    {
      "module_path": "HardCamlBloop.Cnf.Comb.Unsigned",
      "description": "Converts between a custom unsigned type and a value type, supports arithmetic and comparison operations on values, and allows resizing values to specified bit widths. Works with a single value type representing unsigned integers. Used for low-level bit manipulation and arithmetic in hardware description or protocol parsing.",
      "description_length": 325,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Cnf.Comb.Signed",
      "description": "Converts between signed integer types and their underlying representations, supports arithmetic and comparison operations on signed values, and allows resizing of signed values to different bit widths. Works with the `v` type, representing signed integers of arbitrary size. Resizes audio samples to fit within specific bit depths and performs bitwise comparisons in signal processing pipelines.",
      "description_length": 395,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Cnf.Comb.Uop",
      "description": "Converts between signal representations, performs arithmetic and comparison operations on signals, and resizes signals to specified bit widths. Works with a custom signal type representing digital or numerical data. Used to manipulate and compare signals in hardware description or simulation contexts.",
      "description_length": 302,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Cnf.Comb.Sop",
      "description": "Converts between signal representations, performs arithmetic and comparison operations on signals, and resizes signal data. Works with signal data types representing time-series or binary streams. Used to manipulate and compare signal values in real-time processing pipelines.",
      "description_length": 276,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Gates.Make_comb.Unsigned",
      "description": "Converts between a custom unsigned type and a value type, supports arithmetic and comparison operations on values, and allows resizing of values to specified bit widths. Operates on a distinct value type representing unsigned integers. Used for low-level bit manipulation and arithmetic in embedded systems or protocol parsing.",
      "description_length": 327,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Gates.Make_comb.Signed",
      "description": "Converts between signed values and their signal representations, supports arithmetic and comparison operations on signed values, and allows resizing of signed values to specified bit widths. Operates on the `v` type, which represents signed numeric values. Used for manipulating signed integers in hardware description or low-level numeric processing tasks.",
      "description_length": 357,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Gates.Make_comb.Uop",
      "description": "Converts between signal representations, performs arithmetic and comparison operations on signals, and resizes signals to specified bit widths. Works with a custom signal type representing digital or numerical data. Used to manipulate and compare signal values in hardware description or embedded systems code.",
      "description_length": 310,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Gates.Make_comb.Sop",
      "description": "Converts between signal representations, performs arithmetic and comparison operations on signals, and resizes signal data. Works with signal data structures representing binary or numeric values. Used to manipulate and compare signal states in hardware description or digital logic applications.",
      "description_length": 296,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Gates.Comb.Unsigned",
      "description": "Converts between a custom unsigned type and a value type, supports arithmetic and comparison operations on values, and allows resizing values to specified bit widths. Works with a single value type representing unsigned integers. Used for low-level bit manipulation and arithmetic in hardware description or embedded systems.",
      "description_length": 325,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Gates.Comb.Signed",
      "description": "Converts between signed values and their signal representations, performs arithmetic and comparison operations on signed values, and resizes signed values to specified bit widths. Works with the `v` type, representing signed binary values. Used for implementing bitwise arithmetic in hardware description and low-level numerical computations.",
      "description_length": 342,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Gates.Comb.Uop",
      "description": "Converts between signal representations, performs arithmetic and comparison operations on signals, and resizes signals to specified bit widths. Works with a custom signal type representing digital or numerical values. Used to manipulate and compare signals in hardware description or simulation contexts.",
      "description_length": 304,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Gates.Comb.Sop",
      "description": "Converts between signal representations, performs arithmetic and comparison operations on signals, and resizes signals to specified lengths. Works with signal data types representing binary or numeric sequences. Used to manipulate and compare signal values in hardware description or digital signal processing contexts.",
      "description_length": 319,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Gates.Tseitin.Vmap",
      "description": "This module offers operations for manipulating key-value mappings, including insertion, deletion, lookup, and traversal, with a focus on integer-keyed maps. It enables transformations, splitting, and iteration over entries, supporting tasks like configuration management or data processing pipelines. Specific use cases include dynamic data restructuring and efficient key-based access in scenarios requiring frequent updates or analysis.",
      "description_length": 438,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Cnf.Comb",
      "description": "Converts between a type `t` and a type `v`, supports arithmetic and comparison operations on `v`, and resizes `v` to a specified length. Works with numeric or structured values represented by `v`. Used for signal processing tasks requiring element-wise operations and size adjustments.",
      "description_length": 285,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Cnf.M",
      "description": "The module offers operations for managing key-value mappings, including insertion, deletion, lookup, and value transformation, with support for traversal, filtering, and merging. It works with a type 'a t structured around integer keys, featuring both strict and optional functions, as well as sequence-based processing for iterative operations. Use cases include dynamic data configuration, state management, and efficient data aggregation where key-based access and modification are critical.",
      "description_length": 494,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Expr.Uset",
      "description": "This module provides set operations such as membership checks, unions, intersections, and element transformations, along with utilities for querying and modifying set-like structures containing unique identifiers. It supports conversions between sets, lists, and sequences, enabling efficient manipulation of collections where uniqueness and element-specific queries are critical. Use cases include managing user IDs or resource identifiers, performing predicate-based filtering, and optimizing data processing workflows requiring structured set operations.",
      "description_length": 557,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Expr.Umap",
      "description": "The module provides key-based manipulation, aggregation, and iteration over maps with unique identifier (uid) keys and generic values, supporting operations like insertion, deletion, lookup, and transformation. It enables use cases such as handling optional data, sequence-based processing, and structured data management through strict and optional variants of functions.",
      "description_length": 372,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Expr.S",
      "description": "The module offers set operations such as membership checks, union, intersection, and element manipulation, along with collection queries like retrieving min/max elements and converting between lists or sequences. It works with generic types `t` containing elements of type `elt`, supporting both strict and optional variants for flexibility. Use cases include managing unique element collections, data transformation pipelines, and efficient set-based computations.",
      "description_length": 465,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Expr.M",
      "description": "The module provides key-based operations for managing and transforming elements in a generic key-value structure, including insertion, deletion, lookup, and aggregation, along with traversal, filtering, and conversion to sequences. It enables efficient data processing through predicate-based searches, min/max extraction, and bidirectional conversion between collections and sequences, suitable for applications like configuration management or real-time data analysis.",
      "description_length": 470,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Bddx.V",
      "description": "The module offers set operations such as membership checks, unions, intersections, and element transformations for a generic type 't, enabling efficient collection management. It also includes specialized functions for handling structured data, like pairs of `Expr.t` and `float`, supporting tasks such as element retrieval, filtering, and conversion in contexts like symbolic computation or numerical analysis.",
      "description_length": 411,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Mig.Basic_gates",
      "description": "Provides logical operations on boolean-like values represented as edges, including conjunction, disjunction, negation, and implication. Works with a custom `edge` type to model binary states. Used to construct and manipulate logical expressions in digital circuit simulations.",
      "description_length": 276,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Mig.Base",
      "description": "Provides logical operations on edge values, including conjunction, disjunction, negation, and implication. Works with a custom edge type representing logical states. Used to construct and manipulate boolean expressions in circuit design or formal verification.",
      "description_length": 260,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Gates.Basic_gates",
      "description": "Performs logical conjunction, disjunction, negation, and implication on boolean expressions. Operates on the `Expr.t` type, representing symbolic logical expressions. Used to construct and manipulate propositional logic formulas in circuit design and formal verification.",
      "description_length": 271,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Gates.Basic_gates_simple_opt",
      "description": "Performs logical conjunction, disjunction, negation, and implication on boolean expressions represented as `Expr.t`. Operates on structured logical expressions to construct and manipulate propositional logic circuits. Used to build complex boolean logic for circuit design or symbolic reasoning tasks.",
      "description_length": 301,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Gates.Basic_gates_opt",
      "description": "Performs logical conjunction, disjunction, negation, and implication on boolean expressions represented as `Expr.t`. Operates on structured logical expressions to construct and manipulate propositional logic circuits. Enables creation of complex boolean conditions for digital circuit modeling and symbolic logic evaluation.",
      "description_length": 324,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Gates.Basic_gates_derive_xor",
      "description": "Performs logical AND, OR, NOT, and XOR operations on boolean expressions represented as `Expr.t`. Accepts two boolean expressions for binary operations and one for unary negation. Used to construct and manipulate logical circuits or symbolic expressions in digital logic design.",
      "description_length": 278,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Gates.Make_comb",
      "description": "Converts between a custom type and a value type, enabling arithmetic and comparison operations on the value type. Supports element-wise operations like addition, subtraction, and comparison, along with resizing values to a specified length. Used to manipulate numerical data in signal processing workflows.",
      "description_length": 306,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Gates.Comb",
      "description": "Converts between a type `t` and a type `v`, supports arithmetic and comparison operations on `v`, and resizes `v` to a specified length. Operations include addition, subtraction, multiplication, and relational checks. Used for manipulating numerical data structures with precise control over size and values.",
      "description_length": 308,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Gates.Tseitin",
      "description": "manages integer-keyed maps with insertion, deletion, lookup, and traversal, enabling dynamic data restructuring and efficient key-based access. It supports transformations, splitting, and iteration, allowing for flexible data processing and configuration management. Operations include updating entries, extracting subsets, and iterating over key-value pairs. Examples include maintaining runtime configurations or processing event logs with frequent key modifications.",
      "description_length": 469,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Pcn.Cube",
      "description": "This module offers operations for constructing, transforming, and analyzing cube structures, including set-like manipulations (intersection, supercube), boolean property checks (dontcare detection), and arithmetic conversions. It works with a custom `t` type representing cubes, alongside integers, lists, and arrays for input/output, enabling tasks like cofactor extraction and bitwise logic. Applications include symbolic computation, formal verification, and constraint solving where cube-based representations model variable interactions.",
      "description_length": 542,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Pcn.Cubelist",
      "description": "The module provides Boolean logic manipulation through operations like folding, cofactor computation, and variable analysis on a structured data type representing cubes. It enables tasks such as unateness checking and sum-of-products conversion, tailored for applications in digital circuit analysis and formal verification. Specific use cases include variable occurrence counting and transformation workflows in logic synthesis.",
      "description_length": 429,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Pcn.Tautology",
      "description": "Checks if a boolean formula in CNF is always true by evaluating its clauses. Operates on a list of clauses represented as cubes, returning boolean results or selection metrics. Used to determine logical validity and select optimal variables for decomposition.",
      "description_length": 259,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Pcn.Complement",
      "description": "Generates a list of cubes that fill the gaps between input cubes, handling both single and multiple cube configurations. Operates on cube and cubelist data structures representing 3D spatial regions. Used to compute missing regions in a 3D grid for collision detection or spatial partitioning.",
      "description_length": 293,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Pcn.Calculator",
      "description": "Performs logical negation, conjunction, and disjunction on cube lists representing Boolean functions. Operates on `Cubelist.t`, a structure encoding sets of binary vectors. Evaluates expressions with bitwise operations and output constraints to generate final cube lists.",
      "description_length": 271,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Espresso.I",
      "description": "This module provides set operations such as insertion, deletion, union, intersection, and difference, along with traversal, transformation, and predicate-based filtering for managing collections of elements. It works with a set-like structure containing integers, enabling efficient membership checks, min/max retrieval, and conversions between lists, sequences, and sets. Use cases include dynamic data management, symbolic computation, and scenarios requiring frequent set manipulations and element transformations.",
      "description_length": 517,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Espresso.Expand",
      "description": "Expands a list of cubes into a more detailed representation by splitting each cube into its constituent subcubes. It operates on the `Pcn.Cubelist.t` type, which represents a collection of hypercubes. This function is used to generate a finer-grained cube structure for detailed analysis or visualization.",
      "description_length": 305,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Espresso.Reduce",
      "description": "Reduces a list of cubes by merging overlapping or adjacent cubes into a single cube, and simplifies a single cube by removing redundant dimensions. It operates on cube representations and lists of cubes from the Pcn module. This is used to minimize logical expressions in binary decision diagram manipulations.",
      "description_length": 310,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Espresso.Irredundant",
      "description": "Removes redundant cubes from a list by checking for inclusion relationships between them. Operates on lists of cubes represented as tuples of bitvectors and masks. Used to optimize Boolean function representations in circuit synthesis tools.",
      "description_length": 241,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Espresso.Cover",
      "description": "Constructs an interval from a list of booleans, where each boolean represents the presence of a covered element. Identifies positions of non-zero intervals in a list of intervals. Used to convert binary coverage data into interval representations and extract indices of active intervals.",
      "description_length": 287,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Kmap.Render",
      "description": "Generates visual representations of Karnaugh maps for 2, 3, and 4 variables using nested integer lists to encode cell values. Each function produces a vector graphics image suitable for display or export. The output is tailored for logic circuit visualization and educational purposes.",
      "description_length": 285,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Kmap.Notebook",
      "description": "Generates SVG render data for Karnaugh maps of varying sizes using nested integer lists and arrays. Processes 2x2, 3x3, and 4x4 grid configurations, producing structured visual outputs. Used to create visual representations of boolean logic expressions in digital circuit design.",
      "description_length": 279,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Gates.Unsigned",
      "description": "Converts between a custom unsigned type and a value type, supports arithmetic and comparison operations on values, and allows resizing values to specified bit widths. Operates on the `v` type, which represents unsigned numeric values. Used for low-level bit manipulation and arithmetic in hardware description or protocol parsing.",
      "description_length": 330,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Gates.Signed",
      "description": "Converts between signed integer types and their underlying representations, supports arithmetic and comparison operations on signed values, and allows resizing of signed values to different bit widths. Works with the `v` type, representing signed integers of arbitrary size. Resizes audio samples to fit specific bit depths and performs bitwise comparisons in signal processing pipelines.",
      "description_length": 388,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Gates.Uop",
      "description": "Converts between signal representations, performs arithmetic and comparison operations on signals, and resizes signals to specified bit widths. Works with a custom signal type representing digital or numerical values. Used to manipulate and compare signals in hardware description or simulation contexts.",
      "description_length": 304,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Gates.Sop",
      "description": "Converts between signal representations, performs arithmetic and comparison operations on signals, and resizes signal data. Works with signal data structures representing time-series or binary values. Used for signal processing tasks such as filtering, thresholding, and data transformation.",
      "description_length": 291,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Expr",
      "description": "Combines set and map operations for managing unique identifiers and associated values, supporting membership checks, unions, intersections, insertions, deletions, and transformations. It handles generic types and provides strict and optional variants for flexible data manipulation, enabling efficient querying, filtering, and conversion between collections and sequences. Users can perform predicate-based searches, extract min/max elements, and manage structured data like user IDs or configuration settings. Examples include filtering unique elements, aggregating map values, and converting between sets and lists for data processing pipelines.",
      "description_length": 647,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Pcn",
      "description": "combines cube-based operations for logical and spatial analysis, handling tasks like intersection, negation, and gap filling using custom `t` types and cubelist structures. It supports boolean property checks, CNF validation, and spatial region computation, enabling applications in circuit analysis, formal verification, and 3D partitioning. Operations include cofactor extraction, unateness detection, and clause evaluation, with inputs and outputs in integers, lists, and arrays. Examples include determining logical validity, generating missing spatial regions, and converting logic expressions to sum-of-products form.",
      "description_length": 623,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Gates",
      "description": "Converts between a custom type and a value type, enabling arithmetic and comparison operations on the value type. Supports bitwise and relational operations with explicit operator names, and allows resizing of values to specified bit widths. Used to manipulate and transform signal representations in hardware description or digital logic contexts.",
      "description_length": 348,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Mig",
      "description": "Combines logical operations on edge-based boolean values, supporting conjunction, disjunction, negation, and implication. Operates on a custom edge type to represent binary states, enabling the construction of complex logical expressions. Supports tasks such as circuit design and formal verification by allowing manipulation of boolean-like structures. Examples include building truth tables, simplifying expressions, and analyzing signal dependencies.",
      "description_length": 453,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Bddx",
      "description": "manages collections with set operations and structured data transformations, supporting tasks like filtering and conversion for types such as `Expr.t` paired with `float`. It provides membership checks, unions, intersections, and element-wise operations across generic and specialized data structures. Users can efficiently manipulate symbolic expressions and numerical values within the same framework. Examples include combining sets of expressions, extracting paired values, and transforming data for analysis.",
      "description_length": 513,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Cnf",
      "description": "combines value conversion and manipulation with key-value management, enabling both numeric and structured data processing alongside dynamic data configuration. It provides operations for arithmetic, comparison, and resizing on values, along with insertion, deletion, and transformation on key-based mappings. Users can perform element-wise signal processing and manage state through key-value sequences. Examples include adjusting signal dimensions and dynamically updating configuration parameters.",
      "description_length": 500,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HardCamlBloop.Sat",
      "description": "Provides functions to solve Boolean satisfiability problems from expressions and combinational gates, returning results as labeled boolean arrays. Works with custom types representing solution vectors and nested result structures. Used to generate human-readable solution reports and iterate through multiple valid solutions.",
      "description_length": 325,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Kmap",
      "description": "Encodes and visualizes Karnaugh maps for 2, 3, and 4 variables using nested integer lists and arrays, generating structured SVG outputs. Supports 2x2, 3x3, and 4x4 grid layouts to represent boolean logic expressions. Functions produce vector graphics suitable for educational and circuit design applications. Examples include rendering 4-variable maps with grouped cells to simplify logic expressions.",
      "description_length": 401,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Algebraic",
      "description": "Provides operations to convert between sum-of-products representations and a custom expression type, perform division with remainder, and analyze shared cubes in logical expressions. Works with nested lists of expressions, sets of expressions, and custom algebraic structures representing logical terms. Used for simplifying and decomposing logical formulas in symbolic computation tasks.",
      "description_length": 388,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop.Espresso",
      "description": "manages collections of hypercubes through expansion, reduction, and optimization, enabling detailed analysis and simplification of complex cube structures. It supports operations on `Pcn.Cubelist.t` and bitvector-based cube tuples, including splitting, merging, and eliminating redundancies. Interval conversion and extraction are also provided, transforming boolean coverage data into structured ranges. This allows for efficient manipulation of logical expressions, circuit optimization, and precise interval analysis.",
      "description_length": 520,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "hardcaml-bloop",
      "description": "Processes boolean functions using position cube notation, enabling efficient manipulation of logical expressions. Operates on data structures such as cubes, implicants, and boolean formulas to represent and simplify circuit logic. Supports tasks like equivalence checking and minimization of logical expressions in digital circuit design.",
      "description_length": 338,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HardCamlBloop",
      "description": "Combines set, map, and cube operations for managing unique identifiers, logical expressions, and structured data, with support for membership checks, unions, intersections, and transformations across generic and specialized types. Offers arithmetic, comparison, and bitwise operations on custom value types, along with edge-based boolean logic and Karnaugh map visualization. Enables solving Boolean satisfiability problems, converting between logical representations, and optimizing hypercube structures for circuit analysis and symbolic computation. Examples include generating solution vectors, simplifying logic expressions, and rendering 4-variable Karnaugh maps for circuit design.",
      "description_length": 687,
      "index": 56,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 57,
    "meaningful_modules": 57,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 687,
    "min_description_length": 241,
    "avg_description_length": 372.57894736842104,
    "embedding_file_size_mb": 0.2074451446533203
  }
}