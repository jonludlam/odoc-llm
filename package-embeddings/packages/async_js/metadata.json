{
  "package": "async_js",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 12,
  "creation_timestamp": "2025-08-14T23:14:45.821246",
  "modules": [
    {
      "module_path": "Async_js_test",
      "library": "async_js.async_test",
      "description": "This module implements asynchronous test execution and expectation management for JavaScript-compatible environments. It provides functions to define and run test cases with deferred evaluation, assertion handling, and result comparison. The module works with promises, test contexts, and custom configuration settings to support testing asynchronous workflows in web-based OCaml applications.",
      "description_length": 393,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Bonsai_test_handle_garbage_collector",
      "library": "async_js.test_handle_garbage_collector",
      "description": "Registers and runs cleanup actions for test handles, specifically for garbage collection during test execution. Works with function thunks that perform resource cleanup. Used to ensure test resources are properly released between test runs in different testing configurations.",
      "description_length": 276,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Async_js.Persistent_connection.Rpc.Event",
      "library": "async_js",
      "description": "Converts a persistent RPC connection event to an S-expression representation, using a provided function to serialize the address. Works with generic address types and event structures in asynchronous RPC connections. Useful for logging or debugging connection events with structured data.",
      "description_length": 288,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Async_js.Persistent_connection.Rpc",
      "library": "async_js",
      "description": "Handles persistent RPC connections with support for connection management, event handling, and address resolution. It works with asynchronous RPC connections, generic address types, and structured events. Useful for maintaining reliable client-server communication over RPC with custom retry logic and connection lifecycle monitoring.",
      "description_length": 334,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Async_js.Http.Method_with_args",
      "library": "async_js",
      "description": "This module defines HTTP methods with associated arguments, supporting `GET` requests with query parameters and `POST` requests with optional body data. It works with tuples of string pairs for query parameters and a Post_body type for payloads. Concrete use cases include constructing HTTP requests for API calls where query strings or JSON/form data payloads are required.",
      "description_length": 374,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Async_js.Rpc.Connection",
      "library": "async_js",
      "description": "This module enables bidirectional asynchronous RPC communication over a transport layer, offering connection lifecycle management (establishment, heartbeat monitoring, graceful shutdown), state inspection (liveness checks, I/O statistics), and metadata exchange (peer identification, menus). It supports client-server architectures through dedicated server setup and client connection functions, with robust error handling for handshake failures and timeout scenarios. Use cases include distributed systems requiring reliable peer communication, connection health monitoring, and structured data exchange during RPC handshakes.",
      "description_length": 627,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Async_js.Http.Post_body",
      "library": "async_js",
      "description": "This module handles constructing HTTP POST request bodies from various data types. It supports creating bodies from strings, DOM documents, blobs, and form data objects. Use it when sending structured data to a server via HTTP POST in a JavaScript environment.",
      "description_length": 260,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Async_js.Persistent_connection",
      "library": "async_js",
      "description": "Maintains persistent asynchronous RPC connections with support for connection management, event handling, and address resolution. It works with generic address types and structured events to enable reliable client-server communication with custom retry logic and lifecycle monitoring. Useful for implementing robust RPC clients that handle network failures and versioned protocol changes.",
      "description_length": 388,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Async_js.Http",
      "library": "async_js",
      "description": "This module implements HTTP client functionality for making asynchronous requests in a JavaScript environment. It provides operations for sending `GET` and `POST` requests with optional query parameters and structured request bodies, returning deferred responses. It works directly with string URLs, key-value lists for query parameters, and specialized body types such as form data or JSON payloads, enabling concrete use cases like calling REST APIs or submitting web forms.",
      "description_length": 476,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Async_js.Debug",
      "library": "async_js",
      "description": "This module outputs Sexp.t values to the console either as JavaScript objects or strings, and converts sexp expressions into JavaScript objects for display. It works directly with Core.Sexp.t and Js_of_ocaml.Js.Unsafe.any types. Use cases include debugging OCaml values in JavaScript environments by logging fully expanded representations or converting them for inspection.",
      "description_length": 373,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Async_js.Rpc",
      "library": "async_js",
      "description": "This module implements asynchronous RPC communication over a transport layer, managing connection lifecycles, heartbeats, and metadata exchange. It works with connection state, peer identifiers, and RPC menus, supporting client-server setups with error handling for handshakes and timeouts. Use it for building distributed systems that require reliable peer communication, connection health checks, and structured data exchange during RPC initialization.",
      "description_length": 454,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Async_js",
      "library": "async_js",
      "description": "This module provides asynchronous programming primitives and network communication capabilities, including functions for managing deferred execution, RPC and HTTP clients, and persistent connections. It works with connection states, HTTP requests and responses, and Sexp-based logging data, supporting concrete use cases such as implementing distributed systems, calling REST APIs, and debugging OCaml values in JavaScript environments. Key operations include `sleep`, `yield`, and initialization of the async scheduler, alongside structured data exchange and connection lifecycle management.",
      "description_length": 592,
      "index": 11,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 14,
    "meaningful_modules": 12,
    "filtered_empty_modules": 2,
    "retention_rate": 0.8571428571428571
  },
  "statistics": {
    "max_description_length": 627,
    "min_description_length": 260,
    "avg_description_length": 402.9166666666667,
    "embedding_file_size_mb": 0.17427921295166016
  }
}