{
  "package": "zanuda",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 17,
  "creation_timestamp": "2025-08-15T12:10:21.160897",
  "modules": [
    {
      "module_path": "Tast_pattern.Packed",
      "library": "zanuda.tast_pattern",
      "description": "This module packs and unpacks typed tree patterns for deferred matching. It works with `Typedtree` structures, enabling pattern parsing at different stages. Use it to create reusable pattern extractors that can be applied later to typed AST nodes.",
      "description_length": 247,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "My_printtyped",
      "library": "zanuda.tast_pattern",
      "description": "This module extends the functionality of the compiler's `Printtyped` module with additional printing functions for specific AST components. It provides concrete operations to format and print typed expressions, module expressions, and attributes using OCaml's `Format.formatter`. These functions are useful when inspecting or debugging typedtree nodes during compiler plugin development or when generating typed AST representations for analysis or tooling.",
      "description_length": 456,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "My_untype",
      "library": "zanuda.tast_pattern",
      "description": "This module converts typed abstract syntax trees (ASTs) into untyped ones, translating structures, signatures, expressions, patterns, and other typed elements into their corresponding untyped representations. It provides functions like `untype_structure`, `untype_signature`, and `untype_expression` for direct conversion, along with a customizable `mapper` to override specific translation steps. Use cases include generating Parsetree from Typedtree for code transformation, analysis, or pretty-printing tools.",
      "description_length": 512,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zanuda_core.Utils.RDJsonl",
      "library": "zanuda.core",
      "description": "This module provides functions for pretty-printing structured data in JSONL format to a formatter, with contextual information such as filename and line number. It operates on arbitrary data types using a provided printer function, and supports optional inclusion of error codes. Concrete use cases include logging diagnostic messages and formatting structured output for analysis tools.",
      "description_length": 387,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zanuda_core.Utils.Report",
      "library": "zanuda.core",
      "description": "Handles reporting and formatting of diagnostic messages, including plain text and JSONL output. Works with OCaml's `Format.formatter`, `Location.t`, and string-based file identifiers. Used to generate structured error reports and diagnostic logs during static analysis or linting processes.",
      "description_length": 290,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zanuda_core.Dune_project.Library",
      "library": "zanuda.core",
      "description": "This module defines a data structure representing a Dune library, including its name, unique identifier, source directory, dependencies, and constituent modules. It provides functions to parse this structure from S-expressions, enabling analysis of Dune project configurations. Concrete use cases include static analysis tools that process Dune project metadata to detect issues or gather statistics on library dependencies and module organization.",
      "description_length": 448,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zanuda_core.Utils.ErrorFormat",
      "library": "zanuda.core",
      "description": "Formats error messages with precise location information including filename, line, and column. Works with OCaml's `Format.formatter` and arbitrary data types for error values. Useful for displaying compiler or interpreter errors with contextual source code positions.",
      "description_length": 267,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zanuda_core.Collected_decls",
      "library": "zanuda.core",
      "description": "This module tracks defined and used values across a codebase to identify unused declarations. It provides functions to log declarations, mark them as used, and report unused values, operating on strings as identifiers. It analyzes signature trees to detect publicly exposed but unused fields in libraries.",
      "description_length": 305,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zanuda_core.Dune_project",
      "library": "zanuda.core",
      "description": "This module defines data structures to represent components of a Dune project, including modules, executables, libraries, and build contexts, along with functions to serialize and deserialize these structures using S-expressions. It supports parsing detailed project metadata such as module file paths, executable dependencies, and library configurations. Concrete use cases include static analysis tools that inspect Dune project layouts to identify module dependencies, enforce coding standards, or generate project documentation.",
      "description_length": 532,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zanuda_core.Collected_lints",
      "library": "zanuda.core",
      "description": "This module maintains a global, mutable collection of lints and type declarations. It provides operations to add and clear lints with their locations and reporter modules, and to report all collected lints. It also tracks type declarations to suppress lints in derived code, with functions to add, check, and clear these declarations. Use cases include accumulating linting results during code analysis and managing suppression of lints in generated code from type declarations.",
      "description_length": 478,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zanuda_core.Config",
      "library": "zanuda.core",
      "description": "This module manages configuration and runtime settings for a linter tool through a mutable record and global state. It provides operations to toggle analysis checks, specify input/output paths, filter files via inclusion lists, and control output formats (e.g., JSONL, GoLint) using string-based identifiers and boolean flags. Key use cases include customizing linting behavior per project, enabling/disabling specific rules, and directing results to files or streams.",
      "description_length": 468,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zanuda_core.Unused_ML_logger",
      "library": "zanuda.core",
      "description": "Tracks unused values in OCaml source files by analyzing TAST (Typed AST) structures during compilation. It integrates with the Tast_iterator module to log and report values that are defined but never used. Useful for identifying dead code in large OCaml projects during static analysis passes.",
      "description_length": 293,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zanuda_core.LINT",
      "library": "zanuda.core",
      "description": "This module defines core types and interfaces for building linters that analyze OCaml program trees. It includes types to classify lints by group (e.g., Style, Correctness, Perf), severity level (e.g., Warn, Deny), and origin (e.g., Camelot, Clippy). Concrete use cases include configuring linting rules, categorizing static analysis findings, and reporting issues with structured metadata.",
      "description_length": 390,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zanuda_core.Utils",
      "library": "zanuda.core",
      "description": "This module includes functions for formatted output, error message generation, and structured data printing. It works with OCaml's `Format.formatter`, `Location.t`, strings, and custom types like `rdjsonl_code`. Concrete uses include logging diagnostics with source positions, generating JSONL output for analysis tools, and producing structured error reports during linting or static analysis.",
      "description_length": 394,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zanuda_core.Lint_filesystem",
      "library": "zanuda.core",
      "description": "Performs linting operations on filesystem paths and configurations. Works with Dune project structures and JSON output formats. Checks for invalid paths, permission issues, and enforces project layout rules.",
      "description_length": 207,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zanuda_core.Load_dune",
      "library": "zanuda.core",
      "description": "This module traverses a directory, loading and analyzing Dune files by processing both implementation and interface files. It accepts callbacks to handle untyped file paths, typed structures from implementation files, and signatures from interface files, with a distinction between wrapped and non-wrapped contexts. It is used to inspect or transform OCaml codebases by analyzing their typed representations during Dune-based builds.",
      "description_length": 433,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zanuda_core",
      "library": "zanuda.core",
      "description": "This module implements a linter infrastructure for OCaml codebases with a focus on static analysis, lint collection, and Dune project inspection. It provides functionality for tracking unused declarations, managing lint suppression, defining lint rules and severity levels, analyzing filesystem paths, and parsing Dune project metadata. Concrete use cases include enforcing code quality standards, identifying dead code in typed ASTs, generating structured diagnostic output, and validating project layouts during CI/CD pipelines.",
      "description_length": 530,
      "index": 16,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 18,
    "meaningful_modules": 17,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9444444444444444
  },
  "statistics": {
    "max_description_length": 532,
    "min_description_length": 207,
    "avg_description_length": 390.4117647058824,
    "embedding_file_size_mb": 0.24676990509033203
  }
}