{
  "package": "gospel",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 47,
  "creation_timestamp": "2025-07-15T23:15:02.278153",
  "modules": [
    {
      "module_path": "Gospel.Opprintast.Option",
      "library": "gospel",
      "description": "Extracts the value from an option type, returning a default if none. Works with `'a option` and a default value of type `'a`. Useful for safely handling optional values without raising exceptions.",
      "description_length": 196,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Identifier.Ident",
      "library": "gospel",
      "description": "This module manages uniquely tagged identifiers with attributes, location, and string names. It supports creation with customizable attributes and location, comparison, equality checks, hashing, pretty-printing, and modification of identifier properties. Concrete use cases include tracking typed identifiers during compilation, managing source locations for error reporting, and handling identifier attributes in code transformations.",
      "description_length": 435,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Identifier.Preid",
      "library": "gospel",
      "description": "This module represents identifiers produced by the parser, containing a name, attributes, and source location. It supports creating identifiers with optional attributes and location, adding attributes, and pretty-printing. Used to track untyped AST identifiers with metadata for error reporting and transformation passes.",
      "description_length": 321,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Symbols.Sls",
      "library": "gospel",
      "description": "This module provides a custom ordered collection type that supports both set-like operations (union, intersection, membership checks) and list-like functional manipulations (mapping, folding, filtering) over elements of a specific type. It includes interoperability with sequences and supports conversions to/from lists, enabling efficient data processing workflows that combine ordered traversal with set-theoretic operations or iterative transformations. Use cases include symbolic computation tasks requiring hybrid data manipulation, such as analyzing or transforming structured collections with dynamic membership constraints and ordered dependencies.",
      "description_length": 656,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Ttypes.Ts",
      "library": "gospel",
      "description": "This module implements operations for comparing, hashing, and checking equality of type symbols. It works directly with the `tysymbol` type from the `Gospel.Ttypes` module. These functions are used to support efficient data structure operations like set membership and map key lookups when processing or analyzing type information in a compiler or static analysis tool.",
      "description_length": 369,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gospel.Symbols.Vs",
      "library": "gospel",
      "description": "This module represents and compares value symbols in a program's intermediate representation. It provides a concrete type `t` for value symbols and a comparison function `compare` to establish a total order between them. Useful for managing variable identifiers in compilers or analysis tools where symbol equality and ordering are required.",
      "description_length": 341,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Tmodule.Mid",
      "library": "gospel",
      "description": "This module provides ordered map operations for dictionaries keyed by identifiers, supporting efficient lookups, transformations, and combinations of polymorphic values. It works with maps (`Mid.t`) and sequences of key-value pairs, offering functions for structural manipulation (e.g., merging, filtering, partitioning), ordered traversal, and conversion between maps and sequences. Specific use cases include managing identifier-scoped data in compilers, aggregating list-valued entries, and maintaining sorted key-value associations for incremental updates or range queries.",
      "description_length": 577,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gospel.Ttypes.Tvar",
      "library": "gospel",
      "description": "This module represents and manipulates type variables as symbols. It provides equality checking, comparison, and hashing operations for type variables. These functions are used when managing type inference variables in a compiler or type checker.",
      "description_length": 246,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gospel.Ttypes.Hts",
      "library": "gospel",
      "description": "This module supports efficient key-value storage and manipulation using hash tables indexed by keys of type `Gospel.Ttypes.Ts.t`. It provides imperative operations for individual entry management (insertion, lookup, deletion) and bulk transformations via sequence-driven initialization, in-place filtering, and iterative processing. Typical applications include aggregating data from sequential sources, maintaining dynamic mappings with high-performance lookups, and implementing caches or symbol tables requiring O(1) access patterns.",
      "description_length": 536,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gospel.Symbols.Svs",
      "library": "gospel",
      "description": "This module provides functional set operations and transformations over immutable collections of elements, supporting membership queries, set algebra (union, intersection, difference), ordered element selection, and sequence-based manipulation. It works with sets represented as `Svs.t` and their elements of type `Svs.elt`, offering both standard combinatorial operations and performance-optimized traversals. The design accommodates use cases requiring persistent data structures for symbolic computation, static analysis, or scenarios where immutability ensures safe sharing of set states across computations.",
      "description_length": 612,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Ttypes.Mts",
      "library": "gospel",
      "description": "This module enables management of key-value associations with `Ts.t` keys, offering operations like insertion, deletion, merging, and ordered traversal, alongside filtering, mapping, and predicate checks. It supports maps with arbitrary value types, facilitating use cases such as data aggregation, configuration management, and sequence-based processing where ordered traversal or bulk conversions are required.",
      "description_length": 412,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Symbols.Mls",
      "library": "gospel",
      "description": "This module implements dictionary operations on ordered maps with keys of type `LS.t`, supporting insertion, deletion, merging, and querying with optional values or list conversions. It provides functions for iteration, mapping, filtering, and bidirectional transformations between maps and sequences, including key-based ordering and range operations. These capabilities are suited for managing hierarchical or ordered key-value data, merging partial maps, and efficiently converting between structured formats while preserving traversal order.",
      "description_length": 545,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gospel.Utils.Fmt",
      "library": "gospel",
      "description": "This library extends OCaml's Format module with composable pretty-printing combinators for structured data visualization, offering precise control over layout through box models (hbox, vbox), separators, and customizable formatting pipelines. It handles basic types (numbers, strings, booleans), structured data (records, lists, exceptions), and containers (arrays, hash tables, queues) with support for binary representations, colored output, and error-specific formatting. Designed for applications like debugging tools, logging systems, and terminal interfaces requiring rich text rendering or complex data serialization.",
      "description_length": 624,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Ttypes.Htv",
      "library": "gospel",
      "description": "This module provides hash table operations for managing mappings between `Tvar.t` keys and arbitrary values, supporting imperative-style modifications like insertion, deletion, bulk updates from sequences, and filtered iteration. It operates on a mutable, hash table-like structure optimized for in-place transformations and efficient bulk construction from key-value sequences. Typical use cases include incremental data aggregation, transient state management, and scenarios requiring high-performance lookups or batch processing of variable-to-value associations.",
      "description_length": 566,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Ttypes.Mxs",
      "library": "gospel",
      "description": "This module provides operations for managing finite maps with keys of type `Xs.t` and arbitrary values, including insertion, deletion, lookup, merging, and transformation via mapping and folding. It supports bidirectional iteration, filtering, and bulk updates through conversions to and from sequences. Use cases include scenarios requiring efficient key-based access, combining maps with custom merge strategies, or processing ordered key-value pairs in bulk operations.",
      "description_length": 472,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gospel.Symbols.LS",
      "library": "gospel",
      "description": "This module defines a type `t` representing logical symbols and provides operations for comparing, checking equality, and computing hash values for these symbols. It works directly with the `lsymbol` type from the `Gospel.Symbols` module. Concrete use cases include managing identifiers for logical functions and predicates in formal verification tasks.",
      "description_length": 353,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Ttypes.Xs",
      "library": "gospel",
      "description": "This module defines operations for comparing and checking equality of exception symbols. It provides the `equal` and `compare` functions, which are used to determine structural equivalence and ordering of values of type `Gospel.Ttypes.xsymbol`. These operations are essential for managing exception identifiers in contexts like error handling and symbol table management.",
      "description_length": 371,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Utils.Sstr",
      "library": "gospel",
      "description": "This implementation offers an immutable data structure for managing collections of unique strings with efficient membership checks and set operations like union, intersection, and difference. It centers around an abstract type `t` representing ordered string sets, supporting transformations (e.g., `map`, `filter`), structural queries (`subset`, `equal`), and conversions to/from lists and sequences for ordered traversal. Typical use cases include scenarios requiring high-performance set algebra, deduplicated string storage with predictable iteration order, or incremental set construction from sequential data sources.",
      "description_length": 623,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Symbols.Mvs",
      "library": "gospel",
      "description": "The implementation provides a map structure with keys of type `Gospel.Symbols.Vs.t`, supporting associative operations like insertion, deletion, and lookup, as well as advanced transformations such as merging, filtering, and union. It facilitates conversions between maps and sequences of key-value pairs, enabling bulk updates and ordered traversal via iteration and folding. This is particularly useful for managing hierarchical or ordered data associations, combining maps with custom combination logic, and efficiently processing collections with conditional or extremal element extraction.",
      "description_length": 594,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Warnings",
      "library": "gospel",
      "description": "This module defines error and warning types for handling type checking, parsing, and semantic analysis issues in a compiler or linter. It includes specific error kinds like unbound variables, type mismatches, and syntax errors, along with functions to format and display these errors. It is used to report issues during program analysis with precise locations and structured messages.",
      "description_length": 384,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gospel.Uattr2spec",
      "library": "gospel",
      "description": "Processes OCaml parsetrees to extract Gospel specifications from attributes, returning an annotated parsetree with those specifications linked to their corresponding AST nodes. Works directly with `Ppxlib.signature` and `Gospel.Uast.s_signature` structures. Useful for integrating Gospel-based specification extraction into OCaml toolchains during compilation.",
      "description_length": 360,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Parser_frontend",
      "library": "gospel",
      "description": "This module handles parsing of OCaml and GOSPEL files, resolving file paths against a load path and integrating GOSPEL specifications into OCaml signatures. It works with strings representing file paths, OCaml signatures, and GOSPEL abstract syntax trees. Concrete use cases include locating interface files in a search path, parsing OCaml signatures, and merging GOSPEL annotations into those signatures for formal verification.",
      "description_length": 429,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Tterm",
      "library": "gospel",
      "description": "This module defines core data structures and operations for representing and manipulating logical terms and patterns in a type system. It includes types like `term`, `pattern`, and `binop` that model logical expressions, quantifiers, and binary operations, along with formatters and printers for these structures. It is used to build and serialize logical formulas with type information and source locations, suitable for theorem proving or formal verification tasks.",
      "description_length": 467,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gospel.Tterm_printer",
      "library": "gospel",
      "description": "This module provides functions to format and print various components of terms and symbols, including variables, logical symbols, patterns, binary operations, and quantifiers. It works directly with data types such as `vsymbol`, `lsymbol`, `pattern`, `binop`, `quant`, and `term` from the `Gospel.Symbols` and `Gospel.Tterm` modules. Use cases include generating human-readable representations of terms for debugging, logging, or user-facing output in theorem proving or formal verification tools.",
      "description_length": 497,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Identifier",
      "library": "gospel",
      "description": "This module manages identifiers with predefined constants and notation styles for DSLs or compilers, offering functions to create and recognize identifiers with prefix, infix, or mixfix forms. It supports core operations like name generation and pattern checks, while child modules extend functionality to handle uniquely tagged identifiers with attributes and source locations, enabling typed identifier tracking and metadata-aware transformations. One submodule provides full attribute and location management with comparison and hashing, and another focuses on parser-generated identifiers for untyped ASTs with metadata support. Examples include generating operator symbols, tracking variable declarations with types, and preserving source positions for error reporting.",
      "description_length": 774,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Utils",
      "library": "gospel",
      "description": "This module provides utilities for list manipulation, including functions to split lists by predicate or index while preserving order, combined with submodules for advanced formatting and string set operations. The core module handles list transformations, while the formatting submodule offers composable pretty-printing combinators for structured data, and the string set submodule provides an immutable, ordered representation of unique strings with efficient set operations. Examples include splitting log entries for processing, rendering complex data structures with custom layouts, and managing ordered collections of unique identifiers with union and intersection operations. Together, these components enable structured data transformation, rich text formatting, and efficient string set manipulation.",
      "description_length": 810,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Gospellib",
      "library": "gospel",
      "description": "Retrieves the contents of a file as a string. Works with file paths as strings. Useful for reading small text files or configuration data directly into memory.",
      "description_length": 159,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Coercion",
      "library": "gospel",
      "description": "This module manages a collection of coercion functions between types, represented as a data structure of type `t`. It supports adding coercions from a symbol representing a function, looking up coercions between specific types, and merging coercion sets asymmetrically. It is used to handle type conversions during type checking or program transformation tasks.",
      "description_length": 361,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Tast",
      "library": "gospel",
      "description": "This module provides pretty-printing, parsing, and structural representation operations for abstract syntax trees (ASTs) in a formal specification language. It works with types like function arguments (`lb_arg`), value/type specifications (`val_spec`, `type_spec`), algebraic type declarations (`type_declaration`, `constructor_decl`), axioms, and module system constructs (`signature_item`, `module_type`). These operations support formal verification workflows, effect analysis, and type system modeling by converting structured data into readable formats or intermediate representations for tooling.",
      "description_length": 602,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Patmat",
      "library": "gospel",
      "description": "Performs exhaustiveness and redundancy checks for pattern matching. It takes a type, a list of patterns with optional guards and associated terms, and validates that all possible cases are covered without overlap. Useful when implementing or analyzing pattern matches in typed terms.",
      "description_length": 283,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Tast_helper",
      "library": "gospel",
      "description": "This module constructs and manipulates typed abstract syntax trees for a logic language embedded in OCaml. It provides functions to build type declarations, value specifications, function definitions, axioms, and signature items with precise type and symbol information. These operations are used to represent and process formal specifications and program logic, such as defining function contracts, algebraic data types, and logical assertions.",
      "description_length": 445,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Ulexer",
      "library": "gospel",
      "description": "This module handles lexical analysis for parsing, including token recognition, string and character literal decoding, and comment processing. It works with lexing buffers and string buffers to parse input, supporting numeric conversions, escape sequences, and whitespace handling. Concrete use cases include parsing source code tokens, processing quoted strings with escapes, and handling multi-line comments.",
      "description_length": 409,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Tmodule",
      "library": "gospel",
      "description": "This module manages hierarchical namespaces and module structures while enabling type-level transformations through core data types like `namespace`, `module_uc`, and signatures. It supports symbol visibility control, module hierarchy composition, and type substitution, with operations for building, opening, closing, and serializing module systems. Submodule 1 extends this by providing ordered map operations over identifier keys (`Mid.t`), enabling efficient lookups, merges, and ordered traversals for managing polymorphic, scoped data such as compiler symbol tables. Together, they allow structured manipulation of nested modules and typed environments, supporting advanced workflows like incremental module updates and scoped type inference.",
      "description_length": 748,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Ttypes",
      "library": "gospel",
      "description": "This module represents and manipulates type variables, symbols, and exceptions, supporting substitution, type instantiation, and equality checks. It handles built-in types like integers and booleans, parameterized types such as lists and options, and structured exceptions, enabling symbolic type manipulation for language implementation and type system design. Submodules provide equality, comparison, and hashing for type symbols and variables, along with efficient hash tables and maps indexed by these types for managing dynamic associations and performing bulk transformations. Examples include tracking type variables during inference, aggregating data in symbol tables, and comparing or merging exception identifiers in error handling workflows.",
      "description_length": 752,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gospel.Opprintast",
      "library": "gospel",
      "description": "This module transforms and formats OCaml abstract syntax trees, handling operator fixity, precedence-aware layout, and structured data rendering for elements like expressions, patterns, and type definitions. It provides operations to format AST nodes using context-aware formatters and manipulate Parsetree elements programmatically, enabling tasks like generating readable OCaml source from ASTs or building custom pretty-printers. A helper function extracts values from option types with a default fallback, simplifying safe handling of optional data during transformation passes. Together, these capabilities support both fine-grained AST manipulation and robust formatting logic in compiler toolchains.",
      "description_length": 706,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Uast",
      "library": "gospel",
      "description": "This module defines core data structures and types for representing program specifications and terms in a formal verification context. It includes types for qualified identifiers, polymorphic type expressions, patterns, terms, and specifications such as preconditions, postconditions, and axioms. It is used to model function and value signatures with detailed behavioral annotations, supporting precise static analysis and proof obligations generation.",
      "description_length": 453,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Dterm",
      "library": "gospel",
      "description": "This module enables typed term manipulation with unification, type inference, coercion, and symbol specialization over algebraic data types representing terms, patterns, types, and formulas. It includes type environment management for variable bindings and location tracking, supporting formal verification workflows in proof assistants and program analysis tools. Operations allow concrete tasks like unifying two terms under a substitution, inferring the type of a term in a given environment, or specializing a symbol based on type constraints. Submodules structure representations of terms, patterns, types, and formulas while providing environment utilities for managing scoped bindings and error tracking during type checking.",
      "description_length": 732,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Pps",
      "library": "gospel",
      "description": "Handles parsing and pretty-printing of OCaml code. Works with lexing buffers and formatters to process and output structured data. Useful for tools that analyze or transform OCaml source code, such as linters or code generators.",
      "description_length": 228,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Upretty_printer",
      "library": "gospel",
      "description": "This module provides functions for pretty-printing various abstract syntax tree (AST) elements using OCaml's `Format` module. It handles structures like qualified identifiers, type specifications, function declarations, and module types, formatting them into readable string representations. Use cases include generating human-readable output for program analysis, debugging AST transformations, and printing type-checked code during compilation phases.",
      "description_length": 453,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gospel.Tterm_helper",
      "library": "gospel",
      "description": "This module provides utilities for building and analyzing typed abstract syntax trees with a focus on term and pattern manipulation. It operates on structured representations of terms, patterns, and logical expressions augmented with source location metadata, supporting operations like conditional construction, lambda binding, and logical connective composition. Key use cases include intermediate representation generation for compilers, type-safe term transformation, and formal verification tasks requiring precise control over variable scoping and logical formula construction.",
      "description_length": 583,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Uparser",
      "library": "gospel",
      "description": "This module defines a comprehensive set of lexical tokens used in parsing a formal specification language. It includes functions to parse value, type, and function specifications, as well as axioms and full function definitions. These parsers consume tokens from a `Lexing.lexbuf` and produce abstract syntax tree nodes defined in the `Uast` module, enabling precise interpretation of formal contracts and logical assertions in source code.",
      "description_length": 440,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Symbols",
      "library": "gospel",
      "description": "This module manages symbolic representations of variables and logical entities for formal verification, centered around two core types: `vsymbol` for variable identifiers and `lsymbol` for logical symbols such as functions and predicates. It provides utilities to create, compare, hash, and format these symbols, forming the basis for modeling first-order logic expressions and data structures in the Gospel specification language. Child modules extend this foundation with specialized collections\u2014such as ordered hybrid structures for set and list operations, maps keyed by symbols, and functional sets\u2014supporting tasks like static analysis, symbolic computation, and structured data transformation. Examples include tracking variable dependencies with ordered sets, managing logical function definitions in maps, and performing set algebra over symbol collections with efficient traversal and transformation.",
      "description_length": 910,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Typing",
      "library": "gospel",
      "description": "This module supports type checking of module signatures by creating and manipulating parsing environments and module states. It processes signature items within a module under construction, updating the module state and producing typed signatures. Concrete use cases include building typed representations of modules during compilation and validating module dependencies against provided interfaces.",
      "description_length": 399,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospel.Tast_printer",
      "library": "gospel",
      "description": "Prints type-checked Gospel signatures in a human-readable format. It operates on `Gospel.Tast.signature` values, which represent annotated type signatures. Use this module to inspect or debug the structure of type-checked Gospel code directly.",
      "description_length": 243,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gospel",
      "library": "gospel",
      "description": "This module suite provides a comprehensive framework for formal specification, type analysis, and transformation of OCaml and Gospel code. Core data types include logical terms, patterns, type expressions, symbols, and annotated abstract syntax trees, with operations for unification, type inference, coercion, and pretty-printing. You can extract Gospel specifications from OCaml code, validate pattern exhaustiveness, generate human-readable output, and perform precise error reporting with source locations. Specific applications include building linters, implementing formal verification tools, transforming ASTs with type-aware operations, and integrating specification-driven analysis into OCaml toolchains.",
      "description_length": 713,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gospelstdlib.Map",
      "library": "gospel.stdlib",
      "description": "This module implements finite maps using functions from keys to values. It provides operations to create empty maps, add or remove bindings, and lookup values by key. These maps are used to model mutable state in specifications, such as tracking variable assignments or heap structures.",
      "description_length": 286,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gospelstdlib",
      "library": "gospel.stdlib",
      "description": "The module provides a foundation for working with finite maps, enabling the representation of mutable state through key-value bindings. It supports operations to create empty maps, insert or remove key-value pairs, and query values by key, facilitating the modeling of variable assignments and heap-like structures in specifications. Key data types include functions from keys to values, with operations like add, remove, and find. For example, a map can track variable values in a program state or represent dynamic memory allocations.",
      "description_length": 536,
      "index": 46,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 58,
    "meaningful_modules": 47,
    "filtered_empty_modules": 11,
    "retention_rate": 0.8103448275862069
  },
  "statistics": {
    "max_description_length": 910,
    "min_description_length": 159,
    "avg_description_length": 489.59574468085106,
    "embedding_file_size_mb": 0.1711587905883789
  }
}