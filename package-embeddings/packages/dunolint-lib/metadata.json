{
  "package": "dunolint-lib",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 83,
  "creation_timestamp": "2025-07-15T23:19:01.578581",
  "modules": [
    {
      "module_path": "Dunolint.Dune.Pps.Predicate.Flag.Applies_to",
      "library": "dunolint-lib",
      "description": "This module defines a type `t` representing the scope to which a preprocessor flag applies, such as any target, a specific driver, or a named preprocessor. It includes functions for comparing, checking equality, and converting values to and from S-expressions. It is used to specify and manipulate the application targets of flags in Dune preprocessing configurations.",
      "description_length": 368,
      "index": 0,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Dunolint.Dune.Pps.Predicate.Pp_with_flag",
      "library": "dunolint-lib",
      "description": "This module defines a data structure representing a preprocessor with an associated command-line flag and parameter. It supports comparison, equality checks, and S-expression serialization for parsing and generating configuration data. Concrete use cases include analyzing and transforming Dune configuration files based on preprocessor flags and their arguments.",
      "description_length": 363,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Pps.Predicate.Flag",
      "library": "dunolint-lib",
      "description": "This module represents flags in a Dune configuration, capturing their names, parameters, and application scope. It supports comparison, equality checks, and serialization, enabling tasks like parsing Dune files and analyzing flag applicability during build setup. The child module enhances this by defining the scope of a flag, such as applying to any target, a specific driver, or a named preprocessor, with functions to compare and serialize these scopes. Together, they allow precise specification and manipulation of preprocessing flags in Dune projects, such as determining which flags apply to a given build target or converting flag configurations to S-expressions for storage.",
      "description_length": 684,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Instrumentation.Backend.Name",
      "library": "dunolint-lib",
      "description": "This module defines a named type `t` for representing backend names in the Dune instrumentation system, ensuring valid string formatting through controlled construction. It provides comparison, equality, hashing, and S-expression serialization functions for use in data structures and persistent storage. Key operations include safe validation from untrusted strings and direct creation for trusted literals, supporting robust configuration and analysis workflows.",
      "description_length": 464,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Library.Name.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines predicates for matching library names based on exact equality, prefix, or suffix checks. It supports operations like comparison and serialization to/from S-expressions. Concrete use cases include filtering or validating Dune library names during linting or configuration processing.",
      "description_length": 302,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Library.Public_name.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines predicates for matching public library names in Dune files, supporting exact matches, prefix checks, and suffix checks. It operates on `Dunolint.Dune.Library.Public_name.t` values and provides comparison, equality, and S-expression serialization functions. Concrete use cases include filtering or validating library names during Dune file linting based on specific naming conventions.",
      "description_length": 404,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Executable.Name.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines predicates for matching executable names in Dune files, supporting exact matches, prefix checks, and suffix checks. It works with the `name` type representing Dune executable names and standard string values for prefix and suffix conditions. Concrete use cases include filtering or validating executable names during Dune file analysis or linting.",
      "description_length": 367,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune.Executable.Public_name.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines predicates for matching public names of executables using exact equality, prefix, or suffix checks. It supports operations like comparison, equality checking, and S-expression serialization/deserialization for structured name filtering. Use cases include validating or selecting executable names in build configurations based on specific naming conventions or patterns.",
      "description_length": 389,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Pps.Predicate.Param",
      "library": "dunolint-lib",
      "description": "This module defines a polymorphic variant type `t` representing parameter matching conditions in dune file parsing, including exact string matches. It provides comparison, equality checks, and S-expression serialization/deserialization for this type. This is used to specify and evaluate preprocessor parameter conditions in dune configuration files.",
      "description_length": 350,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Config.Skip_subtree.Result",
      "library": "dunolint-lib",
      "description": "This module defines a result type used to represent outcomes of subtree skipping decisions in configuration processing. It provides comparison, equality checks, and S-expression serialization/deserialization for this type. This is used to handle and persist skip rule results in a structured and interoperable way.",
      "description_length": 314,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Library.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines a polymorphic variant type `t` representing predicates for filtering or matching Dune library fields such as name, public name, lint settings, instrumentation, and preprocessing. It includes operations for comparison, equality checks, and S-expression serialization/deserialization tailored to these predicates. Use cases include defining and manipulating structured conditions for Dune library analysis or transformation tools.",
      "description_length": 448,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Instrumentation.Backend",
      "library": "dunolint-lib",
      "description": "The module represents backend names in the Dune instrumentation system with a structured type `t`, ensuring valid formatting through controlled construction. It supports comparison, equality, hashing, and S-expression serialization, enabling use in data structures and persistent storage. Operations include safe validation from untrusted strings and direct creation for trusted literals, facilitating robust configuration and analysis workflows. For example, it allows parsing and validating backend names from configuration files or constructing known names for internal use.",
      "description_length": 577,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Stanza.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines a set of predicates representing Dune stanza types, such as `library`, `executable`, and `include_subdirs`. It provides comparison, equality checks, and S-expression serialization/deserialization for these predicates. These operations support filtering and processing Dune configuration stanzas based on their type in linters or analysis tools.",
      "description_length": 364,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Package.Name",
      "library": "dunolint-lib",
      "description": "This module defines a validated string type for package names, ensuring values conform to expected invariants. It provides comparison, equality checks, hashing, and serialization functions for use in data structures and persistent storage. Concrete use cases include safely handling package names during dune file parsing and validation, where invalid names must be rejected with descriptive errors.",
      "description_length": 399,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Include_subdirs.Mode",
      "library": "dunolint-lib",
      "description": "This module defines a type `t` representing the mode for including subdirectories in Dune files, with variants `no`, `unqualified`, and `qualified`. It provides comparison, equality checking, and S-expression serialization and deserialization functions for this type. This module is used to handle and manipulate include_subdirs modes when processing or generating Dune configuration files.",
      "description_length": 390,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Lint.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines and manipulates predicate expressions used to specify conditions on ppx rewriters and their parameters in lint configurations. It supports operations like comparison, equality checks, and S-expression conversion for a type that includes ppx names, flags, and combined ppx-with-flag patterns. Concrete use cases include defining and serializing lint rules that match specific ppx rewriters or command-line flags in Dune configuration files.",
      "description_length": 459,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune_project.Implicit_transitive_deps.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines a predicate type for filtering implicit transitive dependencies in Dune projects, supporting boolean equality checks. It includes functions for comparison, equality testing, and S-expression serialization/deserialization. A concrete use case is enforcing dependency rules by evaluating whether a dependency matches a specified boolean condition during project analysis.",
      "description_length": 389,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune.Pps.Predicate",
      "library": "dunolint-lib",
      "description": "This module represents predicates for Dune preprocessing rules using a variant type that captures preprocessors, flags, and their combinations. It supports comparison, equality, and S-expression conversion, enabling validation and transformation of Dune configuration files. The module's submodules refine this with specific constructs: one handles preprocessors with flags and parameters, another defines flag scopes and applicability, and a third models parameter matching conditions. Together, they enable precise analysis and manipulation of preprocessing directives, such as determining flag application scope or serializing complex preprocessor configurations.",
      "description_length": 666,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune.Library.Name",
      "library": "dunolint-lib",
      "description": "This module represents library names with a type `t` that enforces valid naming conventions through creation functions like `of_string` and `v`, and supports comparison, equality, hashing, and S-expression serialization. Its core operations enable robust manipulation and validation of library names during Dune file parsing and analysis. The predicates submodule extends this functionality with utilities for matching names based on exact, prefix, or suffix conditions, supporting filtering and validation workflows. Together, they provide a cohesive interface for handling library names in both direct and conditional contexts.",
      "description_length": 629,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune_project.Name.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines a set of predicates for matching Dune project names based on equality, prefix, or suffix checks. It includes comparison, equality, and S-expression conversion functions for these predicates. Concrete use cases include filtering or validating project names in Dune configuration files based on specific naming patterns.",
      "description_length": 338,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Config.Skip_subtree.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines a type `t` representing predicates for skipping subtrees based on file paths, using a variant that wraps a path predicate. It includes functions for comparison, equality checks, and S-expression serialization/deserialization. Concrete use cases include configuring path-based exclusion rules in linters or file processors.",
      "description_length": 342,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Pp.Name",
      "library": "dunolint-lib",
      "description": "This module defines a validated string type for names used in Dune configuration files. It provides comparison, equality, and hashing operations, along with S-expression serialization and deserialization. It includes functions to safely construct values from strings with validation, ensuring correct formatting for use in Dune-specific contexts like field names or identifiers.",
      "description_length": 378,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Preprocess.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines and manipulates predicate values used to specify preprocessor configurations in Dune files. It supports operations like comparison, equality checks, and S-expression serialization/deserialization for a variant type that represents either no preprocessing or a conditional pps specification involving ppx rewriters, flags, or combinations thereof. It is used to enforce precise preprocessing rules in Dune project files, such as restricting allowed ppx rewriters or requiring specific preprocessing flags.",
      "description_length": 524,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune.Library.Public_name",
      "library": "dunolint-lib",
      "description": "This module represents valid public names for Dune libraries using the type `t`, ensuring correctness through validation functions like `of_string` and `v`. It supports comparison, equality, and serialization, along with defining conditions via the `Predicate` module, which allows exact matches, prefix, and suffix checks. Use it to validate and manipulate library names during Dune file processing or enforce naming conventions during linting. The `Predicate` submodule operates on `t` values to filter or validate names based on specific rules.",
      "description_length": 547,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Executable.Public_name",
      "library": "dunolint-lib",
      "description": "This module provides a validated string type for executable public names, enforcing correct naming conventions and offering safe construction from raw strings, equality, comparison, and serialization. Its main data type represents a validated name, with operations to convert, compare, and hash values, while the child module adds pattern-based matching via prefixes, suffixes, and exact matches. Together, they enable parsing, filtering, and validation of executable names in Dune files, ensuring consistent naming across builds. Example uses include checking whether a name conforms to a specific pattern or converting user-provided strings into validated names for build configuration.",
      "description_length": 688,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Executable.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines a polymorphic variant type `t` representing predicates for filtering or matching executable configurations in Dune files, supporting conditions on fields like name, public name, lint settings, instrumentation backends, and preprocessing directives. It includes comparison, equality, and S-expression serialization functions for use in analysis or linting tools. Concrete use cases include validating executable stanzas against specific naming conventions, checking enabled linting passes, or ensuring consistent preprocessing settings across a project.",
      "description_length": 572,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune.Executable.Name",
      "library": "dunolint-lib",
      "description": "This module represents executable names in Dune files using a validated string type that enforces naming constraints. It supports comparison, equality, hashing, and S-expression serialization, with functions to safely construct values from raw strings. The child module adds matching capabilities, allowing exact matches, prefix checks, and suffix checks, both against validated names and raw strings. Together, they enable robust parsing, filtering, and validation of executable names during Dune file processing and static analysis.",
      "description_length": 534,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Instrumentation.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines a type `t` representing predicates for filtering or matching instrumentation backends by name. It provides comparison, equality checks, and S-expression serialization/deserialization for this type. It is used to specify conditions when configuring or querying instrumentation backends in a Dune project.",
      "description_length": 323,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune_project.Generate_opam_files.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines a single predicate type `t` with one constructor `` `is_present `` to represent the presence of a condition. It provides comparison, equality checks, and S-expression serialization/deserialization for this type. The module is used to encode and manipulate simple boolean-like conditions in the context of generating opam files.",
      "description_length": 347,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Include_subdirs.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines a single predicate type that checks if an include subdirectory mode equals a specified value. It supports comparison, equality checks, and S-expression serialization for the predicate type. Useful for validating and comparing directory inclusion modes in Dune configuration files.",
      "description_length": 300,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Stanza",
      "library": "dunolint-lib",
      "description": "This module defines predicates for Dune stanza types like `library`, `executable`, and `include_subdirs`, enabling type-based filtering and analysis of Dune configurations. It supports comparisons, equality checks, and conversion to and from S-expressions, facilitating integration with linters and configuration processors. For example, you can check if a stanza is a `library`, compare two stanza types, or serialize a predicate for storage or transmission.",
      "description_length": 459,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Path.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines predicates for matching file paths using exact equality or glob patterns. It supports operations like comparison, equality checks, and S-expression serialization/deserialization for predicates. Useful for filtering or routing paths in linting or file processing tools based on static or pattern-based rules.",
      "description_length": 327,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Preprocess",
      "library": "dunolint-lib",
      "description": "This module handles predicate values that define preprocessing rules in Dune configurations, supporting precise control over ppx rewriters and preprocessing flags. It provides a variant type to represent either no preprocessing or conditional specifications combining rewriters, flags, and parameters, with operations for comparison, equality, and S-expression serialization. Users can define and enforce constraints such as requiring specific ppx rewriters, disallowing certain flags, or specifying conditional preprocessing logic based on build contexts. For example, it can encode a rule that applies a set of ppx rewriters only when building in a particular mode or host architecture.",
      "description_length": 688,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune_project.Implicit_transitive_deps",
      "library": "dunolint-lib",
      "description": "This module provides a system for defining and evaluating predicates that filter implicit transitive dependencies in Dune projects. It supports operations for comparing predicates, checking equality, and serializing to and from S-expressions. The core predicate type allows expressing boolean conditions that dependencies must satisfy, enabling use cases such as validating dependency rules during project analysis. For example, a predicate can enforce that only dependencies matching a specific pattern are allowed in a given context.",
      "description_length": 535,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines a type `t` representing structured predicates for filtering and matching Dune configuration elements like executables, libraries, and preprocessing settings. It supports operations to compare, serialize, and parse these predicates, enabling precise condition-based analysis of Dune files. Concrete use cases include validating naming conventions, checking preprocessing flags, and enforcing linting rules in Dune projects.",
      "description_length": 442,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune_project.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines a type `t` representing predicates for filtering or matching Dune project properties, such as whether to generate OPAM files, how to handle implicit transitive dependencies, or conditions on project names. It includes standard comparison, equality, and S-expression conversion functions to support serialization and structured matching. Concrete use cases include defining inclusion/exclusion rules for Dune project analysis or transformation tools based on project metadata.",
      "description_length": 495,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Include_subdirs",
      "library": "dunolint-lib",
      "description": "This module handles subdirectory inclusion modes in Dune configurations, centered around the type `t` with variants `no`, `unqualified`, and `qualified`. It supports comparisons, equality checks, and S-expression serialization for both the mode type and a predicate that checks for specific mode values. You can use it to validate, compare, and serialize directory inclusion settings when working with Dune files. For example, you can check if a mode is `qualified`, or convert a mode to and from S-expressions for configuration parsing and generation.",
      "description_length": 552,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Config.Skip_subtree",
      "library": "dunolint-lib",
      "description": "This module orchestrates subtree skipping logic by combining predicate definitions and evaluation results to control linting behavior across file hierarchies. It centers around the `t` type for path-based skip conditions and a dedicated result type to capture and persist the outcome of applying these rules. Operations include predicate composition, result comparison, and S-expression serialization for configuration and logging purposes. For example, it enables skipping linting on all files under `/generated/` while tracking which rules triggered the exclusion.",
      "description_length": 566,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Instrumentation",
      "library": "dunolint-lib",
      "description": "This module manages instrumentation backend names and predicates for filtering them, ensuring valid construction and structured comparison. It provides two core types: a structured representation of backend names with safe validation and serialization, and a predicate type for defining matching conditions. These types support operations like parsing untrusted strings, constructing trusted literals, and comparing or serializing predicates. Example uses include validating backend names from configuration files and defining filter rules for querying instrumentation data.",
      "description_length": 574,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune_project.Generate_opam_files",
      "library": "dunolint-lib",
      "description": "This module represents and manipulates simple boolean conditions using a predicate type `t` with a single constructor `` `is_present ``. It supports comparisons, equality checks, and S-expression serialization for conditions used in opam file generation. For example, it can encode the presence of a feature or dependency, and serialize that state to an S-expression for inclusion in an opam file. Developers can use it to programmatically construct and compare conditions that influence package configuration.",
      "description_length": 510,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune.Lint",
      "library": "dunolint-lib",
      "description": "This module handles predicate expressions for lint configurations, enabling conditions on ppx rewriters and their parameters. It supports comparisons, equality checks, and S-expression conversion for types representing ppx names, flags, and combined patterns. You can define and serialize lint rules that match specific ppx rewriters or command-line flags in Dune files. For example, it allows creating a rule that applies only when a certain ppx is used with a given flag.",
      "description_length": 473,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Config.Rule",
      "library": "dunolint-lib",
      "description": "This module defines and manipulates linting rules composed of predicates and conditions. It supports comparison, equality checks, and S-expression serialization/deserialization for rule instances. Concrete use cases include loading and processing linting configurations from files or user input.",
      "description_length": 295,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Pp",
      "library": "dunolint-lib",
      "description": "This module implements a validated string type for Dune configuration names, ensuring correct formatting through safe construction and validation functions. It supports comparison, equality, hashing, and S-expression serialization and deserialization. You can create validated identifiers from strings, compare and hash them, and convert them to and from S-expressions for use in Dune-specific contexts like field names. Example uses include parsing and manipulating Dune configuration identifiers with guaranteed format correctness.",
      "description_length": 533,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Config.Std",
      "library": "dunolint-lib",
      "description": "This module provides logical combinators for constructing boolean expressions over `'a Blang.t` values, enabling composition of predicates with operators like `and_`, `or_`, and `not_`. It includes constructors for Dune-specific configuration conditions (e.g., `backend`, `dune`, `flag`) and stanza nodes, which wrap strings, paths, and Dune types into a tagged `Blang.t` algebraic structure. These tools are used to define and validate rules in OCaml project build systems, such as enforcing linting policies or evaluating configuration stanzas.",
      "description_length": 546,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune_project.Name",
      "library": "dunolint-lib",
      "description": "This module provides a validated string type for project names in Dune files, enforcing naming constraints and supporting comparison, equality, hashing, and S-expression serialization. It includes functions like `of_string` and `v` to construct validated names from raw input, ensuring correctness in configuration processing. A child module extends this with predicates for matching names by equality, prefix, or suffix, enabling pattern-based filtering and validation in Dune files. Together, they support robust handling of project names in both direct usage and structured configurations.",
      "description_length": 592,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune.Pps",
      "library": "dunolint-lib",
      "description": "This module represents predicates for Dune preprocessing rules using a variant type that captures preprocessors, flags, and their combinations. It supports comparison, equality, and S-expression conversion, enabling validation and transformation of Dune configuration files. Submodules handle preprocessors with flags and parameters, define flag scopes, and model parameter matching conditions. Specific uses include analyzing preprocessing directives, determining flag applicability, and serializing complex preprocessor configurations.",
      "description_length": 537,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune.Library",
      "library": "dunolint-lib",
      "description": "This module provides types and utilities for representing and manipulating Dune library names and public names, enforcing validity through controlled construction and validation functions. It supports structured filtering via polymorphic predicates that enable exact, prefix, and suffix matching, facilitating precise name-based selection and transformation rules. Core operations include name comparison, equality, hashing, and S-expression serialization, ensuring robust handling during Dune file parsing and analysis. Examples include validating library names with `of_string`, defining match conditions using predicate combinators, and filtering libraries based on naming conventions or configuration settings.",
      "description_length": 714,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune.Executable",
      "library": "dunolint-lib",
      "description": "This module enforces valid naming conventions for executables in Dune files using validated string types, ensuring safe construction and consistent handling of names. It supports core operations like comparison, hashing, and serialization, along with pattern-based matching through prefixes, suffixes, and exact checks. The polymorphic variant type `t` extends functionality by enabling rich filtering based on executable properties such as lint settings and preprocessing directives. Examples include validating user-provided names, filtering executables by naming patterns, and enforcing build configuration rules across projects.",
      "description_length": 632,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Dune.Package",
      "library": "dunolint-lib",
      "description": "This module provides a robust type for package names that enforces validity through its construction API, ensuring safe handling during operations like dune file parsing. It supports comparison, equality, hashing, and serialization, making it suitable for use in data structures and persistent storage. Users can create validated package name instances, compare and hash them efficiently, and serialize values for storage or transmission while maintaining type safety. Example usage includes validating and storing package identifiers in build configurations or dependency graphs.",
      "description_length": 580,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Trilang",
      "library": "dunolint-lib",
      "description": "This module implements a ternary logic system with values `True`, `False`, and `Undefined`. It provides logical operations such as `conjunction`, `disjunction`, and their variants `for_all` and `exists`, which evaluate lists of values under ternary semantics. These operations are used to evaluate expressions in a custom language (`Blang.t`) where predicates return ternary results, enabling precise short-circuiting logic in analysis or linting workflows.",
      "description_length": 457,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Config",
      "library": "dunolint-lib",
      "description": "This module manages linting configurations through structured types like `t`, `Skip_subtree.t`, and `Rule.t`, enabling creation, comparison, and serialization of settings for static analysis. It supports directory exclusion logic via predicate composition and result tracking, such as skipping linting under `/generated/` while logging exclusion causes. Linting rules are defined and manipulated using boolean combinators and Dune-specific conditions, allowing policy enforcement based on build system metadata. Functionality extends to loading, processing, and validating rule sets from files or user input, integrating logical operations over structured expressions.",
      "description_length": 668,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Std",
      "library": "dunolint-lib",
      "description": "Includes core modules like `List`, `Option`, and `Result` for working with common data structures. Provides direct access to standard library components without additional abstractions. Useful for simplifying imports and avoiding deeply nested paths when writing applications or libraries.",
      "description_length": 289,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune_project",
      "library": "dunolint-lib",
      "description": "This module system provides a structured way to define and evaluate boolean conditions that filter or match properties of Dune projects, particularly around dependencies and project metadata. Core data types include predicate types for expressing conditions (`t`), supporting operations like comparison, equality, and S-expression serialization, along with a validated project name type that enforces naming rules and enables pattern-based matching. These types can be used to enforce dependency rules, control opam file generation, or apply inclusion/exclusion logic during project analysis. For example, a predicate can restrict allowed dependencies based on project name patterns, or encode feature presence in generated opam files.",
      "description_length": 735,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Condition",
      "library": "dunolint-lib",
      "description": "This module represents conditions as parsed logical expressions over file system predicates. It supports comparing and checking equality of conditions, along with serialization to and from S-expressions. It is used to define and manipulate structured linting rules based on file metadata.",
      "description_length": 288,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Path",
      "library": "dunolint-lib",
      "description": "This module provides predicates for matching file paths using exact strings or glob patterns, enabling conditional logic based on path names. It supports comparison, equality checks, and S-expression serialization for predicates, allowing storage or transmission of path rules. You can use it to filter files in a directory, route processing logic based on path patterns, or define static rules for linting and transformation tools. For example, you might define a predicate that matches all `.ml` files or exclude paths matching `**/test/**`.",
      "description_length": 543,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dunolint.Dune",
      "library": "dunolint-lib",
      "description": "This collection of modules provides a structured and validated framework for analyzing and manipulating Dune configuration elements through precise predicates and typed representations. Core data types include predicates for stanza kinds, preprocessing rules, subdirectory modes, instrumentation backends, and naming conventions, each supporting comparison, serialization, and condition-based filtering. Operations allow users to define, validate, and enforce build rules such as restricting ppx rewriters, checking naming patterns, or encoding conditional preprocessing logic. Example uses include linting Dune files based on structured conditions, validating library and executable names, and serializing configuration predicates for storage or analysis.",
      "description_length": 756,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Rule",
      "library": "dunolint-lib",
      "description": "This module defines operations for comparing, serializing, and evaluating rule structures parameterized by predicate and invariant types. It supports equality checks, ordering, S-expression conversion, and rule evaluation against a given function. Concrete use cases include defining and validating linting rules in a code analysis tool, where rules determine whether to enforce invariants, skip subtrees, or return early based on predicate evaluation.",
      "description_length": 452,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Glob",
      "library": "dunolint-lib",
      "description": "This module implements glob pattern matching, providing operations to create, compare, and test glob patterns against strings. It works with a custom `t` type representing compiled glob patterns, and supports serialization to and from S-expressions. Concrete use cases include filename pattern matching, path filtering, and command-line argument expansion.",
      "description_length": 356,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint.Predicate",
      "library": "dunolint-lib",
      "description": "This module defines a polymorphic type `t` that represents predicates over paths, dune files, or dune_project files, using boolean logic expressions. It provides comparison, equality checks, and S-expression serialization/deserialization for these predicates. It is used to encode conditional rules that determine inclusion or exclusion of files or project configurations during linting.",
      "description_length": 387,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dunolint",
      "library": "dunolint-lib",
      "description": "This module system provides a rich framework for defining and evaluating structured logical conditions across diverse domains like linting, file paths, Dune configurations, and custom expressions. Core data types include ternary logic values, boolean predicates, glob patterns, and rule structures, with operations for logical composition, comparison, serialization, and evaluation against real-world data such as file metadata or project configurations. You can encode linting rules that skip generated directories, enforce dependency constraints based on project names, match files using glob patterns, or validate Dune stanzas against structured predicates. These capabilities enable precise, composable policy enforcement and static analysis workflows tailored to OCaml project ecosystems.",
      "description_length": 793,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Blang.Let_syntax.Let_syntax",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module enables the construction and composition of boolean expressions using monadic operations like `bind`, `map`, `both`, and `return`, working with values of type `'a Blang.t`. It supports chaining and combining boolean conditions into complex logical expressions, such as validating multiple interdependent constraints in sequence or in parallel. The module includes a child module that, while currently empty, could be extended to provide additional combinators or utilities for working with boolean expressions in specific domains.",
      "description_length": 542,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Blang.Stable.V1",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module represents boolean expressions built from basic properties and standard logical operators like conjunction, disjunction, and negation. It supports operations for structural comparison, equality checking, hashing, and S-expression serialization/deserialization. Concrete use cases include persisting boolean logic configurations, comparing expression trees, and using expressions as keys in hash tables.",
      "description_length": 414,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Blang.For_monad",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module provides monadic versions of mapping, binding, and evaluating boolean expressions. It operates on boolean expressions parameterized over a monadic context, allowing for sequencing and transformation within that monad. Concrete use cases include evaluating boolean expressions with side effects, such as checking conditions that depend on external state or I/O operations.",
      "description_length": 383,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Blang.Monad_infix",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module provides monadic sequencing and transformation operations for boolean expressions. It works with the `'a Blang.t` type, enabling chaining of computations where each step depends on the result of the previous. Use it to build complex boolean logic in a pipeline style, such as evaluating conditional properties in sequence or transforming intermediate results within a boolean context.",
      "description_length": 396,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Blang.Stable",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module represents boolean expressions constructed from basic properties and logical operators such as conjunction, disjunction, and negation. It supports structural comparison, equality checking, hashing, and S-expression serialization and deserialization. Main data types include expression trees composed of variables and logical connectives. Examples include persisting logic configurations, comparing or hashing expression structures, and using expressions as keys in hash tables.",
      "description_length": 489,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Blang.Constructors",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module provides functions to construct boolean expressions using basic logical operations such as negation, conjunction, and disjunction. It works with the `'a Blang.t` type, representing boolean expressions parameterized over a context type `'a`. These functions enable building complex conditions from simple predicates, suitable for applications like rule engines or configuration filters where logical expressions must be composed and evaluated dynamically.",
      "description_length": 466,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Blang.Let_syntax",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module provides monadic operations for constructing and composing boolean expressions, centered around the `'a Blang.t` type. It supports chaining computations with `bind` (`>>=`), transforming results with `map` (`>>|`), and combining expressions in parallel using `both`. You can build complex logical conditions, such as validating interdependent constraints in sequence or simultaneously evaluating multiple boolean-typed computations. The structure allows for future extensions through its currently empty child module, which could host domain-specific combinators.",
      "description_length": 575,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Blang.Monadic-M-Monad_infix",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module defines monadic sequencing operations for building and composing boolean expressions. It provides the `>>=` and `>>|` operators to chain computations that produce boolean values within a monadic context. These functions enable constructing complex boolean logic by combining simpler expressions that depend on shared input data, such as evaluating conditions over a set of named boolean variables.",
      "description_length": 409,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Blang.Monadic-M-Let_syntax-Let_syntax",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module provides monadic operations for building and composing boolean expressions, including `bind`, `map`, and `both` for sequencing and transforming computations. It works with boolean expressions represented as `'a M.t`, supporting the construction of complex logical conditions from simpler components. Concrete use cases include defining conditional logic in configuration systems, validation pipelines, and rule-based evaluators where boolean expressions must be composed and evaluated in context.",
      "description_length": 508,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Blang.Monadic-M",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module implements monadic operations for building and composing computations in a monadic context. It provides functions like `bind`, `map`, `return`, and `join`, along with infix operators for sequencing and transforming monadic values. It supports working with any monadic type `'a M.t`, enabling structured composition of effectful computations, such as parsing, state manipulation, or asynchronous operations, while abstracting over the specific behavior of the monad.",
      "description_length": 477,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Blang.Raw",
      "library": "dunolint-lib.vendor_blang",
      "description": "Converts boolean expressions into S-expressions for debugging, using a provided function to handle the expression's data type. Works with any type `'a` combined with boolean logic structures. Useful for inspecting the internal form of expressions during development or troubleshooting.",
      "description_length": 285,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Blang.Monadic-M-Let_syntax",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module provides monadic operations for sequencing computations, including `return`, bind (`>>=`), and map (`>>|`). It works with monadic types `'a M.t` to structure asynchronous or effectful operations. Concrete use cases include composing database queries, handling optional values, and managing state transitions in a type-safe way.",
      "description_length": 339,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Blang.O",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module provides operations for constructing and manipulating boolean expressions using a set of combinators and infix operators. It works with the `'a Blang.t` type, representing boolean expressions parameterized over a context type `'a`. Concrete use cases include building complex boolean logic trees, such as combining conditions for filtering data or encoding logical constraints in a domain-specific language.",
      "description_length": 419,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Blang.Monadic",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module defines monadic operations for transforming and evaluating boolean expressions. It provides `map`, `bind`, and `eval` functions that work with boolean expressions parameterized over a monadic context `M`. These functions enable composing and interpreting expressions where values and predicates are computed within a monad, such as handling side effects or non-determinism during evaluation.",
      "description_length": 403,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Blang",
      "library": "dunolint-lib.vendor_blang",
      "description": "This module represents boolean expressions as parameterized trees (`'a t`) built from logical operations like negation, conjunction, and disjunction, supporting structural analysis, transformation, and partial evaluation. It includes combinators and infix operators for constructing complex conditions dynamically, enabling use cases such as rule engines, configuration filters, and logical constraint systems. Submodules extend the core type with monadic operations for sequencing, binding, and mapping, allowing expressions to incorporate side effects, external state, or I/O during evaluation. Additional functionality includes S-expression serialization, hashing, and equality comparison for persisting, inspecting, or using expressions as keys in data structures.",
      "description_length": 768,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Container_key.S",
      "library": "dunolint-lib.vendor_vcs",
      "description": "This module defines a key type with comparison, equality, and hashing operations, along with S-expression serialization and deserialization. It supports use cases like using custom types as keys in maps or sets, where stable comparison and hashing are required. The module works directly with its own type `t`, treating it as a first-class key for container structures.",
      "description_length": 369,
      "index": 75,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Validated_string.Make",
      "library": "dunolint-lib.vendor_vcs",
      "description": "This module provides functions to validate and convert string values with strict guarantees. It works with string types that require invariant checks, ensuring values meet specific criteria before use. Concrete use cases include validating untrusted input strings (e.g., user input, external data) via `of_string`, and safely constructing validated strings from trusted literals using `v`.",
      "description_length": 389,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Validated_string_intf.S",
      "library": "dunolint-lib.vendor_vcs",
      "description": "This module defines a validated string type that enforces an invariant through controlled construction. It provides `of_string` to safely validate and wrap strings, returning an error if the input fails the check, and `v` to create a validated string from trusted literals with exceptions on failure. It works directly with string values to ensure data integrity in contexts like input validation or domain modeling.",
      "description_length": 416,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Container_key.String_impl",
      "library": "dunolint-lib.vendor_vcs",
      "description": "This module defines a string-based key type with comparison, equality, and hashing operations. It supports use cases like using strings as keys in hash tables or ordered containers where consistent hashing and comparison are required. The module also includes serialization and deserialization functions for converting values to and from S-expressions.",
      "description_length": 352,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Validated_string_intf.X",
      "library": "dunolint-lib.vendor_vcs",
      "description": "This module defines a validation interface for strings, ensuring they meet specific criteria before being used in critical contexts. It includes a validation function that checks whether an input string satisfies defined invariants, and a module name used solely for error reporting. It is useful for validating untrusted input such as user-provided identifiers, configuration values, or external data fields.",
      "description_length": 409,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Container_key",
      "library": "dunolint-lib.vendor_vcs",
      "description": "This module provides key-based access to container structures with operations like `find`, `add`, and `remove`, supporting key-value associations where keys are comparable. It integrates with submodules that define key types equipped with comparison, equality, hashing, and S-expression serialization, enabling custom and string-based keys for use in maps, sets, and hash tables. You can manage configuration settings using string keys, or define custom key types that work seamlessly in containers with stable comparison and hashing. Submodules handle key behavior directly, while the parent module uses those keys to provide container operations over structures like associative lists and maps.",
      "description_length": 696,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Validated_string",
      "library": "dunolint-lib.vendor_vcs",
      "description": "This module ensures safe manipulation of string-based abstract types by enforcing validation rules and maintaining invariants. It centers around a main abstract data type that wraps strings, with operations `of_string` for validating untrusted input and `v` for constructing trusted instances directly. Users can define custom validation criteria, such as ensuring a string is non-empty, matches a regex, or falls within a length range. For example, it can validate email formats at runtime or enforce that a string identifier is exactly 8 alphanumeric characters.",
      "description_length": 564,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Validated_string_intf",
      "library": "dunolint-lib.vendor_vcs",
      "description": "This module provides interfaces for validating and manipulating string-based data with strict format constraints, combining core operations for parsing, sanitizing, and converting strings with typed wrappers that enforce validity. It includes a validated string type that ensures invariants through controlled construction via `of_string` and `v`, and a validation interface that checks string criteria for use in critical contexts. Together, these components support type-safe handling of structured string data such as identifiers, email addresses, and configuration values. Example usage includes validating user input, modeling domain-specific strings, and safely converting between formats with explicit error handling.",
      "description_length": 724,
      "index": 82,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 85,
    "meaningful_modules": 83,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9764705882352941
  },
  "statistics": {
    "max_description_length": 793,
    "min_description_length": 285,
    "avg_description_length": 479.33734939759034,
    "embedding_file_size_mb": 0.30201053619384766
  }
}