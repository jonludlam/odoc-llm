{
  "package": "opine",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 4,
  "creation_timestamp": "2025-07-15T23:05:32.010053",
  "modules": [
    {
      "module_path": "Opine.Unparse.Precedence",
      "library": "opine",
      "description": "This module defines a set of precedence levels for unparsing expressions, such as `Test`, `Or`, `And`, and `Cmp`, used to determine the order in which operators are applied. It includes functions to compare, convert to and from integers, and hash these precedence values. It is used to manage operator precedence when generating or transforming expression syntax trees.",
      "description_length": 369,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Opine.Unparse.State",
      "library": "opine",
      "description": "This module manages state during the unparsing of Python expressions, handling indentation, buffering output, and precedence tracking. It provides operations to modify the current buffer (++=), control indentation (block), and wrap output with delimiters (delimit, delimit_if), while tracking expression precedence to determine parenthesization (require_parens). Use cases include generating properly formatted Python code from AST nodes, ensuring correct spacing, indentation, and parenthesization based on context.",
      "description_length": 516,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Opine.Unparse",
      "library": "opine",
      "description": "This module converts Python abstract syntax trees into readable source code by managing operator precedence, expression formatting, and contextual state during generation. It defines precedence levels for expressions and uses stateful tracking to handle indentation, buffering, and parenthesization through operations like `++=`, `block`, and `delimit`. You can generate properly formatted code from AST nodes, control operator grouping with precedence values, and ensure correct spacing and indentation in the output. Specific features include handling docstrings, escaped literals, and contextual formatting decisions based on expression structure.",
      "description_length": 650,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Opine",
      "library": "opine",
      "description": "This module transforms Python abstract syntax trees into well-formatted source code by managing operator precedence, contextual state, and expression structure. It provides data types for AST nodes and stateful operations like `++=`, `block`, and `delimit` to control formatting, indentation, and parenthesization during code generation. You can use it to convert ASTs into readable code, handle escaped literals and docstrings, and ensure correct spacing and grouping based on precedence rules. Example uses include generating function bodies with proper indentation, inserting parentheses around low-precedence expressions, and formatting complex nested expressions with consistent layout.",
      "description_length": 691,
      "index": 3,
      "embedding_norm": 1.0000001192092896
    }
  ],
  "filtering": {
    "total_modules_in_package": 4,
    "meaningful_modules": 4,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 691,
    "min_description_length": 369,
    "avg_description_length": 556.5,
    "embedding_file_size_mb": 0.014936447143554688
  }
}