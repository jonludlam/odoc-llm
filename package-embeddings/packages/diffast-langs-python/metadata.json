{
  "package": "diffast-langs-python",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 24,
  "creation_timestamp": "2025-08-15T14:10:27.554762",
  "modules": [
    {
      "module_path": "Mpython.Py_lib.Analyzing.Postprocessing",
      "library": "diffast-langs-python",
      "description": "This module specializes in AST differencing and transformation through tree manipulation, move detection, and edit script optimization. It operates on abstract syntax trees (`tree_t`, `node_t`), node mappings, and edit structures (`Edit.t`) to refine diff results by resolving structural conflicts, synchronizing edits, and eliminating redundant operations like orphaned relabels or fragmented insertions/deletions. Use cases include code refactoring analysis, version comparison in repositories, and optimizing program transformation pipelines by normalizing subtree moves and validating node relationships with customizable thresholds.",
      "description_length": 637,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mpython.Py_lib.Analyzing",
      "library": "diffast-langs-python",
      "description": "This module provides functions for analyzing and comparing abstract syntax trees (ASTs), focusing on operations like subtree matching, boundary detection, and diff status computation. It works with tree structures (`tree_t`, `node_t`), edit sequences, and node mappings to support concrete tasks like identifying matching code regions across versions, detecting structural boundaries in ASTs, and computing detailed diff statistics for version comparison. Use cases include code evolution analysis, refactoring detection, and optimizing AST differencing pipelines in software engineering tools.",
      "description_length": 594,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mpython.Py_lib",
      "library": "diffast-langs-python",
      "description": "This module implements precise AST differencing and code change extraction through subtree matching, node mapping, and edit sequence elaboration. It operates on abstract syntax trees (`tree_t`, `node_t`), node mappings, and edit operations (`add`, `delete`, `relabel`) to support concrete tasks like change impact analysis, code refactoring identification, and version comparison in Python codebases. Key functions include `extract_change` for isolating code modifications and `elaborate_edits` for refining edit sequences with customizable thresholds for matching and conflict resolution.",
      "description_length": 589,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mpython",
      "library": "diffast-langs-python",
      "description": "This module provides precise AST differencing and code change extraction through subtree matching, node mapping, and edit sequence elaboration. It operates on abstract syntax trees (`tree_t`, `node_t`), node mappings, and edit operations (`add`, `delete`, `relabel`) to support tasks like change impact analysis, code refactoring identification, and version comparison. Key functions include `extract_change` for isolating code modifications and `elaborate_edits` for refining edit sequences with customizable thresholds.",
      "description_length": 521,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_tree.Tree",
      "library": "diffast-langs-python.base",
      "description": "This module constructs and manipulates tree nodes with support for annotations, identifiers, and structural comparison. It operates on XML-like tree structures with labeled nodes, handling tasks such as node creation, labeling, and serialization. Concrete use cases include building abstract syntax trees with metadata, comparing tree elements by label, and unparsing trees to output streams.",
      "description_length": 392,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_lib_base.Tree",
      "library": "diffast-langs-python.base",
      "description": "This module implements tree construction and manipulation operations for abstract syntax trees, using node types that carry labels, annotations, and optional original labels. It provides functions to create leaf and internal nodes, compare nodes by label, and extract label and annotation data from node objects. Concrete use cases include building ASTs during parsing, preserving source metadata, and supporting tree transformations with identity tracking.",
      "description_length": 457,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_label.Statement",
      "library": "diffast-langs-python.base",
      "description": "This module defines a type `t` representing different kinds of Python statements, such as conditionals, loops, function and class definitions, and error markers. It provides operations to convert statements to strings, extract names, check naming status, anonymize identifiers, and serialize to a tagged format. Concrete use cases include analyzing or transforming Python AST nodes, generating readable representations of statements, and handling labeled identifiers in parsing or refactoring tools.",
      "description_length": 499,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_unparsing.Tree",
      "library": "diffast-langs-python.base",
      "description": "This module constructs and manipulates abstract syntax trees for Python code unparsing. It provides functions to create nodes and leaves with annotations, original labels, and unique identifiers, supporting precise tree transformations. Key operations include `mknode`, `mkleaf`, and `get_lab`, which are used to build and inspect tree elements during code generation or diffing tasks.",
      "description_length": 385,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Python_base.Py_label.BinaryOperator",
      "library": "diffast-langs-python.base",
      "description": "This module defines a variant type representing binary operators in Python, including arithmetic, comparison, bitwise, and logical operations. It provides functions to convert these operators to string representations and map them from abstract syntax tree (AST) nodes. Concrete use cases include parsing Python expressions, generating human-readable operator names, and translating AST binary operations into labeled forms for analysis or code generation.",
      "description_length": 456,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Python_base.Py_unparsing.UPB",
      "library": "diffast-langs-python.base",
      "description": "This module provides low-level formatting and code emission primitives for Python AST unparser, focusing on layout control and token generation. It operates on simple values like strings and options while managing structural elements through block styles and boxes, enabling precise reconstruction of Python source code from abstract syntax representations. Its components handle tasks such as indentation management, punctuation insertion, and literal rendering in a formatter-based pipeline.",
      "description_length": 493,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_label.Literal",
      "library": "diffast-langs-python.base",
      "description": "This module defines a variant type for representing Python literals such as integers, floats, strings, and boolean values, along with conversion and transformation functions. It provides operations to convert literals to different string formats, anonymize values, and extract structured tags with metadata. Use cases include parsing and manipulating Python AST literals during static analysis or code transformation tasks.",
      "description_length": 423,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_lib_base.Fact",
      "library": "diffast-langs-python.base",
      "description": "This module provides functions for constructing semantic nodes in triple-based representations and traversing Python abstract syntax trees to access node properties, search labeled elements, and navigate hierarchical relationships. It operates on Diffast_core.Triple nodes, Python AST structures, and labeled hierarchical objects with parent-child links. These capabilities enable modeling software artifacts, analyzing Python codebases, and resolving contextual relationships in labeled data hierarchies through predicate-driven ancestor searches.",
      "description_length": 548,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_label.SimpleStatement",
      "library": "diffast-langs-python.base",
      "description": "This module defines a variant type representing simple statements in Python, such as assignments, control flow, and imports. It provides operations to convert these statements to strings, anonymize them, and extract tags with associated data. Use cases include analyzing or transforming Python code structures, such as identifying control flow statements or normalizing code for comparison.",
      "description_length": 390,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_label.Primary",
      "library": "diffast-langs-python.base",
      "description": "This module defines a type `t` representing primary expression labels in Python syntax trees, including names, literals, and structural elements like tuples or calls. It provides operations to convert these labels to strings, strip or anonymize identifiers, and extract tags with associated metadata. Use cases include analyzing or transforming Python AST nodes during parsing or code generation tasks.",
      "description_length": 402,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_unparsing.Fmtr",
      "library": "diffast-langs-python.base",
      "description": "This module provides direct access to a `Format.formatter` value for use in formatting and printing operations. It supports functions that write formatted text to standard output, custom buffers, or other output channels. Concrete use cases include pretty-printing data structures, logging, and generating structured output such as JSON or XML fragments.",
      "description_length": 354,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Python_base.Py_label.AssignmentOperator",
      "library": "diffast-langs-python.base",
      "description": "This module defines a variant type representing Python assignment operators such as `=`, `+=`, `-=`, etc., along with conversions to string representations and parsing from AST nodes. It supports operations like converting operators to different string formats, mapping AST augmentation operators to the variant type, and extracting tagged representations. Concrete use cases include code generation, AST transformation, and pretty-printing in Python tooling.",
      "description_length": 459,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_label.UnaryOperator",
      "library": "diffast-langs-python.base",
      "description": "This module defines unary operator types like `Positive`, `Negative`, `Complement`, and `Not`, and provides conversions to string representations and AST tags. It works with unary operator data structures in Python ASTs, mapping them to internal types and labels. Use cases include parsing and pretty-printing Python code involving unary operations.",
      "description_length": 349,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_label",
      "library": "diffast-langs-python.base",
      "description": "This module provides operations for converting, manipulating, and analyzing labeled syntactic elements in Python ASTs, including literals, operators, statements, and structured nodes like list comprehensions or slices. It works with labeled types (`t`) representing identifiers, expressions, control structures, and metadata, enabling tasks like code transformation, pretty-printing, and structural analysis. Specific use cases include anonymizing identifiers, extracting semantic roles (e.g., parameters, assignments), determining label compatibility, and mapping AST nodes to internal representations for analysis or code generation.",
      "description_length": 635,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_lib_base",
      "library": "diffast-langs-python.base",
      "description": "This module includes two submodules, Tree and Fact, which handle tree construction and semantic node manipulation for abstract syntax trees. Tree provides functions to create and manipulate nodes with labels and annotations, while Fact offers operations for traversing and querying triple-based representations of Python ASTs. Use cases include building and transforming ASTs during parsing, preserving source metadata, and modeling software artifacts through labeled hierarchical data.",
      "description_length": 486,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_unparsing",
      "library": "diffast-langs-python.base",
      "description": "This module implements a Python abstract syntax tree unparser with precise layout control and code generation capabilities. It provides tree construction and inspection functions, formatting utilities, and low-level primitives for emitting Python source code from AST representations. Concrete use cases include generating Python code from internal data structures, performing syntax-preserving transformations, and producing structured output with exact indentation and punctuation.",
      "description_length": 483,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base.Py_tree",
      "library": "diffast-langs-python.base",
      "description": "This module handles tree node construction and manipulation with support for annotations, identifiers, and structural comparison. It operates on XML-like tree structures, providing functions for node creation, labeling, serialization, and metadata extraction. Concrete use cases include building and comparing abstract syntax trees with metadata, and unparsing trees to output streams.",
      "description_length": 385,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Python_base",
      "library": "diffast-langs-python.base",
      "description": "This module provides precise manipulation and transformation of Python abstract syntax trees with rich labeling and annotation support. It includes operations for constructing and comparing tree nodes, extracting and analyzing semantic elements like identifiers and expressions, and unparsing trees into valid Python code with exact formatting control. Use cases include code anonymization, structural analysis, syntax-preserving transformations, and code generation from ASTs.",
      "description_length": 477,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mpython_p.Py_lib_p",
      "library": "diffast-langs-python.p",
      "description": "This module includes `sprintf` for formatted string generation using OCaml's format specifiers, and `extract_fact`, which performs an extraction operation involving three data types, though its exact use depends on context. These functions handle string manipulation and data extraction tasks. A concrete use case is generating formatted output strings or extracting structured data from nested values.",
      "description_length": 402,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mpython_p",
      "library": "diffast-langs-python.p",
      "description": "This module provides `sprintf` for generating formatted strings using OCaml's format specifiers and `extract_fact`, which extracts data from nested structures involving three specific types. It operates on strings and structured data, enabling tasks like formatted output generation and structured data retrieval. A concrete use case is building dynamic string messages or pulling specific values from compound data types.",
      "description_length": 422,
      "index": 23,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 49,
    "meaningful_modules": 24,
    "filtered_empty_modules": 25,
    "retention_rate": 0.4897959183673469
  },
  "statistics": {
    "max_description_length": 637,
    "min_description_length": 349,
    "avg_description_length": 468.25,
    "embedding_file_size_mb": 0.34814453125
  }
}