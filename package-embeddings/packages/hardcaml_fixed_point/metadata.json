{
  "package": "hardcaml_fixed_point",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 7,
  "creation_timestamp": "2025-08-14T23:12:01.255739",
  "modules": [
    {
      "module_path": "Hardcaml_fixed_point.Unsigned.Overflow",
      "library": "hardcaml_fixed_point",
      "description": "This module implements overflow handling for unsigned fixed-point arithmetic. It provides two strategies: `wrap` for modular arithmetic where values wrap around on overflow, and `saturate` to clamp values at the maximum representable value. These functions operate on bit vectors, taking width and fractional parameters to determine behavior during overflow.",
      "description_length": 358,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_fixed_point.Signed.Round",
      "library": "hardcaml_fixed_point",
      "description": "This module defines rounding functions for fixed-point arithmetic, operating on bit representations of numbers. It provides specific rounding modes such as rounding toward zero, away from zero, to nearest even or odd, and toward positive or negative infinity. These functions are used when converting or truncating fixed-point values, ensuring precise control over rounding behavior in hardware description contexts.",
      "description_length": 416,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_fixed_point.Unsigned.Round",
      "library": "hardcaml_fixed_point",
      "description": "This module defines rounding functions for unsigned fixed-point arithmetic, operating on bit representations. It provides specific rounding modes such as rounding toward zero, away from zero, to nearest even or odd, and toward positive or negative infinity. These functions are used when converting or truncating fixed-point values where precise control over rounding behavior is required.",
      "description_length": 389,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_fixed_point.Signed.Overflow",
      "library": "hardcaml_fixed_point",
      "description": "This module defines overflow handling strategies for fixed-point arithmetic operations. It provides two functions, `wrap` and `saturate`, which determine how values behave when they exceed representable bounds. These functions operate on bit vectors (`bits`) and are used to implement signed fixed-point overflow behavior in digital circuit design.",
      "description_length": 348,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_fixed_point.Signed",
      "library": "hardcaml_fixed_point",
      "description": "This module provides arithmetic and bit-level manipulation operations for signed fixed-point numbers, supporting creation from floats, resizing, normalization, and precise control over rounding (e.g., truncation, rounding modes) and overflow handling (saturation, wrapping). It operates on fixed-point values represented as `t` and bit vectors, enabling hardware synthesis through operations like power-of-two scaling (`scale_pow2`) and bit-width adjustments. Use cases include digital signal processing, FPGA design, and scenarios requiring deterministic fixed-point behavior with explicit bit-level representation.",
      "description_length": 616,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_fixed_point.Unsigned",
      "library": "hardcaml_fixed_point",
      "description": "This module implements arithmetic and manipulation operations for unsigned fixed-point numbers represented as bit vectors, with explicit handling of integer and fractional components. It supports addition, subtraction, multiplication, comparisons, resizing with customizable rounding and overflow strategies, scaling via bit shifts with boundary checks, and normalization, targeting applications in hardware design where precise control over numerical precision and overflow behavior is critical.",
      "description_length": 496,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_fixed_point",
      "library": "hardcaml_fixed_point",
      "description": "This module defines a shared interface for fixed-point arithmetic, implemented separately for signed and unsigned numbers. It supports precise operations like addition, multiplication, scaling, and comparisons on bit vector representations with customizable rounding, overflow, and resizing behaviors. Use cases include FPGA-based numerical computation, DSP algorithms, and hardware-critical applications requiring explicit control over bit-width and arithmetic semantics.",
      "description_length": 472,
      "index": 6,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 7,
    "meaningful_modules": 7,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 616,
    "min_description_length": 348,
    "avg_description_length": 442.14285714285717,
    "embedding_file_size_mb": 0.10189056396484375
  }
}