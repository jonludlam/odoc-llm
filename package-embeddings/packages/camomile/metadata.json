{
  "package": "camomile",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 219,
  "creation_timestamp": "2025-07-15T23:53:28.970624",
  "modules": [
    {
      "module_path": "Camomile.Make.UReStr.Make.SubText.Buf",
      "library": "camomile",
      "description": "This module provides a mutable buffer for efficiently building Unicode text values (`SubText.t`). It supports operations like appending characters, strings, or other buffers, and allows resetting or clearing the buffer's contents. Concrete use cases include constructing dynamic text output, such as generating formatted messages or accumulating stream data.",
      "description_length": 358,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UReStr.Make.SubText",
      "library": "camomile",
      "description": "This module provides a mutable buffer for efficiently building Unicode text values, supporting operations like appending characters, strings, or other buffers, with the ability to reset or clear contents. It includes child modules that extend functionality for dynamic text construction, such as formatting and stream accumulation. Main data types include `SubText.t`, and key operations involve appending, clearing, and converting buffers to strings. Example uses include generating formatted messages or assembling text from streaming data sources.",
      "description_length": 550,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UReStr.Make.SubText.Buf",
      "library": "camomile",
      "description": "This module provides operations to build and manipulate Unicode text buffers. It supports creating buffers, adding characters or substrings, and retrieving or resetting contents. Concrete use cases include constructing dynamic Unicode strings efficiently, such as assembling output for internationalized text processing or building multi-lingual user interface elements.",
      "description_length": 370,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UNF.Make.NFCBuf",
      "library": "camomile",
      "description": "This module provides a mutable buffer for building Unicode Normalization Form C (NFC) text incrementally. It supports operations to add characters, strings, or other buffers, and to retrieve or reset the accumulated content. Concrete use cases include efficient construction of normalized text during parsing or streaming operations.",
      "description_length": 333,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.CaseMap.Make",
      "library": "camomile",
      "description": "This module performs case conversion and comparison operations on text values, including lowercase, uppercase, capitalize, titlecase, and casefolding. It supports locale-sensitive transformations and provides a function for case-insensitive comparison. Use it when handling internationalized text processing tasks such as normalizing user input or comparing strings regardless of case.",
      "description_length": 385,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Make.UReStr.Type",
      "library": "camomile",
      "description": "This module provides operations for compiling and executing Unicode regular expressions over text values, including matching and searching with optional match semantics. It works with text sequences and index positions, returning subtext captures via the SubText module. Concrete use cases include parsing structured text formats, validating input patterns, and extracting substrings based on complex Unicode-aware regular expressions.",
      "description_length": 435,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UCol.Make",
      "library": "camomile",
      "description": "This module implements Unicode-aware string comparison and sorting operations using customizable collation rules. It supports operations like `compare` for ordering texts, `sort_key` for generating binary-sortable keys, and `search` variants for substring matching with collation sensitivity. It works with text data types and indexes, enabling precise linguistic comparisons and efficient sorting in multilingual contexts.",
      "description_length": 423,
      "index": 6,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Camomile.Make.UReStr.Type-SubText",
      "library": "camomile",
      "description": "This module provides operations for precise manipulation of Unicode character sequences using indexed views, including index navigation (`next`, `prev`, `move`), comparison, slicing, and buffer management via the `Buf` submodule. It works with `SubText.t` for representing text regions, alongside `ur_text` and `ur_index` for Unicode-ready text and position tracking. These tools are ideal for applications requiring accurate text slicing and position mapping in Unicode-aware contexts, such as internationalized text editors or complex script processing pipelines.",
      "description_length": 565,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.StringPrep.Make",
      "library": "camomile",
      "description": "This module implements the StringPrep algorithm for text normalization, providing a `stringprep` function that processes text according to specified profiles such as `Saslprep` or `Nameprep`. It operates on a `text` type defined by the `Text` module, typically representing Unicode strings. It is used to prepare strings for protocols like SASL, XMPP, and LDAP, ensuring consistent representation of identifiers and passwords.",
      "description_length": 426,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UReStr.Make.SubText",
      "library": "camomile",
      "description": "This module handles Unicode character sequences with precise index management, using `SubText.t` to represent bounded text regions and enabling operations like substring extraction, position comparison, and iteration over ranges. It integrates a buffer module for efficiently building and modifying Unicode text, supporting dynamic string assembly and content retrieval. You can extract a substring from a structured document, track its position relative to the original text, and use the buffer to construct internationalized output incrementally. Direct API functions work alongside buffer operations to support both static text analysis and dynamic text generation with accurate Unicode handling.",
      "description_length": 699,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.UNF.Make.NFCBuf",
      "library": "camomile",
      "description": "This module provides a mutable buffer for building Unicode Normalization Form C (NFC) text incrementally. It supports operations to add characters, strings, or other buffers, and to retrieve or reset the accumulated NFC-normalized text. Concrete use cases include constructing NFC-normalized output from streaming input or dynamically assembling Unicode text for processing or serialization.",
      "description_length": 391,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Make.UNF.Make",
      "library": "camomile",
      "description": "This module normalizes Unicode text through standard forms (NFD, NFKD, NFC, NFKC), enabling direct transformations and incremental decomposition over text types and indexes. It supports precise character manipulation, comparison, and streaming construction through a mutable buffer specialized for NFC. Main data types include normalized text values and index-based references, with operations for full or stepwise normalization, concatenation, and comparison. Examples include normalizing user input for consistent display, streaming NFC construction during JSON parsing, and decomposing characters for Unicode-aware search indexing.",
      "description_length": 634,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UReStr.Make",
      "library": "camomile",
      "description": "This module combines Unicode regular expression compilation and execution with efficient text manipulation capabilities. It supports matching, searching, and capturing subtexts using compiled regex patterns, while its child modules provide a mutable buffer for dynamic text construction, enabling operations like appending, formatting, and stream-based assembly. Key data types include `compiled_regexp` for patterns and `SubText.t` for matched substrings, alongside buffer types for incremental text building. Examples include parsing log entries with regex captures and constructing output text from streaming data using buffer operations.",
      "description_length": 641,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UReStr.Type-SubText-Buf",
      "library": "camomile",
      "description": "This module provides operations to efficiently build and manipulate Unicode text buffers. It supports creating buffers, adding characters or strings, and retrieving or resetting contents. Use it for constructing dynamic Unicode text sequences, such as parsing streams or generating formatted output.",
      "description_length": 299,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.CharEncoding.Type",
      "library": "camomile",
      "description": "This module defines operations for converting between encoded byte strings and structured text representations. It supports decoding byte strings into typed text values and encoding those text values back into byte strings using a specified character encoding. Concrete use cases include handling UTF-8 or Latin-1 encoded data in text processing applications.",
      "description_length": 359,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Make.CharEncoding.Make",
      "library": "camomile",
      "description": "This module handles character encoding and decoding between strings and a specified text type. It uses an encoding specification to convert strings into the text type and vice versa. Useful for working with different character sets in text processing tasks like reading and writing files or handling network data.",
      "description_length": 313,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.UReStr.Type-SubText-Buf",
      "library": "camomile",
      "description": "This module provides a mutable buffer for building SubText values efficiently. It supports operations to add characters, strings, or other buffers, along with functions to retrieve or reset the buffer's contents. It is useful for incremental construction of Unicode text fragments, such as during parsing or formatting.",
      "description_length": 319,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UNF",
      "library": "camomile",
      "description": "This module provides Unicode normalization through standard forms (NFD, NFKD, NFC, NFKC), supporting both full and incremental transformations over text. It offers normalized text values and index-based references, enabling precise character manipulation, streaming construction via NFC-specialized buffers, and comparison operations. Users can normalize input for consistent display, build NFC-normalized strings during JSON parsing, or decompose characters for Unicode-aware search indexing.",
      "description_length": 493,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Make.UCharInfo",
      "library": "camomile",
      "description": "This module provides operations for analyzing and transforming Unicode characters through property queries and normalization, including categorization, script identification, case mapping, and decomposition. It works with Unicode characters (`UChar.t`) and leverages trie-based tables (`UCharTbl`), sets (`USet`), and maps (`UMap`) to efficiently handle tasks like case folding, composition, and version-aware property checks. It is particularly useful for internationalization tasks requiring precise Unicode handling, such as text normalization, locale-aware case conversion, and script-specific processing.",
      "description_length": 609,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UReStr.Make",
      "library": "camomile",
      "description": "This module compiles and matches Unicode regular expressions against text, supporting exact matches, partial matches, and forward searches using text and index types alongside compiled patterns. It enables parsing structured formats, validating input, and extracting substrings with Unicode awareness. Subtext regions (`SubText.t`) represent bounded text segments for precise extraction and position tracking, while integrated buffer operations allow efficient construction and modification of Unicode text. Use cases include analyzing document substrings, iterating over text ranges, and building internationalized output dynamically with accurate text handling.",
      "description_length": 663,
      "index": 19,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Camomile.CharEncoding.Type",
      "library": "camomile",
      "description": "This module handles character encoding conversions by decoding byte strings into Unicode text and encoding Unicode text back into byte strings using specified encoding schemes. It operates on `string` and `text` types, where `text` represents Unicode characters. Concrete use cases include converting between UTF-8 byte strings and Unicode text representations for processing or transmission.",
      "description_length": 392,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UNF.Make",
      "library": "camomile",
      "description": "This module normalizes Unicode text using NFD, NFKD, NFC, and NFKC forms, offering functions to decompose and compare characters canonically over `Text`-based values, with support for incremental processing and buffer-backed output. Its core operations handle normalization of entire strings or streams, enabling tasks like preparing text for comparison, sanitizing user input, or ensuring consistent encoding in I/O protocols. The child module extends this by providing a mutable buffer that incrementally builds NFC-normalized text, allowing efficient assembly of normalized output from partial inputs. Together, they support both one-shot and streaming normalization, with direct operations for conversion and comparison alongside buffer-based accumulation for dynamic text construction.",
      "description_length": 790,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.StringPrep",
      "library": "camomile",
      "description": "This module implements the StringPrep algorithm for normalizing Unicode text according to specific profiles like `Saslprep` or `Nameprep`, ensuring consistent string representation across protocols such as SASL, XMPP, and LDAP. It provides a `stringprep` function that processes text by applying canonicalization, mapping, and normalization rules. The main data type is `text`, representing Unicode strings, and the core operation is the `stringprep` function that transforms text based on the selected profile. For example, it can be used to prepare user identifiers or passwords by removing invisible characters, mapping spaces, or enforcing case-folding.",
      "description_length": 657,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.CharEncoding.Make",
      "library": "camomile",
      "description": "This module converts between string representations and a specified text type using a given character encoding. It supports decoding strings into the text type and encoding text back into strings. Useful for handling text in different encodings, such as UTF-8 or Latin-1, within a consistent interface.",
      "description_length": 302,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.CharEncoding",
      "library": "camomile",
      "description": "This module provides character encoding conversion, detection, and registration, enabling text transformation between formats like UTF-8, UTF-16, Latin-1, and ASCII. It operates on strings and byte buffers, using functors to abstract encoding logic for Unicode and legacy sequences, with core operations for decoding bytes into structured text and encoding text back into bytes. Submodules focus on converting between encoded strings and typed text representations, supporting tasks like reading files or handling network data in different character sets. Examples include converting UTF-8 to Latin-1, decoding legacy encodings, or dynamically resolving unknown input encodings.",
      "description_length": 678,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.UCol.Make",
      "library": "camomile",
      "description": "This module implements Unicode collation operations for comparing and sorting text with customizable locale and strength settings. It provides functions to generate sort keys, compare texts or keys, and perform substring searches respecting collation rules. Concrete use cases include sorting internationalized strings, generating consistent string keys for hashing, and implementing locale-aware search in text processing applications.",
      "description_length": 436,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Make.CaseMap",
      "library": "camomile",
      "description": "This module handles case conversion and comparison operations for text, supporting transformations like lowercase, uppercase, capitalize, titlecase, and casefolding. It includes locale-aware functions for accurate international text processing and enables case-insensitive comparisons. You can normalize user input, compare strings without case sensitivity, or apply specific casing rules based on locale settings. For example, it can convert \"HELLO\" to \"hello\", compare \"User\" and \"USER\" as equal, or properly capitalize names in different languages.",
      "description_length": 551,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.CaseMap.Make",
      "library": "camomile",
      "description": "This module provides functions to transform text by changing case, including lowercase, uppercase, capitalize, titlecase, and casefolding, all respecting locale-specific rules. It operates on text values from the associated `Text` module, handling Unicode characters appropriately. Use cases include normalizing user input, preparing strings for case-insensitive comparison, and adapting text for display in different linguistic contexts.",
      "description_length": 438,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Make.UCol",
      "library": "camomile",
      "description": "This module implements Unicode collation algorithms for comparing, sorting, and searching strings according to locale-specific rules, supporting customizable comparison levels and handling of ignorable characters. It provides core operations like `compare`, `sort_key`, and `search` for precise linguistic ordering and matching, working with text data types and indexes. Child modules extend this functionality to enable efficient multilingual text processing, such as generating binary-sortable keys or performing collation-aware substring searches. Examples include sorting a list of names in French accent-insensitive order or searching for a substring in a Japanese text with case and diacritic sensitivity.",
      "description_length": 711,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.StringPrep.Make",
      "library": "camomile",
      "description": "This module implements the StringPrep algorithm for preparing Unicode strings according to specified profiles such as `Saslprep` or `Nameprep`. It operates on text values provided by the `Text` module, transforming them through normalization, case folding, and filtering of prohibited characters. Concrete use cases include preparing strings for internationalized domain names, SASL authentication, and other protocols requiring canonicalized Unicode input.",
      "description_length": 457,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.UReStr.Type",
      "library": "camomile",
      "description": "This module provides operations for compiling and executing Unicode-aware regular expressions over text values. It supports matching and searching text using compiled patterns, with optional match semantics, returning submatch results as arrays of optional substrings. Concrete use cases include parsing structured text formats, validating input strings, and extracting data from Unicode-encoded documents.",
      "description_length": 406,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UReStr",
      "library": "camomile",
      "description": "This module enables working with Unicode regular expressions and text manipulation through a suite of tools for compiling patterns, executing matches, and handling text regions with precision. It introduces key types like `compiled_regexp` for regex patterns and `SubText.t` for representing and extracting matched or sliced text regions, supporting operations such as match capture, index navigation, and buffer-based text construction. Submodules provide indexed text views for accurate slicing and position tracking, a mutable buffer for assembling Unicode text incrementally, and integrated regex execution that ties pattern matching to text transformation workflows. Example uses include parsing structured logs with regex captures, building internationalized text editors with precise cursor handling, and streaming text generation using buffer operations.",
      "description_length": 862,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-URe-Make-SubText",
      "library": "camomile",
      "description": "This module provides functions for creating, accessing, and iterating over Unicode character sequences (`SubText.t`) with safe traversal via index manipulation (e.g., `get`, `look`, `next`, `prev`), substring extraction, and comparison. It also supports conversion between `SubText` and `ur_text` types, enabling content copying, retrieval of original text context, and index mapping. These capabilities are particularly useful in text processing tasks requiring precise navigation, such as parsing or analysis tools that must track positions across different text representations.",
      "description_length": 581,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-ULine-Make",
      "library": "camomile",
      "description": "This module processes Unicode text lines with operations for splitting, trimming, and normalizing line breaks. It works with `Text.t` values representing Unicode strings. Concrete use cases include parsing multiline input, handling line-oriented text formats like CSV or logs, and ensuring consistent line endings across platforms.",
      "description_length": 331,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-UText-Buf",
      "library": "camomile",
      "description": "This module implements a mutable buffer for efficiently constructing Unicode text values. It supports creating buffers with initial capacity, appending characters or strings, and extracting the current contents as either a Unicode text value or a string. Typical uses include building large text values incrementally, such as generating output for serialization or formatting multi-line documents.",
      "description_length": 397,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-URe-module-type-Type-SubText-Buf",
      "library": "camomile",
      "description": "This module provides operations to create, manipulate, and manage a buffer for building SubText values. It supports appending characters, strings, and other buffers, along with clearing or resetting the buffer contents. Concrete use cases include efficiently constructing dynamic SubText content, such as assembling output for text processing or formatting operations.",
      "description_length": 368,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UnicodeString",
      "library": "camomile",
      "description": "This module defines the signature for Unicode string implementations, including operations for character encoding and decoding, string concatenation, and indexing. It supports data types such as UText, XString, UTF8, UTF16, and UCS4, which represent strings in different encoding formats. Concrete use cases include handling multilingual text processing, converting between encoding schemes, and ensuring correct Unicode character manipulation in applications like text editors or parsers.",
      "description_length": 489,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-UCharTbl-Bits",
      "library": "camomile",
      "description": "This module implements efficient lookup tables for small integers (0\u2013255) using bit manipulation. It supports creating tables from maps and retrieving integer values by Unicode character keys. Useful for optimizing character classification or mapping operations in text processing where the key range is limited.",
      "description_length": 312,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UnicodeString-module-type-Type-Buf",
      "library": "camomile",
      "description": "This module provides operations to efficiently build and manipulate Unicode character buffers. It supports creating buffers with a specified initial size, appending characters or strings, and clearing or resetting buffer contents. Concrete use cases include constructing dynamic Unicode strings during parsing or formatting operations, where incremental assembly is more efficient than repeated string concatenation.",
      "description_length": 416,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UText",
      "library": "camomile",
      "description": "This module implements Unicode string handling with mutable (`utext`) and immutable (`ustring`) representations backed by integer arrays. It provides indexed character access, safe traversal via abstract positions, and operations like slicing, appending, and Latin-1 conversion, supporting use cases such as text processing requiring precise Unicode-aware manipulation and encoding transformations. The design emphasizes safety through bounds-checked navigation and efficient bulk operations analogous to standard string semantics.",
      "description_length": 531,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type",
      "library": "camomile",
      "description": "This module provides Unicode-centric operations for string manipulation, encoding conversion (UTF-8, UTF-16, UCS-4), and character set/map handling, emphasizing normalization, collation, and case transformation. It supports internationalized text processing through locale-aware sorting, regular expression matching, and protocol-specific string preparation (e.g., IDNA, SASL), operating on Unicode characters and strings to ensure consistent handling of multilingual text.",
      "description_length": 473,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-SubText",
      "library": "camomile",
      "description": "This module provides functions for creating and manipulating substrings with position and length tracking within a parent string. It works with string and substring data types, enabling precise text slicing and indexing operations. Concrete use cases include parsing structured text formats and implementing lexers where tracking character positions is essential.",
      "description_length": 363,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UReStr-Make",
      "library": "camomile",
      "description": "This module compiles and matches regular expressions against text values, supporting both anchored and unanchored searches. It provides functions to compile regex patterns, test matches at specific indices, and search forward for matches, returning structured results in optional arrays. Concrete use cases include parsing structured text formats, validating input patterns, and extracting substrings based on dynamic regular expressions.",
      "description_length": 438,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UTF8-Buf",
      "library": "camomile",
      "description": "This module provides functions to efficiently build and manipulate UTF-8 encoded strings using a buffer. It supports operations like adding Unicode characters, UTF-8 strings, or other buffers to an existing buffer, as well as clearing or resetting the buffer. It is useful for tasks such as constructing dynamic text output, concatenating multiple UTF-8 fragments, or streaming Unicode content.",
      "description_length": 394,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-UnicodeString-module-type-Type",
      "library": "camomile",
      "description": "This module handles Unicode character sequences with precise indexing and traversal operations. It supports character access by integer index or abstract index, iteration, comparison, and index manipulation for valid ranges. Concrete use cases include text processing, Unicode-aware string indexing, and implementing custom string buffers with the included `Buf` submodule.",
      "description_length": 373,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-StringPrep-Make",
      "library": "camomile",
      "description": "This module implements string preparation algorithms for normalizing text according to specific profiles defined in various RFCs. It operates on text values using the `stringprep` function, which applies the designated normalization rules to prepare strings for protocols such as SASL, XMPP, and iSCSI. Common use cases include processing usernames, resource identifiers, and authentication tokens in network communication protocols.",
      "description_length": 433,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-UPervasives",
      "library": "camomile",
      "description": "This module provides functions for converting between Unicode characters and integers, escaping Unicode characters and UTF-8 strings, and printing UTF-8 strings and individual Unicode characters using OCaml's formatting library. It operates on the `uchar` type representing Unicode characters and standard UTF-8 encoded strings. Concrete use cases include handling Unicode input/output, debugging Unicode-aware text processing, and ensuring correct display of non-ASCII characters in formatted output.",
      "description_length": 501,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-UNF",
      "library": "camomile",
      "description": "Performs Unicode normalization on text data using the NFC, NFD, NFKC, and NFKD algorithms. Works with string and Uchar.t sequence types to ensure consistent textual representation. Useful for validating and comparing internationalized text such as filenames, identifiers, or user input in multilingual applications.",
      "description_length": 315,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UCharTbl-Make",
      "library": "camomile",
      "description": "This module implements a character-indexed lookup table using a hash-based representation. It supports creating tables from maps with a default value for undefined characters and provides efficient character-based indexing. It is used for compact, fast character property lookups like Unicode attribute tables.",
      "description_length": 310,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-URe-Make",
      "library": "camomile",
      "description": "This module compiles and applies regular expressions to text values, providing precise matching and searching operations. It supports matching regular expressions against substrings starting at specific indices and returns detailed match results, including capture groups. Use cases include parsing structured text formats, validating input patterns, and extracting specific substrings based on dynamic regular expressions.",
      "description_length": 423,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UTF8",
      "library": "camomile",
      "description": "This module handles UTF-8 encoded Unicode strings as standard OCaml strings, offering direct access to individual Unicode characters via indexed operations. It provides functions for validation, character retrieval, string construction, iteration, and lexicographic comparison, with support for navigating string positions using byte indices. Concrete use cases include parsing UTF-8 input streams, implementing text editors handling Unicode, and validating user-provided strings before further processing.",
      "description_length": 506,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UCS4-Buf",
      "library": "camomile",
      "description": "This module provides operations to create, manipulate, and retrieve contents from a buffer designed for handling UCS4-encoded characters. It supports adding individual characters, strings, or entire buffers to an existing buffer, and allows clearing or resetting the buffer's contents. Concrete use cases include efficient construction of UCS4 strings during text processing or parsing operations.",
      "description_length": 397,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-UCS4",
      "library": "camomile",
      "description": "This module handles operations on UCS4-encoded strings represented as 32-bit integer bigarrays. It provides functions for validation, character access, iteration, and index manipulation, supporting precise Unicode character processing. Use cases include parsing and validating UCS4-encoded text, implementing custom string transformations, and working with Unicode-aware text buffers.",
      "description_length": 384,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-USet",
      "library": "camomile",
      "description": "This module offers interval-based set operations for Unicode characters, supporting efficient union, intersection, difference, and complement operations alongside membership checks and range manipulations. It works with interval-encoded character sets (`USet.t`), enabling iteration, filtering, and conversion to integer-based sets (`ISet`), while exposing cardinality, boundary elements, and code point comparisons. Typical applications include text processing tasks requiring efficient Unicode character class manipulation, such as validating character ranges or partitioning code points based on numeric properties.",
      "description_length": 618,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-URe",
      "library": "camomile",
      "description": "This module implements a regular expression engine with support for constructing and manipulating regex patterns using algebraic data types like `Alt`, `Seq`, `Rep`, and `Group`. It provides operations for defining match semantics (`First`, `Longest`, etc.) and removing grouping constructs from expressions. Concrete use cases include parsing structured text, validating input formats, and extracting data from strings through pattern matching.",
      "description_length": 445,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UCharTbl",
      "library": "camomile",
      "description": "This module implements fast constant-time lookup tables indexed by Unicode characters. It provides operations to create and access tables with arbitrary value types, optimized for efficient retrieval using Unicode code points. Use cases include mapping characters to properties, such as categorizing Unicode characters or implementing character-based state machines.",
      "description_length": 366,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-Locale",
      "library": "camomile",
      "description": "This module handles locale identifiers and provides functions for reading localized data files and checking locale containment. It works with locale strings formatted as `lang_country_modifier`, using ISO codes. Use it to load region-specific data files or determine if one locale is a subset of another, such as checking if \"fr\" applies to \"fr_CA\".",
      "description_length": 349,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UNF",
      "library": "camomile",
      "description": "This module normalizes Unicode text using NFD, NFKD, NFC, and NFKC forms, offering functions for both one-shot and streaming normalization. It supports direct string conversion, canonical comparison, and incremental processing with buffer-backed output. A mutable buffer efficiently assembles NFC-normalized text from partial inputs. Example uses include preparing text for comparison, sanitizing input, and ensuring consistent encoding in I/O streams.",
      "description_length": 452,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-CharEncoding",
      "library": "camomile",
      "description": "This module type provides functionality for encoding conversion, detection, and registration, operating on strings and streams to handle common encodings like UTF-8, UTF-16, Latin-1, and ISO-2022 variants. It includes a functor to construct custom encoding implementations parameterized by character type, supporting use cases such as text processing, data interchange, and handling input with unknown encodings.",
      "description_length": 412,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-URe-module-type-Type-SubText",
      "library": "camomile",
      "description": "This module enables precise manipulation of Unicode text substrings through operations like indexed character access, bidirectional iteration, and bounded substring extraction. It operates on `SubText.t` structures paired with `SubText.index` positions, which interface with unified text representations (`ur_text`) and their native indices (`ur_index`) for seamless context-aware navigation. These capabilities are particularly useful for parsing, text analysis, or any application requiring robust handling of Unicode character positioning and range operations.",
      "description_length": 563,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-SubText-module-type-Type-Buf",
      "library": "camomile",
      "description": "This module implements a mutable buffer for efficiently constructing text values by appending characters, strings, or other buffers. It provides operations to create a buffer with a specified initial size, retrieve its current contents, and modify its state through additions or resets. Concrete use cases include building dynamic SQL queries, assembling log messages incrementally, and implementing custom text serialization routines.",
      "description_length": 435,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UCharInfo",
      "library": "camomile",
      "description": "This module enables querying Unicode character properties, categories, and scripts (e.g., Latin, Cyrillic), as well as conditional case mappings and normalization rules like decomposition and composition. It operates on Unicode characters (`UChar.t`) using structures like `UMap`, `USet`, and `UCharTbl` to represent transformations and equivalence, with support for Unicode version-specific behavior. It is particularly useful for text processing tasks requiring internationalization, case-insensitive comparisons, or canonical normalization of Unicode strings.",
      "description_length": 562,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-OOChannel",
      "library": "camomile",
      "description": "Converts an object-oriented input channel into a stream, enabling sequential reading of values. Works with `'a obj_input_channel` and produces an `'a Stream.t`. Useful for processing data from channels as lazy, on-demand streams, such as reading lines or tokens incrementally from a file or network input.",
      "description_length": 305,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UCol-Make",
      "library": "camomile",
      "description": "This module implements Unicode collation algorithms for comparing and sorting text with customizable locale, precision, and variable handling options. It provides functions to generate binary sort keys, compare texts directly, and perform substring searches respecting collation rules. Use cases include internationalized string sorting, case-insensitive comparisons, and efficient repeated comparisons via precomputed sort keys.",
      "description_length": 429,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-CaseMap-Make",
      "library": "camomile",
      "description": "This module provides functions for case conversion and case-insensitive comparison of text, including lowercase, uppercase, capitalize, titlecase, and casefolding operations. It works with the `text` type defined in the provided `Text` module, which typically represents Unicode text. These operations are useful for text normalization and comparison in internationalized contexts, such as processing user input or preparing strings for indexing.",
      "description_length": 446,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UNF-Make",
      "library": "camomile",
      "description": "This module normalizes Unicode text using NFD, NFKD, NFC, and NFKC forms, providing direct transformations and incremental decomposition. It operates on text types from the Text module and mutable buffers from CamomileLib.XString, supporting precise character manipulation and comparison. Concrete use cases include preparing Unicode strings for comparison, canonicalizing input for processing, and handling character composition in text editors or parsers.",
      "description_length": 457,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.StringPrep",
      "library": "camomile",
      "description": "This module prepares Unicode strings according to standardized profiles like `Saslprep` and `Nameprep`, transforming input through normalization, case folding, and removal of prohibited characters. It operates on text values from the `Text` module, producing canonicalized output suitable for protocols requiring consistent Unicode representation. For example, it can process user input for SASL authentication or normalize domain names in internationalized URLs. Key operations include applying profile-specific rules to ensure equivalence between different string representations.",
      "description_length": 582,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UChar",
      "library": "camomile",
      "description": "This module directly handles Unicode (ISO-UCS) characters as 31-bit code points. It provides conversions to and from Latin-1 characters (`char_of`, `of_char`), encoding/decoding functions (`code`, `chr`, `uint_code`, `chr_of_uint`), and comparison operations (`eq`, `compare`). It is used when working with individual Unicode characters beyond the ASCII range, especially in text processing or internationalization tasks requiring precise code point manipulation.",
      "description_length": 463,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.UCol",
      "library": "camomile",
      "description": "This module provides Unicode-aware collation for comparing and sorting strings with customizable precision and variable handling, using types like `variable_option` and `precision` to control behavior. It supports locale-specific sorting, substring searches, and sort key generation, enabling linguistically correct ordering of names or dictionary entries across languages. Submodules extend these capabilities with additional control over strength settings and locale-specific rules. Example uses include internationalized string sorting, consistent key generation for hashing, and locale-aware text search.",
      "description_length": 608,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UCharInfo",
      "library": "camomile",
      "description": "This module enables Unicode character classification, case mapping, and normalization by determining properties such as category, script, and decomposition form using `UChar.t` representations. It supports text processing tasks like normalization (NFC/NFD), case-insensitive comparisons via folding, and handling scripts or symbols through decomposition and composition operations. Key data structures include character property tables, case-folding rules, and version metadata, which facilitate precise text manipulation and compatibility checks.",
      "description_length": 547,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UReStr",
      "library": "camomile",
      "description": "This module combines Unicode-aware regular expression compilation and matching with efficient text manipulation capabilities. It supports compiling patterns from strings using `regexp` and escaping special characters with `quote`, while its child modules enable incremental text construction through a mutable buffer and precise subtext handling via `SubText.t`. The buffer module allows dynamic assembly of Unicode fragments, and the matching components perform exact or partial regex searches, returning detailed submatch results for tasks like parsing, validation, and data extraction. Examples include building internationalized output dynamically, analyzing document substrings, and extracting structured data from Unicode-encoded content.",
      "description_length": 744,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-SubText-module-type-Type",
      "library": "camomile",
      "description": "This module offers operations for creating and manipulating sub-texts of Unicode text data, enabling indexed traversal, slicing, and comparison. It works with sub-text slices (`t`) and their corresponding full-text representations (`ur_text`), allowing conversion between them via index mapping and contextual extraction. These capabilities support use cases like efficient text slicing, contextual analysis, and precise navigation within Unicode text structures.",
      "description_length": 463,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UTF16",
      "library": "camomile",
      "description": "This module implements UTF-16 encoded Unicode string manipulation with direct access to individual characters via indexing operations. It supports string validation, character retrieval and modification, index navigation, and iteration over Unicode code points. Concrete use cases include parsing and processing UTF-16 encoded text data, such as handling Windows Unicode strings or decoding/encoding network protocols that use UTF-16.",
      "description_length": 434,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-UCharTbl-Bool",
      "library": "camomile",
      "description": "Maps Unicode characters to boolean values. Supports lookup with `get` and construction from a set of characters with `of_set`. Useful for representing character properties, such as identifying whitespace or punctuation.",
      "description_length": 219,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make",
      "library": "camomile",
      "description": "This module suite provides comprehensive Unicode text processing capabilities, integrating normalization, encoding conversion, case manipulation, collation, and regular expression handling. Core data types include text representations, encoded buffers, and compiled regex patterns, with operations for normalization forms, locale-aware case conversion, collation keys, and encoding transformations. Users can prepare internationalized strings for protocols, convert between encodings, perform Unicode-aware searches, or sort text according to linguistic rules. Example workflows include normalizing JSON string input, preparing SASL credentials, converting legacy encodings, or implementing multilingual text search and transformation pipelines.",
      "description_length": 745,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UCharTbl-Bytes",
      "library": "camomile",
      "description": "This module implements space-efficient lookup tables for integers using `Bytes.t`, optimized for cases where integer keys do not span the full 31-bit or 63-bit range. It provides conversion from a map to a compact byte-based table and supports fast key-based lookups using Unicode characters as keys. Concrete use cases include storing sparse mappings from Unicode code points to integer values, such as character property tables.",
      "description_length": 430,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UReStr-module-type-Type-SubText",
      "library": "camomile",
      "description": "This module provides operations for precise Unicode text manipulation through character indexing, range navigation, and substring referencing, working directly with `SubText.t` and `SubText.index` types. It supports conversions between `SubText.t` and `ur_text`, enabling tasks like content extraction, index mapping, and contextual analysis of text segments. These capabilities are particularly useful for applications requiring robust Unicode handling, such as text editors, parsers, or internationalization tools where accurate character positioning and format interoperability are critical.",
      "description_length": 594,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-XString-Buf",
      "library": "camomile",
      "description": "This module implements a mutable buffer for building Unicode strings efficiently. It supports operations to add characters, strings, or other buffers, and provides methods to access, clear, or reset the buffer's contents. Concrete use cases include constructing large strings incrementally, such as when parsing input or generating output in a streaming fashion.",
      "description_length": 362,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-StringPrep",
      "library": "camomile",
      "description": "This module implements the StringPrep algorithm for preparing Unicode strings, performing operations like mapping, normalization, and checking for prohibited characters. It works with Unicode code point sequences and string-like data structures. Concrete use cases include preparing internationalized domain names (IDNA) and handling user input in protocols requiring canonical string representations.",
      "description_length": 401,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-CharEncoding-Make",
      "library": "camomile",
      "description": "This module implements encoding and decoding between Unicode text and byte strings using specified character encodings. It operates on Unicode text values from the `Text` submodule and standard OCaml strings. Use it to convert text to and from encodings like UTF-8, ISO-8859-1, or other supported encodings.",
      "description_length": 307,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-CharEncoding-module-type-Type",
      "library": "camomile",
      "description": "This module handles conversion between Unicode text and byte strings using specified character encodings. It provides `decode` to transform encoded strings into Unicode text and `encode` to convert Unicode text back into byte strings. Use this module when working with text input/output in different encodings, such as reading or writing files, network communication, or processing user input.",
      "description_length": 393,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UTF16-Buf",
      "library": "camomile",
      "description": "This module provides operations to efficiently build and manipulate UTF-16 encoded strings using a buffer structure. It supports creating buffers, appending characters or strings, and retrieving or resetting contents. Concrete use cases include constructing dynamic UTF-16 text output and accumulating fragments of Unicode text for processing or serialization.",
      "description_length": 360,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.CaseMap",
      "library": "camomile",
      "description": "This module transforms text using locale-aware case operations such as lowercase, uppercase, capitalize, titlecase, and casefolding, ensuring correct handling of Unicode characters. It works seamlessly with the `Text` module's data structures to support tasks like normalizing user input, preparing strings for comparison, and formatting text for display in multilingual environments. For example, it can convert a user's input to lowercase for case-insensitive matching or apply titlecase to format headings according to specific language rules. Key data types include text values processed through these transformation functions.",
      "description_length": 631,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UNF-Make-NFCBuf",
      "library": "camomile",
      "description": "This module implements a mutable buffer for handling Unicode Normalization Form C (NFC) text. It provides operations to create, clear, reset, and append characters, strings, or other buffers to an NFC-normalized text buffer. Concrete use cases include efficiently building normalized Unicode strings for text processing, serialization, or output generation where NFC consistency is required.",
      "description_length": 391,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UReStr-Make-SubText-Buf",
      "library": "camomile",
      "description": "This module implements a mutable buffer for building Unicode text values (`SubText.t`) through incremental appending of characters, strings, or other buffers. It provides operations to create, clear, reset, and extract the current contents of the buffer. Concrete use cases include efficient construction of Unicode strings during parsing or data transformation tasks.",
      "description_length": 368,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-URe-Make-SubText-Buf",
      "library": "camomile",
      "description": "This module implements a mutable buffer for building Unicode text values, supporting operations to add characters, strings, or other buffers. It manages data of type `SubText.t` and `SubText.Buf.buf`, optimized for efficient concatenation and modification. Concrete use cases include constructing dynamic Unicode strings incrementally, such as when parsing or transforming text streams.",
      "description_length": 386,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UReStr-module-type-Type",
      "library": "camomile",
      "description": "This module compiles and applies regular expressions to text values, supporting operations like matching at a specific index and searching forward for matches. It works with text, compiled regular expressions, and index values, returning optional arrays of matched substrings. Concrete use cases include parsing structured text formats, validating input patterns, and extracting data from strings using regex.",
      "description_length": 409,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-CaseMap",
      "library": "camomile",
      "description": "Implements case mapping operations for Unicode characters and strings using customizable rules. Works with character and string types to apply case transformations like uppercase, lowercase, and titlecase. Useful for text processing tasks requiring locale-specific or specialized case conversion, such as normalizing user input or formatting output in internationalized applications.",
      "description_length": 383,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UReStr",
      "library": "camomile",
      "description": "This module compiles and manipulates Unicode regular expressions. It provides functions to create regex patterns from strings, escape special characters, and match or search text using those patterns. Concrete use cases include parsing structured text formats, validating input formats like email addresses, and extracting data from Unicode strings.",
      "description_length": 349,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-ULine-module-type-Type",
      "library": "camomile",
      "description": "This module handles operations on Unicode text lines, including splitting, joining, and normalizing line breaks. It works with the `text` type, which represents Unicode character sequences. Concrete use cases include processing multiline user input, formatting text output, and handling line-based file content.",
      "description_length": 311,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-ULine",
      "library": "camomile",
      "description": "Handles line-oriented input/output with support for various line separators, including CR, LF, CRLF, NEL, LS, and PS. Provides functions for reading and writing lines using a specified separator, enabling precise control over line-based data processing. Useful for parsing or generating text files with custom or non-standard line endings.",
      "description_length": 339,
      "index": 90,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.CharEncoding",
      "library": "camomile",
      "description": "This module provides functions to decode byte strings into Unicode text and encode Unicode text back into byte strings using specified character encodings. It operates on two main types: `string` for byte sequences and `text` for Unicode representations. The core functionality allows conversion between these types for encodings like UTF-8 or Latin-1, enabling tasks such as reading encoded text from a file, converting it to Unicode for processing, and writing it back in the same or different encoding. Submodules build on this by offering additional encoding-specific operations and utilities for more specialized text handling tasks.",
      "description_length": 638,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UCharTbl-module-type-Type",
      "library": "camomile",
      "description": "This module implements a character-indexed lookup table that maps Unicode characters to values of a specified type. It supports operations to retrieve values for specific characters and construct tables from Unicode maps with a default fallback value. It is useful for efficiently handling sparse character sets, such as defining character properties or classifications over Unicode ranges.",
      "description_length": 390,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UCharTbl-Char",
      "library": "camomile",
      "description": "This module implements character mapping tables indexed by Unicode characters, using bytes as the underlying storage. It supports creating mappings from a character and a Unicode map, and retrieving mapped characters via a lookup function. It is useful for implementing efficient character transformations or encodings where each Unicode character maps to a single byte value.",
      "description_length": 376,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-SubText-Make-Buf",
      "library": "camomile",
      "description": "This module implements a mutable buffer for handling Unicode text, supporting efficient character and string appending. It works with Unicode characters and strings through the `UChar.t` type and its own buffer type. Concrete use cases include building dynamic text output, accumulating log messages, or constructing protocol data in network applications.",
      "description_length": 355,
      "index": 94,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-UReStr-Make-SubText",
      "library": "camomile",
      "description": "This module provides functions for creating and manipulating indexed Unicode character sequences, enabling precise text slicing, traversal, and comparison through character-level indexing and iteration. It operates on `SubText.t` structures representing substrings with contextual references to their parent `ur_text` data, using `UChar.t` for Unicode characters and custom index types to map positions between original and sliced texts. Key use cases include extracting substrings with `refer`, converting subtext regions to standalone `ur_text`, and resolving indices to maintain positional context within larger text bodies.",
      "description_length": 627,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-UMap",
      "library": "camomile",
      "description": "This module provides operations to manage mappings from Unicode characters to arbitrary values, supporting range-based updates, domain restrictions, and conversions to integer maps or Unicode sets. It works with Unicode character maps, integer maps, and Unicode sets, enabling efficient representation transformations and subset extractions based on value predicates. Typical use cases include text processing tasks requiring compact encoding of character ranges or interoperability between different map/set representations.",
      "description_length": 525,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Type-UReStr-module-type-Type-SubText-Buf",
      "library": "camomile",
      "description": "This module provides operations to create, manipulate, and manage extensible buffers for handling Unicode text. It supports appending characters, strings, and other buffers, along with clearing or resetting buffer contents. Concrete use cases include building dynamic Unicode text efficiently, such as constructing output for internationalized text processing or assembling multi-part messages.",
      "description_length": 394,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-UCol",
      "library": "camomile",
      "description": "This module provides collation operations for Unicode strings, supporting customizable collation strength and handling of variable-weight characters. It works with Unicode strings and defines options for treating variable-weight characters (`Blanked`, `Shifted`, etc.) and precision levels (`Primary`, `Tertiary`, etc.). Concrete use cases include sorting and comparing internationalized strings according to locale-specific rules.",
      "description_length": 431,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Type-URe-module-type-Type",
      "library": "camomile",
      "description": "This module compiles and executes regular expressions on text values, supporting operations like matching at a specific index and searching forward for matches. It works with text, compiled regular expressions, and index types, returning match results as optional arrays of subtext. Concrete use cases include parsing structured text formats, validating input patterns, and extracting data from strings using regex.",
      "description_length": 415,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile",
      "library": "camomile",
      "description": "This module provides comprehensive Unicode text processing capabilities, combining core operations for character encoding, normalization, case mapping, and collation with a suite of submodules for efficient text construction, substring manipulation, and regular expression handling. Key data types include `SubText.t` for indexed Unicode character sequences, `UChar.t` for individual Unicode characters, and various buffer implementations for UTF-8, UTF-16, and UCS-4 encoded text. Users can perform tasks such as NFC-normalizing strings, building dynamic Unicode content with mutable buffers, splitting and normalizing line breaks, and executing Unicode-aware regex searches with submatch extraction. Submodules enhance these capabilities with specialized tools for locale-aware sorting, character classification, encoding conversion, and protocol-specific string preparation, enabling robust internationalized text processing across diverse applications.",
      "description_length": 956,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStr.Configure.Make.SubText.Buf",
      "library": "camomile.lib",
      "description": "This module provides operations to build and manipulate UTF-8 encoded text buffers, specifically supporting character and string appending with `add_char`, `add_string`, and `add_buffer`. It works with the `buf` type, which efficiently accumulates `CamomileLib.UChar.t` characters and `SubText.t` strings for constructing dynamic Unicode text. Concrete use cases include assembling output strings during text processing, building multi-part messages, or collecting results from iterative pattern matching.",
      "description_length": 505,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStr.Configure.Make.SubText",
      "library": "camomile.lib",
      "description": "This module enables precise UTF-8 text manipulation using index-based substrings and efficient conversions to and from `ur_text`, supporting operations like substring creation, iteration, and comparison. It handles Unicode-aware tasks such as parsing identifiers with specific script properties or processing Japanese text components using accurate character indexing. The child module extends this functionality by offering dynamic text construction through buffer operations like `add_char`, `add_string`, and `add_buffer`, which accumulate Unicode characters and substrings efficiently. Together, they support tasks like assembling multi-part messages, collecting pattern matching results, or building complex text outputs during iterative processing.",
      "description_length": 754,
      "index": 102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.URe.Make.SubText.Buf",
      "library": "camomile.lib",
      "description": "This module provides operations to build and manipulate Unicode-aware text buffers, including adding characters, strings, or other buffers. It works with `buf` for efficient text construction and `SubText.t` for substring management. Use it to construct dynamic text output during regex processing or parsing, where incremental assembly and controlled memory allocation are needed.",
      "description_length": 381,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UNF.Make.NFCBuf",
      "library": "camomile.lib",
      "description": "This module implements incremental Unicode normalization (NFC) for text processing. It provides functions to create and manipulate buffers that accumulate characters or strings, automatically normalizing them as they are added. Typical use cases include normalizing user input, processing text streams, or building normalized output incrementally.",
      "description_length": 347,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStr.Configure.Make",
      "library": "camomile.lib",
      "description": "This module compiles and executes regular expressions over UTF-8 text with Unicode support, enabling pattern matching, testing, and searching from specific indices. It handles advanced patterns using Unicode character properties and set operations, ideal for parsing structured formats or validating identifiers. The text module provides precise UTF-8 manipulation with index-based substrings and Unicode-aware iteration, while its buffer extension supports efficient dynamic text construction. Together, they enable tasks like parsing multilingual data, assembling messages from matched components, or processing Japanese text using accurate character indexing.",
      "description_length": 662,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStr.Configure.Type",
      "library": "camomile.lib",
      "description": "This module defines configuration types for handling Unicode-aware regular expressions, supporting operations like compiling patterns with Unicode properties and performing matches on UTF-8 encoded text. It works with text, index, and compiled regular expression types, enabling precise matching of Unicode character sets and groups. Concrete use cases include validating identifiers with specific Unicode categories and extracting substrings from multilingual text.",
      "description_length": 466,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.CharEncoding.Configure.Type",
      "library": "camomile.lib",
      "description": "This module defines operations for converting between Unicode text and byte strings using specific encodings. It provides `decode`, which transforms a byte string into Unicode text according to a given encoding, and `encode`, which converts Unicode text into a byte string. These operations are essential for handling text input/output in different character encodings, such as UTF-8 or ISO-8859-1.",
      "description_length": 398,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStr.Configure.Type-SubText",
      "library": "camomile.lib",
      "description": "This module provides operations for precise Unicode text manipulation, including creation, slicing, and bidirectional iteration over UTF-8 encoded sequences using a custom index type. It works with `SubText.t` and `ur_text` types to enable index conversion, content copying, and context-aware text referencing, particularly supporting use cases like parsing structured text with Unicode properties (e.g., script-specific patterns in Japanese or identifier validation with character categories).",
      "description_length": 494,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.CharEncoding.Configure.Make",
      "library": "camomile.lib",
      "description": "This module provides functions to decode strings into Unicode text and encode Unicode text into strings using a specified encoding. It operates on a user-defined `text` type, which represents Unicode text. Concrete use cases include handling text conversions for different character encodings, such as UTF-8 or ISO-8859-1, in input/output operations or string processing tasks.",
      "description_length": 377,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStr.Configure.Type-SubText-Buf",
      "library": "camomile.lib",
      "description": "This module provides operations for constructing and manipulating UTF-8 encoded text buffers that support Unicode-aware regular expressions. It works with the `buf` type for buffering sequences of Unicode characters (`CamomileLib.UChar.t`) and `SubText.t` strings. Concrete use cases include building dynamic regex patterns with Unicode properties, assembling multi-part text for matching, and efficiently managing substrings during parsing or transformation tasks.",
      "description_length": 465,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.SubText.Make.Buf",
      "library": "camomile.lib",
      "description": "This module implements a mutable buffer for efficiently building and manipulating UTF-8 encoded text. It provides operations to create, clear, and reset buffers, as well as append characters, strings, or other buffers. Concrete use cases include constructing dynamic SQL queries, assembling HTTP responses, or processing streaming text data.",
      "description_length": 341,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.URe.Make.SubText",
      "library": "camomile.lib",
      "description": "This module handles Unicode character sequences with precise index management, enabling safe substring extraction and traversal through operations like `refer`. It introduces `SubText.t` and `ur_text` types, supporting conversions and context-aware index translation for robust Unicode text processing. The child module extends this functionality by providing `buf` for efficient dynamic text construction, allowing incremental assembly of text during parsing or regex operations. Together, they support tasks like slicing, traversal, and buffer-based text assembly with strong bounds checking and Unicode safety.",
      "description_length": 613,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Charmap.Interface",
      "library": "camomile.lib",
      "description": "This module defines operations for mapping between character encodings and Unicode scalar values, using data structures like `enc_to_ucs` and `t`. It supports creating encoding-to-Unicode mappings, probing for character matches, and retrieving conversion tables by name. Concrete use cases include handling legacy character encodings and implementing encoding-aware string transformations.",
      "description_length": 389,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UText.Buf",
      "library": "camomile.lib",
      "description": "This module implements a mutable buffer for building Unicode strings efficiently. It supports operations to add characters, strings, or other buffers, and to retrieve or reset the current contents. Typical uses include accumulating output from iterative processing of Unicode data, such as formatting text or parsing input streams.",
      "description_length": 331,
      "index": 114,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "CamomileLib.ULine.Type",
      "library": "camomile.lib",
      "description": "Handles line-oriented text processing with operations for reading, writing, and manipulating lines of text. Works with the `text` type, representing lines as Unicode strings. Useful for parsing and transforming text files line by line, such as log processing or configuration file reading.",
      "description_length": 289,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.CharEncoding.Interface",
      "library": "camomile.lib",
      "description": "This module provides operations for converting between byte sequences and Unicode characters, detecting encoding formats, and managing encoding aliases. It works with byte streams and Unicode character streams, supporting encodings like UTF-8, UTF-16, and ISO-2022 variants. Typical use cases include text processing pipelines, file or network data decoding, and dynamic encoding resolution for multilingual content.",
      "description_length": 416,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStr.Interface-Make-SubText",
      "library": "camomile.lib",
      "description": "This module provides character-level manipulation and analysis of UTF-8 encoded Unicode text through the `SubText.t` type, supporting safe index traversal, substring extraction, and conversion to low-level `ur_text`/`ur_index` representations. It enables precise handling of text ranges and Unicode properties, suitable for parsing multilingual content (e.g., Japanese script components) or validating identifiers using Unicode categories like `{Lu & ID_Start}`. Key operations include contextual substring extraction and robust index comparison to ensure correct processing of non-ASCII character sequences.",
      "description_length": 608,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.CaseMap.Type",
      "library": "camomile.lib",
      "description": "This module provides functions for case conversion and case-insensitive comparison of Unicode text, including lowercase, uppercase, capitalize, titlecase, and casefolding operations. It works with the `text` type, which represents Unicode character sequences. These functions are used for text normalization and linguistic processing tasks where case distinctions need to be removed or standardized.",
      "description_length": 399,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Tbl31.Make",
      "library": "camomile.lib",
      "description": "This module implements a fast integer-keyed table structure optimized for 31-bit integers, providing efficient `get` operations to retrieve values by key. It converts a standard integer map into a specialized table using the `of_map` function, which initializes the table with a default value and a map of specific key-value pairs. Concrete use cases include optimizing lookups in scenarios like memoization or state management where integer keys are used to index precomputed or dynamic values.",
      "description_length": 495,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharTbl.Char",
      "library": "camomile.lib",
      "description": "This module implements fast byte-based lookup tables for Unicode characters, optimized for constant-time access. It provides functions to create tables from character maps and retrieve mapped values using Unicode code points. Use it for efficient character property lookups, such as case mappings or classification, where each Unicode character corresponds to a byte value.",
      "description_length": 373,
      "index": 120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.StringPrep_data.MappingMap",
      "library": "camomile.lib",
      "description": "This module implements a character-to-mapping table for efficiently applying RFC 3454 string preparation rules. It provides `get` to retrieve the mapped value for a Unicode character and `of_map` to construct a table with a default mapping for undefined characters. It works with Unicode character tables (`UCharTbl.tbl`) and is used to normalize characters during string preparation processes like IDNA or SASL.",
      "description_length": 412,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.StringPrep_data.Make",
      "library": "camomile.lib",
      "description": "This module provides functions to retrieve predefined character mapping tables and prohibited character sets defined in RFC 3454, specifically for string preparation profiles. It includes mappings for B1/B2, B1-only, and SASLprep, along with prohibited character tables for profiles like Nodeprep, Resourceprep, Nameprep, SASLprep, and others. These values are used to implement string preparation and normalization routines required for protocols such as XMPP, LDAP, and iSCSI.",
      "description_length": 478,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Unimap.Make",
      "library": "camomile.lib",
      "description": "This module implements bidirectional mappings between Unicode and Asian character encodings, supporting efficient lookup and mutation operations. It works with integer-based code points for both Unicode (UCS) and encoding-specific values, using mutable and immutable mapping structures. Concrete use cases include converting legacy Asian character encodings to and from Unicode, handling code page translations, and managing custom character set mappings.",
      "description_length": 455,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.URe.Type-SubText",
      "library": "camomile.lib",
      "description": "This module provides functions for manipulating Unicode text through substring and index abstractions, supporting character access, bidirectional navigation, slicing, and iteration. It handles conversions between substring views (`SubText.t`) and flat text representations (`ur_text`), including index mapping and bounds extraction. Use cases include precise Unicode-aware text processing, incremental parsing, and maintaining positional integrity when transforming text segments.",
      "description_length": 480,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharTbl.Bool",
      "library": "camomile.lib",
      "description": "This module implements fast boolean lookup tables indexed by Unicode characters. It provides operations to create a table from a set of Unicode characters and to query membership efficiently. Concrete use cases include checking if a character belongs to a predefined set, such as punctuation or whitespace, in constant time.",
      "description_length": 324,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.ConfigBase.Type",
      "library": "camomile.lib",
      "description": "This module defines configuration paths for directories containing compiled Unicode and locale data, along with character mapping tables. It provides direct access to these paths as string values, enabling applications to locate and load specific data files required for internationalization and text processing tasks. Use cases include setting up Unicode support, locale-aware operations, and character encoding conversions using external data files.",
      "description_length": 451,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UReStr.Interface-module-type-Type",
      "library": "camomile.lib",
      "description": "This module provides operations for compiling and matching regular expressions with Unicode-aware syntax, supporting non-ASCII characters and Unicode character properties in patterns. It works with UTF-8 encoded text, indices, and compiled regular expressions, enabling precise matching and extraction of substrings based on complex Unicode criteria. Concrete use cases include parsing identifiers with Unicode character categories, matching Japanese text components, and validating strings against Unicode-aware patterns.",
      "description_length": 522,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.Unidata.Make",
      "library": "camomile.lib",
      "description": "This module supports operations for mapping and decomposing Unicode character categories, scripts, and numeric encodings, while managing collation elements for normalization and sorting. It operates on Unicode characters (`UChar.t`) and structured tables that associate character sequences with collation data, including types like `col_info` and `ce` for locale-aware sorting. It is particularly useful for internationalized text processing tasks requiring precise Unicode handling, such as implementing language-specific collation rules or canonical normalization forms.",
      "description_length": 572,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.StringPrep.Make",
      "library": "camomile.lib",
      "description": "This module implements string preparation algorithms for normalizing text according to specific IETF profiles such as Nameprep, Saslprep, and Nodeprep. It operates on text values of type `Text.t` and provides the `stringprep` function to apply a chosen profile's normalization rules. Use this module when handling internationalized identifiers, authentication strings, or trace tokens that require strict formatting per RFC standards.",
      "description_length": 434,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UReStr.Configure",
      "library": "camomile.lib",
      "description": "This module compiles and manipulates regular expressions with Unicode-aware syntax, supporting UTF-8 encoded text and advanced pattern matching using Unicode character properties and set operations. It provides core types such as compiled regexps, Unicode character sequences, and index-aware substrings, along with operations for escaping, matching, and dynamic text assembly. The text submodule enables precise UTF-8 slicing and iteration, while the buffer extension supports efficient construction of Unicode-based patterns and substrings during parsing or transformation tasks. Examples include validating identifiers using Unicode categories, extracting script-specific substrings from Japanese text, and building dynamic regex patterns from multilingual components.",
      "description_length": 771,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.StringPrep.Type",
      "library": "camomile.lib",
      "description": "This module implements string preparation algorithms for normalizing text according to specific profiles defined in various RFCs, such as Nameprep, Nodeprep, and Saslprep. It operates on a `text` type, applying the chosen profile's rules to produce a canonicalized output. Concrete use cases include preparing internationalized domain names, XMPP node identifiers, and SASL authentication strings for comparison or storage.",
      "description_length": 423,
      "index": 131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.URe.Type-SubText-Buf",
      "library": "camomile.lib",
      "description": "This module provides operations for building and manipulating Unicode-aware text buffers, specifically designed for efficient construction of `SubText.t` values. It supports adding characters, strings, and other buffers, along with clearing and resetting buffer contents. Concrete use cases include assembling dynamic text during regex processing or incremental parsing tasks.",
      "description_length": 376,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharTbl.Type",
      "library": "camomile.lib",
      "description": "This module implements fast constant-time lookup tables indexed by Unicode characters, mapping each character to a specific value type `elt`. It supports operations to retrieve values for individual characters and construct tables from Unicode maps with a default fallback. Concrete use cases include efficient character classification, such as determining whitespace or digit characters, and building optimized Unicode-aware processing tables.",
      "description_length": 444,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Charmap.Configure",
      "library": "camomile.lib",
      "description": "This module builds and manages character encoding conversion tables, specifically translating between Unicode and external encodings. It provides functions to construct mappings, probe for valid character sequences, and retrieve conversion data by name. Concrete use cases include handling legacy encodings in text processing and enabling correct character interpretation during file or network I/O.",
      "description_length": 399,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.CaseMap.Make",
      "library": "camomile.lib",
      "description": "This module provides functions to perform case mappings on text according to Unicode standards, including lowercase, uppercase, capitalize, titlecase, and casefolding operations. It supports case-insensitive comparison and allows optional locale specification for culturally sensitive transformations. Use this module for accurate text normalization and comparison in multilingual applications.",
      "description_length": 394,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharTbl.Make",
      "library": "camomile.lib",
      "description": "This module creates fast Unicode character lookup tables using a specified hash and equality function. It supports table creation from a map and constant-time value retrieval. Use it to implement efficient Unicode property lookups, such as character classifications or case mappings.",
      "description_length": 283,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.SubText.Type-Buf",
      "library": "camomile.lib",
      "description": "This module implements a mutable buffer for handling Unicode text, supporting dynamic construction of strings through character and string appending. It provides operations to create, clear, reset, and extract contents from buffers, as well as combining buffers. Useful for efficiently building large strings or processing Unicode input incrementally, such as in text parsers or output generation.",
      "description_length": 397,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Config.Type",
      "library": "camomile.lib",
      "description": "This module defines configuration paths for Unicode and locale data used by the library. It includes directories for compiled Unicode data, ISO-style character mappings, camomile-style mappings, and locale files. These values are used internally to locate necessary data files for text processing and localization.",
      "description_length": 314,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStr.Interface-Make",
      "library": "camomile.lib",
      "description": "This module compiles and matches regular expressions with Unicode-aware syntax, supporting non-ASCII characters and Unicode property sets in patterns. It operates on text values from the `Text` module, using indices to track positions, and returns matched substrings or boolean results. Concrete use cases include parsing UTF-8 encoded identifiers with specific character properties or segmenting Japanese text components using script-based patterns.",
      "description_length": 450,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharTbl.Bits",
      "library": "camomile.lib",
      "description": "This module implements compact lookup tables for small integers using bit manipulation, optimized for Unicode character sets under 256. It provides `of_map` to build tables from mappings and `get` for fast character-based lookups. Ideal for encoding or categorizing ASCII-range Unicode characters with minimal memory overhead.",
      "description_length": 326,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.URe.Type",
      "library": "camomile.lib",
      "description": "This module provides operations for compiling regular expressions and performing pattern matching on Unicode text. It supports matching and searching operations that return detailed capture groups or boolean results, working with Unicode text values and indices. Concrete use cases include parsing structured text formats, validating input patterns, and extracting substrings based on complex regular expressions.",
      "description_length": 413,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Unidata.Type",
      "library": "camomile.lib",
      "description": "This module handles Unicode data operations such as normalization, collation, and character classification, alongside decomposition and locale-specific sorting rules. It works with Unicode characters, collation tables, and decomposition mappings to enable internationalized string comparison and transformation. Key use cases include implementing language-agnostic text sorting, canonical equivalence checks, and script/category-based character analysis.",
      "description_length": 454,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UNF.Type-NFCBuf",
      "library": "camomile.lib",
      "description": "This module implements a mutable buffer for constructing Unicode-normalized text in NFC form. It provides operations to add characters, strings, or other buffers to the buffer, clear or reset its contents, and extract the normalized result. It is used for efficiently building normalized text incrementally, such as when processing input streams or assembling strings from multiple sources.",
      "description_length": 390,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharTbl.Bytes",
      "library": "camomile.lib",
      "description": "This module implements space-efficient lookup tables for integer values indexed by Unicode characters, using `Bytes.t` for storage. It provides operations to construct a table from a map and retrieve values by character key, optimized for cases where integer values do not span the full 31-bit or 63-bit range. It is suitable for scenarios like character classification or encoding conversion where compact representation is critical.",
      "description_length": 434,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UnicodeString.Type-Buf",
      "library": "camomile.lib",
      "description": "This module implements character buffer operations for Unicode strings, providing functions to create, modify, and retrieve contents from a buffer. It supports appending characters, strings, or other buffers, and allows clearing or resetting the buffer state. Concrete use cases include efficient string concatenation, incremental string building, and handling Unicode text input/output.",
      "description_length": 387,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Sites.Sites",
      "library": "camomile.lib",
      "description": "This module provides access to predefined lists of locations for character maps, databases, locales, and mappings. It works with lists of location values representing file or directory paths. These lists are used to locate and load specific resources during configuration or execution of internationalization and localization workflows.",
      "description_length": 336,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Config.Default",
      "library": "camomile.lib",
      "description": "This module defines paths to directories containing compiled data files for Unicode, character mappings, and locale information. It provides direct access to these directories through string values, enabling applications to locate necessary data resources. Concrete use cases include initializing Unicode-aware libraries or configuring internationalization systems that rely on specific data file locations.",
      "description_length": 407,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UnicodeString.Type",
      "library": "camomile.lib",
      "description": "This module defines operations for handling Unicode strings with precise character indexing and traversal. It supports efficient access to individual Unicode characters, iteration, and comparison, along with index manipulation for navigating within strings. Concrete use cases include text processing, internationalized string manipulation, and implementing custom Unicode string types with strict index semantics.",
      "description_length": 414,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.ULine.Make",
      "library": "camomile.lib",
      "description": "This module handles line-oriented input and output operations for Unicode text, using a specified text type. It provides functions to read and write lines, manage line buffers, and handle end-of-line markers. Concrete use cases include processing Unicode text files line by line and implementing custom line-based parsers.",
      "description_length": 322,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.Unimap.Type",
      "library": "camomile.lib",
      "description": "This module defines data structures and operations for bidirectional Unicode and Asian character encoding mappings. It provides functions to create, modify, and convert between read-write and read-only mapping tables, supporting efficient lookups in both directions. Concrete use cases include handling character encoding conversions for legacy Asian encodings and managing fallback values for unmappable characters.",
      "description_length": 416,
      "index": 150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UCS4.Buf",
      "library": "camomile.lib",
      "description": "This module provides a buffer for building UCS4-encoded strings dynamically. It supports operations to add characters, strings, or other buffers, and to retrieve or reset the accumulated content. Use it when constructing large UCS4 strings incrementally, such as during parsing or text processing.",
      "description_length": 297,
      "index": 151,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "CamomileLib.CharEncoding.Interface-module-type-Type",
      "library": "camomile.lib",
      "description": "This module handles character encoding conversions through `decode` and `encode` functions. It works with `string` values representing encoded byte sequences and `text` values representing Unicode text. Use it to convert between different character encodings, such as UTF-8, ISO-8859-1, or Windows code pages, during input/output or string processing tasks.",
      "description_length": 357,
      "index": 152,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UReStr.Interface-Make-SubText-Buf",
      "library": "camomile.lib",
      "description": "This module provides operations to build and manipulate UTF-8 encoded text buffers that support Unicode-aware regular expressions. It works with `buf` type buffers, adding characters, strings, or other buffers, and extracting contents as `SubText.t`. Concrete use cases include constructing dynamic regex patterns with Unicode properties and efficiently building large text segments with proper character encoding.",
      "description_length": 414,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UNF.Make",
      "library": "camomile.lib",
      "description": "This module provides Unicode normalization operations for transforming text into canonical forms, including NFC, NFD, NFKC, and NFKD. It supports both direct normalization of entire texts and incremental processing through buffers, enabling efficient handling of streams or partial input. Key operations include `nfd`, `nfc`, `canon_compare`, and the `NFCBuf` module, which allows building normalized text incrementally. Examples include normalizing user input before comparison, processing streamed text, or ensuring consistent encoding in I/O operations.",
      "description_length": 556,
      "index": 154,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.CharEncoding.Interface-Make",
      "library": "camomile.lib",
      "description": "This module handles encoding and decoding of Unicode text to and from byte strings using a specified character encoding. It operates on the `text` type provided by the `Text` submodule and supports concrete encodings like UTF-8 or ISO-8859-1. Use it when converting between string representations and Unicode text in I/O operations or protocol implementations.",
      "description_length": 360,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Tbl31.Bytes",
      "library": "camomile.lib",
      "description": "This module implements a compact, fast lookup table for byte values indexed by 31-bit integers. It provides operations to create a table from a map and retrieve byte values by key. It is used for efficient byte-oriented data indexing and retrieval in applications like text encoding and decoding.",
      "description_length": 296,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UTF16.Buf",
      "library": "camomile.lib",
      "description": "This module provides a mutable buffer for efficiently constructing UTF-16 encoded strings. It supports operations to add individual Unicode characters, UTF-16 strings, or other buffers, and to retrieve or reset the current contents. It is useful for incremental string building, such as parsing or generating UTF-16 encoded text.",
      "description_length": 329,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCol.Type",
      "library": "camomile.lib",
      "description": "This module implements Unicode collation for string comparison and sorting, adhering to the UTR #10 standard. It provides functions to compare text with customizable locale, precision, and variable handling, along with generating binary sort keys for efficient repeated comparisons. Use cases include sorting user-facing strings in a locale-aware manner and performing efficient substring searches within collated text.",
      "description_length": 419,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Tbl31.Bits",
      "library": "camomile.lib",
      "description": "This module implements a space-efficient bit table for storing and retrieving integer values indexed by 31-bit keys. It supports operations to construct a table from a map and to query values by key, optimized for fast access and compact representation. It is suitable for scenarios requiring compact storage of large, sparse integer-indexed data, such as Unicode property tables or bit-encoded metadata.",
      "description_length": 404,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharInfo.Make",
      "library": "camomile.lib",
      "description": "This module supports querying and applying Unicode character properties, including classification into categories (e.g., alphabetic, whitespace), script identification (e.g., Latin, Han), and case transformations using conditional rules. It operates on Unicode characters (`UChar.t`) via specialized tables (`UCharTbl`) to handle decomposition, composition, and normalization, ensuring precise text processing for internationalized applications. Key use cases include Unicode normalization (e.g., canonical equivalence) and locale-aware string manipulation where accurate casing and character metadata are critical.",
      "description_length": 615,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.XString.Buf",
      "library": "camomile.lib",
      "description": "This module implements a mutable buffer for building Unicode strings efficiently. It supports operations to add characters, strings, or other buffers, and to retrieve or reset the accumulated content. Useful for constructing large strings incrementally, such as in text serialization or dynamic content generation.",
      "description_length": 314,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UNF.Type",
      "library": "camomile.lib",
      "description": "This module implements Unicode normalization forms (NFD, NFKD, NFC, NFKC) for text processing. It operates on `text` and `index` types, providing functions to normalize strings, compare them canonically, and decompose characters into their normalized components. Use cases include preparing Unicode strings for comparison, canonicalizing identifiers, and processing text where equivalent character representations must be unified.",
      "description_length": 430,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharInfo.Type",
      "library": "camomile.lib",
      "description": "This module type defines operations for querying Unicode character properties, including general categories (e.g., lowercase letters, decimal digits), scripts (e.g., Latin, Han), and character traits like alphabetic status or whitespace classification. It supports advanced text processing tasks such as case mapping (simple and conditional), decomposition, composition, and case folding, while providing access to normalization metadata like combined classes and exclusion flags for canonical forms (e.g., NFC, NFKC). These capabilities are essential for handling Unicode text normalization, internationalized string comparisons, and script-specific processing in applications like text editors or locale-aware systems.",
      "description_length": 720,
      "index": 163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.URe.Make",
      "library": "camomile.lib",
      "description": "This module compiles and executes regular expressions with support for Unicode text processing through its child modules. It provides core types like regex patterns and match results, along with operations for matching, searching, and extracting captured groups. The integrated Unicode handling enables precise index management, safe substring extraction, and efficient dynamic text assembly using buffers. Examples include parsing structured logs, validating email formats, and extracting fields from UTF-8 encoded strings.",
      "description_length": 524,
      "index": 164,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "CamomileLib.UReStr.Interface-module-type-Type-SubText-Buf",
      "library": "camomile.lib",
      "description": "This module provides operations to create, manipulate, and query a buffer specialized for handling Unicode-aware regular expressions. It supports adding characters, strings, or other buffers to a mutable buffer structure, and extracting the resulting content as a SubText value. Concrete use cases include building dynamic regular expressions with Unicode properties and assembling complex patterns from smaller components.",
      "description_length": 423,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UTF8.Buf",
      "library": "camomile.lib",
      "description": "This module provides functions to efficiently build and manipulate UTF-8 encoded strings using a buffer. It supports operations like adding Unicode characters, appending UTF-8 strings, and combining buffers, all while handling the underlying byte storage. Concrete use cases include constructing dynamic UTF-8 output for text processing, network communication, or file generation.",
      "description_length": 380,
      "index": 166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.Tbl31.Char",
      "library": "camomile.lib",
      "description": "This module implements a fast integer-keyed table specialized for character values. It provides operations to create a table from a character map and retrieve characters by integer keys. It is used for efficient lookups in character encoding or translation tables where integer indices map to specific characters.",
      "description_length": 313,
      "index": 167,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UReStr.Interface",
      "library": "camomile.lib",
      "description": "This module provides functions for compiling regular expressions with Unicode-aware syntax, supporting non-ASCII characters via UTF-8 or \\u-escaped sequences. It allows pattern matching using character properties (e.g., Lu, White_Space) and set operations within regex definitions. Use cases include parsing identifiers with Unicode categories or matching Japanese text components based on script types.",
      "description_length": 403,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.SubText.Make",
      "library": "camomile.lib",
      "description": "This module provides efficient Unicode text processing through immutable sequences and buffer types, supporting indexing, iteration, and comparison. It includes sub-text slices for referencing segments of base texts, enabling content extraction and index conversion, while its mutable buffer submodule optimizes dynamic text construction, such as building SQL queries or HTTP responses. Direct operations allow precise manipulation of text units, with submodules enhancing performance for streaming or large-scale text assembly tasks.",
      "description_length": 534,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.StringPrep_data.Type",
      "library": "camomile.lib",
      "description": "This module provides functions to retrieve character mapping tables and prohibited character sets defined in RFC 3454 for string preparation. It includes mappings for B.1 and B.2 blocks, SASLprep, and prohibited characters for various profiles like Nodeprep, Resourceprep, and Nameprep. These functions are used to implement string preprocessing for protocols such as SASL, XMPP, and iSCSI by checking or transforming input strings according to the specified rules.",
      "description_length": 465,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UReStr.Interface-module-type-Type-SubText",
      "library": "camomile.lib",
      "description": "This module enables precise manipulation of UTF-8 encoded Unicode text through character-level operations like indexing, iteration, and substring extraction, with native support for Unicode properties and complex character set logic using syntax like `{Lu}` or `{Han}`. It bridges `SubText` and `ur_text` types, offering conversions to isolate sub-text segments while preserving their positional context within original texts. It is particularly suited for parsing identifiers constrained by Unicode categories (e.g., capitalized symbols) or segmenting multilingual content using script-specific rules, such as Japanese text components.",
      "description_length": 636,
      "index": 171,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.Tbl31.Bool",
      "library": "camomile.lib",
      "description": "This module implements a compact boolean table indexed by integers, optimized for fast lookups and memory efficiency. It provides operations to create a table from an integer set and retrieve boolean values by index. It is useful for representing sparse boolean data, such as marking presence or absence of specific integer keys in a large range.",
      "description_length": 346,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.CharEncoding.Configure",
      "library": "camomile.lib",
      "description": "This module handles text encoding and decoding operations, converting between Unicode text and byte strings using specific character encodings. It provides core functions like `decode`, which converts a byte string into Unicode text, and `encode`, which transforms Unicode text into a byte string, supporting encodings such as UTF-8 and ISO-8859-1. The `text` type represents Unicode text, enabling precise string manipulation and conversion in input/output or processing tasks. Submodules define low-level encoding logic and user-facing conversion utilities, offering a complete interface for managing text in different encodings.",
      "description_length": 631,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCol.Make",
      "library": "camomile.lib",
      "description": "Implements Unicode-aware string comparison and sorting based on locale-specific collation rules. Provides functions to generate sort keys, compare strings with configurable precision and variable handling, and perform substring searches respecting collation. Useful for internationalized applications needing accurate string ordering and search in specific languages or regions.",
      "description_length": 378,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Tbl31.Type",
      "library": "camomile.lib",
      "description": "This module implements a fast integer-keyed table structure optimized for 31-bit integer keys. It provides direct element access via the `get` function and constructs tables from immutable maps using `of_map`. It is used for efficient lookups in scenarios requiring compact, integer-indexed data storage, such as indexing precomputed values or mapping integer identifiers to elements in performance-sensitive contexts.",
      "description_length": 418,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.SubText",
      "library": "camomile.lib",
      "description": "This module provides precise substring manipulation and iteration over text sequences, enabling efficient slicing, mapping, and folding without full string duplication. It supports both mutable and immutable text handling through submodules, including a Unicode buffer for dynamic string construction and a sequence type for indexed text processing. With these tools, users can build large strings incrementally, parse structured text like HTTP or SQL, and manage positional tracking across subranges. Direct operations and submodule enhancements combine to support both streaming and in-place text transformations with minimal overhead.",
      "description_length": 637,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharInfo",
      "library": "camomile.lib",
      "description": "This module provides functions to query and manipulate Unicode character properties, such as checking if a character is a letter, digit, or whitespace, and retrieving general category, case mappings, and numeric values. It operates on Unicode scalar values represented as integers (UCS-4), enabling precise classification, transformation, and normalization of characters for tasks like parsing, validation, and internationalized input handling. Submodules extend this functionality with support for script identification, conditional case transformations, and normalization via specialized tables, allowing operations such as canonical equivalence checks and locale-aware string manipulation. Specific examples include Unicode normalization (NFC, NFKC), case folding for case-insensitive comparisons, and script-specific processing in text editors or multilingual systems.",
      "description_length": 872,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStr",
      "library": "camomile.lib",
      "description": "This module handles Unicode-aware regular expressions with support for non-ASCII characters via UTF-8 or escape sequences, allowing patterns to include character properties and complex set operations. It provides core types like compiled regexps, UTF-8 text with index tracking, and buffers for dynamic pattern construction, enabling precise matching and extraction of multilingual text components such as Japanese script segments or identifiers using Unicode categories. Operations include compiling regex patterns with properties like `{Lu & ID_Start}`, matching and slicing UTF-8 strings based on script types like `{Han}`, and building dynamic patterns using buffer extensions. Submodules enhance text traversal, regex compilation, and buffer manipulation to support lexical analysis, identifier validation, and Unicode-based text transformation workflows.",
      "description_length": 860,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Config",
      "library": "camomile.lib",
      "description": "This module provides an interface for managing abstract configuration data, such as key-value pairs or hierarchical settings, with operations to load, save, and manipulate values. It supports building custom configuration backends like JSON or INI file handlers while defining standard paths for Unicode, locale, and character mapping data used by text processing and internationalization systems. The core API includes types for configuration values and paths, with operations to access and modify settings, alongside concrete string values pointing to data directories. Examples include loading application settings from a file, implementing a custom configuration format, or initializing Unicode-aware libraries using predefined data paths.",
      "description_length": 743,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Byte_labeled_dag",
      "library": "camomile.lib",
      "description": "This module represents a directed acyclic graph (DAG) where nodes are labeled with byte values. It provides operations to construct a DAG from labeled byte sequences, retrieve byte values at leaf nodes, and traverse branch nodes to find child DAGs. Concrete use cases include efficient representation and traversal of byte-based decision trees or finite automata.",
      "description_length": 363,
      "index": 180,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UReStrLexer",
      "library": "camomile.lib",
      "description": "This module implements a lexer for parsing Unicode regular expressions using `Lexing.lexbuf`. It provides the `token` function to read and process input into structured tokens, and internal lexing tables for efficient pattern matching. It is used to tokenize Unicode-aware regular expressions in a streaming fashion.",
      "description_length": 316,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.StringPrep_data",
      "library": "camomile.lib",
      "description": "This module handles Unicode character mappings and prohibited character sets from RFC 3454, enabling string preparation for protocols like XMPP, SASL, and iSCSI. It supports transformations using mapping tables that either replace characters or apply numeric offsets, and it provides functions to retrieve predefined mappings and prohibited sets for specific profiles such as Nameprep and SASLprep. Submodules offer efficient table-based mapping application, access to standard-defined rules, and profile-specific character checks. Example uses include normalizing internationalized domain names and validating input strings against protocol-specific character restrictions.",
      "description_length": 674,
      "index": 182,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.Charmap",
      "library": "camomile.lib",
      "description": "This module implements a character mapping table for efficient lookup and transformation of character-based data, supporting operations like insertion, retrieval, and folding over character sets. It works with character keys and associated values, enabling the creation of custom character encodings, classification, and input stream transformations. The child modules handle encoding-to-Unicode mappings and conversion table management, allowing for translation between Unicode and external encodings using structures like `enc_to_ucs` and `t`. Examples include interpreting legacy encodings during file I/O, building encoding-aware string transformations, and probing character sequences for valid conversions.",
      "description_length": 712,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStrParserType",
      "library": "camomile.lib",
      "description": "This module defines algebraic data types for representing Unicode regular expression syntax trees and set operations. It supports parsing and manipulating complex regex patterns with constructs like alternation, sequence, repetition, and lookaheads/lookbehinds, as well as set operations such as union, intersection, and difference. Concrete use cases include building and transforming regex expressions programmatically and implementing custom regex parsers that handle Unicode character sets and properties.",
      "description_length": 509,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Unimap",
      "library": "camomile.lib",
      "description": "This module provides tools for converting between Unicode and Asian character encodings such as Shift-JIS and EUC-KR, operating on strings and buffers for encoding and decoding. It includes support for bidirectional mappings using integer-based code points, with mutable and immutable structures for efficient lookup and modification. Child modules offer functions to create and manage mapping tables, enabling custom character set translations and fallback handling for unmappable characters. Use cases include processing legacy Asian text data, translating code pages, and maintaining synchronized encoding-Unicode mappings.",
      "description_length": 626,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStrParser",
      "library": "camomile.lib",
      "description": "Parses Unicode regular expressions into abstract syntax trees using a lexer. It tokenizes input into specific symbols and operators, such as characters, quantifiers, and grouping constructs. This module is used to build structured representations of regex patterns for further processing or analysis.",
      "description_length": 300,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.ConfigImpl",
      "library": "camomile.lib",
      "description": "This module retrieves specific directory paths from a list of locations and provides predefined paths for data, locale, character map, and Unicode map directories. It operates on lists of location values and exposes individual locations for resource resolution. It is used to locate internationalization and character encoding resources in a structured directory hierarchy.",
      "description_length": 373,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.CharEncoding",
      "library": "camomile.lib",
      "description": "This module provides core functionality for converting between byte sequences and Unicode text, with support for encodings like UTF-8, UTF-16, and ISO-8859-1. It introduces the `text` type for representing Unicode text and offers `decode` and `encode` functions to transform between byte strings and Unicode values, enabling precise handling of multilingual data in I/O and string processing tasks. Submodules refine this behavior with additional encoding-specific logic and utilities, supporting advanced use cases like dynamic encoding detection and conversion pipelines. Examples include decoding UTF-8 byte strings from files, encoding Unicode text into ISO-8859-1 for legacy systems, or normalizing text during input parsing.",
      "description_length": 730,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.URe",
      "library": "camomile.lib",
      "description": "This module implements a Unicode-aware regular expression engine for pattern matching and text processing, combining regex construction with text manipulation capabilities through its submodules. It provides core types like regex patterns, match results, and Unicode text representations, supporting operations such as pattern composition, matching, searching, and substring extraction. The module enables tasks like parsing structured logs, validating input formats, and extracting data from UTF-8 strings, with precise handling of Unicode indices and efficient buffer-based text assembly. Submodules enhance this functionality with tools for text slicing, bidirectional navigation, and buffer-based text construction, ensuring positional integrity during complex text transformations.",
      "description_length": 786,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Bitsvect",
      "library": "camomile.lib",
      "description": "This module implements a bit vector data structure with fixed-size bit arrays. It supports operations to create, access, and modify individual bits by index, as well as iterate over all bits. Concrete use cases include efficient storage and manipulation of binary flags or bitmaps.",
      "description_length": 281,
      "index": 190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UTF8",
      "library": "camomile.lib",
      "description": "This module handles UTF-8 encoded Unicode strings as standard OCaml strings, offering index-based access to individual characters, string construction, length calculation, and lexicographic comparison. It enables precise traversal and manipulation of characters in both directions, supporting tasks like parsing multilingual text and validating UTF-8 input. The buffer submodule enhances string building by allowing efficient addition of characters and strings, ideal for dynamic text generation in processing pipelines or network communication. Together, they combine direct string operations with high-performance construction techniques for comprehensive UTF-8 handling.",
      "description_length": 673,
      "index": 191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.Unidata",
      "library": "camomile.lib",
      "description": "This module provides core functions for working with Unicode scalar values, enabling operations like case conversion, normalization, and character classification. It integrates submodules that extend functionality to collation, decomposition, and locale-aware sorting using structured data such as collation elements and decomposition mappings. You can use it to implement language-specific sorting rules, normalize text for canonical equivalence checks, or analyze characters by script and category. Examples include processing user input with diacritics, comparing internationalized strings, and transforming text into a normalized form for consistent storage or display.",
      "description_length": 673,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Hangul",
      "library": "camomile.lib",
      "description": "Handles Hangul character decomposition and composition. Works with Unicode characters and extended strings. Enables adding custom decompositions and combining sequences into precomposed Hangul characters. Useful for normalizing Korean text input and processing.",
      "description_length": 261,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.AvlTree",
      "library": "camomile.lib",
      "description": "This module implements balanced binary trees (AVL trees) with operations for creating, modifying, and traversing trees. It supports key operations such as insertion, deletion, and traversal, and maintains balance to ensure efficient lookups and updates. Use cases include storing ordered data with fast access, implementing sets or maps, and managing hierarchical data where balance and efficient operations are critical.",
      "description_length": 421,
      "index": 194,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UCS4",
      "library": "camomile.lib",
      "description": "This module handles UCS-4 encoded Unicode strings stored as 32-bit integer bigarrays, offering direct access to characters by index, iteration, and index manipulation for efficient text navigation. It supports use cases like text editors and parsers that require random access to Unicode code points. A child buffer module allows dynamic construction of UCS-4 strings by appending characters or other buffers, ideal for incremental text processing. Together, they enable both direct manipulation of Unicode strings and efficient assembly of large or complex text data.",
      "description_length": 568,
      "index": 195,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UCol",
      "library": "camomile.lib",
      "description": "This module implements the Unicode Collation Algorithm (UTR #10) for locale-aware string comparison and sorting. It supports customizable collation strengths (primary to quaternary) and variable weighting options, enabling precise control over sorting behavior for different languages and regions. The module provides functions to compare strings, generate binary sort keys for efficient comparisons, and perform substring searches that respect collation rules. These capabilities make it suitable for internationalized applications such as multilingual user interfaces and locale-specific database queries.",
      "description_length": 607,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharTbl",
      "library": "camomile.lib",
      "description": "This module provides fast constant-time lookup tables indexed by Unicode characters, enabling efficient mapping of code points to arbitrary values. It supports creating tables from character maps, querying individual characters, and using default values for unspecified entries, ideal for tasks like character classification or state machine implementation. Submodules optimize for specific use cases: boolean membership checks, byte-sized properties, integer mappings with compact storage, and hash-based lookups, all leveraging Unicode code point keys for constant-time access. Examples include checking punctuation membership, mapping characters to case variants, or classifying ASCII characters with minimal memory overhead.",
      "description_length": 728,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.XArray",
      "library": "camomile.lib",
      "description": "This module offers operations for dynamically managing arrays with safe positional access, supporting creation, element manipulation, slicing, and resizing. It works with extensible arrays (`xarray`) and an `index` type that ensures valid position tracking, enabling efficient appending, iteration, and conversion to standard arrays. Ideal for scenarios requiring dynamic sequence handling, such as incremental data collection or buffer management with precise bounds enforcement.",
      "description_length": 480,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Bytesvect",
      "library": "camomile.lib",
      "description": "This module implements byte vectors with operations for indexed access, modification, and iteration. It supports creating vectors of a specified length with initial values, copying vectors, and setting or retrieving bytes at specific positions, including an identifier for each vector. Use cases include efficient byte-level data manipulation, such as handling binary data buffers or implementing custom binary protocols.",
      "description_length": 421,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UPervasives",
      "library": "camomile.lib",
      "description": "This module provides functions for converting between Unicode characters and integers, escaping Unicode characters and UTF-8 strings, and printing UTF-8 strings and individual Unicode characters using OCaml's format system. It operates on the `uchar` type (from `UChar.t`) and UTF-8 encoded strings. Concrete use cases include handling Unicode input/output, debugging Unicode-aware text processing, and ensuring safe string escaping in user-facing applications.",
      "description_length": 461,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UText",
      "library": "camomile.lib",
      "description": "This module implements Unicode strings using integer arrays, providing efficient storage and manipulation of Unicode data. It includes a mutable buffer submodule for building and modifying strings incrementally, supporting operations like appending characters, strings, or other buffers. Main data types include the Unicode string type and the buffer type, with operations for encoding, decoding, concatenation, and substring extraction. Example uses include parsing input streams, formatting text, and constructing dynamic Unicode content efficiently.",
      "description_length": 552,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Database",
      "library": "camomile.lib",
      "description": "This module provides low-level file-based key-value storage operations using custom serialization and deserialization functions. It works with arbitrary data types through user-provided readers and writers, storing each key as a uniquely named file within a specified directory. Concrete use cases include persisting locale-specific data or cached results where keys may contain special characters and require reliable escaping.",
      "description_length": 428,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.CaseMap",
      "library": "camomile.lib",
      "description": "This module handles Unicode case transformations, offering lowercase, uppercase, titlecase, and casefolding operations for characters and strings, with support for locale-specific mappings. It includes submodules that extend these capabilities to Unicode text sequences, enabling case-insensitive comparisons and linguistic processing. Operations can normalize input, adapt display text in internationalized interfaces, or support multilingual comparison logic. Example uses include converting user input to a consistent case, performing case-insensitive searches, and formatting text for display according to language-specific rules.",
      "description_length": 634,
      "index": 203,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.ULine",
      "library": "camomile.lib",
      "description": "This module provides line-oriented input and output with customizable line separators such as `CR`, `LF`, and `CRLF`, supporting both byte-oriented and Unicode text processing. It offers functions to read, write, and manipulate lines from strings and channels, with a focus on handling text files, log data, and network protocols that require precise line ending control. The `text` type allows for Unicode-aware line processing, enabling operations like line buffering, transformation, and custom parser implementation. Specific use cases include reading log files with mixed line endings, generating network messages with specific separators, and transforming configuration files line by line.",
      "description_length": 695,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.USet",
      "library": "camomile.lib",
      "description": "This module supports interval-based representation and manipulation of Unicode character sets, enabling efficient standard set operations (union, intersection, difference) and membership queries. It works with `t` for set structures and `UChar.t` for individual characters, offering iteration, folding, and filtering over ranges to handle tasks like text classification, code point range analysis, or custom character set transformations.",
      "description_length": 438,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UNF",
      "library": "camomile.lib",
      "description": "This module implements Unicode normalization forms (NFD, NFKD, NFC, NFKC) for transforming and comparing UTF-8 encoded strings according to UTR #15. It provides direct operations like `nfd`, `nfc`, and `canon_compare` to normalize and compare strings, ensuring consistent representations for tasks like sorting or identifier comparison. The `NFCBuf` submodule offers a mutable buffer for incrementally building NFC-normalized text, supporting efficient processing of streams or partial input. Together, the module and its submodules enable both one-step and incremental normalization, unifying equivalent character representations in internationalized text processing.",
      "description_length": 668,
      "index": 206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.OOChannel",
      "library": "camomile.lib",
      "description": "This module converts object-oriented input channels into streams, enabling sequential reading of values from channels using stream semantics. It operates on `obj_input_channel` and produces a stream of values of type `'a`. A concrete use case is processing a channel's contents as a lazy stream, where each read operation retrieves the next value from the channel.",
      "description_length": 364,
      "index": 207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.Sites",
      "library": "camomile.lib",
      "description": "The module organizes predefined paths for locating resources like character maps, databases, locales, and mappings. It supports operations to retrieve and manage these paths as lists of locations, enabling efficient resource discovery during internationalization workflows. For example, it can return a list of directories to search for locale definitions or provide a default path for loading character encodings.",
      "description_length": 414,
      "index": 208,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "CamomileLib.Locale",
      "library": "camomile.lib",
      "description": "This module handles locale identifiers and provides functions for reading localized data files and checking locale containment. It works with locale strings formatted as `lang_country_modifier`, using ISO codes for language and country. Use it to load resources specific to a locale, falling back to more general locales if necessary, or determine if one locale is a subset of another.",
      "description_length": 385,
      "index": 209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.Tbl31",
      "library": "camomile.lib",
      "description": "This module provides fast, compact table structures keyed by 31-bit integers, optimized for constant-time lookups and efficient memory use. It supports specialized submodules for boolean flags, byte sequences, bit patterns, characters, and integers, enabling efficient representations for sparse or large datasets. Operations include table construction from maps and direct key-based access via `get`, with concrete uses in encoding tables, bitfield storage, and indexed metadata retrieval. Submodules tailor these capabilities to specific data types while maintaining a unified, performance-focused interface.",
      "description_length": 610,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.ISet",
      "library": "camomile.lib",
      "description": "This module implements an integer set structure using AVL trees of intervals, enabling efficient membership checks, insertions, deletions, and set algebra operations (union, intersection, complement) alongside bulk range manipulations like `add_range` and `remove_range`. It supports both element-wise and interval-based transformations through iteration, folding, and partitioning, maintaining internal data as non-overlapping integer ranges. It is particularly suited for scenarios requiring compact representation of sparse integer ranges, such as Unicode code point handling or resource allocation tracking.",
      "description_length": 611,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.XString",
      "library": "camomile.lib",
      "description": "This module provides extensible Unicode strings with mutable buffers for efficient construction and manipulation. It supports character-level access, index-based navigation, and substring operations, along with appending, shrinking, and conversion to standard Unicode representations. The mutable buffer submodule enables incremental string building, ideal for serialization or content generation. Examples include parsing internationalized text, building dynamic documents, or managing editable buffers in text editors.",
      "description_length": 520,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.ConfigBase",
      "library": "camomile.lib",
      "description": "This module provides a unified interface for managing configuration values from multiple sources, such as files and environment variables, while defining abstract data types for keys, values, and errors. It supports operations to load, parse, and validate configurations, enabling tasks like initializing application parameters and handling feature toggles. The child module integrates by exposing specific configuration paths for Unicode and locale data directories, allowing applications to access these resources directly for internationalization and text processing. Together, they enable structured configuration workflows with built-in support for both general and data-specific setup tasks.",
      "description_length": 697,
      "index": 213,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.StringPrep",
      "library": "camomile.lib",
      "description": "This module implements string preparation algorithms for Unicode normalization and case folding, following IETF profiles such as Nameprep, Saslprep, and Nodeprep. It provides the core `stringprep` function to process text values according to specified rules, handling operations like canonical decomposition, case folding, and removal of non-ASCII spaces. Use it to prepare internationalized domain names, usernames, and authentication tokens for consistent comparison or storage. Submodules extend this functionality with profile-specific implementations, operating on `Text.t` values to enforce strict formatting required by protocols like SASL, TLS, and XMPP.",
      "description_length": 662,
      "index": 214,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UnicodeString",
      "library": "camomile.lib",
      "description": "This module provides a unified interface for working with Unicode strings across multiple encodings, supporting core operations like concatenation, substring extraction, length calculation, and character indexing. It includes a buffer module for efficient string building and mutation, enabling tasks like incremental text assembly and input/output handling, and an indexing module for precise character traversal and comparison, crucial for text processing and custom string implementations. Together, these components allow working with Unicode text in internationalized applications, encoding conversion, and high-performance parsing scenarios. Key data types include encoded string representations and buffers, with operations tailored to maintain consistency and efficiency across different use cases.",
      "description_length": 806,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UChar",
      "library": "camomile.lib",
      "description": "This module represents Unicode (ISO-UCS) characters, supporting all 31-bit code points. It provides functions to convert between characters and their integer code points, including safe and unsafe conversions, and supports equality and ordering operations. Concrete use cases include handling and manipulating Unicode characters in text processing, encoding/decoding routines, and internationalization tasks.",
      "description_length": 408,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UTF16",
      "library": "camomile.lib",
      "description": "This module provides UTF-16 string manipulation with direct code point access, validation, and efficient indexing over data stored in a Bigarray. It supports iteration, comparison, and operations like parsing or constructing UTF-16 text from external sources or for internationalized formats. A mutable buffer submodule enables incremental string building by appending characters, strings, or other buffers, with options to retrieve or reset contents. Together, these components allow efficient processing, construction, and validation of UTF-16 encoded Unicode data in applications like text editors or UTF-16-aware parsers.",
      "description_length": 625,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib",
      "library": "camomile.lib",
      "description": "This library provides comprehensive Unicode text processing capabilities, centered around efficient string manipulation, character property handling, and regular expression support. Core data types include Unicode strings, buffers for dynamic text construction, and specialized structures for encoding conversion, normalization, and case transformation. Users can perform tasks such as parsing multilingual text with Unicode-aware regexps, normalizing strings for internationalized identifiers, and mapping between encodings like UTF-8 and Shift-JIS. Additional components support structured text traversal, locale-aware collation, and configuration management for internationalization resources.",
      "description_length": 696,
      "index": 218,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 320,
    "meaningful_modules": 219,
    "filtered_empty_modules": 101,
    "retention_rate": 0.684375
  },
  "statistics": {
    "max_description_length": 956,
    "min_description_length": 219,
    "avg_description_length": 474.31963470319636,
    "embedding_file_size_mb": 0.7957868576049805
  }
}