{
  "package": "camomile",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 116,
  "creation_timestamp": "2025-08-18T19:00:14.864604",
  "modules": [
    {
      "module_path": "CamomileLib.UReStr.Configure.Make.SubText.Buf",
      "library": "camomile.lib",
      "description": "This module provides operations to create, manipulate, and manage a buffer (`buf`) for building and modifying `SubText.t` values. It supports adding characters, strings, or other buffers, clearing or resetting contents, and retrieving the current buffer contents. It is useful for efficiently constructing Unicode text incrementally, such as during string processing or output generation.",
      "description_length": 388,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStr.Configure.Make.SubText",
      "library": "camomile.lib",
      "description": "This module enables precise manipulation of Unicode text through `SubText.t`, offering character-level access, iteration, substring extraction, and efficient incremental construction via a dedicated buffer. It bridges `SubText.t` and `ur_text` by preserving original source indices during conversions, which is critical for tasks like parsing or analyzing substrings where positional context must remain accurate. The buffer optimizes dynamic text assembly, supporting frequent appending and in-place modifications with minimal overhead.",
      "description_length": 537,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.URe.Make.SubText.Buf",
      "library": "camomile.lib",
      "description": "This module provides operations for building and manipulating Unicode-aware text buffers, including adding characters, strings, or other buffers. It works with the `buf` type for buffering and `SubText.t` for text representation. Concrete use cases include constructing dynamic Unicode text output during regex processing or streaming text transformations.",
      "description_length": 356,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UReStr.Configure.Make",
      "library": "camomile.lib",
      "description": "This module compiles and executes regular expressions on Unicode text using a Str-like syntax. It provides precise matching and searching operations with support for capture groups and custom match semantics, returning results as arrays of substrings. It is used for parsing and analyzing structured or patterned Unicode text, such as log files, configuration data, or linguistic annotations.",
      "description_length": 392,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.CharEncoding.Configure.Make",
      "library": "camomile.lib",
      "description": "This module converts between Unicode text and byte strings using specific character encodings. It provides `decode` and `encode` functions that handle conversion in both directions. Use it when working with text input/output in formats like UTF-8 or ISO-8859-1.",
      "description_length": 261,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.URe.Make.SubText",
      "library": "camomile.lib",
      "description": "This module enables slicing, indexed character access, and iteration over Unicode text fragments while maintaining their relationship to a source `ur_text`. It supports conversion between `SubText.t` and `ur_text`, mapping sub-text indexes to the original text's indexing scheme and extracting bounded substrings with positional metadata. These capabilities are optimized for regex processing tasks like pattern matching on text segments and efficient substring manipulation with preserved context.",
      "description_length": 498,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.SubText.Make.Buf",
      "library": "camomile.lib",
      "description": "This module implements a mutable buffer for efficiently building and manipulating UTF-8 encoded text. It provides operations to create, clear, and reset buffers, as well as append characters, strings, or other buffers. Concrete use cases include constructing dynamic SQL queries, assembling log messages, and streaming UTF-8 encoded content.",
      "description_length": 341,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UNF.Make.NFCBuf",
      "library": "camomile.lib",
      "description": "This module implements a buffer for incrementally constructing Unicode Normalization Form C (NFC) text. It provides operations to add characters, strings, or other buffers to the internal state while maintaining NFC normalization. Use it when building normalized Unicode strings dynamically, such as processing or transforming UTF-8 encoded text streams.",
      "description_length": 354,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Charmap.Configure",
      "library": "camomile.lib",
      "description": "This module builds and manages character encoding conversion tables for mapping between UCS (Unicode) and specific encodings. It provides functions to create and query encoding-to-UCS tables, handle probe states for partial matches during decoding, and retrieve predefined character maps by name. Concrete use cases include implementing text encoding conversion routines and handling character set aliases in internationalized applications.",
      "description_length": 440,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.ULine.Make",
      "library": "camomile.lib",
      "description": "This module handles line-oriented input and output operations for Unicode text, using the provided `Text` module for text representation. It supports reading and writing lines from input and output channels, preserving line endings and handling encoding-specific details. Concrete use cases include processing Unicode text files line by line or implementing custom line-based protocols over input/output streams.",
      "description_length": 412,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UCharTbl.Bits",
      "library": "camomile.lib",
      "description": "This module implements compact lookup tables for small integers using bit manipulation, optimized for Unicode code points under 256. It provides `of_map` to construct tables from mappings and `get` for constant-time lookups. Useful for efficient encoding or classification of ASCII-range Unicode characters.",
      "description_length": 307,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.CharEncoding.Configure",
      "library": "camomile.lib",
      "description": "This module provides operations for defining, converting between, and detecting character encodings, with support for stream-based transformations between byte sequences and Unicode characters. It works with encodings like UTF-8, UTF-16, and ISO-2022 variants, enabling tasks such as text encoding conversion, multilingual data handling, and automatic encoding detection in input streams. Key functionality includes alias management, stateful decoding, and configurable encoding pipelines for processing text in diverse formats.",
      "description_length": 528,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Unimap.Make",
      "library": "camomile.lib",
      "description": "This module implements bidirectional mappings between Unicode and Asian character encodings, supporting operations to create, modify, and query mutable and immutable mapping tables. It works with integer-based code points for both Unicode (UCS) and encoding-specific values, allowing efficient translation in both directions. Concrete use cases include handling legacy Asian encodings like Shift-JIS or EUC-KR, where specific code points need conversion to or from Unicode, such as in text processing or file format parsers.",
      "description_length": 524,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.XString.Buf",
      "library": "camomile.lib",
      "description": "This module implements a mutable buffer for building Unicode strings efficiently through incremental character or string appending. It provides operations to add characters, strings, or other buffers, along with functions to retrieve the current contents, length, and to reset or clear the buffer. Concrete use cases include constructing dynamic SQL queries, assembling multi-part HTTP responses, or collecting output from streaming Unicode data sources.",
      "description_length": 454,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Tbl31.Char",
      "library": "camomile.lib",
      "description": "This module implements a fast lookup table for character data indexed by integers. It converts a character map into an optimized table structure and retrieves characters based on integer keys. Useful for efficient character encoding or translation tables where integer indices represent specific character codes.",
      "description_length": 312,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharTbl.Bytes",
      "library": "camomile.lib",
      "description": "This module implements space-efficient lookup tables for integer values indexed by Unicode characters, using `Bytes.t` for storage. It converts a map of integer keys to integers into a compact byte array, optimized for sparse integer ranges. The table allows constant-time lookups via Unicode characters, making it suitable for character classification or property mapping tasks where memory efficiency is critical.",
      "description_length": 415,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Tbl31.Bool",
      "library": "camomile.lib",
      "description": "This module implements a compact boolean table indexed by integers, optimized for fast lookups and memory efficiency. It provides operations to create a table from an integer set and retrieve boolean values by key. Useful for representing sparse boolean data like presence flags or bitmasks over large integer ranges.",
      "description_length": 317,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UCS4.Buf",
      "library": "camomile.lib",
      "description": "This module implements a mutable buffer for building UCS4-encoded strings efficiently. It supports operations to add individual characters, strings, or other buffers, and provides methods to access or reset the buffer's contents. Typical use cases include incremental construction of large UCS4 strings, such as during parsing or text processing, where frequent reallocation should be minimized.",
      "description_length": 395,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.SubText.Make",
      "library": "camomile.lib",
      "description": "This module provides operations for managing immutable UTF-8 text with precise character indexing and sub-region abstractions, supporting cursor-based navigation and efficient text construction through a mutable buffer. It works with text values, sub-text references (`t`), and absolute indices (`ur_index`) within a larger `ur_text`, enabling slicing, index conversion, and context-aware text manipulation. It is particularly useful for tasks requiring fine-grained control over text regions, such as parsing, transformation pipelines, or interactive text editing with positional tracking.",
      "description_length": 590,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UNF.Make",
      "library": "camomile.lib",
      "description": "This module normalizes Unicode text into canonical forms (NFD, NFKD, NFC, NFKC) using functions like `nfd`, `nfkd`, `nfc`, and `nfkc` on text values. It supports incremental normalization with specialized buffers such as `NFCBuf` for dynamic construction of NFC-normalized text. Use it to process UTF-8 streams, compare Unicode strings canonically with `canon_compare`, or decompose characters for normalization-sensitive operations like text rendering or data interchange.",
      "description_length": 473,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharTbl.Char",
      "library": "camomile.lib",
      "description": "Implements fast byte-based lookup tables for Unicode characters, enabling constant-time access. Uses a type `t` to represent the table and provides `of_map` to construct tables from character mappings and `get` to retrieve values for specific Unicode characters. Useful for efficiently handling character encodings or transformations where per-character actions are required.",
      "description_length": 375,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharTbl.Bool",
      "library": "camomile.lib",
      "description": "Implements fast boolean lookup tables indexed by Unicode characters. Provides `get` to retrieve boolean values and `of_set` to construct tables from Unicode sets. Useful for efficiently checking membership or properties of characters in Unicode-aware text processing tasks.",
      "description_length": 273,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UTF16.Buf",
      "library": "camomile.lib",
      "description": "This module provides a mutable buffer for efficiently constructing UTF-16 encoded strings. It supports operations to add characters, strings, or other buffers, and to retrieve or reset the current contents. It is useful for incremental UTF-16 string building, such as when processing input streams or generating output in UTF-16.",
      "description_length": 329,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.CaseMap.Make",
      "library": "camomile.lib",
      "description": "This module performs case conversion and caseless comparison on text according to Unicode case mappings, with optional locale-specific rules. It supports operations like lowercase, uppercase, capitalize, titlecase, and casefolding, all taking an optional locale parameter. Use it when handling text normalization, case-insensitive comparisons, or internationalized string processing where locale-aware casing matters.",
      "description_length": 417,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.StringPrep_data.Make",
      "library": "camomile.lib",
      "description": "This module provides functions to retrieve pre-defined character mapping tables and prohibited character sets defined in RFC 3454, specifically for string preparation profiles like SASLprep, Nameprep, and Resourceprep. It operates on Unicode character data using types like `MappingMap.t` and `UCharTbl.Bool.t` to represent transformation rules and character restrictions. Concrete use cases include validating and normalizing internationalized strings for protocols such as XMPP, LDAP, and iSCSI.",
      "description_length": 497,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Tbl31.Bits",
      "library": "camomile.lib",
      "description": "This module implements a space-efficient bit table for storing and retrieving integer values indexed by 31-bit keys. It supports constant-time lookups and conversions from integer maps. Use it for compact storage of bit patterns or flags where fast access by integer key is required.",
      "description_length": 283,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Tbl31.Bytes",
      "library": "camomile.lib",
      "description": "Tbl31.Bytes provides fast byte-sized integer storage indexed by 31-bit integers. It supports creating tables from integer maps and retrieving byte values by key. This module is useful for compact, efficient lookups in large mappings where values fit within a byte, such as encoding or frequency tables.",
      "description_length": 302,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UText.Buf",
      "library": "camomile.lib",
      "description": "This module implements a mutable buffer for building Unicode strings efficiently. It supports operations to add characters, strings, or other buffers, and to retrieve or reset the current contents. Typical uses include accumulating output from iterative text processing or constructing complex strings without repeated concatenation overhead.",
      "description_length": 342,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStr.Configure",
      "library": "camomile.lib",
      "description": "This module compiles and executes regular expressions on Unicode text using a Str-like syntax. It provides precise matching, searching, and capture group extraction, returning results as arrays of substrings. It is used for parsing structured Unicode input such as log files, configuration data, and linguistic annotations.",
      "description_length": 323,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.StringPrep_data.MappingMap",
      "library": "camomile.lib",
      "description": "This module implements a mapping table for Unicode characters used in string preparation, allowing efficient lookup of character mappings. It provides functions to retrieve mapped values for specific Unicode characters and to construct a mapping table from a default value and a custom map. The module is used to apply RFC 3454 string preparation rules, such as handling character normalization and replacement in protocols like SASL or IDNA.",
      "description_length": 442,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.StringPrep.Make",
      "library": "camomile.lib",
      "description": "This module implements string preparation algorithms for normalizing text according to specific IETF profiles such as `Nameprep`, `Saslprep`, and `Nodeprep`. It operates on text values of type `Text.t`, applying Unicode normalization, case folding, and character filtering as defined by each profile. It is used to process identifiers like usernames, hostnames, and resource names in protocols such as XMPP and SASL.",
      "description_length": 416,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharTbl.Make",
      "library": "camomile.lib",
      "description": "This module creates fast Unicode character lookup tables using a specified hash and equality function. It generates tables from a map with a default value for undefined characters. Useful for implementing Unicode property lookups or efficient character classification.",
      "description_length": 268,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UTF8.Buf",
      "library": "camomile.lib",
      "description": "This module provides functions to efficiently build and manipulate UTF-8 encoded strings using a buffer. It supports operations like adding Unicode characters, UTF-8 strings, or other buffers to an existing buffer, and retrieving or resetting buffer contents. Concrete use cases include constructing dynamic UTF-8 strings incrementally, such as generating text output or assembling multi-part messages.",
      "description_length": 402,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.Tbl31.Make",
      "library": "camomile.lib",
      "description": "This module implements a fast integer-keyed table structure optimized for 31-bit integers, providing efficient lookup via the `get` function. It converts a map of type `IMap.t` into a table using `of_map`, where elements are of the type provided by the `H` module. It is useful for scenarios requiring quick access to data indexed by integer keys, such as implementing caches or lookup tables in performance-sensitive code.",
      "description_length": 423,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Unidata.Make",
      "library": "camomile.lib",
      "description": "This module provides mappings between Unicode character properties and enumerated types or integers, supporting operations like categorization, script identification, and decomposition. It works with collation elements (`ce_type`), collation tables (`ce_tbl`), and locale-specific collation data (`col_info`) to enable Unicode normalization, sorting, and string comparison. Specific use cases include handling decomposition rules for characters and generating locale-aware collation keys for text processing.",
      "description_length": 508,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Config.Default",
      "library": "camomile.lib",
      "description": "This module defines standard directory paths for compiled Unicode and locale data, character mapping tables, and camomile-style unimap files. It provides direct access to these paths as string values, enabling applications to locate and load corresponding data resources. Use cases include initializing data loaders, configuring Unicode processing, and setting up locale-aware operations.",
      "description_length": 388,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.URe.Make",
      "library": "camomile.lib",
      "description": "This module compiles and executes regular expressions on Unicode text, providing precise matching and substring extraction with index tracking. It supports operations like `regexp_match` for capturing groups, `string_match` for boolean checks, and `search_forward` for scanning text. Concrete use cases include parsing structured text formats, validating input patterns, and extracting contextual substrings from Unicode documents.",
      "description_length": 431,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Sites.Sites",
      "library": "camomile.lib",
      "description": "This module provides access to predefined lists of resource locations for character maps, databases, locales, and mappings. It works with lists of `Dune_site.Private_.Helpers.Location.t` values, which represent file or directory paths in a build configuration. These values are used to locate and manage external data files required during the compilation or execution of internationalization and localization components.",
      "description_length": 421,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCol.Make",
      "library": "camomile.lib",
      "description": "This module implements Unicode-aware string comparison and sorting based on collation rules, supporting locale-specific ordering, variable weighting, and customizable precision. It operates on text values and indices, producing sort keys for efficient repeated comparisons and enabling substring searches according to collation equivalence. Use this for sorting user-facing strings in a linguistically correct way, or for implementing search features that respect cultural conventions in text processing.",
      "description_length": 504,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharInfo.Make",
      "library": "camomile.lib",
      "description": "This module provides operations for querying Unicode character properties such as category classification, script identification, case mappings with contextual rules, and decomposition/composition for normalization. It works with compact data structures like `UMap`, `UCharTbl`, and `USet` to efficiently represent and manipulate Unicode versioned data, case conversion tables, and normalization forms. Typical use cases include text processing, internationalization support, and implementing Unicode-aware string operations like case folding or canonical normalization.",
      "description_length": 570,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStrLexer",
      "library": "camomile.lib",
      "description": "This module implements a lexer for parsing Unicode regular expressions using `Lexing.lexbuf`. It provides the `token` function to read and process input into structured tokens, and internal lexing tables for pattern matching. It is used to tokenize Unicode strings into components for regular expression parsing.",
      "description_length": 312,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Unimap",
      "library": "camomile.lib",
      "description": "This module implements bidirectional mappings between Unicode and Asian character encodings, supporting operations to create, modify, and query mutable and immutable mapping tables. It works with integer-based code points for both Unicode (UCS) and encoding-specific values, allowing efficient translation in both directions. Concrete use cases include handling legacy Asian encodings like Shift-JIS or EUC-KR, where specific code points need conversion to or from Unicode, such as in text processing or file format parsers.",
      "description_length": 524,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Charmap",
      "library": "camomile.lib",
      "description": "This module provides operations to build and query character encoding conversion tables, supporting mappings between UCS (Unicode) and specific encodings. It includes functions for creating encoding tables, managing probe states during partial decoding, and retrieving predefined character maps by name. Use cases include implementing text encoding conversion and handling character set aliases in internationalized applications.",
      "description_length": 429,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UTF16",
      "library": "camomile.lib",
      "description": "This module implements UTF-16 encoded Unicode string manipulation with support for character access, validation, and index-based navigation. It operates on bigarray-based UTF-16 strings and Unicode characters, providing direct access to code points and efficient traversal. Concrete use cases include parsing UTF-16 encoded input, building UTF-16 output incrementally using the Buf submodule, and validating or processing strings from external sources.",
      "description_length": 452,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.OOChannel",
      "library": "camomile.lib",
      "description": "This module provides object-oriented input and output channel abstractions with standardized interfaces for handling byte streams. It supports conversion between input channels and lazy streams, enabling efficient, on-demand data processing from sources like files or network connections. Concrete use cases include parsing structured binary data, implementing custom stream filters, and integrating with network protocols requiring precise byte-level control.",
      "description_length": 460,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStr",
      "library": "camomile.lib",
      "description": "This module compiles and executes regular expressions on Unicode text using a Str-like syntax. It supports precise matching, searching, and capture group extraction, returning results as arrays of substrings. It is used for parsing structured Unicode input such as log files, configuration data, and linguistic annotations.",
      "description_length": 323,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.SubText",
      "library": "camomile.lib",
      "description": "This module provides precise UTF-8 text slicing, index conversion, and cursor-based navigation using sub-text references and absolute indices. It supports efficient text manipulation and construction through immutable text values and a mutable buffer, enabling operations like splitting, joining, and positional tracking within structured text. Concrete use cases include implementing parsers, text transformation pipelines, and interactive editors requiring accurate region management.",
      "description_length": 486,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCS4",
      "library": "camomile.lib",
      "description": "This module implements UCS4-encoded strings as bigarrays of 32-bit integers, providing direct access to Unicode characters via indexing and iteration. It supports operations such as character retrieval, validation, buffer-based construction, and index manipulation for navigating through the string. Concrete use cases include parsing binary data with embedded Unicode text, building large Unicode strings efficiently, and implementing text processing tools that require direct access to code points.",
      "description_length": 500,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.ULine",
      "library": "camomile.lib",
      "description": "This module handles line-oriented input and output for Unicode text, supporting reading and writing lines from channels while preserving line endings. It works with Unicode text and input/output channels, handling encoding-specific details. Use it to process Unicode text files line by line or implement line-based protocols over streams.",
      "description_length": 338,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UChar",
      "library": "camomile.lib",
      "description": "This module directly handles Unicode (ISO-UCS) characters as 31-bit code points. It provides conversions to and from Latin-1 characters (`char_of`, `of_char`), encoding/decoding to integer representations (`code`, `chr`, `uint_code`, `chr_of_uint`), and comparison operations (`eq`, `compare`). Concrete use cases include processing Unicode text streams, implementing encoders/decoders for text formats, and handling character sets that exceed the Latin-1 range.",
      "description_length": 462,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.Unidata",
      "library": "camomile.lib",
      "description": "This module maps Unicode character properties to enumerated types or integers, enabling operations like categorization, script identification, and decomposition. It works with collation elements, collation tables, and locale-specific collation data to support Unicode normalization, sorting, and string comparison. Use it to handle character decomposition rules and generate collation keys for locale-aware text processing.",
      "description_length": 423,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UPervasives",
      "library": "camomile.lib",
      "description": "This module provides functions for converting between Unicode characters and integers, escaping Unicode characters and UTF-8 strings, and printing UTF-8 strings and individual Unicode characters using OCaml's formatting library. It operates on the `uchar` type representing Unicode characters and standard UTF-8 encoded strings. Use cases include handling Unicode input/output, debugging Unicode-aware text processing, and integrating with OCaml's toplevel printing system for custom character representations.",
      "description_length": 510,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.Byte_labeled_dag",
      "library": "camomile.lib",
      "description": "This module implements a byte-labeled directed acyclic graph (DAG) structure for representing and querying hierarchical byte sequences. It provides operations to construct a DAG from labeled byte segments, and to look up leaf and branch nodes by index. Concrete use cases include efficient representation of byte-based decision trees and parsing byte streams using precomputed DAG structures.",
      "description_length": 392,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UTF8",
      "library": "camomile.lib",
      "description": "This module implements UTF-8 encoded Unicode string operations with direct access to individual characters and precise positional control. It supports validation, character indexing, traversal, comparison, and iteration over Unicode characters using efficient low-level operations. Concrete use cases include parsing UTF-8 input streams, implementing text editors, and building custom string manipulation routines that require fine-grained control over UTF-8 content.",
      "description_length": 467,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.StringPrep",
      "library": "camomile.lib",
      "description": "This module implements string preparation algorithms for Unicode strings, handling operations like normalization, case folding, and filtering of prohibited characters. It works with UTF-8 encoded strings and supports customizable profiles for different string preparation standards, such as Nameprep and Resourceprep. Concrete use cases include preparing internationalized domain names (IDNs) and XMPP identifiers for comparison or storage.",
      "description_length": 440,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Sites",
      "library": "camomile.lib",
      "description": "This module provides functions to retrieve and manage predefined resource locations for character maps, databases, locales, and mappings. It operates on lists of `Dune_site.Private_.Helpers.Location.t` values, representing file or directory paths used in build configurations. Concrete use cases include locating external data files needed for internationalization and localization during compilation or runtime.",
      "description_length": 412,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.Config",
      "library": "camomile.lib",
      "description": "This module defines standard directory paths for Unicode and locale data, character mapping tables, and unimap files. It exposes these paths directly as string values for initializing data loaders and configuring Unicode and locale-aware operations. Useful in applications requiring direct access to localization resources or setting up character encoding processing.",
      "description_length": 367,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStrParser",
      "library": "camomile.lib",
      "description": "Parses Unicode regular expressions into abstract syntax trees using a lexer that produces a specific set of token types, including characters, operators, and structural markers. It processes input through a `start` function that drives the parsing process given a token-producing lexer and a lexing buffer. This module is used to build internal representations of regex patterns for further processing or execution.",
      "description_length": 415,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.XArray",
      "library": "camomile.lib",
      "description": "The module enables dynamic array management by supporting element access, index traversal, slicing, and in-place resizing operations. It works with extensible arrays (`xarray`) and standard arrays, offering efficient appending, conversion, and iterative transformations. This facilitates use cases like building dynamic data structures, performing complex array manipulations, and optimizing memory usage during iterative computations.",
      "description_length": 435,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.UCol",
      "library": "camomile.lib",
      "description": "Implements the Unicode Collation Algorithm (UTR #10) for comparing and sorting Unicode strings according to cultural and linguistic rules. It supports customizable collation through options like variable handling (`Blanked`, `Shifted`) and comparison precision (`Primary`, `Tertiary`). Useful for applications requiring accurate internationalized string sorting, such as database queries or multilingual user interfaces.",
      "description_length": 420,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.ConfigBase",
      "library": "camomile.lib",
      "description": "This module defines a common interface for configuration handling, including operations to retrieve and bind configuration values. It works with abstract data types representing configuration sources, such as environment variables or configuration files. Concrete use cases include loading application settings and managing feature flags based on external configuration.",
      "description_length": 370,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Hangul",
      "library": "camomile.lib",
      "description": "This module handles Hangul character decomposition and composition. It provides functions to decompose a Hangul character into its constituent Jamo characters, add custom decomposition mappings, and compose sequences of Jamo characters back into Hangul. It works directly with Unicode characters and strings, enabling precise manipulation of Korean text in applications like input method editors or text normalization tools.",
      "description_length": 424,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CamomileLib.CaseMap",
      "library": "camomile.lib",
      "description": "This module provides functions for converting characters and strings to upper, lower, and title case according to Unicode standards. It supports both ASCII and Unicode data, handling case mappings for a wide range of scripts and special characters. Use cases include text normalization for internationalized applications, case-insensitive string comparison, and processing user input in multilingual contexts.",
      "description_length": 409,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UMap",
      "library": "camomile.lib",
      "description": "Supports efficient management of maps associating Unicode characters to arbitrary values, with operations for insertion, deletion, range-based domain manipulation, membership testing, iteration, mapping, and folding. It also enables conversions between Unicode sets and constant maps, as well as predicate-driven extraction of Unicode sets from maps, useful for handling character range logic or transforming map data based on specific criteria.",
      "description_length": 445,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Bitsvect",
      "library": "camomile.lib",
      "description": "This module implements a compact bit vector with direct access to individual bits. It supports operations to get, set, and iterate over bits, as well as creating and copying bit vectors of a specified length. Useful for efficiently representing and manipulating binary data, such as in low-level data structures, compression algorithms, or hardware simulation.",
      "description_length": 360,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UReStrParserType",
      "library": "camomile.lib",
      "description": "This module defines algebraic data types for representing Unicode regular expression syntax trees and set notations. It supports operations like sequence, alternation, repetition, grouping, and set manipulation using `USet.t`. Concrete use cases include parsing and manipulating complex Unicode regex patterns with support for character sets, ranges, and properties.",
      "description_length": 366,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.AvlTree",
      "library": "camomile.lib",
      "description": "This module implements balanced binary trees (AVL trees) with operations for constructing, deconstructing, and traversing trees. It supports key operations like inserting nodes, extracting leftmost/rightmost elements, concatenating trees, and folding or iterating over elements. It is useful for maintaining ordered data with efficient lookup, insertion, and deletion, such as in symbol tables or priority queues.",
      "description_length": 413,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UnicodeString",
      "library": "camomile.lib",
      "description": "This module defines a signature for handling Unicode strings with support for various encodings, including UTF-8, UTF-16, and UCS-4. It provides operations for string manipulation, indexing, and conversion between different Unicode representations. Concrete use cases include text processing in internationalized applications, encoding-aware string transformations, and handling of Unicode scalar values.",
      "description_length": 404,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Tbl31",
      "library": "camomile.lib",
      "description": "This module implements fast, compact lookup tables keyed by 31-bit integers, offering direct access via the `get` function. It supports specialized submodules for boolean flags, bit patterns, byte values, and characters, each optimized for space and performance. Concrete use cases include encoding tables, frequency counters, bitmask storage, and character code translation.",
      "description_length": 375,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharInfo",
      "library": "camomile.lib",
      "description": "This module offers precise queries for Unicode character properties, including category classification, script identification, case mappings with contextual rules, and normalization via decomposition or composition. It operates on specialized data structures like `UMap`, `UCharTbl`, and `USet` to handle Unicode versioned data, case conversion tables, and normalization forms efficiently. It is used for text processing tasks requiring Unicode awareness, such as case folding, internationalization, and canonical string normalization.",
      "description_length": 535,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.StringPrep_data",
      "library": "camomile.lib",
      "description": "This module implements Unicode character mapping tables and prohibited character sets from RFC 3454 for string preparation. It provides functions to look up character replacements and build custom mapping tables, supporting data types like Unicode characters (`UChar.t`) and specialized boolean and mapping tables. It is used to enforce string normalization rules in protocols such as SASL, IDNA, and XMPP.",
      "description_length": 406,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.ConfigImpl",
      "library": "camomile.lib",
      "description": "This module retrieves specific directory paths for localization and character encoding data using the `get_path` function, which extracts a value from a list context. It provides predefined paths for data, locale, character map, and Unicode map directories, each represented as a location object. These are used to locate resource files during runtime in internationalization workflows.",
      "description_length": 386,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UText",
      "library": "camomile.lib",
      "description": "This module provides functions for manipulating Unicode strings using both immutable (`ustring`) and mutable (`utext`) representations backed by integer arrays. It supports operations like character indexing, slicing, appending, and iteration, along with a mutable buffer for efficient dynamic string construction. It is particularly useful for text processing tasks requiring precise Unicode handling, such as internationalized text manipulation or low-level string transformations.",
      "description_length": 483,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.IMap",
      "library": "camomile.lib",
      "description": "This module offers operations to associate integers with arbitrary values, enabling insertions, lookups, deletions, and transformations over individual keys or contiguous ranges, alongside iteration and folding over key-value pairs. It operates on integer-keyed maps and supports converting these maps into integer sets by extracting key domains or filtering keys based on value predicates. Such functionality is particularly useful for managing integer intervals efficiently and deriving set-based insights from mapped data.",
      "description_length": 525,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Database",
      "library": "camomile.lib",
      "description": "This module provides low-level file-based key-value storage operations using custom serialization functions. It works with arbitrary data types through user-defined readers and writers, storing values in files under a specified directory with a given suffix. Concrete use cases include persisting locale-specific data or configuration settings where keys may contain arbitrary characters, such as language identifiers or user-defined labels.",
      "description_length": 441,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.URe",
      "library": "camomile.lib",
      "description": "This module implements a Unicode-aware regular expression engine with support for complex pattern matching, including alternation, repetition, grouping, and boundary constraints. It provides operations for compiling and executing regexps on Unicode text, with features like substring capture, position tracking, and customizable match semantics (e.g., shortest, longest). Use cases include parsing log files, validating internationalized identifiers, and extracting structured data from multilingual documents.",
      "description_length": 510,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UCharTbl",
      "library": "camomile.lib",
      "description": "This module implements fast, constant-time lookup tables indexed by Unicode characters, supporting efficient data retrieval and classification. It provides specialized submodules for boolean flags, bit-packed integers, byte-based storage, and customizable table construction, all optimized for Unicode-aware text processing tasks. Concrete use cases include Unicode property checks, character encoding conversions, and compact storage of character classifications.",
      "description_length": 464,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Locale",
      "library": "camomile.lib",
      "description": "This module handles locale identifiers and provides functions for reading localized data files and checking locale containment. It works with locale strings formatted as `<LANG>_<COUNTRY>_<MODIFIER>`, using ISO language and country codes. Use cases include loading language-specific resources and determining if one locale is a generalization of another.",
      "description_length": 354,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.UNF",
      "library": "camomile.lib",
      "description": "This module implements Unicode normalization forms (NFD, NFKD, NFC, NFKC) for text processing. It operates on Unicode scalar values and strings, providing functions to normalize and compare encoded text. Use it to ensure consistent string representations, such as preparing text for comparison or canonicalization in internationalized applications.",
      "description_length": 348,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.CharEncoding",
      "library": "camomile.lib",
      "description": "This module defines a framework for handling character encodings, supporting operations like encoding conversion, detection, and stream-based decoding. It works with byte sequences and Unicode characters, targeting encodings such as UTF-8, UTF-16, and ISO-2022 variants. Use cases include processing multilingual text files, converting between encoding formats, and detecting encoding in input streams for accurate text interpretation.",
      "description_length": 435,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.Bytesvect",
      "library": "camomile.lib",
      "description": "This module implements byte vectors with direct access to elements using indices. It supports creating vectors of a specified length initialized with a default value, reading and writing elements safely or unsafely, and iterating over elements with their indices. Use cases include handling binary data buffers, implementing low-level network protocols, and managing fixed-size byte arrays with indexed access.",
      "description_length": 410,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib.XString",
      "library": "camomile.lib",
      "description": "This module supports efficient creation, modification, and navigation of Unicode strings with precise character-level control, including index-based traversal and validation. It operates on extensible Unicode string types (`xstring`) and mutable buffers, enabling operations like appending, substring extraction, and conversion to standard Unicode representations. Designed for tasks requiring low-level Unicode handling, such as dynamic text assembly, internationalization, or complex string transformations where performance and fine-grained manipulation are critical.",
      "description_length": 570,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CamomileLib",
      "library": "camomile.lib",
      "description": "This module offers operations for managing ordered data with balanced trees, manipulating bit and byte sequences, transforming Unicode characters (case mapping, normalization, collation), converting encodings, and handling locale-specific configurations. It works with data structures like AVL trees, byte-labeled DAGs, dynamic arrays, and Unicode string representations (UTF-8, UTF-16, UCS4), alongside resources for bidirectional encoding and Hangul composition. These capabilities are tailored for internationalized text processing, efficient binary data manipulation, and robust Unicode-aware parsing in multilingual applications.",
      "description_length": 634,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UReStr.Make.SubText.Buf",
      "library": "camomile",
      "description": "This module provides a mutable buffer for efficiently building Unicode text values (`SubText.t`). It supports operations to add characters, strings, or other buffers, and allows clearing or resetting the buffer while retaining its underlying storage. Concrete use cases include constructing dynamic text output, such as generating formatted messages or accumulating stream input.",
      "description_length": 379,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UReStr.Make.SubText.Buf",
      "library": "camomile",
      "description": "This module implements a mutable buffer for building Unicode text values (`SubText.t`) through incremental appending of characters, strings, or other buffers. It provides operations to create, reset, clear, and extract the accumulated text, optimized for efficient concatenation. Concrete use cases include constructing dynamic Unicode strings from streaming data or iterative processing without repeated allocation overhead.",
      "description_length": 425,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UNF.Make.NFCBuf",
      "library": "camomile",
      "description": "This module provides a mutable buffer for building Unicode Normalization Form C (NFC) text incrementally. It supports operations to add characters, strings, or other buffers, and to retrieve or reset the accumulated NFC-normalized text. Concrete use cases include efficient construction of normalized text during parsing or streaming operations.",
      "description_length": 345,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UReStr.Make.SubText",
      "library": "camomile",
      "description": "This module enables precise manipulation of Unicode text through operations like character access, index navigation, and substring comparison, while providing a mutable buffer (`Buf`) for efficient text assembly. It works with `SubText.t` and its underlying `ur_text` representation, supporting conversions between index types (`index` and `ur_index`) to maintain positional accuracy during slicing or contextual extraction. These capabilities are particularly useful for Unicode-aware text processing tasks requiring fine-grained position mapping, such as parsing structured documents or dynamically constructing substrings with contextual references.",
      "description_length": 652,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.StringPrep.Make",
      "library": "camomile",
      "description": "This module implements the StringPrep algorithm for text normalization, providing a `stringprep` function that processes text according to specified profiles such as `Saslprep` or `Nameprep`. It operates on text values of type `Text.t`, typically used for preparing strings in protocols like SASL, XMPP, and LDAP. Concrete use cases include normalizing usernames, passwords, and resource identifiers before comparison or storage.",
      "description_length": 429,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UNF.Make.NFCBuf",
      "library": "camomile",
      "description": "This module provides a mutable buffer for constructing Unicode Normalization Form C (NFC) text incrementally. It supports operations to add characters, strings, or other buffers, while maintaining NFC normalization, and allows retrieving or resetting the accumulated content. Concrete use cases include efficiently building normalized text output from disparate inputs, such as processing and combining NFC-normalized user input or file segments.",
      "description_length": 446,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.CaseMap.Make",
      "library": "camomile",
      "description": "This module performs case conversion and comparison operations on text values, including lowercase, uppercase, capitalize, titlecase, and casefolding. It supports locale-sensitive transformations and provides a function for case-insensitive comparison. Use it when handling internationalized text processing where correct case handling per language rules is required, such as in string normalization or user input handling.",
      "description_length": 423,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UReStr.Make.SubText",
      "library": "camomile",
      "description": "This module provides precise Unicode text manipulation through index-aware operations on `SubText.t`, including character access, bidirectional iteration, and contextual substring handling. It bridges `SubText.t` and `ur_text` representations via index translation and conversion functions, while the `Buf` module enables efficient incremental text construction. It is suited for tasks requiring exact position tracking in Unicode text, such as parsing or text transformation workflows with contextual substring extraction.",
      "description_length": 523,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UReStr.Make",
      "library": "camomile",
      "description": "This module provides Unicode-aware regular expression compilation and matching operations over text, supporting precise substring extraction and index tracking. It works with `text` and `SubText.t` types to handle complex text slicing and pattern matching, particularly useful for parsing multilingual documents or implementing lexical analyzers where accurate position mapping is critical. Key functions include `compile` for regex preparation, `regexp_match` for structured matches, and `search_forward` for efficient Unicode text scanning.",
      "description_length": 542,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.CharEncoding.Make",
      "library": "camomile",
      "description": "This module implements character encoding and decoding operations between strings and a specified text type. It works with `CharEncoding.t` to handle different character encodings and converts between byte strings and structured text representations. Concrete use cases include parsing text from encoded byte streams and serializing text into specific encodings like UTF-8 or ISO-8859-1.",
      "description_length": 387,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UCol.Make",
      "library": "camomile",
      "description": "This module implements Unicode-aware string comparison and sorting operations using customizable collation rules. It provides functions to compare text values, generate sort keys, and perform substring searches respecting specified collation parameters like locale and strength. These operations are designed for handling internationalized text data where linguistic ordering and equivalence are required.",
      "description_length": 405,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UNF.Make",
      "library": "camomile",
      "description": "This module provides Unicode normalization operations including NFD, NFKD, NFC, and NFKC forms, along with incremental decomposition and comparison functions. It works with text data represented by the `Text.t` type and supports building normalized text through mutable buffers. Concrete use cases include normalizing text during input processing, comparing Unicode strings canonically, and streaming NFC-normalized output efficiently.",
      "description_length": 435,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UCol",
      "library": "camomile",
      "description": "This module implements Unicode-aware string comparison and sorting with customizable collation rules. It supports operations like comparing text values, generating sort keys, and performing substring searches, respecting linguistic rules such as locale and comparison strength. It works with Unicode strings and allows specifying options like blanked or shifted characters, and precision levels such as primary or quaternary equivalence.",
      "description_length": 437,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.UNF.Make",
      "library": "camomile",
      "description": "This module provides Unicode normalization operations for converting text into NFD, NFKD, NFC, and NFKC forms, as well as incremental decomposition and comparison. It works with Unicode characters and text structures, supporting both immutable transformations and mutable buffer construction via the `NFCBuf` submodule. Concrete use cases include normalizing user input, processing Unicode file segments, and efficiently constructing NFC-normalized output incrementally.",
      "description_length": 470,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.StringPrep",
      "library": "camomile",
      "description": "This module implements the StringPrep algorithm for text normalization, providing a `stringprep` function that processes text according to profiles like `Saslprep` or `Nameprep`. It operates on values of type `Text.t`, preparing strings for protocols such as SASL, XMPP, and LDAP. Use cases include normalizing usernames, passwords, and resource identifiers before comparison or storage.",
      "description_length": 387,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.StringPrep.Make",
      "library": "camomile",
      "description": "This module implements string preparation algorithms for Unicode strings, applying normalization, case folding, and filtering according to specified profiles like `Saslprep` or `Nameprep`. It operates on text values provided by the `Text` module, transforming them into standardized forms suitable for protocol-specific identifiers. Concrete use cases include preparing strings for internationalized domain names, SASL authentication, and LDAP distinguished names.",
      "description_length": 464,
      "index": 98,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Make.CaseMap",
      "library": "camomile",
      "description": "This module performs case conversion and comparison operations on text values, including lowercase, uppercase, capitalize, titlecase, and casefolding. It supports locale-sensitive transformations and provides a function for case-insensitive comparison. Use it for internationalized text processing tasks like string normalization and user input handling where language-specific case rules matter.",
      "description_length": 396,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.CharEncoding.Make",
      "library": "camomile",
      "description": "This module implements character encoding and decoding operations between strings and a specified text type, using a given encoding strategy. It provides `decode` and `encode` functions that convert between byte strings and structured text values. A concrete use case is handling UTF-8 or other Unicode encodings when reading from or writing to external sources like files or network streams.",
      "description_length": 392,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UCol.Make",
      "library": "camomile",
      "description": "This module implements Unicode-aware string comparison and sorting operations using customizable collation rules. It provides functions for comparing text values, generating sort keys, and performing substring searches with configurable locale and collation strength settings. It works directly with text and index types, enabling precise string manipulation and ordering in multilingual contexts.",
      "description_length": 397,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.Make.UReStr",
      "library": "camomile",
      "description": "This module provides Unicode-aware regular expression compilation and matching operations over text, supporting precise substring extraction and index tracking. It works with `text` and `SubText.t` types to handle complex text slicing and pattern matching, particularly useful for parsing multilingual documents or implementing lexical analyzers where accurate position mapping is critical. Key functions include `regexp` for compiling patterns, `quote` for escaping strings, and `regexp_match` for structured matches.",
      "description_length": 518,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UCharInfo",
      "library": "camomile",
      "description": "This module provides operations for querying Unicode character properties like general category, script, age, and case mappings, as well as transformations for decomposition, composition, and case folding. It works directly with Unicode characters (`UChar.t`) and leverages lookup tables (`UCharTbl`, `UMap`) and sets (`USet`) to efficiently manage property data. These capabilities support use cases such as Unicode normalization, text filtering by character properties, version-aware comparisons, and bidirectional case conversion in internationalized text processing.",
      "description_length": 570,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UReStr.Make",
      "library": "camomile",
      "description": "This module implements Unicode-aware regular expression operations on text values, including compiling patterns, matching at specific positions, and searching forward through text. It works with `text` values and `SubText.t` substrings, using `index` to track positions accurately across transformations. It is ideal for parsing structured text formats or implementing lexical analyzers where precise Unicode handling and position tracking are critical.",
      "description_length": 453,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.CaseMap.Make",
      "library": "camomile",
      "description": "This module provides functions to transform text by changing case, including lowercase, uppercase, capitalize, titlecase, and casefolding, all respecting locale-specific rules. It operates on text values from the `Text` module, which represents Unicode strings. Use it for internationalized text processing tasks like normalizing user input or comparing strings without case sensitivity.",
      "description_length": 387,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make.UNF",
      "library": "camomile",
      "description": "This module provides Unicode normalization operations for converting text into NFD, NFKD, NFC, and NFKC forms, along with incremental decomposition and comparison functions. It operates on text values of type `Text.t` and supports efficient streaming and mutable buffer construction of normalized text. Use cases include canonical comparison of Unicode strings, streaming normalized text output, and normalizing input during text processing tasks.",
      "description_length": 447,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.UNF",
      "library": "camomile",
      "description": "This module normalizes Unicode text into NFD, NFKD, NFC, and NFKC forms, offering both full and incremental decomposition. It operates on Unicode characters and text structures, supporting immutable transformations and mutable buffer construction through the `NFCBuf` submodule. Use it to normalize user input, process Unicode file segments, or build NFC-normalized output incrementally.",
      "description_length": 387,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.CharEncoding",
      "library": "camomile",
      "description": "This module provides functions to convert between character encodings (e.g., UTF-8, UTF-16, Latin-1), detect encodings automatically, and manage encoding strategies, operating on strings, character streams, and a custom type representing encodings. It addresses use cases like handling Unicode text during data transmission, file I/O, or network communication, ensuring correct encoding transformations and aliasing. The `Make` functor enables creating dedicated conversion modules for specific encoding strategies, such as UTF-8, to structure text from byte sequences or vice versa.",
      "description_length": 583,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Camomile.UReStr",
      "library": "camomile",
      "description": "This module implements Unicode-aware regular expression operations on text values, including compiling patterns, matching at specific positions, and searching forward through text. It works with `text` values and `SubText.t` substrings, using `index` to track positions accurately across transformations. It is ideal for parsing structured text formats or implementing lexical analyzers where precise Unicode handling and position tracking are critical.",
      "description_length": 453,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.CaseMap",
      "library": "camomile",
      "description": "Transforms Unicode text according to locale-aware case rules, including lowercase, uppercase, capitalize, titlecase, and casefolding operations. Works directly on `Text` module types representing Unicode strings. Useful for internationalized input normalization, case-insensitive comparisons, and text formatting respecting cultural conventions.",
      "description_length": 345,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.StringPrep",
      "library": "camomile",
      "description": "This module implements string preparation algorithms for Unicode strings, applying normalization, case folding, and filtering based on profiles such as `Saslprep` and `Nameprep`. It operates on text values from the `Text` module, transforming them into standardized forms for use in internationalized domain names, SASL authentication, and LDAP distinguished names.",
      "description_length": 365,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UCharInfo",
      "library": "camomile",
      "description": "This library component offers Unicode character classification, case conversion, and normalization through operations like decomposition, composition, and case-folding. It leverages trie-based lookup tables (`UCharTbl.t`) and Unicode character representations (`UChar.t`) to efficiently handle properties such as general category, script, and decomposition mappings. These capabilities are essential for text processing tasks requiring internationalization, such as case-insensitive comparisons, canonical normalization, or script-specific transformations.",
      "description_length": 556,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.Make",
      "library": "camomile",
      "description": "This module provides Unicode character property queries, normalization, collation, case conversion, regular expression matching, and string preparation. It operates on Unicode characters and text, supporting precise text processing tasks like normalization, case-insensitive comparison, and protocol-specific string preparation. Use it for internationalized text handling in applications such as document parsing, user input validation, and multilingual sorting.",
      "description_length": 462,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile.UCol",
      "library": "camomile",
      "description": "This module implements Unicode-aware string comparison and sorting with customizable collation rules. It supports operations like comparing text values, generating sort keys, and performing substring searches, using configurable locale and collation strength settings. It works directly with text and index types to enable precise string manipulation and ordering in multilingual contexts.",
      "description_length": 389,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Camomile",
      "library": "camomile",
      "description": "This module provides Unicode text processing capabilities including normalization, collation, case conversion, and regular expression matching. It operates on Unicode characters and text structures, supporting precise internationalized text handling. Use it for document parsing, multilingual sorting, user input validation, and protocol-specific string preparation.",
      "description_length": 366,
      "index": 115,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 171,
    "meaningful_modules": 116,
    "filtered_empty_modules": 55,
    "retention_rate": 0.6783625730994152
  },
  "statistics": {
    "max_description_length": 652,
    "min_description_length": 261,
    "avg_description_length": 426.3534482758621,
    "embedding_file_size_mb": 1.6810588836669922
  }
}