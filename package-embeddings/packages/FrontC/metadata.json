{
  "package": "FrontC",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 9,
  "creation_timestamp": "2025-08-14T23:05:38.790732",
  "modules": [
    {
      "module_path": "Clexer.HashString",
      "library": "FrontC",
      "description": "This module implements a hash function and equality check for string values. It converts strings into integer hashes and compares them for equality. Useful for efficiently storing and retrieving strings in hash tables or other data structures that rely on hashing.",
      "description_length": 264,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Clexer.StringHashtbl",
      "library": "FrontC",
      "description": "This module implements a string-keyed hash table with operations for creation, insertion, deletion, lookup, iteration, folding, and conversion to and from sequences. It operates on string keys and arbitrary value types, supporting both in-place updates and functional transformations while enabling bulk data manipulation through sequence conversions. Key applications include efficient dictionary management and processing pipelines that require structured key-value transformations or batched data loading.",
      "description_length": 508,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cparser",
      "library": "FrontC",
      "description": "Parses C source code into abstract syntax trees using a lexer function that generates tokens from a lex buffer. It provides two entry points for parsing: one for general input sources and another specifically for files. The module processes input into a list of C abstract syntax definitions, which represent the structure of the parsed code.",
      "description_length": 342,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ctoxml",
      "library": "FrontC",
      "description": "This module converts C abstract syntax trees into XML nodes and documents. It handles C language elements like expressions, statements, types, and function definitions, transforming them into structured XML representations. Use it to generate XML outputs from parsed C code for analysis, documentation, or translation tools.",
      "description_length": 324,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cabs",
      "library": "FrontC",
      "description": "This module defines a `size` type representing size modifiers in C type declarations, such as \"short\", \"long\", and \"long long\". It includes a `version` value indicating the module's version. Use this module when parsing or generating C-like type signatures that require precise size annotations.",
      "description_length": 295,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cxml",
      "library": "FrontC",
      "description": "This module defines data structures for representing XML documents, including elements, attributes, text nodes, comments, and processing instructions. It provides functions to construct and manipulate XML trees, validate and deduplicate element identifiers, and output XML to files or channels. Concrete use cases include generating XML configuration files, exporting structured data, and building custom XML-based formats with proper syntax and structure.",
      "description_length": 456,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cprint",
      "library": "FrontC",
      "description": "This module provides low-level text layout control through indentation tracking, line break insertion, and buffer management, alongside functions to format C-like types, expressions, and abstract syntax trees into human-readable strings. It operates on data structures such as Cabs.base_type, Cabs.expression, and Cabs.name_group, enabling use cases like generating structured C code from ASTs, pretty-printing complex type declarations, and rendering expressions with precise spacing and alignment.",
      "description_length": 499,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Clexer",
      "library": "FrontC",
      "description": "This module supports lexical analysis tasks by parsing C-like tokens (comments, strings, character literals) and processing escape sequences, while managing input buffers and position tracking through a structured handle. It employs string-based hash tables for efficient keyword and identifier handling, along with context manipulation utilities to manage parsing states during recursive lexing operations. The handle abstraction centralizes error reporting, enabling precise underlined error messages tied to file positions, making it suitable for compilers or interpreters requiring robust lexical analysis with contextual awareness.",
      "description_length": 636,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ctokens",
      "library": "FrontC",
      "description": "This module defines a token type representing lexical elements of C-like languages, including keywords, operators, literals, and punctuation. It provides constructors for categorizing tokens with positional information, such as identifiers, constants, control structures, and type specifiers. Concrete use cases include parsing C code, implementing custom lexers, and analyzing or transforming C-based syntax trees.",
      "description_length": 415,
      "index": 8,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 9,
    "meaningful_modules": 9,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 636,
    "min_description_length": 264,
    "avg_description_length": 415.44444444444446,
    "embedding_file_size_mb": 0.13094139099121094
  }
}