{
  "package": "raylib",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 57,
  "creation_timestamp": "2025-08-15T15:47:55.340664",
  "modules": [
    {
      "module_path": "Raylib.Ray",
      "library": "raylib",
      "description": "This module defines a ray with a position and direction, both represented as 3D vectors. It provides functions to create a ray and access or modify its position and direction. Use this module to represent rays in 3D space, such as for collision detection or raycasting operations.",
      "description_length": 280,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.CameraProjection",
      "library": "raylib",
      "description": "This module defines two camera projection types, Perspective and Orthographic, and provides conversion functions to and from integers. It works directly with the `t` variant type representing different projection modes. Use this module when setting up or switching between 3D camera projections in a rendering pipeline.",
      "description_length": 319,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.RenderTexture",
      "library": "raylib",
      "description": "This module manages off-screen rendering targets with OpenGL framebuffer objects. It provides access to color and depth buffer textures attached to a render texture, allowing operations like retrieving or updating these buffers. Use it to implement effects like post-processing, shadow mapping, or rendering to textures for dynamic materials.",
      "description_length": 342,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Vector2",
      "library": "raylib",
      "description": "This module provides operations for manipulating 2D vectors with arithmetic (addition, subtraction, scaling, division), property calculations (length, squared length, dot product, distance), and geometric transformations (rotation, normalization, linear interpolation, reflection). It works with lightweight structures representing 2D coordinates and directions, enabling tasks like physics simulations, game object movement, and graphical effects requiring spatial precision. Specific applications include calculating angles between vectors, smoothing motion with interpolation, and resolving collisions through distance checks.",
      "description_length": 629,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib.TextureWrap",
      "library": "raylib",
      "description": "This module defines texture wrapping modes for 2D textures in OpenGL, supporting repeat, clamp, mirror repeat, and mirror clamp behaviors. It provides conversions between the enumerated type and integer values for compatibility with graphics APIs. Use this module to specify how textures should wrap when sampling beyond their boundaries in rendering operations.",
      "description_length": 362,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.CubemapLayout",
      "library": "raylib",
      "description": "This module defines an enumeration of cubemap layout types used in 3D rendering, including automatic detection, vertical and horizontal lines, cross-shaped layouts, and panorama formats. It provides conversion functions `to_int` and `of_int` to map between the layout variants and their corresponding integer representations. These functions are used when configuring cubemap textures in graphics pipelines where layout specification is required.",
      "description_length": 446,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.RayCollision",
      "library": "raylib",
      "description": "This module handles ray collision detection in 3D space, providing access to hit status, distance, impact point, and surface normal data. It operates on ray collision structures that store intersection results from ray casting operations. Use this module to determine precise collision details when testing rays against 3D geometry, such as in picking or physics interactions.",
      "description_length": 376,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.MouseCursor",
      "library": "raylib",
      "description": "This module defines a set of cursor shapes and converts between cursor values and integers. It works with the `t` type, representing different mouse cursor styles like arrow, crosshair, and resize indicators. Use it to set or retrieve the current mouse cursor in a graphical application.",
      "description_length": 287,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Image",
      "library": "raylib",
      "description": "This module handles image data manipulation, providing access to properties like width, height, mipmap levels, and pixel format. It works with the `t` type, which wraps image data and metadata. Use it to inspect or modify image attributes before rendering or processing.",
      "description_length": 270,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib.ConfigFlags",
      "library": "raylib",
      "description": "This module defines a set of configuration flags used to control window and rendering behavior. It provides conversions between flag values and integers, enabling bitwise operations for combining multiple flags. These flags are used to set display modes, window properties, and rendering hints when initializing a window or graphics context.",
      "description_length": 341,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib.Wave",
      "library": "raylib",
      "description": "This module provides functions to manipulate audio wave data, including getting and setting sample rate, bit depth, and channel count. It works directly with the `t` type representing audio waves, allowing configuration of audio properties for playback or processing. Concrete use cases include adjusting audio format parameters before rendering sound effects or music in a game.",
      "description_length": 379,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Key",
      "library": "raylib",
      "description": "This module defines an enumeration of keyboard key values and provides bidirectional conversion between the key type and integers. It includes representations for standard alphanumeric keys, function keys, modifiers, and special keys like navigation and media controls. Use this module to handle keyboard input in applications by matching key presses against specific enumerated values or converting raw integer codes to typed keys.",
      "description_length": 432,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.FontType",
      "library": "raylib",
      "description": "This module defines font types used for rendering text, including default, bitmap, and signed distance field (SDF) formats. It provides conversions between font type values and their integer representations. Use this module when selecting or querying the font rendering method in text display operations.",
      "description_length": 304,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.VrStereoConfig",
      "library": "raylib",
      "description": "This module manages VR stereo configuration data for rendering 3D scenes in virtual reality. It provides access to projection and view offset matrices for each eye, lens and screen center coordinates, and distortion scaling factors. These values are used to correctly position and render stereo images for VR headsets, enabling immersive 3D visualization. Functions allow both reading and updating of these parameters, supporting dynamic adjustments during VR rendering.",
      "description_length": 470,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Rectangle",
      "library": "raylib",
      "description": "This module defines a rectangle structure with positional and dimensional attributes, including `x`, `y`, `width`, and `height`. It provides functions to create rectangles and access or modify their fields directly. Use this module to represent and manipulate 2D rectangular areas, such as UI elements or collision boxes in graphics applications.",
      "description_length": 346,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.ShaderLocationIndex",
      "library": "raylib",
      "description": "This module defines a set of symbolic identifiers for common shader input locations used in rendering pipelines. It includes operations to convert these identifiers to and from integer values, enabling direct mapping between shader variables and their corresponding locations in GPU programs. Use cases include setting up vertex attributes, passing transformation matrices, and configuring material properties in shaders for 3D rendering.",
      "description_length": 438,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.ModelAnimation",
      "library": "raylib",
      "description": "Handles skeletal animation data for 3D models, providing access to bone information, frame counts, and pose transformations. Works with arrays of `BoneInfo` and `Transform` types to define skeleton hierarchies and animated poses. Use to load and manipulate model animations, such as character movements or object transformations, in a 3D scene.",
      "description_length": 344,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.AudioStream",
      "library": "raylib",
      "description": "This module manages audio stream configuration through direct manipulation of sample rate, bit depth, and channel count. It provides accessors and setters for these properties, working with unsigned integers to ensure valid values. Concrete use cases include adjusting playback quality dynamically or configuring audio input/output parameters for specific hardware requirements.",
      "description_length": 378,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Transform",
      "library": "raylib",
      "description": "This module manages 3D transformations by composing translation, rotation, and scale operations. It works with `Vector3` for position and scale, and `Vector4` for rotation (typically representing quaternions). Direct use cases include setting and retrieving object transforms in a 3D scene, such as positioning models, applying rotations, or adjusting scale in a game engine or visualization tool.",
      "description_length": 397,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Vector3",
      "library": "raylib",
      "description": "This module provides arithmetic operations (addition, subtraction, scaling, cross products), geometric calculations (length, distance, normalization, dot product), and transformations (rotation, reflection, interpolation) for 3D vectors. It operates on C-compatible 3D vectors with float components, supporting advanced interactions with matrices and quaternions for spatial manipulations. These capabilities are critical for applications like physics simulations, game development, and 3D graphics programming.",
      "description_length": 511,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.GamepadButton",
      "library": "raylib",
      "description": "This module defines an enumeration of gamepad button inputs and provides conversions between the enumerated values and integers. It represents physical buttons on a gamepad, such as face buttons, triggers, and thumbsticks. Use this module to map gamepad input events to specific actions in a game or interactive application.",
      "description_length": 324,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.PixelFormat",
      "library": "raylib",
      "description": "This module defines pixel format enumerations for texture and image data, including uncompressed and compressed formats with varying bit depths and channel configurations. It provides conversions between these formats and integer representations. Use this module when specifying or interpreting pixel data layouts for graphics operations like texture loading or image processing.",
      "description_length": 379,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib.BlendMode",
      "library": "raylib",
      "description": "This module defines a set of blending modes used for controlling how colors are combined during rendering. It includes functions to convert between blending mode values and their integer representations. Concrete use cases include setting transparency effects, additive lighting, and color manipulation in 2D graphics rendering.",
      "description_length": 328,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.MaterialMapIndex",
      "library": "raylib",
      "description": "This module defines a set of identifiers for material maps used in 3D rendering, such as Albedo, Normal, and Roughness. It provides conversions between these identifiers and integers using `to_int` and `of_int`. These operations are useful when interfacing with graphics APIs or shaders that expect material map indices as integer values.",
      "description_length": 338,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib.ShaderLoc",
      "library": "raylib",
      "description": "Handles shader location identifiers used for interacting with GPU shaders. Provides functions to retrieve and manipulate uniform and attribute locations within compiled shaders. Useful when passing data like transformation matrices or material properties to shaders during rendering.",
      "description_length": 283,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.MaterialMap",
      "library": "raylib",
      "description": "This module defines a material map structure that combines a texture, color, and scalar value, providing direct access and mutation of these fields. It works with `Texture.t`, `Color.t`, and `float` to represent material properties used in rendering. Concrete use cases include configuring surface appearance in 3D graphics, such as setting diffuse maps, specular highlights, or opacity values for materials.",
      "description_length": 408,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.TextureFilter",
      "library": "raylib",
      "description": "This module defines texture filtering modes used in graphics rendering, including point sampling, bilinear, trilinear, and anisotropic filtering at various levels. It provides conversions between the filtering modes and integer representations. Use these types to set or retrieve texture filtering behavior in rendering pipelines or material configurations.",
      "description_length": 357,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Mesh",
      "library": "raylib",
      "description": "This module provides operations to create and manipulate mesh data structures by managing vertex attributes (positions, normals, texture coordinates, colors, bone weights) and index arrays, enabling precise control over geometry and animation properties. It works directly with `Raylib.Mesh.t` objects and C-style arrays of primitive types to configure vertex buffer layouts, support skinning workflows, and optimize rendering via indexed triangles. These functions are ideal for building or modifying 3D models at a low level, implementing skeletal animations, or handling dynamic geometry updates required for GPU rendering pipelines.",
      "description_length": 636,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Font",
      "library": "raylib",
      "description": "This module manages font resources for rendering text in a graphics application. It provides access to font properties such as base size, glyph padding, texture atlas, and glyph metadata, along with functions to modify these properties. Direct use cases include loading and configuring custom fonts, extracting glyph layout data, and integrating fonts with rendering pipelines for UI or game text display.",
      "description_length": 405,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.AutomationEventList",
      "library": "raylib",
      "description": "Handles lists of automation events, providing operations to create, manipulate, and iterate over sequences of `AutomationEvent` elements. Works directly with the `t` type, which wraps a C-compatible list structure. Useful for recording and replaying user input events in game development scenarios.",
      "description_length": 298,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Model",
      "library": "raylib",
      "description": "This module defines a data structure for handling 3D models, including their geometry, materials, and skeletal animation data. It provides accessors and mutators for transform matrices, meshes, materials, bones, and bind poses. Direct use cases include loading and manipulating animated 3D models, managing mesh and material assignments, and configuring skeletal transformations for animation playback.",
      "description_length": 402,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Music",
      "library": "raylib",
      "description": "This module provides functions to manipulate music data by accessing and modifying its audio stream, looping behavior, and context type. It works with the `t` type representing a music resource, and interacts directly with audio streams and integer identifiers for file types. Concrete use cases include loading and controlling background music playback, adjusting looping flags at runtime, and associating music with specific audio file formats.",
      "description_length": 446,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Gesture",
      "library": "raylib",
      "description": "This module defines gesture recognition types and conversions for handling touch and mouse input in interactive applications. It supports operations to convert between gesture values and integers, enabling event processing and user interaction detection. Concrete use cases include implementing touch controls for games or UI elements based on swipes, taps, and pinches.",
      "description_length": 370,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib.NPatchInfo",
      "library": "raylib",
      "description": "This module manages n-patch (9-slice) texture information, allowing the definition and manipulation of border offsets, source rectangles, and layout types such as 3x3, 1x3, or 3x1. It provides functions to create, access, and modify fields of an n-patch structure, which is used for scalable UI elements like buttons or panels in 2D graphics. Direct use cases include configuring texture regions for resizable GUI components while preserving corner and edge visuals.",
      "description_length": 466,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.MouseButton",
      "library": "raylib",
      "description": "This module defines a set of constructors representing mouse button inputs and provides conversions between these buttons and integer values. It works with the `t` sum type, which includes variants for common mouse buttons like `Left`, `Right`, and `Middle`. Use this module to handle mouse input events in applications such as games or GUIs where precise button detection is required.",
      "description_length": 385,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib.CameraMode",
      "library": "raylib",
      "description": "This module defines camera movement modes for 3D scenes, including free movement, orbital rotation, and first/third-person views. It provides conversions between the mode type and integer representations. Use it to control camera behavior in games or visualizations requiring specific navigation styles.",
      "description_length": 303,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.ShaderUniformDataType",
      "library": "raylib",
      "description": "This module defines types representing shader uniform data kinds like floats, vectors, and samplers. It provides conversions between these types and integer codes using `to_int` and `of_int`. Use this module when setting or retrieving uniform variable types in shaders, such as specifying whether a uniform is a `Vec3` or a `Sampler2d`.",
      "description_length": 336,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib.Camera3D",
      "library": "raylib",
      "description": "This module defines a 3D camera configuration with functions to create and manipulate camera parameters such as position, target, orientation, and projection type. It operates on `Camera3D` structures that encapsulate properties like field-of-view, up vector, and projection mode (`perspective` or `orthographic`). Direct use cases include setting up view transformations for 3D rendering, adjusting camera angles for gameplay, and switching between perspective and orthographic views in a 3D scene.",
      "description_length": 499,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.AutomationEvent",
      "library": "raylib",
      "description": "This module defines a data type `t'` and its wrapped form `t` for representing automation events in the Raylib library. It provides the necessary type definitions and bindings to work with event data in C-compatible memory layouts. Concrete use cases include handling input events or window actions in automated testing scenarios within Raylib applications.",
      "description_length": 357,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.GamepadAxis",
      "library": "raylib",
      "description": "Represents gamepad axis inputs with specific variants for left/right X/Y axes and triggers. Converts between axis values and integers for direct access to gamepad state. Useful for reading analog input values from connected controllers in games or interactive applications.",
      "description_length": 273,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Camera2D",
      "library": "raylib",
      "description": "This module defines a 2D camera structure with operations to create and manipulate camera properties including position, rotation, and zoom. It works with `Raylib.Vector2.t` for coordinates and provides direct accessors and setters for camera parameters. Concrete use cases include setting up dynamic camera views in 2D games, adjusting camera focus during gameplay, and implementing zoom and rotation effects.",
      "description_length": 410,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Material",
      "library": "raylib",
      "description": "This module manages material properties for 3D rendering, providing access to shaders, texture maps, and parameter arrays. It supports operations to get and set the material's shader, texture maps array, and parameter values. Use this module to configure and manipulate materials in a rendering pipeline, such as applying textures or adjusting material parameters dynamically.",
      "description_length": 376,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.BoundingBox",
      "library": "raylib",
      "description": "This module defines a bounding box structure using minimum and maximum 3D vector points. It provides functions to create a box from two corners and to get or set the min and max vertices. Useful for collision detection and spatial queries in 3D environments.",
      "description_length": 258,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.TraceLogLevel",
      "library": "raylib",
      "description": "This module defines a set of log severity levels and provides conversions between those levels and integers. It works with the `t` variant type representing different log levels such as `Trace`, `Debug`, `Error`, and `None`. Use this module to filter or interpret logging output based on severity in applications using the Raylib library.",
      "description_length": 338,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.FilePathList",
      "library": "raylib",
      "description": "Handles lists of file paths, providing access to the underlying data structure and conversion to standard OCaml string lists. Works directly with `Raylib.FilePathList.t'` and `Raylib.ctyp`-wrapped instances. Useful for retrieving and manipulating collections of file paths, such as when processing directory contents or asset bundles.",
      "description_length": 334,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Vector4",
      "library": "raylib",
      "description": "The module provides arithmetic operations, interpolation methods, and conversion utilities for 4D vectors, including normalization, length computation, and component-wise manipulation. It operates on tuples of four floats, enabling transformations between vector types, matrix interactions, and rotation representations, primarily supporting graphics programming tasks like 3D transformations and physics simulations requiring precise vector mathematics.",
      "description_length": 454,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.BoneInfo",
      "library": "raylib",
      "description": "This module defines bone information for skeletal animation, including parent-child relationships. It provides access to and modification of the parent index of a bone, used in 3D model rigging. Direct use cases include setting up hierarchical relationships between bones in an animation system.",
      "description_length": 295,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib.Matrix",
      "library": "raylib",
      "description": "This module provides operations for constructing and manipulating 4x4 matrices, including linear algebra operations like determinant calculation, transposition, inversion, and transformations such as translation, rotation, and scaling. It works with matrices represented as 16-float structures and integrates with 3D vectors to support spatial transformations. These capabilities are used for tasks like camera control, object manipulation, and projection matrix generation in 3D graphics rendering.",
      "description_length": 499,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib.Color",
      "library": "raylib",
      "description": "The module provides operations to create color values using RGBA components, extract individual color channels, and access predefined color constants like `skyblue` or `purple`. It centers around the `Color.t` type, which encapsulates color data in a C-compatible memory layout for efficient graphics processing. These features are particularly useful in rendering workflows for tasks like tinting, pixel manipulation, or applying color-based visual effects.",
      "description_length": 458,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.GlyphInfo",
      "library": "raylib",
      "description": "This module defines a data structure for storing glyph information used in text rendering, including character values, positioning offsets, advance width, and image data. It provides functions to create and manipulate glyph records, enabling precise control over character layout and rendering in a graphics context. Concrete use cases include building custom font renderers or handling dynamic text layout in games and visual applications.",
      "description_length": 440,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib.NPatchLayout",
      "library": "raylib",
      "description": "This module defines layout types for rendering scalable patches in 2D graphics, specifically supporting nine-patch and three-patch (vertical or horizontal) configurations. It provides conversion functions `to_int` and `of_int` to map between the layout variants and integer representations. Use this module when implementing UI elements or sprites that require adaptive scaling behavior in a raylib-based application.",
      "description_length": 417,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.ShaderAttributeDataType",
      "library": "raylib",
      "description": "This module defines types and conversions for shader attribute data types used in graphics programming. It supports operations to convert between type representations and integer values, facilitating interaction with GPU data. Concrete use cases include specifying vertex attribute formats in OpenGL shaders and managing data type mappings during rendering pipeline setup.",
      "description_length": 372,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib.Rlgl",
      "library": "raylib",
      "description": "This component enables low-level OpenGL-style graphics operations for matrix manipulation, vertex buffer management, and GPU state configuration. It works with vertex arrays, textures, shaders, framebuffers, and matrix structures from the `Raylib_c.Types` module to support tasks like real-time 3D rendering, visual effects via shader programs, and direct pixel/vertex data handling. Specific use cases include configuring depth testing, blending modes, and stereo projections for immersive 3D environments, as well as managing off-screen rendering with custom framebuffers.",
      "description_length": 574,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Sound",
      "library": "raylib",
      "description": "This module manages audio playback through low-level sound and audio stream operations. It provides functions to access and modify audio streams associated with sound objects, enabling dynamic audio manipulation during playback. Concrete use cases include streaming music files, applying real-time audio effects, and synchronizing audio with game events.",
      "description_length": 354,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Shader",
      "library": "raylib",
      "description": "This module manages GPU shaders by providing functions to create, access, and modify shader programs and their associated locations. It works with shader identifiers and arrays of shader location indices to configure shader parameters. Concrete use cases include setting up custom rendering effects, managing uniform variables in fragment and vertex shaders, and dynamically updating shader properties during runtime.",
      "description_length": 417,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Raylib.Texture",
      "library": "raylib",
      "description": "This module manages GPU texture resources with operations to create and query textures using OpenGL identifiers, dimensions, mipmap levels, and pixel formats. It works directly with texture objects containing metadata like width, height, and format. Concrete use cases include loading and managing 2D textures for rendering, handling texture parameters for shaders, and interfacing with rendering pipelines using raw OpenGL identifiers.",
      "description_length": 436,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Raylib",
      "library": "raylib",
      "description": "This module provides low-level operations for graphics rendering, input handling, audio management, and window control in game and multimedia applications. It works extensively with geometric types like `Vector2`, `Matrix`, and `Color`, resource types such as `Texture`, `Mesh`, and `Sound`, and input enums for keyboard, mouse, and gamepad interactions. Key use cases include 2D/3D shape drawing, shader and camera configuration, collision detection, image manipulation, and real-time input processing for desktop applications.",
      "description_length": 528,
      "index": 56,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 58,
    "meaningful_modules": 57,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9827586206896551
  },
  "statistics": {
    "max_description_length": 636,
    "min_description_length": 258,
    "avg_description_length": 389.5438596491228,
    "embedding_file_size_mb": 0.8265571594238281
  }
}