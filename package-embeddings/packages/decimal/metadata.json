{
  "package": "decimal",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 3,
  "creation_timestamp": "2025-07-15T23:04:39.301066",
  "modules": [
    {
      "module_path": "Decimal.Signal",
      "library": "decimal",
      "description": "This module manages signal states that influence the behavior of decimal arithmetic operations under exceptional conditions. It provides functions to create, query, and modify signal arrays, along with identifiers for specific signal types such as overflow, division by zero, and rounding events. These signals are used to track and control how decimal operations respond to edge cases like invalid input, loss of precision, or numerical limits.",
      "description_length": 445,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Decimal.Context",
      "library": "decimal",
      "description": "This module defines settings that control decimal arithmetic behavior, including precision, rounding modes, exponent limits, and handling of exceptional conditions. It works with decimal contexts to configure arithmetic operations, supporting precise control over calculations for applications like financial computations where exactness is critical. Functions allow creating, copying, and modifying contexts, as well as inspecting and formatting their settings.",
      "description_length": 462,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Decimal",
      "library": "decimal",
      "description": "This module provides precise decimal floating-point arithmetic with configurable precision and rounding, using the `t` type for decimal numbers and `Context.t` for controlling arithmetic behavior. It supports core operations like addition, multiplication, modulo, and square root, along with conversions to and from integers, floats, strings, and JSON, ensuring exact decimal behavior for financial and accounting applications. Submodules manage signal states for tracking arithmetic exceptions like overflow and division by zero, and define context settings to control precision, rounding modes, and exponent limits during calculations. For example, `Decimal.(of_string \"1.00\" mod of_string \"0.1\")` correctly returns `0.00`, and contexts can be configured to raise errors on rounding or clamp exponents within specified bounds.",
      "description_length": 828,
      "index": 2,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 3,
    "meaningful_modules": 3,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 828,
    "min_description_length": 445,
    "avg_description_length": 578.3333333333334,
    "embedding_file_size_mb": 0.01131439208984375
  }
}