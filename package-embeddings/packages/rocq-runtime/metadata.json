{
  "package": "rocq-runtime",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 1123,
  "creation_timestamp": "2025-08-19T11:25:44.380164",
  "modules": [
    {
      "module_path": "Perf",
      "library": "rocq-runtime.perf",
      "description": "Tracks CPU instruction counts with initialization, reading, and cleanup. Uses an internal counter state to measure executed instructions. Useful for performance profiling or benchmarking code sections by measuring instruction counts between start and end points.",
      "description_length": 262,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rtauto_plugin.Proof_search",
      "library": "rtauto_plugin",
      "description": "This module implements a proof search algorithm for intuitionistic propositional logic. It manipulates logical formulas composed of atoms, arrows, conjunctions, disjunctions, and falsity, and constructs proofs using natural deduction rules. The core operations include state initialization, proof projection, branching search, and success checking, with concrete use cases in automated theorem proving and logic verification tasks.",
      "description_length": 431,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rtauto_plugin.Refl_tauto",
      "library": "rtauto_plugin",
      "description": "This module implements a reflexive tautology checker for Coq's proof engine. It translates logical formulas into an internal representation using a context of atoms, then applies a decision procedure to automatically prove tautologies. Key operations include converting hypotheses into a normalized form, managing atom environments, and executing the `rtauto` tactic to solve goals involving propositional logic.",
      "description_length": 412,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rtauto_plugin",
      "library": "rtauto_plugin",
      "description": "This module provides algorithms for automated reasoning in intuitionistic propositional logic. It handles logical formulas built from atoms, implication, conjunction, disjunction, and falsity, using natural deduction rules to construct proofs. It supports tasks like theorem proving and logic verification through a dedicated tactic that solves propositional goals.",
      "description_length": 365,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Number_string_notation_plugin.G_number_string",
      "library": "number_string_notation_plugin",
      "description": "This module defines Coq's vernacular argument types and entries for parsing number-string notations, including mappings, modifiers, and options. It works with qualified identifiers, boolean flags, and custom types for number-string conversion strategies. Concrete use cases include declaring custom number notations with associated string representations and parsing options in Coq's syntax extensions.",
      "description_length": 402,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Number_string_notation_plugin.Number_string",
      "library": "number_string_notation_plugin",
      "description": "This module defines and registers number and string notations with custom parsing and printing behavior, using qualified identifiers and scoped options. It supports associating notations via transformation functions and handling optional parameters for notation processing. Concrete use cases include extending the syntax for numeric and string literals in Coq's vernacular language with user-defined representations and scopes.",
      "description_length": 428,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Number_string_notation_plugin",
      "library": "number_string_notation_plugin",
      "description": "This module implements Coq's number-string notation system, handling the declaration and registration of custom numeric and string literal syntax with support for scoped parsing, transformation functions, and optional parameters. It operates on qualified identifiers, boolean flags, and strategy-specific types to enable syntax extensions such as user-defined number formats and string representations in Coq's vernacular.",
      "description_length": 422,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cc_plugin",
      "library": "cc_plugin",
      "description": "Implements congruence closure algorithms over graph structures, providing functions to merge nodes, track equivalences, and check consistency. Operates on directed acyclic graphs (DAGs) with labeled edges, supporting efficient equality reasoning. Useful in symbolic execution and program analysis for maintaining equivalence relations among expressions.",
      "description_length": 353,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coqargs",
      "library": "rocq-runtime.coqargs",
      "description": "This module supports parsing, validation, and management of command-line arguments and configuration settings. It operates on data such as file paths, compiler flags, logical options, and numeric values through conversion functions and error reporting utilities. Commonly used in initialization workflows to process user inputs, enforce valid parameters, and handle missing or malformed arguments.",
      "description_length": 397,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrview.AdaptorDb",
      "library": "ssreflect_plugin",
      "description": "This module manages a database of global Coq terms associated with different directional kinds, supporting retrieval and registration of these terms. It works with the `kind` type, which classifies entries as forward, backward, or equivalence views, and lists of `glob_constr` terms. It is used to store and access term-level adapters for view-based rewriting in proof scripts.",
      "description_length": 377,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrcommon.MakeState",
      "library": "ssreflect_plugin",
      "description": "This module provides tactics for manipulating a state within a proof view, specifically allowing retrieval, setting, and updating of the state through functions like `tclGET`, `tclSET`, and `tacUPDATE`. It works with the `S.state` type defined in the parameter module `S`, and interacts with the `Proofview` monad for tactic execution. Concrete use cases include managing per-proof state in Coq tactics, such as tracking progress or maintaining context during interactive theorem proving.",
      "description_length": 488,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrparser.Internal",
      "library": "ssreflect_plugin",
      "description": "This module provides functions for parsing and manipulating proof scripts in a tactic language, focusing on operations like registering tactics, handling introduction patterns, and binding forward hints. It works with data types such as tactic expressions, introduction patterns, binder formats, and closure terms, primarily used in proof automation and goal manipulation. Concrete use cases include processing intros commands, formatting and printing proof state components, and managing hint-based tactic application during interactive theorem proving.",
      "description_length": 554,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssripats.Internal",
      "library": "ssreflect_plugin",
      "description": "This module provides low-level operations for manipulating and analyzing proof terms during tactic execution. It includes functions for examining abstracted proof terms and retrieving evar identifiers associated with specific proof components. These operations are critical for implementing advanced proof automation and term introspection in interactive theorem proving.",
      "description_length": 371,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ssreflect_plugin.Ssrfwd",
      "library": "ssreflect_plugin",
      "description": "This module implements tactics for structured proof scripting, including forward reasoning, hypothesis management, and subgoal manipulation. It operates on proof terms and Coq's tactic state, using data types like identifiers, patterns, and closure terms. Concrete use cases include asserting intermediate goals, performing conditional rewritings, and introducing and manipulating hypotheses in a structured manner.",
      "description_length": 415,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ssreflect_plugin.Ssrtacs",
      "library": "ssreflect_plugin",
      "description": "This module provides utilities for defining and manipulating tactic arguments in the SSReflect language, focusing on parsing and interpreting constructs like rewrite rules, case analysis patterns, and clause transformations. It operates on generalized argument types (`Genarg`) that represent terms, patterns, and binder information, including specialized variants for handling optional or non-empty rewrite rules, bracket-enclosed patterns, and occurrence specifications. These components enable precise control over tactic behavior in Coq proofs, such as managing rewrite directions, structuring case splits, and applying lemmas with custom argument parsing.",
      "description_length": 660,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ssreflect_plugin.Ssrvernac",
      "library": "ssreflect_plugin",
      "description": "This module defines generalized argument types for handling Coq expressions and view positions in the context of the Ssreflect proof language. It provides `wit_ssrhintref` for constraint expressions and `wit_ssrviewpos`/`wit_ssrviewposspc` for managing tactic view positions with optional kind annotations. These are used internally to support parsing and execution of Ssreflect tactics involving constraints and view-based reasoning.",
      "description_length": 434,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrtacticals",
      "library": "ssreflect_plugin",
      "description": "This module implements tactics for structured proof scripting, including sequence and clause handling, with support for pattern matching and hint application. It operates on Coq's tactic state, using data types like `interp_sign`, `ssrdir`, `ssrhyps`, and `cpattern` to manage proof contexts and term manipulation. Concrete use cases include building complex proof scripts with tacticals like `tclSEQAT` for applying tactics at specific positions, or `tclCLAUSES` for case analysis with structured clauses.",
      "description_length": 506,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrprinters",
      "library": "ssreflect_plugin",
      "description": "This module offers utilities for rendering Ssreflect tactic language components into human-readable formats, focusing on structured output for terms, patterns, hypotheses, and control structures like blocks and simplification rules. It operates on abstract syntax trees (ASTs) from the Ssreflect plugin, producing Coq's `Pp.t`-typed output to integrate with proof environment displays. Specific functions like `pr_occ` format occurrence data for clarity, while `debug_ssr` supports tracing plugin internals, aiding tasks like debugging proof scripts or inspecting tactic behavior during development.",
      "description_length": 599,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrbwd",
      "library": "ssreflect_plugin",
      "description": "Performs backward reasoning in proofs by applying tactics to the current goal. Works with proof terms, tactic expressions, and goal contexts represented in the Ssrast module. Used to implement custom proof automation strategies in Coq by applying user-defined tactics to specific parts of a proof state.",
      "description_length": 303,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrparser",
      "library": "ssreflect_plugin",
      "description": "The module enables parsing and processing of SSReflect tactics and patterns, emphasizing introspection, rewriting, and structured hypothesis manipulation. It works with Coq tactic expressions, pattern-matching constructs, and SSReflect-specific data structures like `ssripats` and `ssrterms`, supporting proof automation tasks such as goal transformation, binder handling, and hint-driven simplification.",
      "description_length": 404,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ssreflect_plugin.Ssripats",
      "library": "ssreflect_plugin",
      "description": "This module processes and manipulates proof patterns used in interactive theorem proving, supporting operations such as variable abstraction, case analysis, rewriting, and hypothesis clearing. It works with identifiers, proof terms, and structured blocks of operations to enable precise control over proof state transformations. Concrete use cases include implementing custom tactics for proof automation, restructuring proof goals, and managing hypotheses during case analysis or rewriting steps.",
      "description_length": 497,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrequality",
      "library": "ssreflect_plugin",
      "description": "This module implements tactics for equality-based rewriting and simplification in proof scripts. It processes rewrite rules with directional and occurrence constraints, supporting operations like `rewrite`, `unlock`, and congruence application. Key data types include `ssrrule` for specifying rewrite kinds and terms, and `ssrrwarg` for structured rewrite arguments with patterns and clear instructions. It directly handles proof terms and environments to apply reductions and transformations during tactic execution.",
      "description_length": 517,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrelim",
      "library": "ssreflect_plugin",
      "description": "This module implements tactics for elimination and case analysis in proof scripts, handling operations like `ssrelim`, `elimitac`, and `casetac` that manipulate hypotheses and goals using patterns and occurrences. It works with data types such as `elim_what`, `constr`, `ssrhyp`, and `ssripat`, primarily dealing with Coq's proof state and term structures. Concrete use cases include performing injections, destructing hypotheses, and applying elimination rules based on matching patterns in the current goal or assumptions.",
      "description_length": 524,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrcommon",
      "library": "ssreflect_plugin",
      "description": "This module enables the manipulation of Coq proof terms, environments, and hypotheses through operations on types like `EConstr.t`, `Environ.env`, and `Evd.evar_map`. It provides functionality for constructing terms (lambdas, applications), managing identifiers and metavariables, and applying tactics such as rewriting, conversion, and hypothesis clearing. These tools are used in SSReflect to implement proof automation, manage proof state, and develop custom tactics for term manipulation and context transformations.",
      "description_length": 520,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrast",
      "library": "ssreflect_plugin",
      "description": "This module defines abstract syntax tree (AST) types for the SSReflect tactic language, encompassing identifiers, patterns, terms, and structures for hypotheses, rewriting directions, and simplification controls. It provides data structures like options, lists, and identifier-pattern combinations to represent tactic expressions, goal manipulations, and clause targeting in proof scripts. These components support parsing, introspection, and term generation for interactive theorem proving in Coq.",
      "description_length": 498,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrview",
      "library": "ssreflect_plugin",
      "description": "This module provides tactics for applying view-based rewriting in proof scripts, using registered global Coq terms classified by directionality. It supports operations to apply views to a subject term or the conclusion, handling both forward and backward transformations. The module works with `glob_constr` terms, `ast_closure_term` lists, and `EConstr.t`, enabling precise term manipulation during tactic execution.",
      "description_length": 417,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin",
      "library": "ssreflect_plugin",
      "description": "This module provides functionalities for parsing, manipulating, and executing SSReflect tactics within Coq's proof environment. It handles data structures such as tactic expressions, proof terms, identifiers, patterns, and clause specifications to support operations like rewriting, case analysis, hypothesis manipulation, and goal transformations. Concrete use cases include implementing custom proof automation, structuring interactive proof scripts, and performing precise term transformations during theorem proving.",
      "description_length": 520,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn.Val.Map",
      "library": "ltac2_plugin",
      "description": "This module implements a type-safe map from type tags to values parameterized by the tag type, supporting operations like insertion, lookup, modification, and iteration. It works with dynamically typed values indexed by keys representing Coq's Ltac2 type tags, where each key-value pair is existentially packaged to preserve type information. Concrete use cases include managing dynamic tactic arguments and maintaining typed state across tactic invocations in Coq's proof engine.",
      "description_length": 480,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn.Val.HMap",
      "library": "ltac2_plugin",
      "description": "This module provides operations to transform and filter typed maps of dynamic values using user-defined strategies. It works with maps indexed by type tags, where values are parameterized by two distinct type representations (V1 and V2). Concrete use cases include adapting or selectively processing Ltac2 values during tactic execution based on their inferred types.",
      "description_length": 367,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2typing_env.TVar.Map",
      "library": "ltac2_plugin",
      "description": "This module implements a map structure with keys of type `TVar.t` and polymorphic values, supporting operations like insertion, deletion, lookup, and traversal. It provides both imperative-style modifications (add, remove, update) and functional transformations (fold, filter, partition) with optional return types for safe value handling. Such maps are useful for managing variable bindings or typed environments in formal systems where keys represent logical variables or type parameters.",
      "description_length": 490,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn.Val.Easy",
      "library": "ltac2_plugin",
      "description": "This module provides functions to inject and project typed values into a dynamic representation, enabling safe type conversions and runtime type tagging. It works with abstract values of type `t` and type-specific tags, supporting operations like `inj` for wrapping values with their type and `prj` for extracting them. Concrete use cases include handling heterogeneous data in Ltac2 tactics, where values of different types need to be stored and retrieved dynamically while preserving type safety.",
      "description_length": 498,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2val.Valexpr",
      "library": "ltac2_plugin",
      "description": "This module provides operations for constructing and inspecting values used in tactic expressions, primarily working with the `valexpr` type. It supports creating block and integer values, checking if a value is an integer, accessing and modifying fields of block values, and retrieving the tag of a value. These operations are used to manipulate intermediate values during tactic evaluation and compilation.",
      "description_length": 408,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2core.Core",
      "library": "ltac2_plugin",
      "description": "This module defines fundamental type constants and constructors for the Ltac2 tactic language, including basic types like unit, int, string, list, array, and option, along with their corresponding value and constructor expressions. It provides the core building blocks for representing and manipulating Ltac2 terms and values within Coq's tactic system. These elements are used directly in the implementation of Ltac2 tactics to construct and deconstruct expressions and values during proof automation.",
      "description_length": 502,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn.Val",
      "library": "ltac2_plugin",
      "description": "This module represents dynamic values with type tags for Coq's Ltac2 tactics, supporting operations to create, compare, and inspect tags by name. It works with existentially typed values and boxed tags, enabling type-safe storage and retrieval of heterogeneous data. Concrete use cases include managing dynamic tactic arguments and preserving type information across tactic executions.",
      "description_length": 385,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2typing_env.TVar",
      "library": "ltac2_plugin",
      "description": "This module defines a type `t` representing logical variables and an equality function for comparing them. It includes a `Map` submodule that implements a map structure keyed by these variables, supporting standard operations like insertion, deletion, lookup, and traversal. The module is used to manage variable bindings in type environments or logical contexts where precise variable identity and mapping are essential.",
      "description_length": 421,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2expr.PartialPat",
      "library": "ltac2_plugin",
      "description": "This module defines a type `r` for representing partial patterns in Ltac2, used during tactic elaboration. It supports operations like variable binding (`Var`), atomic values (`Atom`), constructor applications (`Ref`), disjunctions (`Or`), and pattern annotations (`As`). These structures are used to match and deconstruct terms in custom Ltac2 tactics, enabling precise control over proof term manipulation.",
      "description_length": 408,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn.Arg",
      "library": "ltac2_plugin",
      "description": "This module defines and manipulates dynamic argument tags used in the Ltac2 abstract syntax tree. It provides operations to create unique argument tags, compare them for equality, and retrieve their string representation. A concrete use case is enabling type-safe handling of dynamically typed arguments within Ltac2 tactics during proof script execution.",
      "description_length": 355,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2entries.Pltac",
      "library": "ltac2_plugin",
      "description": "This module provides parsing and construction utilities for Ltac2 tactic expressions that manipulate proof states, such as relocating goals, introducing variables or hypotheses, and building assertions. It operates on Coq's abstract syntax trees (wrapped with `CAst.t`), identifiers (`Names.Id.t`), and Ltac2-specific types like `raw_tacexpr`, enabling seamless embedding of Ltac2 code within Coq's syntax and supporting tactic entry points for proof automation tasks.",
      "description_length": 468,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn.ArgMap",
      "library": "ltac2_plugin",
      "description": "This module implements a map for dynamic tactic arguments, supporting operations to add, remove, and retrieve packed values associated with typed tags. It works with a polymorphic map type `t` and tagged pairs of raw and global values. It is used to manage dynamic argument storage in Ltac2 tactics, where each argument is identified by a type-safe tag.",
      "description_length": 353,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2print",
      "library": "ltac2_plugin",
      "description": "This module facilitates the conversion of Ltac2 abstract syntax trees into human-readable text, handling identifier formatting, type/expression-level rendering, and customizable output via registered printers for specific types. It processes structured format descriptions\u2014parsed from raw string specifiers\u2014to control output layout, working with name environments and syntax trees to support use cases like pretty-printing tactics or debugging. The combination of AST traversal utilities and flexible formatting enables precise control over code representation in scenarios such as error reporting or interactive displays.",
      "description_length": 622,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2expr",
      "library": "ltac2_plugin",
      "description": "This module defines types for Ltac2's core language constructs, enabling operations like type abstraction, algebraic data type definitions, and pattern matching over tactic expressions. It works with structured representations of tactic terms, execution contexts (e.g., `frame`, `backtrace`), and type definitions (e.g., constructors, type schemes), while supporting term deconstruction and tactic composition. These components facilitate tasks like proof automation, error handling in tactic execution, and manipulating Coq terms through typed patterns and expressions.",
      "description_length": 570,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2env",
      "library": "ltac2_plugin",
      "description": "This module centers on operations for defining and managing Ltac2 tactics, types, constructors, and notations within Coq's global environment, with support for compilation, deprecation tracking, and qualified identifier resolution. It works with Ltac2 expressions, semantic metadata, and Coq-specific structures like `tacref` and `ltac_projection`, enabling use cases such as tactic visibility control, symbol registration, and integration with Coq's internal types and ML modules. Key patterns include name resolution, path conversion, and variable quotation handling for Gallina terms.",
      "description_length": 587,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2tactics",
      "library": "ltac2_plugin",
      "description": "This module provides tactics for structured proof transformation, including hypothesis manipulation, lemma application, induction, rewriting, and intermediate goal assertion, alongside reduction operations like `cbv` and `cbn` for term normalization. It works with Coq's proof terms (`EConstr.constr`), tactic states (`Proofview.tactic`), and hint databases to automate reasoning tasks such as congruence closure, unification, and hint-driven proof search. These tools are used for interactive proof scripting, simplifying terms during proofs, and automating equality goals or repetitive logical steps.",
      "description_length": 602,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2bt",
      "library": "ltac2_plugin",
      "description": "This module manages backtraces for Ltac2 tactics, providing operations to capture, retrieve, and print backtrace information during tactic execution. It works with Ltac2 expressions and proof views, allowing tactics to be wrapped with backtrace frames and enabling customizable frame printing through hooks. Concrete use cases include debugging tactic failures by inspecting the Ltac2 call stack and selectively displaying backtrace details based on user configuration.",
      "description_length": 469,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2intern",
      "library": "ltac2_plugin",
      "description": "This module provides utilities for type-checking, substituting, and resolving global identifiers in Ltac2 expressions, working with abstract syntax trees (`raw_tacexpr`, `glb_tacexpr`), type schemes, and substitution environments. It ensures type safety through inference and subtyping checks, handles variable substitution in both expressions and types, and manages global identifier resolution during tactic execution. Specific use cases include validating tactic definitions, isolating environments via cleanup operations like `drop_ltac2_env`, and supporting type-level computations during tactic synthesis.",
      "description_length": 611,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn",
      "library": "ltac2_plugin",
      "description": "This module handles dynamic arguments for Ltac2 tactics, providing type-safe creation, storage, and retrieval of heterogeneous values during proof execution. It works with tagged dynamic values and polymorphic maps to associate typed data with unique identifiers. Concrete use cases include passing and managing dynamically typed parameters within Ltac2 tactics while preserving type integrity across tactic invocations.",
      "description_length": 420,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2match",
      "library": "ltac2_plugin",
      "description": "This module implements the core logic for Ltac2's `match goal` construct, enabling pattern matching on proof goals and hypotheses. It works with proof environments, evar maps, and specialized pattern types to deconstruct and analyze goal structures. It is used to implement tactics that conditionally apply transformations based on the current proof state.",
      "description_length": 356,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2externals",
      "library": "ltac2_plugin",
      "description": "This module defines external tactics in Ltac2 by specifying their behavior and return types using high-level declarations. It supports defining both pure and monadic tactics that can accept arguments converted from Ltac2 values, with special variants to handle environment, evar map, or goal context. Concrete use cases include implementing custom proof automation tactics that interface directly with Coq's proof engine, such as tactic plugins that inspect or modify the proof state based on specific logical patterns.",
      "description_length": 519,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2val",
      "library": "ltac2_plugin",
      "description": "This module manipulates tactic expressions and closures during evaluation, primarily handling the `valexpr` type for representing structured and immediate values. It provides operations to construct and deconstruct values, apply closures to arguments, and manage arity during function application. Concrete use cases include compiling and evaluating Ltac2 tactics, handling closures with `apply` and `mk_closure`, and inspecting or modifying structured blocks.",
      "description_length": 460,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.G_ltac2",
      "library": "ltac2_plugin",
      "description": "This module provides parsing and syntactic manipulation capabilities for Ltac2 constructs, focusing on token sequence recognition (e.g., parentheses, identifiers) and abstract syntax tree transformations. It operates on Ltac2 expressions, types, definitions, and tactic modes, enabling seamless integration of Ltac2 code within Coq's vernacular language. Specific applications include parsing raw Ltac2 expressions, validating syntax atoms, and embedding tactic definitions into Coq's proof scripting environment.",
      "description_length": 513,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2core",
      "library": "ltac2_plugin",
      "description": "This module implements core tactic primitives and type representations for Ltac2, supporting operations like exception throwing with `throw`, tactic application with `pf_apply`, and handling of polymorphic maps and sets through typed tags. It works with fundamental data types such as integers, strings, identifiers, inductive types, constructors, and constants, along with structured collections like maps and sets indexed by these types. Concrete use cases include building and manipulating Ltac2 expressions, implementing custom tactic combinators, and registering and working with domain-specific map and set types during proof automation.",
      "description_length": 643,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2typing_env",
      "library": "ltac2_plugin",
      "description": "This environment management system provides operations for variable binding, type unification, and expression normalization, working with generalized type representations and mixed-variable contexts. It maintains type consistency through substitution, abstraction, and inference mechanisms, supporting complex type manipulation in tactic development. These capabilities directly enable type-safe logical reasoning and tactic composition in proof assistant frameworks.",
      "description_length": 467,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2entries",
      "library": "ltac2_plugin",
      "description": "This module supports defining, registering, and evaluating Ltac2 tactics, types, and notations within Coq's plugin system, including mechanisms for parsing tactic expressions and managing scope interpretations. It operates on Coq abstract syntax trees (`CAst.t`), identifiers (`Names.Id.t`), and Ltac2-specific types like `raw_tacexpr`, with submodules handling proof state manipulations such as goal relocation and variable introduction. This enables use cases like building automated proof tactics, implementing custom evaluation strategies, and integrating domain-specific notations into Coq's tactic language.",
      "description_length": 613,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2types",
      "library": "ltac2_plugin",
      "description": "This module redefines Ltac1 data structures to resolve compatibility issues between Ltac1 and Ltac2. It introduces types for hypotheses, bindings, occurrences, and tactics used in proof manipulation, such as `quantified_hypothesis`, `constr_with_bindings`, and `destruction_arg`. These types support concrete operations like hypothesis elimination, term rewriting, and induction clause handling during tactic execution.",
      "description_length": 419,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2ffi",
      "library": "ltac2_plugin",
      "description": "This module provides bidirectional serialization and deserialization operations between OCaml values and Ltac2's dynamic value system, primarily handling primitive types, structured data (tuples, lists, closures), and Coq-specific types like terms, identifiers, and exceptions. It enables safe, typed interoperability through marshaling functions that map OCaml data structures to Ltac2's `valexpr` representations and vice versa, using intermediate `repr` types to define encoding logic. Specific use cases include embedding Coq's internal data (e.g., `EConstr.t`, `Pattern.constr_pattern`) into Ltac2 expressions and handling foreign function interface (FFI) conversions for tactic development.",
      "description_length": 696,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2interp",
      "library": "ltac2_plugin",
      "description": "This module evaluates Ltac2 expressions within a given environment, mapping identifiers to values and supporting operations like tactic execution and global value evaluation. It works with environments, Ltac2 expressions, and tactic values, enabling concrete tasks such as interpreting user-defined tactics or resolving global constants. Use cases include executing Ltac2 scripts during proof construction and binding Ltac2 variables to values in a tactic context.",
      "description_length": 464,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2quote",
      "library": "ltac2_plugin",
      "description": "The module enables syntactic quoting of Ltac2 expressions by constructing and manipulating abstract syntax trees (`raw_tacexpr`), supporting data like identifiers, integers, pairs, lists, tuples, and Ltac2-specific constructs such as intro patterns, clauses, and conversions. These functions transform syntactic elements\u2014including orientations, rewriting rules, and occurrences\u2014into tactic expressions, primarily for building notations and tactic quotations. They also handle term and preterm construction with identifiers, aiding in parsing and pretty-printing Ltac2 syntax.",
      "description_length": 575,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2stdlib",
      "library": "ltac2_plugin",
      "description": "This module provides direct access to standard tactics shared with Ltac1, specifically including the `intro_pattern` function for deconstructing hypotheses during proof scripting. It operates on Ltac2's internal representation of tactics and interacts with the proof engine to manipulate goals and assumptions. A concrete use case is writing custom tactics that integrate with Coq's standard proof automation, such as refining goals or introducing quantified variables and hypotheses.",
      "description_length": 484,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2extffi",
      "library": "ltac2_plugin",
      "description": "This module defines representations for handling quantified hypotheses, variable bindings, and constructions with associated bindings in the context of tactic definitions. It provides direct access to Coq's Ltac2 internal structures, enabling precise manipulation of proof terms and hypotheses during tactic execution. Concrete use cases include writing custom tactics that introspect or modify the proof context, such as automating hypothesis management or implementing domain-specific proof automation.",
      "description_length": 504,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2qexpr",
      "library": "ltac2_plugin",
      "description": "This module defines abstract syntax tree types for quoted Ltac2 expressions with anti-quotation support, enabling structured representation of tactic notations and scopes. It operates on Coq's internal syntax types like `constr_expr`, `raw_tacexpr`, and identifiers, modeling constructs such as hypothesis bindings, pattern matching, conversions, and assertion/pose expressions wrapped in `CAst.t`. These types facilitate embedding Ltac2 logic into quoted syntax, particularly for defining notation scopes that dynamically integrate tactic expressions with Coq's term and goal manipulations.",
      "description_length": 591,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin",
      "library": "ltac2_plugin",
      "description": "This module provides operations for defining, parsing, and executing tactics in a proof assistant, with capabilities for syntactic manipulation of expressions, type checking, and closure management. It works with Ltac2 expressions, tactic values, Coq terms, and identifiers, supporting structured transformations and dynamic evaluation. Key use cases include compiling and inspecting tactics, handling metaprogramming tasks, and integrating FFI conversions for proof automation.",
      "description_length": 478,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CMap.Make.Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized `map` and `mapi` functions that transform values in a map while attempting to preserve structural sharing to improve performance. It operates on map data structures where keys and values are immutable. These functions are useful when applying transformations to large maps where maintaining efficiency through shared structure is critical.",
      "description_length": 370,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Monad.Make.List",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic list operations including mapping, filtering, and folding with left-to-right or right-to-left traversal, handling effects at each step. It supports standard list transformations where each element computation is monadic, producing results in a wrapped type. Use cases include processing lists with side effects, accumulating state across elements, or building result lists from effectful element computations.",
      "description_length": 438,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CMap.Make.Monad",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic traversal and transformation operations over maps, including `fold`, `mapi`, `fold_left`, and `fold_right`, which apply functions across key-value pairs and accumulate results within a monadic context. It works with map structures where keys and values are processed with monadic actions defined by the parameter module `M`. Concrete use cases include building transformed maps with side-effecting operations, aggregating values under monadic constraints, and sequencing map-based computations that require error handling or state management.",
      "description_length": 571,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HMap.Make.Smart",
      "library": "rocq-runtime.clib",
      "description": "Implements hash maps with structural sharing preservation during mapping operations, optimized for keys with hashability. Provides `map` and `mapi` functions that transform values while attempting to reuse unchanged parts of the map. Useful when efficiently updating large maps with mostly identical elements, such as tracking incremental state changes in configuration or document models.",
      "description_length": 389,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HMap.Make.Monad",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic variants of standard hash map operations. It supports `fold` and `mapi` functions that work within an arbitrary monad `M`, enabling effectful computations during iteration and transformation. It operates on purely functional hash maps with arbitrary key and value types.",
      "description_length": 299,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.Set.List",
      "library": "rocq-runtime.clib",
      "description": "Performs set union operations on a list of `CString.Set.t` values, combining them into a single set. It works directly with lists of finite string sets. Useful for aggregating multiple string sets into one, such as collecting unique identifiers from separate groups.",
      "description_length": 266,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PolyMap.Make.Map",
      "library": "rocq-runtime.clib",
      "description": "This module implements a polymorphic map with operations to add, find, and modify values associated with typed tags. It supports efficient lookups and updates using first-class modules for type-safe value handling. Concrete use cases include managing configuration settings or state values indexed by unique, typed identifiers.",
      "description_length": 327,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSet.Make.List",
      "library": "rocq-runtime.clib",
      "description": "Performs union operations on a list of sets, combining all elements into a single set. Works with lists of elements that form sets, ensuring uniqueness in the result. Useful for aggregating multiple disjoint sets into one, such as merging results from parallel computations.",
      "description_length": 274,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CString.Map.Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized versions of `map` and `mapi` that attempt to preserve structural sharing when transforming values in a finite map over strings. It works directly with `CString.Map.t`, maintaining efficient operations for key-value transformations. These functions are useful when updating map values based on existing keys or values while minimizing unnecessary memory allocation.",
      "description_length": 395,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.Map.Monad",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic traversal and transformation operations over finite maps with string keys. It supports `fold`, `mapi`, `fold_left`, and `fold_right`, which apply functions across key-value pairs, enabling sequential computation and structure manipulation. These operations are useful for processing maps in a monadic context, such as accumulating results with error handling or state.",
      "description_length": 397,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dyn.Make.Map",
      "library": "rocq-runtime.clib",
      "description": "This module implements a type-safe map from type tags to values parameterized by the tag type, supporting operations like insertion, lookup, modification, and filtering. It works with dynamically typed values indexed by type-specific keys, enabling heterogeneous storage and transformation of values under a unified interface. Use cases include managing configuration settings with varying types, implementing extensible registries, and handling attribute-based data where type preservation is critical.",
      "description_length": 503,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dyn.Make.HMap",
      "library": "rocq-runtime.clib",
      "description": "This module transforms and filters maps with dynamically typed values using per-value-type functions. It operates on maps where keys are universally quantified over their type tags and values are boxed using modules V1 and V2. Concrete use cases include type-preserving map transformations and dynamic value filtering based on type-specific predicates.",
      "description_length": 352,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dyn.Make.Easy",
      "library": "rocq-runtime.clib",
      "description": "Creates dynamic type representations with injection and projection functions for arbitrary types. Provides `inj` and `prj` to wrap and unwrap values using type tags, enabling type-safe dynamic dispatch. Useful for implementing plugins or variant-like structures where types need to be manipulated heterogeneously.",
      "description_length": 313,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Int.Map.Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized `map` and `mapi` functions that operate on integer-keyed maps, preserving structural sharing during transformations. It works specifically with `Int.Map.t`, a standard map structure where keys are integers. These functions are useful when performing value transformations on large maps while minimizing memory allocation and maintaining performance.",
      "description_length": 380,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CArray.Fun1.Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized versions of array operations that avoid closure allocation by taking an additional environment argument directly. It works with arrays and functions that require an environment parameter alongside elements. Use it to efficiently map or transform arrays in performance-sensitive code paths where minimizing allocations is critical.",
      "description_length": 361,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Int.Map.Monad",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic traversal and transformation functions for integer-keyed maps, including `fold`, `mapi`, `fold_left`, and `fold_right`. It works with `Int.Map.t` structures, applying monadic operations to each key-value pair. Concrete use cases include accumulating results across a map with monadic effects or transforming map values while sequencing monadic actions.",
      "description_length": 381,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dyn.Make",
      "library": "rocq-runtime.clib",
      "description": "This module creates and manages dynamic type tags with operations for type registration, equality checking, and name-based lookup. It works with dynamically typed values encapsulated in existential types, supporting concrete use cases like heterogeneous data storage, plugin systems with type-safe injection/projection, and extensible registries keyed by type. Functions include tag creation, equality comparison, type naming, and introspection via dumping registered types.",
      "description_length": 474,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SList.Smart",
      "library": "rocq-runtime.clib",
      "description": "Performs transformations and stateful traversals over sparse lists, applying functions only to non-default elements. Works with sparse lists by skipping default values during iteration. Use to efficiently process or accumulate values in sparse data structures like sparse vectors or matrices.",
      "description_length": 292,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.Map",
      "library": "rocq-runtime.clib",
      "description": "This module implements associative map operations for string keys, including binding creation, lookup, insertion, deletion, and ordered queries like `min_binding` and `max_binding`, alongside structural transformations such as merging, filtering, and symmetric difference computation. It operates on finite maps with string keys (`CString.t`), leveraging optimized structural sharing for efficiency, and supports monadic folds (`fold_left_map`, `fold_right_map`) to accumulate state or transform values during traversal. Use cases include managing hierarchical configurations, processing string-indexed datasets with key-based queries, and implementing algorithms that require incremental map updates or stateful traversal of key-value pairs.",
      "description_length": 742,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Memprof_coq.Mutex_aux",
      "library": "rocq-runtime.clib",
      "description": "Handles mutual exclusion by executing a given function within a locked section, ensuring thread safety. Works with standard mutexes and arbitrary functions that perform critical operations. Useful for synchronizing access to shared resources in concurrent programs, such as updating a counter or modifying a shared data structure.",
      "description_length": 330,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Int.Set",
      "library": "rocq-runtime.clib",
      "description": "This module provides operations for managing ordered integer collections with uniqueness guarantees, supporting set algebra (union, intersection, difference), element manipulation (addition, removal, safe lookup), and ordered traversal via iterators, folds, and sequence conversions. It works with immutable sets of integers, lists, and sequences, emphasizing ordered processing and predicate-based filtering. Typical applications include efficient membership checks, sorted data aggregation, and transformations requiring stable iteration or bulk conversion between collection types.",
      "description_length": 584,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Store.Make",
      "library": "rocq-runtime.clib",
      "description": "This module creates a dynamic store type with operations to manage named fields. It supports creating fields, setting and getting typed values, removing fields, and merging stores. It works with a polymorphic field type and a store type that holds key-value pairs. Use cases include dynamic configuration management and runtime extensible data structures.",
      "description_length": 355,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Memprof_coq.Thread_map",
      "library": "rocq-runtime.clib",
      "description": "This module provides thread-local storage with scoped value binding, allowing values to be associated with individual threads during specific execution scopes. It supports creating empty maps, temporarily binding values to threads, and retrieving the current thread's bound value. Use cases include managing per-thread state in asynchronous applications, such as tracking request-specific data across function calls.",
      "description_length": 416,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CArray.Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized versions of common array transformations like `map`, `map2`, and combined fold-map operations, which avoid unnecessary array copies when the result is identical to the input. It works directly with OCaml arrays (`'a array`) and is useful in performance-sensitive contexts where in-place updates can be safely elided. Concrete use cases include efficient array processing where functions may leave elements unchanged, such as conditional in-place modifications or iterative algorithms that converge without altering the array.",
      "description_length": 556,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Predicate.Make",
      "library": "rocq-runtime.clib",
      "description": "Constructs infinite sets over an ordered type with operations including membership testing, set union, intersection, difference, and complement. It supports concrete use cases like representing mathematical sets, managing inclusion and exclusion rules, and defining constraints over ordered values. The module handles both finite and infinite sets, providing explicit element enumeration when possible.",
      "description_length": 402,
      "index": 85,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CString.Pred",
      "library": "rocq-runtime.clib",
      "description": "This module implements a set-like structure for character strings, supporting standard operations such as membership testing, union, intersection, and complement. It works with the type `CString.t` as elements and represents sets using predicates, allowing both finite and potentially infinite sets. Concrete use cases include efficiently managing inclusion and exclusion of string values in filters, access control checks, or configuration rules where exact string matches are required.",
      "description_length": 487,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Option.List",
      "library": "rocq-runtime.clib",
      "description": "This module extends list operations to work with `'a option` values, providing functions like `cons`, `flatten`, and `map` that handle optional values within lists. It operates on lists of `'a option` and returns standard `'a list` or `'a list option` results based on the operation. Use cases include safely constructing lists from optional values, extracting present values from a list of options, and mapping over a list while propagating failure if any element is `None`.",
      "description_length": 475,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hashcons.Make",
      "library": "rocq-runtime.clib",
      "description": "This module implements hash-consing for a given data type, using user-provided canonicalization functions. It allows creating a hash-consing table, performing hash-consed value insertion, and retrieving statistics on the table's usage. It is used for efficiently managing and deduplicating values of a structured type during symbolic processing or term rewriting.",
      "description_length": 363,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSet.Hashcons",
      "library": "rocq-runtime.clib",
      "description": "This module implements hash-consing for sets using a user-provided hashing function that must align with the set's comparison logic. It operates on set types defined by a module `M`, allowing for efficient sharing of structurally identical sets through a hash table. Use it when you need to canonicalize sets, such as in symbolic computation or when managing immutable set values with guaranteed uniqueness.",
      "description_length": 407,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.Set",
      "library": "rocq-runtime.clib",
      "description": "This module implements standard set-theoretic operations like union, intersection, and difference alongside transformations such as filtering, folding, and extremal element retrieval for finite collections of strings. It operates on sets of `CString.t` values, supports conversions from sequences, and includes specialized list aggregation functions to combine multiple sets efficiently. Typical applications include data deduplication, membership testing, and hierarchical set composition from sequential data sources.",
      "description_length": 519,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Memprof_coq.Masking",
      "library": "rocq-runtime.clib",
      "description": "Handles resource management by acquiring a resource, applying a scoped operation, and releasing the resource, ensuring proper cleanup. Works with any resource type `'a` that requires setup and teardown. Useful for managing external resources like file handles or network connections where allocation and deallocation must be carefully paired.",
      "description_length": 342,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unionfind.Make",
      "library": "rocq-runtime.clib",
      "description": "Implements an imperative Union-Find data structure with path compression and in-place partition updates. It supports element addition, equivalence class lookup via `find`, and merging classes using `union` or `union_set`. Designed for managing dynamic partitions of elements from a set, with concrete use cases like tracking connected components in graphs or grouping equivalent items in batch operations.",
      "description_length": 405,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hashset.Make",
      "library": "rocq-runtime.clib",
      "description": "This module implements a hash-consing set where elements are stored based on a user-provided hash key. It supports creating sets with a custom initial size, clearing existing sets, inserting or retrieving canonical elements using a precomputed hash key, and gathering statistics on set usage. Concrete use cases include interning values like expressions or symbols where hash keys are computed externally and efficient canonicalization is required.",
      "description_length": 448,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Diff2.Make",
      "library": "rocq-runtime.clib",
      "description": "Implements the O(ND) difference algorithm to compute diffs and longest common subsequences (LCS) between two sequences. Works with any sequence type through the parameter module, supporting element comparison via a customizable equality function. Useful for efficiently generating line-based diffs in text files or synchronizing data structures like lists and arrays.",
      "description_length": 367,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Int.PMap",
      "library": "rocq-runtime.clib",
      "description": "This module implements a map structure for integer keys with efficient access and iteration, optimized for contiguous or zero-starting keys using persistent arrays internally. It supports standard map operations like `add`, `find`, `remove`, and `fold`, along with set-based domain tracking and casting to a standard integer map. It is ideal for scenarios requiring fast lookups in dense integer key ranges, such as indexing arrays or managing compact integer-identified resources.",
      "description_length": 481,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.List",
      "library": "rocq-runtime.clib",
      "description": "This module implements association lists with string keys, providing operations to check equality, membership, and associations. It supports functions to retrieve values by key, remove key-value pairs, and check for membership in both standard and symmetric association list formats. Use cases include managing configuration settings, mapping identifiers to values, and handling key-based data retrieval in stateless contexts.",
      "description_length": 426,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HMap.Make",
      "library": "rocq-runtime.clib",
      "description": "This module provides operations for creating, modifying, and querying purely functional hash maps with keys of type `M.t` and arbitrary values, supporting efficient insertion, combination, and traversal over key-value pairs. It works with hash map structures (`'a t`) and interacts with a companion set module (`Set.t`) for key-centric operations, enabling use cases like structural sharing optimizations, monadic effect handling via `Monad`, and symmetric difference computations. Key features include hash-based lookups, higher-order transformations, and functions to manipulate map domains while avoiding order-dependent behaviors.",
      "description_length": 634,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Option.Smart",
      "library": "rocq-runtime.clib",
      "description": "Smart implements optimized variants of common option operations with a focus on memory efficiency. It provides functions like `map` that perform in-place updates when possible to reduce allocation. This module works directly with `'a option` types, making it ideal for scenarios where optional values are frequently transformed and memory usage needs to be minimized.",
      "description_length": 367,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Int.Map",
      "library": "rocq-runtime.clib",
      "description": "The module implements key-based functional manipulation and structural transformation of integer-keyed maps with polymorphic values, supporting efficient traversal, filtering, and combination operations alongside monadic state accumulation for processing bindings in specified orders. It facilitates use cases like ordered key-value management, conditional binding modification, and effectful iterative transformations requiring threaded state or side effects through dedicated folding and mapping constructs.",
      "description_length": 509,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CList.Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized list transformations that maximize physical sharing between input and output lists when possible. It includes `map`, `fold_left_map`, and `fold_right_map` functions that return results sharing suffixes with the input if the transformation leaves elements unchanged. These functions are useful for efficiently processing lists in scenarios where many elements may remain the same, reducing memory allocation and improving performance.",
      "description_length": 464,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSet.Make",
      "library": "rocq-runtime.clib",
      "description": "This module provides operations for constructing and manipulating ordered sets, including set-theoretic operations (union, intersection, difference), membership queries, and transformations like partitioning or element retrieval. It works with immutable sets parameterized over an ordered element type `M.t`, supporting conversions to and from lists and sequences, as well as bulk operations for merging disjoint sets. These capabilities are particularly useful for tasks like aggregating results from parallel computations, managing unique element collections, or implementing algorithms requiring efficient set-based data manipulation.",
      "description_length": 637,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Monad.Make",
      "library": "rocq-runtime.clib",
      "description": "Implements monadic operations including bind, map, and sequencing, working with a generic monadic type `'a t`. Provides combinators for chaining effectful computations and transforming values within the monad. Useful for handling asynchronous operations, stateful computations, or effectful list processing where each element depends on prior effects.",
      "description_length": 351,
      "index": 102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SList.Skip",
      "library": "rocq-runtime.clib",
      "description": "This module provides iteration, mapping, folding, and predicate checking operations that skip over default values in sparse lists. It works directly with sparse lists, applying functions only to explicitly set elements. Use it to process non-default elements efficiently, such as summing values, transforming entries, or validating conditions without traversing the entire structure.",
      "description_length": 383,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Int.List",
      "library": "rocq-runtime.clib",
      "description": "This module extends standard list operations specialized for integers, providing functions to check membership, retrieve associated values, test for associations, and remove key-value pairs from lists of integer-keyed tuples. It works with integer values and lists of integer-'a pairs. Use this module for efficiently managing key-value lists where keys are integers, such as mapping identifiers to data in configuration or lookup scenarios.",
      "description_length": 441,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Int.PArray",
      "library": "rocq-runtime.clib",
      "description": "This module implements a persistent array structure indexed by native integers, supporting efficient lookup and update operations. It allows creating arrays with a specified initial size, retrieving values by index with optional presence checks, and setting or unsetting values at specific indices to produce new array instances. It is suitable for scenarios requiring immutable integer-indexed collections with sparse or dynamic sizing, such as memoization tables or sparse matrices.",
      "description_length": 484,
      "index": 105,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CArray.Fun1",
      "library": "rocq-runtime.clib",
      "description": "This module provides higher-order versions of array operations like `map`, `iter`, and `iter2`, where function arguments take an additional environment parameter. It works with arrays of arbitrary types and functions that require an environment alongside elements. Use these functions to reduce closure allocations in performance-critical sections, such as tight loops or real-time processing pipelines.",
      "description_length": 403,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hashcons.Hstring",
      "library": "rocq-runtime.clib",
      "description": "This module hash-conses strings into a shared table, ensuring that equal strings share the same memory representation. It provides functions to generate a hash-consing table, perform hash-consing on strings, and retrieve table statistics. Use it when interning strings to reduce memory usage or optimize equality checks in compilers or data-processing pipelines.",
      "description_length": 362,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CMap.Make",
      "library": "rocq-runtime.clib",
      "description": "This module implements an ordered map abstraction with polymorphic keys and values, structured as balanced binary trees to ensure logarithmic time complexity for insertion, deletion, and lookup operations. It supports set-like key manipulations, value transformations via higher-order functions, and monadic workflows for composing stateful traversals while preserving structural sharing. Typical applications include efficient data aggregation, selective binding updates, and scenarios requiring both strong type guarantees and performance-optimized immutable state transitions.",
      "description_length": 579,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Memprof_coq.Resource_bind",
      "library": "rocq-runtime.clib",
      "description": "This module enables the `let&` binding operator for managing resources with automatic cleanup at the end of a scope. It works with functions that take a resource and produce a result, ensuring the resource is released after use. Concrete use cases include handling file handles, memory allocations, or network connections where deterministic cleanup is required.",
      "description_length": 362,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PolyMap.Make",
      "library": "rocq-runtime.clib",
      "description": "This module creates a polymorphic map structure that associates values with typed tags, supporting operations to add, find, and modify values based on these tags. It works with first-class modules and unique tags to ensure type-safe access and manipulation of stored values. Concrete use cases include managing application settings or runtime state where type-preserving keys are required.",
      "description_length": 389,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Heap.Functional",
      "library": "rocq-runtime.clib",
      "description": "Implements a purely functional max-heap structure where each operation returns a new heap instance. It supports efficient insertion (`add`), maximum retrieval (`maximum`), and maximum removal (`remove`), all in logarith time complexity. This module is ideal for scenarios requiring persistent heap states, such as priority queue implementations with immutable snapshots or backtracking algorithms needing previous heap versions.",
      "description_length": 428,
      "index": 111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hashset.Combine",
      "library": "rocq-runtime.clib",
      "description": "This module provides hash value combination functions that interleave hash key computations. It works with integers representing hash values, combining them into new integers to produce composite hash keys. These functions are used to implement efficient hash-consing strategies where multiple components contribute to a single hash value.",
      "description_length": 339,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hashcons.Hlist",
      "library": "rocq-runtime.clib",
      "description": "This module implements hash-consing for lists using a dedicated hash table, ensuring that structurally identical lists are represented by the same physical object. It provides functions to generate a hash-consing table, perform hash-consing on lists, and retrieve statistics about the table's usage. A concrete use case is optimizing memory usage and equality checks in symbolic computation or AST manipulation where many duplicate lists may arise.",
      "description_length": 448,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "OrderedType.UnorderedPair",
      "library": "rocq-runtime.clib",
      "description": "Represents pairs of values where order does not matter. Provides a comparison function to treat pairs like sets, ensuring (a, b) equals (b, a). Useful for graph edges, unique pairings, or symmetric relations.",
      "description_length": 208,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Trie.Make",
      "library": "rocq-runtime.clib",
      "description": "Implements a trie structure parameterized over label and data types, supporting operations to add, remove, and retrieve data at paths composed of label sequences. Works with labeled paths as lists of `Label.t` and associates them with values of type `Data.t`. Useful for prefix-based lookups, such as autocomplete systems or hierarchical data indexing.",
      "description_length": 352,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "OrderedType.Pair",
      "library": "rocq-runtime.clib",
      "description": "Defines a lexicographical ordering for pairs of values from two ordered types. Provides a `compare` function that compares first elements using `M.compare`, then `N.compare` for second elements if needed. Useful for sorting or comparing tuples where each component has a defined order, like coordinates or version numbers.",
      "description_length": 322,
      "index": 116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unicodetable",
      "library": "rocq-runtime.clib",
      "description": "This module provides operations for classifying Unicode characters into general categories (like letters, digits, punctuation) and performing case conversions. It works with data structures representing Unicode code point ranges as integer pairs, including mappings for uppercase-to-lowercase transformations using delta encoding. These capabilities are useful for text processing tasks requiring precise character property analysis or case normalization.",
      "description_length": 455,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HMap",
      "library": "rocq-runtime.clib",
      "description": "Implements purely functional hash maps with efficient insertion, lookup, and traversal over key-value pairs using a hashable key module. Supports operations like map, filter, union, and symmetric difference, working with map (`'a t`) and set (`Set.t`) structures for key-value and key-centric manipulations. Enables use cases such as caching with structural sharing, aggregating results with monadic effects, and diffing map states for synchronization tasks.",
      "description_length": 458,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hashset",
      "library": "rocq-runtime.clib",
      "description": "This module implements hash-consing sets with user-provided hash keys and provides utilities for combining hash values. It supports creating, clearing, and managing sets with custom hash functions, along with functions to interleave hash computations for composite keys. Use cases include interning expressions or symbols where hash keys are computed externally and efficient canonicalization is required.",
      "description_length": 405,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SList",
      "library": "rocq-runtime.clib",
      "description": "This module implements sparse lists with operations to construct, deconstruct, and manipulate lists containing optional values. It supports list-like operations such as length, equality, comparison, and conversion to and from standard option lists, while providing specialized traversal modules that skip default values or perform stateful processing. Use this to efficiently represent and operate on data with many missing or default values, such as sparse vectors or matrices.",
      "description_length": 478,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CEphemeron",
      "library": "rocq-runtime.clib",
      "description": "This module implements ephemeral keys for managing weak references to values of any type. It allows creating a key tied to a value, retrieving the value if still alive, or providing a default if reclaimed. Useful for caching systems where resources should be automatically released when no longer referenced.",
      "description_length": 308,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "OrderedType",
      "library": "rocq-runtime.clib",
      "description": "This module defines a signature for types that support a total ordering, primarily used to parameterize other modules requiring comparison operations. It includes a comparison function `compare` that returns values in the `Pervasives` style (-1, 0, +1). Commonly used in data structures like sets and maps to define key ordering.",
      "description_length": 329,
      "index": 122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Predicate",
      "library": "rocq-runtime.clib",
      "description": "This module implements infinite sets over an ordered type, supporting operations like membership testing, union, intersection, difference, and complement. It works with ordered data types, enabling precise set manipulations for mathematical sets, constraint systems, and inclusion-exclusion rule engines. Concrete use cases include symbolic computation, constraint solving, and representing ranges or intervals over ordered values.",
      "description_length": 431,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Exninfo",
      "library": "rocq-runtime.clib",
      "description": "This module enriches exceptions with additional metadata, including backtraces and custom typed information. It provides operations to attach, retrieve, and manipulate this data on exceptions, supporting precise error handling and debugging. Concrete use cases include capturing contextual error details during exception propagation and extracting backtrace strings for diagnostics.",
      "description_length": 382,
      "index": 124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Int",
      "library": "rocq-runtime.clib",
      "description": "This module defines core operations for native integer manipulation, including equality checks, comparison, and hashing. It provides specialized data structures and functions tailored for integers, such as sets, maps, lists, and persistent arrays. These support concrete use cases like efficient membership testing, ordered key-value management, and handling sparse or indexed collections.",
      "description_length": 389,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Trie",
      "library": "rocq-runtime.clib",
      "description": "Implements a generic trie structure parameterized over key types and group operations. Supports associative storage and retrieval of values using sequences of keys, with efficient prefix-based lookups and aggregations. Useful for autocomplete systems, dictionary implementations, and hierarchical key-value storage.",
      "description_length": 315,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unionfind",
      "library": "rocq-runtime.clib",
      "description": "Implements union-find data structures with path compression and in-place updates for efficient partition management. Operates on elements that can be compared using Pervasive's comparison, organizing them into disjoint sets. Useful for dynamic connectivity problems, such as tracking connected components in graphs or merging sets in type inference algorithms.",
      "description_length": 360,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString",
      "library": "rocq-runtime.clib",
      "description": "This module offers low-level string manipulation, binary parsing, and text transformation capabilities, focusing on operations like character indexing, substring extraction, UTF-encoding conversion, and endianness-aware integer decoding from byte sequences. It primarily works with built-in strings and characters, augmented by utility functions for hashing, case conversion, and semantic text formatting, alongside specialized modules for set/map abstractions over string keys. Typical applications include binary data parsing, internationalized text processing, and efficient string-centric data structure management in configuration systems or lexical analyzers.",
      "description_length": 665,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSig",
      "library": "rocq-runtime.clib",
      "description": "This module defines type classes for working with sets and maps in OCaml, including both unique and non-unique variants. It provides abstractions for set and map operations such as membership testing, insertion, deletion, and traversal. Concrete use cases include implementing custom set and map structures with specific comparison behaviors or extending existing data structures to conform to standard interfaces.",
      "description_length": 414,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CUnix",
      "library": "rocq-runtime.clib",
      "description": "This module handles path manipulation, file checks, and command execution. It provides functions for normalizing and transforming file paths, checking file readability, and running system commands with precise control over arguments. Use cases include safely constructing file paths, verifying file existence and equivalence, and executing external programs without shell interference.",
      "description_length": 385,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CList",
      "library": "rocq-runtime.clib",
      "description": "The module offers advanced list manipulation capabilities, including indexed transformations, multi-list folds, set-theoretic operations, and association list utilities, with support for custom predicates, equality checks, and physical equality. It operates primarily on polymorphic lists (`'a list`) and association lists, enabling efficient sorting, merging, slicing, and combinatorial operations like Cartesian products or unique element extraction. These functions cater to complex data processing pipelines, key-value pair management, and performance-critical scenarios requiring optimized transformations or lexicographic comparisons.",
      "description_length": 640,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NeList",
      "library": "rocq-runtime.clib",
      "description": "This module implements a non-empty list structure, providing operations to access the head and tail, apply functions to elements, and convert to and from standard lists. It supports data types like `'a NeList.t` internally represented as a head element followed by a list of remaining elements. Use cases include safely handling lists guaranteed to have at least one element, such as parsing results, user input validation, or initializing accumulators in computations.",
      "description_length": 469,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CMap",
      "library": "rocq-runtime.clib",
      "description": "Implements an ordered map abstraction with polymorphic keys and values stored in balanced binary trees, ensuring logarithmic time complexity for core operations. Supports key-based set-like manipulations, value transformations with higher-order functions, and monadic workflows for stateful traversals. Useful for efficient data aggregation, selective state updates, and type-safe immutable state transitions.",
      "description_length": 409,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Diff2",
      "library": "rocq-runtime.clib",
      "description": "Implements the O(ND) difference algorithm to compute diffs and longest common subsequences (LCS) between two sequences. Works with any sequence type through a parameter module, supporting element comparison via a customizable equality function. Useful for efficiently generating line-based diffs in text files or synchronizing data structures like lists and arrays.",
      "description_length": 365,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CObj",
      "library": "rocq-runtime.clib",
      "description": "This module measures the physical and logical sizes of OCaml values, including support for shared structure analysis. It operates on arbitrary OCaml values and uses paths (integer lists) to identify object occurrences in shared structures. Concrete use cases include memory profiling, detecting memory-heavy data structures, and analyzing object sharing in complex values.",
      "description_length": 372,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Heap",
      "library": "rocq-runtime.clib",
      "description": "The `Functional` submodule implements a purely functional max-heap with efficient insertion, maximum retrieval, and removal operations, all in logarithmic time. It works with ordered elements using a comparison function provided by the user. Concrete use cases include priority queues where immutability is desired and backtracking algorithms that require access to previous heap states.",
      "description_length": 387,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Terminal",
      "library": "rocq-runtime.clib",
      "description": "This module handles terminal styling operations, including creating, merging, and comparing styles with support for foreground and background colors, bold, italic, underline, and negative attributes. It works with ANSI escape sequences and file descriptors to apply styles to terminal output. Concrete use cases include formatting terminal output with colors and effects, parsing LS_COLORS environment variables, and resetting terminal attributes.",
      "description_length": 447,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unicode",
      "library": "rocq-runtime.clib",
      "description": "This module handles Unicode character classification, string validation, and transformation for identifiers. It provides functions to check character properties like letters or identifier validity, manipulate UTF-8 strings, and convert non-ASCII characters to escaped representations. Use cases include validating and normalizing Rocq identifiers, processing UTF-8 input, and ensuring ASCII compatibility in string outputs.",
      "description_length": 423,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PolyMap",
      "library": "rocq-runtime.clib",
      "description": "This module implements a polymorphic map that associates typed tags with values, enabling type-safe insertion, retrieval, and update operations. It works with first-class modules and uniquely typed keys to ensure type integrity across operations. It is useful for managing heterogeneous application state or configuration where type-preserving keys are necessary.",
      "description_length": 363,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Option",
      "library": "rocq-runtime.clib",
      "description": "This module provides a suite of operations for OCaml's `'a option` type, mirroring list idioms like `map`, `fold`, and `bind` to treat optional values as lists with at most one element. It supports safe value extraction, transformation through catamorphisms and default handling, and efficient processing of optional data sequences, with specialized submodules addressing memory optimization and list-of-options manipulation. These capabilities are particularly valuable in domains like data parsing, error handling, and functional pipelines where optional values must be composed or unwrapped reliably.",
      "description_length": 603,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Segmenttree",
      "library": "rocq-runtime.clib",
      "description": "This module implements a segment tree data structure that maps ranges of integers to values. It provides operations to construct a tree from a list of sorted, non-overlapping intervals and to query the value associated with a specific integer key. It is useful for efficiently resolving interval-based mappings, such as assigning properties to ranges of indices or time intervals.",
      "description_length": 380,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Store",
      "library": "rocq-runtime.clib",
      "description": "This module defines a polymorphic store with operations to add, retrieve, and remove values by key. It works with key-value pairs where keys are hashable and values can be of any type. Concrete use cases include caching results of expensive computations and managing state in a key-based lookup system.",
      "description_length": 302,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Memprof_coq",
      "library": "rocq-runtime.clib",
      "description": "This module implements resource management, thread-local state, and concurrency primitives. It provides scoped resource binding with automatic cleanup, thread-scoped value storage, and safe mutex locking. Use cases include handling file descriptors, managing per-thread context in servers, and synchronizing shared state in multi-threaded programs.",
      "description_length": 348,
      "index": 143,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CThread",
      "library": "rocq-runtime.clib",
      "description": "This module enables thread-safe input operations and thread management. It provides functions to wrap input channels for safe concurrent reading, read values and bytes from threads, and create threads with a given function and argument. It also includes utilities for executing code within a locked scope using a mutex. Concrete use cases include coordinating access to shared resources like network sockets or log files while ensuring safe I/O operations across multiple threads.",
      "description_length": 480,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dyn",
      "library": "rocq-runtime.clib",
      "description": "This module handles dynamically typed values with operations for creating, manipulating, and converting values while preserving type safety. It works with abstract data types representing dynamic values, maps, and typed interfaces. Concrete use cases include handling heterogeneous data structures, implementing generic serialization, and supporting plugins or extensions with runtime type checking.",
      "description_length": 399,
      "index": 145,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Monad",
      "library": "rocq-runtime.clib",
      "description": "Implements monadic operations like bind, map, and sequencing for a generic monadic type `'a t`. Provides combinators to chain and transform effectful computations, supporting use cases such as asynchronous workflows, stateful processing, and effect-dependent list operations.",
      "description_length": 275,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hashcons",
      "library": "rocq-runtime.clib",
      "description": "This module implements hash-consing for structured data types, providing functions to create and manage hash-consing tables, insert values, and retrieve usage statistics. It works with arbitrary structured types like strings and lists, ensuring that equal values share the same representation to optimize memory and equality checks. Concrete use cases include interning strings in compilers and deduplicating lists in symbolic computation or AST manipulation.",
      "description_length": 459,
      "index": 147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mutex_aux",
      "library": "rocq-runtime.clib",
      "description": "Handles exclusive access to shared resources by acquiring and releasing a mutex lock around a given operation. Works with `Stdlib.Mutex.t` locks and executes a scoped function while the lock is held. Useful for ensuring thread-safe execution of critical sections in concurrent programs.",
      "description_length": 286,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSet",
      "library": "rocq-runtime.clib",
      "description": "This module implements immutable ordered sets with operations like union, intersection, difference, and membership checks. It works with elements of a fixed ordered type, allowing set manipulation and conversion to and from lists and sequences. It is useful for tasks like merging results from parallel computations, maintaining unique collections, and implementing algorithms that rely on efficient set operations.",
      "description_length": 415,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Range",
      "library": "rocq-runtime.clib",
      "description": "This module implements skewed binary lists, enabling efficient O(log n) indexed access while maintaining O(1) cons and head/tail operations. It supports standard list transformations like map and fold, along with precise index-based retrieval and traversal. Use it when fast prepend and indexed lookup are required, such as in performance-sensitive parsing or sequence processing tasks.",
      "description_length": 386,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IStream",
      "library": "rocq-runtime.clib",
      "description": "This module implements purely functional streams that preserve elements after access, supporting operations like `cons`, `peek`, and `map_filter` for non-destructive stream manipulation. It works with lazy, potentially infinite sequences of values through constructors like `thunk` and conversion functions such as `of_list` and `to_list`. Concrete use cases include parsing input incrementally, generating infinite sequences with controlled evaluation, and processing data streams without mutation.",
      "description_length": 499,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Derive_plugin.Derive",
      "library": "derive_plugin",
      "description": "Starts a proof for a given constraint involving a to-be-defined function `f`, initializing `f` as a placeholder and allowing the user to interactively derive its definition. It takes attributes, binders, a constraint expression, and a lemma name, producing a proof context that, when completed, defines both the function and its correctness proof. This supports interactive development of functions alongside their correctness proofs in a structured manner.",
      "description_length": 457,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Derive_plugin",
      "library": "derive_plugin",
      "description": "Implements interactive proof-driven function derivation, initializing undefined functions as placeholders and generating proof contexts for constraints. Works with logical expressions, binders, and lemmas to define functions alongside their correctness proofs during development. Enables step-by-step refinement of function definitions within ongoing proofs.",
      "description_length": 358,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vcs.Make.Dag.Property",
      "library": "rocq-runtime.stm",
      "description": "This module provides operations to compare, convert to string, and access the data and node set of a property value. It works with property values that are parameterized by a data type `'d` and associated with a set of DAG nodes. Concrete use cases include inspecting and validating properties attached to nodes in a version control system's DAG, such as tracking metadata or annotations across different commits.",
      "description_length": 413,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vcs.Make.Dag.NodeSet",
      "library": "rocq-runtime.stm",
      "description": "This module implements an immutable set data structure for elements of type `OT.t`, ordered via `OT.compare`, supporting standard operations like union, intersection, difference, and element queries. It provides efficient transformations (iteration, mapping, filtering), ordered traversal (via sequences and lists), and set construction from sequences, all preserving internal ordering. It is particularly suited for managing collections of DAG nodes in version control systems, enabling tasks like dependency resolution, branch merging, and incremental state comparisons.",
      "description_length": 572,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dag.Make.Property",
      "library": "rocq-runtime.stm",
      "description": "This module provides operations to compare, convert to string, and access data from property values associated with a directed acyclic graph (DAG) node. It works with property values parameterized by a data type `'d` and supports extracting the underlying data and identifying nodes that have a specific property. Concrete use cases include analyzing node properties in a DAG, such as checking equality of properties, enumerating nodes with a given property, or generating string representations for debugging.",
      "description_length": 510,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vcs.Make.Dag",
      "library": "rocq-runtime.stm",
      "description": "This module implements a directed acyclic graph (DAG) structure where nodes are of type `OT.t`, edges carry values of type `'e`, nodes can have associated information of type `'i`, and properties parameterized by `'d` can be attached to nodes. It supports creating and modifying graphs through adding or removing edges and nodes, querying node presence, retrieving connected nodes, and managing node properties and metadata. Concrete use cases include modeling commit histories in version control systems, tracking dependencies between nodes, and managing annotations or metadata across a DAG structure.",
      "description_length": 603,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vcs.Make.Branch",
      "library": "rocq-runtime.stm",
      "description": "This module defines a concrete type `t` representing version control system branches. It provides operations to create a branch from a string, compare branches for equality and ordering, convert a branch to its string representation, and access a predefined `master` branch. It is used to manage and manipulate branch names in a type-safe way within a version control system implementation.",
      "description_length": 390,
      "index": 158,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dag.Make.NodeSet",
      "library": "rocq-runtime.stm",
      "description": "This module implements an ordered set structure for elements of type `OT.t`, supporting standard operations like union, intersection, difference, and ordered traversal via iterators, folds, and sequence conversions. It provides transformations such as mapping, filtering, and partitioning, along with utilities for querying membership, extremal elements, and cardinality. Use cases include maintaining ordered collections of nodes with efficient set-theoretic operations, converting between sequences and sets, and iterating over elements in a defined order.",
      "description_length": 558,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm.DynBlockData.Map",
      "library": "rocq-runtime.stm",
      "description": "This module implements a type-safe map associating type tags with values parameterized by those tags. It supports operations like adding, removing, and modifying entries based on strongly-typed keys, as well as iterating, folding, and filtering over heterogeneous entries. Use cases include managing dynamic collections of typed state components within a transactional system.",
      "description_length": 376,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm.DynBlockData.Easy",
      "library": "rocq-runtime.stm",
      "description": "This module simplifies working with dynamically typed block data in a transactional state machine. It provides functions to create injective and projective transformations for arbitrary types, enabling type-safe storage and retrieval of heterogeneous data. Use it when handling blocks that must carry and expose structured, type-specific information during state transitions.",
      "description_length": 375,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Stm.DynBlockData.HMap",
      "library": "rocq-runtime.stm",
      "description": "This module transforms or filters heterogeneous maps of dynamic block data using provided mappings or predicates. It operates on `Stm.DynBlockData.Map(V1).t` values, applying per-tag functions to produce a new map with values in `V2` or filtering entries based on tag-specific conditions. Concrete use cases include converting block data representations across versions or selectively retaining entries matching specific criteria during state transitions.",
      "description_length": 455,
      "index": 162,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AsyncTaskQueue.MakeWorker",
      "library": "rocq-runtime.stm",
      "description": "Implements a server task dispatcher that initializes and runs a main loop for handling asynchronous tasks. Works with unit values as triggers for initialization and execution phases. Used to set up and start processing tasks in a server environment, specifically during Coqtop's initialization and runtime.",
      "description_length": 306,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dag.Make",
      "library": "rocq-runtime.stm",
      "description": "This module implements a directed acyclic graph (DAG) structure with nodes of type `OT.t`, supporting operations to add and remove edges and nodes, query node existence, and manage node metadata. It allows associating edge labels of arbitrary type with each connection, retrieving outgoing edges for a node, and maintaining per-node information and properties through dedicated operations. Concrete use cases include building dependency graphs with labeled relationships, tracking node properties for analysis or serialization, and efficiently managing sets of nodes with ordered traversal and set operations.",
      "description_length": 609,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm.AsyncOpts",
      "library": "rocq-runtime.stm",
      "description": "Handles configuration of asynchronous proof processing, including worker settings, caching strategies, and error resilience policies. Operates on proof states and tactic execution contexts to control parallelism and resource allocation. Used to tune performance and reliability in distributed proof checking scenarios.",
      "description_length": 318,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm.DynBlockData",
      "library": "rocq-runtime.stm",
      "description": "This module manages dynamic type tags and associated values in a transactional state machine. It supports creating unique type tags, comparing and identifying types, and maintaining a global registry of registered types. It is used to handle heterogeneous data blocks that carry structured, type-specific information during state transitions.",
      "description_length": 342,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WorkerPool.Make",
      "library": "rocq-runtime.stm",
      "description": "This module manages a pool of worker processes for executing tasks asynchronously. It provides operations to create a pool with a specified size and priority, cancel individual or all workers, and check pool status. The module works with a model-specific extra data type and handles worker lifecycle events like handshake during spawning. Use it to parallelize Coq proof processing tasks across multiple threads with controlled resource allocation.",
      "description_length": 448,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm.ProofTask",
      "library": "rocq-runtime.stm",
      "description": "This module defines operations for managing proof tasks within a distributed state transaction system. It handles task assignment, response processing, and feedback forwarding between master and worker processes. Key data types include `task`, `worker_status`, `request`, and `response`, used to represent proof tasks, worker states, and communication between components. Concrete use cases include generating worker requests based on task status, processing proof results, and handling task expiration or worker failures.",
      "description_length": 522,
      "index": 168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vcs.Make",
      "library": "rocq-runtime.stm",
      "description": "This module enables managing hierarchical branch structures with operations for merging, resetting, and switching, while modeling versioned histories as directed acyclic graphs (DAGs) where nodes carry metadata and diffs. It supports attaching arbitrary properties to DAG nodes and employs reachability analysis to clean up obsolete data, ensuring efficient storage. These capabilities suit collaborative systems requiring branching workflows, audit trails, and garbage-collected version graphs, such as distributed code repositories or document collaboration platforms.",
      "description_length": 570,
      "index": 169,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AsyncTaskQueue.MakeQueue",
      "library": "rocq-runtime.stm",
      "description": "This module implements a task queue system that allows creating, managing, and synchronizing workers for executing tasks of type `T.task`. It supports operations such as task enqueuing with cancellation support, dynamic worker management, task ordering, and queue destruction. Concrete use cases include parallel execution of Coq proof tasks with controlled concurrency and cancellation.",
      "description_length": 387,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Partac.TacTask",
      "library": "rocq-runtime.stm",
      "description": "This module defines task and worker interaction logic for a distributed system, handling task assignment, response processing, and worker status updates. It works with tasks, worker statuses, and communication requests/responses, supporting operations like task matching, response handling, and feedback forwarding. Concrete use cases include marshaling task data, managing worker lifecycle events, and executing remote task requests.",
      "description_length": 434,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm.QueryTask",
      "library": "rocq-runtime.stm",
      "description": "This module defines operations for managing task execution in a distributed system. It includes functions for generating worker requests based on task and worker status, matching tasks to workers, processing responses, and handling errors or cancellations. The module works with tasks, worker statuses, and responses, and is used to coordinate task distribution and result handling between a master and worker processes.",
      "description_length": 420,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vcs",
      "library": "rocq-runtime.stm",
      "description": "This module defines core abstractions for version control system operations, including types for change kinds and a signature for version-controlled data. It works with abstract data types representing file states, diffs, and repositories. Concrete use cases include tracking file modifications, applying patches, and managing commit histories in a type-safe manner.",
      "description_length": 366,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "TQueue",
      "library": "rocq-runtime.stm",
      "description": "This module implements a thread-safe queue with support for blocking operations, dynamic ordering, and synchronization primitives. It allows pushing and popping elements, waiting for specific queue states, and clearing with optional value transformation. Concrete use cases include coordinating producer-consumer workflows, managing prioritized task queues, and synchronizing threads based on queue conditions.",
      "description_length": 410,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Spawned",
      "library": "rocq-runtime.stm",
      "description": "This module manages communication channels for inter-process communication, using either anonymous pipes or TCP sockets. It provides functions to initialize and retrieve input/output channels, as well as to obtain the current process's identifier. Concrete use cases include setting up control and data channels in distributed systems or multi-process applications where processes need to exchange messages or coordinate tasks.",
      "description_length": 427,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm",
      "library": "rocq-runtime.stm",
      "description": "This module orchestrates document lifecycle management and transactional state tracking in proof-checking systems, supporting operations like parsing, editing, proof retrieval, and state-aware queries. It works with document and state types, dynamic data blocks, and task structures to enable collaborative editing, distributed task coordination, and error-resilient workflows, particularly in interactive proof assistants and distributed environments requiring atomic state transitions with asynchronous processing.",
      "description_length": 516,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ProofBlockDelimiter",
      "library": "rocq-runtime.stm",
      "description": "This module manages the detection and handling of proof block boundaries in a document, using dynamic state to track focused goals and determine their simplicity. It provides functions to evaluate whether a goal is independent, crawl through document nodes to find block closures, and convert between bullet markers and dynamic block data. It is used to structure proof scripts by identifying self-contained proof blocks that can be safely skipped or processed independently.",
      "description_length": 475,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Partac",
      "library": "rocq-runtime.stm",
      "description": "This module enables parallel execution by initializing workers with specified arguments and count. It coordinates task distribution and worker communication through the `TacTask` submodule, which handles task assignment, response processing, and worker status tracking. Use it to execute distributed tasks, manage worker interactions, and process remote execution requests with marshaled data.",
      "description_length": 393,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WorkerPool",
      "library": "rocq-runtime.stm",
      "description": "This module manages a pool of worker processes for executing tasks asynchronously. It supports creating a pool with a specified size and priority, canceling individual or all workers, and checking the pool's status. It is used to parallelize Coq proof processing tasks across multiple threads while controlling resource allocation.",
      "description_length": 331,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dag",
      "library": "rocq-runtime.stm",
      "description": "Implements a directed acyclic graph (DAG) with nodes of type `OT.t`, supporting addition and removal of nodes and edges, edge labeling with arbitrary types, and retrieval of outgoing edges. Provides operations to query node existence, manage node metadata, and perform set-like operations on node collections. Useful for modeling dependency graphs with labeled edges, tracking node properties, and enabling ordered traversal or serialization workflows.",
      "description_length": 452,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stmargs",
      "library": "rocq-runtime.stm",
      "description": "Handles parsing of command-line arguments related to STM (Software Transactional Memory) options. Extracts and processes STM-specific flags from a list of arguments, returning the parsed options and remaining arguments. Useful for configuring STM behavior in Coq through command-line parameters.",
      "description_length": 295,
      "index": 181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AsyncTaskQueue",
      "library": "rocq-runtime.stm",
      "description": "This module manages a queue of asynchronous tasks for external workers, providing operations to enqueue tasks, control cancellation, and handle task execution flags. It works with task modules conforming to the `Task` signature, string lists for flags, and cancellation switches using boolean references. Concrete use cases include coordinating proof generation across multiple worker processes and managing task lifecycles in distributed systems.",
      "description_length": 447,
      "index": 182,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cc_core_plugin.Ccalgo.ATerm",
      "library": "cc_core_plugin",
      "description": "This module defines a term representation with operations to construct and deconstruct terms, including symbols, products, applications, and constructors. It works with Coq's `Constr.constr`, `Sorts.t`, and environment types, providing direct term manipulation. Concrete use cases include building and analyzing terms during proof search or tactic execution.",
      "description_length": 358,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cc_core_plugin.Ccproof",
      "library": "cc_core_plugin",
      "description": "This module defines a type `rule` representing inference rules for constructing equality proofs, including axioms, reflexivity, symmetry, transitivity, congruence, and injection. It supports operations over terms and proof structures used in the context of a proof assistant's kernel, particularly for handling inductive types and equality reasoning. The `build_proof` function generates a proof object based on a given goal, using environment and evar_map state to resolve variables and constraints.",
      "description_length": 500,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cc_core_plugin.Cctac",
      "library": "cc_core_plugin",
      "description": "Performs equality reasoning and congruence closure in Coq proofs. Works directly with Coq's `EConstr.constr` type to manipulate proof goals. Use to automatically solve equalities, apply congruence rules, or reduce goals using `f_equal`.",
      "description_length": 236,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cc_core_plugin.Ccalgo",
      "library": "cc_core_plugin",
      "description": "This module provides operations for term construction and analysis, proof state forest management, and congruence handling during tactic execution. It works with terms, patterns, equalities, term graphs, and stateful solver contexts to support tasks like disequality propagation, quantifier handling, and path joining in congruence closure algorithms. These capabilities enable automated reasoning in Coq plugins, particularly for managing complex proof states and axiom-driven transformations.",
      "description_length": 494,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cc_core_plugin",
      "library": "cc_core_plugin",
      "description": "This module implements core components for congruence closure and equality reasoning in Coq plugins. It provides term manipulation, proof construction, and tactic execution capabilities tailored for handling equalities, congruences, and proof state transformations. Designed for use in automated reasoning tasks such as solving equality goals, propagating disequalities, and managing inductive type equalities during interactive proving.",
      "description_length": 437,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_plugin",
      "library": "nsatz_plugin",
      "description": "Implements decision procedures for algebraic structures using Gr\u00f6bner bases, focusing on polynomial ideal membership testing. Operates on ring and field structures, particularly for solving equations in commutative algebra. Useful in formal verification of mathematical properties and automated theorem proving in algebraic contexts.",
      "description_length": 333,
      "index": 188,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Firstorder_core_plugin.Formula.Env",
      "library": "firstorder_core_plugin",
      "description": "Represents a mapping between variables and their associated values or types in logical formulas. Supports operations to add, lookup, and manage variable bindings within formula environments. Used to evaluate or manipulate first-order logic expressions by maintaining variable context during processing.",
      "description_length": 302,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Unify.Item",
      "library": "firstorder_core_plugin",
      "description": "This module represents individual items used in unification processes, typically containing logical terms or variables. It provides operations to compare items, check if they are ground (fully instantiated), and retrieve their representation as a pair of an integer and a constructor. These functions support unification algorithms in formal logic systems by managing term structure and equivalence.",
      "description_length": 399,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Sequent",
      "library": "firstorder_core_plugin",
      "description": "This module manages sequents for first-order proof search, providing operations to manipulate hypotheses and goals, add or retrieve formulas, and control proof state depth. It works with data types including sequents, formulas, atoms, and environment mappings for variables and hints. Concrete use cases include implementing proof automation tactics that require tracking and modifying logical context, such as adding conclusions or hypotheses from constraints, iterating over redexes, or deepening the search state.",
      "description_length": 516,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Unify",
      "library": "firstorder_core_plugin",
      "description": "This module implements unification operations for logical atoms and terms, working with ground and variable terms represented as items. It provides functions to unify atoms under a given environment, check generalization relationships between terms, and handle both real and phantom term instances. Concrete use cases include supporting first-order logic reasoning and constraint solving in proof assistants.",
      "description_length": 408,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Rules",
      "library": "firstorder_core_plugin",
      "description": "This module implements tactics for applying logical rules in a sequent calculus, handling operations like conjunction, disjunction, implication, quantifiers, and induction on atomic formulas. It works with data types such as `tactic`, `seqtac`, `lseqtac`, `GlobRef`, `pinductive`, and `constr`, primarily operating over sequents and formulas. Concrete use cases include constructing proof steps for first-order logic goals, performing case analysis on inductive types, and applying logical equivalences during proof automation.",
      "description_length": 527,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Formula",
      "library": "firstorder_core_plugin",
      "description": "This module centers on constructing and manipulating first-order logical formulas using a GADT-based representation (`any_formula`) to unify polymorphic formula types. It operates on logical atoms, quantifiers, connectives, and environments tracking variable bindings and type information, with functions like `build_formula` to create and compare expressions in a logical context. Specific use cases include formal verification, automated reasoning, and theorem proving where precise handling of logical structure, identifiers, and side data (e.g., type annotations) is essential.",
      "description_length": 581,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Ground",
      "library": "firstorder_core_plugin",
      "description": "Implements grounding tactics for first-order logic proofs, providing flag management and tactic application on sequents. It operates on logical formulas and proof states, enabling case analysis and rule application based on formula structure. Used to automate proof steps in formal verification tasks involving quantifiers and logical connectives.",
      "description_length": 347,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Instances",
      "library": "firstorder_core_plugin",
      "description": "This module provides operations for collecting and handling quantified formulas within a sequent, using environment and evar_map context. It includes a tactic for applying quantified formula transformations with backtracking. Concrete use cases involve processing first-order logic formulas during proof search or tactic execution.",
      "description_length": 331,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin",
      "library": "firstorder_core_plugin",
      "description": "This module provides core components for first-order logic reasoning, including formula construction, sequent manipulation, unification, and rule-based proof tactics. It operates on logical formulas, sequents, atoms, terms, and environments, supporting precise handling of quantifiers, connectives, and inductive structures. Concrete use cases include formal verification, automated theorem proving, and tactic development in proof assistants requiring deep logical analysis and transformation.",
      "description_length": 494,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CLexer.LexerDiff.State",
      "library": "rocq-runtime.parsing",
      "description": "This module manages a global state for tracking and retrieving comments during lexical analysis. It provides operations to initialize, set, get, and drop the current state, as well as to extract a list of comments with their positions. Each comment is represented as a tuple of a position range and a string.",
      "description_length": 308,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CLexer.Lexer.State",
      "library": "rocq-runtime.parsing",
      "description": "This module manages the state of a lexer, including initialization, setting, and retrieving the current state, as well as extracting collected comments with their positions. It operates on a state type `t` and maintains a global state reference internally. Concrete use cases include tracking lexer progress during parsing and collecting comments for later processing or analysis.",
      "description_length": 380,
      "index": 199,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CLexer.Error",
      "library": "rocq-runtime.parsing",
      "description": "This module defines an error type for handling lexical analysis errors in C-like syntax. It provides a `to_string` function to convert error values into human-readable messages. Use this module to report and display syntax errors during tokenization of C source code.",
      "description_length": 267,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.GramState",
      "library": "rocq-runtime.parsing",
      "description": "This module manages a dynamic key-value store for grammar-related state during parsing, where keys are typed fields and values can be any marshallable data. It supports creating, setting, getting, and removing fields, as well as merging state from multiple sources. Useful for tracking contextual information like variable bindings or type annotations across different grammar rules.",
      "description_length": 383,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Symbol",
      "library": "rocq-runtime.parsing",
      "description": "This module constructs and manipulates grammar symbols for defining parsers, including non-terminals, terminals, and structured repetitions like lists and optional elements. It works with grammar entries and symbols parameterized over self-types and recursion markers, producing parsed values of arbitrary types. Concrete use cases include defining syntactic constructs such as expressions, statements, and lists of tokens or sub-expressions with precise structural control.",
      "description_length": 474,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Entry",
      "library": "rocq-runtime.parsing",
      "description": "This module defines entry points for parsing Rocq code, providing operations to create, parse, and manipulate entries using string names and token streams. It supports data types like `t` for entries, `any_t` for heterogeneous entry storage, and uses parser functions to convert input into structured values. Concrete use cases include registering named parsers, parsing token streams into AST elements, and accumulating entries into mapped collections for modular language processing.",
      "description_length": 485,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CLexer.LexerDiff",
      "library": "rocq-runtime.parsing",
      "description": "This module implements a lexer for parsing tokens with support for keyword recognition and comment tracking. It processes character streams into token streams, matching patterns to extract lexical elements and associate them with positions. The State submodule maintains comment records during lexing, enabling retrieval of comments with their source locations for analysis or documentation tools.",
      "description_length": 397,
      "index": 204,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Procq.Constr",
      "library": "rocq-runtime.parsing",
      "description": "This module focuses on constructing and transforming Coq's logical and type-level expressions, including binders, patterns, type constraints, and record declarations. It operates on abstract syntax tree nodes like `constr_expr` and leverages parser combinators (`Procq.Entry.t`) to build structured representations of Coq terms from concrete syntax. Its functionality supports use cases such as parsing lambda expressions, type annotations, and inductive type definitions within Coq's formal logic framework.",
      "description_length": 508,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Rule",
      "library": "rocq-runtime.parsing",
      "description": "This module builds and manipulates parsing rules for a grammar, composing them with symbols to define recursive and non-recursive productions. It works with rule and symbol types parameterized over grammars, result types, and self-references. Concrete use cases include defining parser entry points, chaining token sequences, and structuring recursive grammars for language processing.",
      "description_length": 385,
      "index": 206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CLexer.Lexer",
      "library": "rocq-runtime.parsing",
      "description": "This module implements a lexer for tokenizing input streams, providing functions to define and match token patterns, extract token text, and associate locations with tokens. It operates on streams of characters and produces streams of tokens equipped with location information. Concrete use cases include parsing source code by breaking it into meaningful tokens and extracting comments with their positions during lexical analysis.",
      "description_length": 432,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Rules",
      "library": "rocq-runtime.parsing",
      "description": "This module defines and constructs parsing rules for the Rocq parser, focusing on integrating grammar definitions with location tracking. It works with abstract syntax tree nodes, grammar productions, and location information from the `Loc` module. Concrete use cases include defining recursive grammar rules, attaching semantic actions to parsed constructs, and handling operator precedence in Rocq's surface language.",
      "description_length": 419,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Prim",
      "library": "rocq-runtime.parsing",
      "description": "This component provides low-level parsing operations for Coq-like syntactic elements, handling identifiers, qualified names, integers, strings, and universe declarations through lexical and syntactic analysis. It processes string inputs and parsing streams to generate structured values like `Names.Id.t` and `Libnames.qualid`, aligning with Coq's concrete syntax requirements. These parsers are specifically used during proof script processing to recognize tokens, hypotheses, and directory paths in the Rocq parser's context.",
      "description_length": 527,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Production",
      "library": "rocq-runtime.parsing",
      "description": "This module defines and constructs parsing productions for the Rocq parser, primarily working with abstract syntax tree nodes and location data. It provides the `make` function to create productions that map parsed rules to values, using a given function and context. Concrete use cases include building structured representations of parsed expressions or statements with associated source locations.",
      "description_length": 400,
      "index": 210,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Procq.Lookahead",
      "library": "rocq-runtime.parsing",
      "description": "This module defines combinators and primitives for constructing lookahead parsers that recognize specific lexical patterns in a token stream. It works with the abstract type `t` representing parser states, supporting operations like concatenation (`>>`), choice (`<+>`), and recognition of identifiers, keywords, numbers, and structured lists. Concrete use cases include parsing Rocq source code elements such as qualified identifiers, keyword sequences, and syntactic constructs without consuming input.",
      "description_length": 504,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Module",
      "library": "rocq-runtime.parsing",
      "description": "This module defines the syntax and structure of modules, including parsing rules for module expressions and types. It works with `module_ast` from `Constrexpr` to represent module constructs as abstract syntax trees. Concrete use cases include parsing module definitions and type annotations in the Rocq language.",
      "description_length": 313,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Parsable",
      "library": "rocq-runtime.parsing",
      "description": "This module provides functions to create and manipulate parsable input streams, primarily handling character-based input with location tracking. It supports operations to consume characters, retrieve comments with their positions, and access the current parsing location. Concrete use cases include parsing source code files where precise position tracking and comment extraction are required.",
      "description_length": 393,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tok",
      "library": "rocq-runtime.parsing",
      "description": "This module defines the token type used by the Rocq lexer and parser, including variants for keywords, identifiers, numbers, strings, and special symbols. It provides functions to compare tokens, extract their string representation, and process quotation delimiters. Concrete use cases include pattern matching in grammar rules and generating error messages with token names during parsing.",
      "description_length": 390,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation_gram",
      "library": "rocq-runtime.parsing",
      "description": "Handles parsing and representation of notation grammars, supporting the definition of syntactic constructs through terminal and non-terminal symbols, list markers, and associativity rules. It works with lists of grammar items, notation levels, and entry keys to define how notations map to Coq's internal syntax. Used to implement custom syntax for logical expressions, arithmetic operations, and domain-specific languages embedded in Coq.",
      "description_length": 439,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pcoq",
      "library": "rocq-runtime.parsing",
      "description": "This component provides tools for constructing and modifying grammars used in Coq's parsing infrastructure, focusing on operations like defining symbolic entries, registering syntactic rules, and synchronizing parser states. It manipulates core types such as `Symbol.t` for representing grammar terminals, `Entry.t` for parsing entry points, and `extend_statement` structures to modify grammar definitions. These capabilities enable developers to implement custom domain-specific languages within Coq, extend existing proof syntax, and manage dynamic parser reconfigurations during interactive theorem proving sessions.",
      "description_length": 619,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "G_prim",
      "library": "rocq-runtime.parsing",
      "description": "Handles low-level process communication and arithmetic operations. Works with process entries and natural numbers. Used for testing pipe closure behavior and performing subtraction on non-negative integers.",
      "description_length": 206,
      "index": 217,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Procq",
      "library": "rocq-runtime.parsing",
      "description": "This module provides parser combinators for constructing and dynamically modifying grammars, state management operations for synchronization and freezing, and utilities for lexing, AST generation, and precise source location tracking. It operates on token streams and string inputs through grammar entities like symbols, production rules, entries, and typed parsing states. Designed for Coq-like syntax parsing\u2014handling terms, modules, and commands\u2014it supports use cases requiring incremental grammar extensions, semantic action execution, and error diagnostics with granular source position data.",
      "description_length": 597,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CLexer",
      "library": "rocq-runtime.parsing",
      "description": "This module manages keyword recognition and identifier validation for lexical analysis, providing functions to add and check keywords, validate identifiers, and associate tokens with locations. It works with strings, token streams, and location data to support parsing C-like syntax. Concrete use cases include defining language keywords, validating identifier names, and resuming parsing from specific positions.",
      "description_length": 413,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notgram_ops",
      "library": "rocq-runtime.parsing",
      "description": "This module manages the parsing rules and grammatical structure of notations, handling operations like declaration and retrieval of notation grammars, non-terminal symbols, and common prefixes between notations. It works with data types such as `Constrexpr.notation`, `Notation_gram.notation_grammar`, and `Extend.constr_entry_key`. Concrete use cases include defining custom syntax parsing rules, resolving ambiguities in notation parsing through common prefix detection, and querying registered notations with fully defined grammar rules.",
      "description_length": 540,
      "index": 220,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "G_constr",
      "library": "rocq-runtime.parsing",
      "description": "This module defines a set of entry points for parsing and validating specific syntactic constructs in a language, such as identifiers, natural numbers, and type annotations followed by assignment operators. It works primarily with token streams and parser state, handling constructs like parentheses, array delimiters, and type annotations. These entries are used in the context of a larger parser to recognize and process language-specific syntax patterns during lexical analysis or abstract syntax tree construction.",
      "description_length": 518,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extend",
      "library": "rocq-runtime.parsing",
      "description": "This module defines data types and operations for managing entry keys and production levels used in parsing and interpreting syntactic constructions. It includes types like `production_position`, `production_level`, and `constr_entry_key` to represent grammatical contexts and their associations, along with equality functions to compare these keys. It is used to specify and differentiate syntactic entry points in the grammar, such as in constr notations for Coq's vernacular language.",
      "description_length": 487,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vm_printers",
      "library": "rocq-runtime.dev",
      "description": "This module provides functions to print various internal data structures used in a virtual machine, including values, stacks, blocks, and relocation information. It operates on types such as `vblock`, `zipper`, `stack`, `atom`, and `values`, among others. These functions are used for debugging and inspecting the state of the virtual machine during execution or compilation.",
      "description_length": 375,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Top_printers",
      "library": "rocq-runtime.dev",
      "description": "This module offers pretty-printing operations for a range of internal OCaml and Coq data structures, including abstract syntax trees (e.g., `Constr.t`, expressions), kernel-level maps (e.g., `Id.Map`, `MPmap`), environments, proof constructs (goals, constraints), and type-checking artifacts (universes, substitutions). The functions convert these complex, often abstract structures into human-readable text using the `Pp.t` mechanism, primarily serving debugging, introspection, and diagnostic purposes during development or interaction with the OCaml toplevel.",
      "description_length": 562,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Array.Fun1.Smart",
      "library": "rocq-runtime.lib",
      "description": "This module provides optimized versions of array operations that avoid closure allocation by taking an extra argument for the function parameter. It works with arrays and functions that accept a shared environment argument alongside elements. Use it to efficiently map over arrays in performance-sensitive code paths where closure creation overhead must be minimized.",
      "description_length": 367,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map.Make.Monad",
      "library": "rocq-runtime.lib",
      "description": "This module provides monadic traversal and transformation operations for map-like structures, including `fold`, `mapi`, `fold_left`, and `fold_right`, all of which sequence computations using the monadic context `M`. It works specifically with key-value maps where values are of type `'a t`, and supports operations that depend on both keys and values. Concrete use cases include accumulating results across a map with effects (e.g., IO, error handling) or transforming map values while propagating monadic state.",
      "description_length": 513,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map.Make.Smart",
      "library": "rocq-runtime.lib",
      "description": "This module provides optimized `map` and `mapi` functions for key-value maps that attempt to preserve structural sharing during transformations. It works specifically with map data structures where keys are of a fixed type and values can be modified in place. These functions are useful when efficiently updating large maps while minimizing memory allocation, such as in incremental data processing or persistent data structure implementations.",
      "description_length": 444,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Set.Make.List",
      "library": "rocq-runtime.lib",
      "description": "This module implements set operations for lists, providing functions like `union` to combine elements from multiple sets into a single list. It works with lists of any type, treating them as sets by ensuring uniqueness of elements. Concrete use cases include merging configuration options, aggregating results from multiple sources, and deduplicating entries in log data.",
      "description_length": 371,
      "index": 228,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Array.Fun1",
      "library": "rocq-runtime.lib",
      "description": "This module provides higher-order versions of standard array operations like `map`, `iter`, and `iter2`, where each function takes an additional environment argument that is passed to the function operand. It works with arrays and functions that accept a shared environment alongside array elements, enabling reuse of the environment without creating closures. Use these functions in performance-critical sections to reduce allocation overhead, such as when applying transformations or performing side effects over large arrays with a shared context.",
      "description_length": 550,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map.Make",
      "library": "rocq-runtime.lib",
      "description": "This module implements polymorphic map operations with ordered keys, supporting standard manipulations like insertion, deletion, and lookup alongside advanced combinators for merging, splitting, and symmetric difference computation. It operates on balanced tree-based maps (`'a t`) with key sets (`Set.Make(M).t`) for structural transformations, enabling efficient ordered folding, key-aware value mapping, and stateful traversals. Use cases include maintaining sorted associative data structures, performing algebraic operations on map collections, and implementing effectful transformations with monadic sequencing.",
      "description_length": 617,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.List.Smart",
      "library": "rocq-runtime.lib",
      "description": "This module provides optimized list transformations that maximize physical sharing between input and output lists when elements are unchanged. It works with standard OCaml lists and supports operations like `map`, `fold_left_map`, and `fold_right_map`, ensuring that unchanged elements in the result are physically equal to those in the input. Concrete use cases include efficient list processing where identity preservation of unmodified elements is important, such as in versioned data structures or diff-based algorithms.",
      "description_length": 524,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Array.Smart",
      "library": "rocq-runtime.lib",
      "description": "This module provides optimized versions of common array transformations like `map`, `map2`, and combined fold-map operations, which avoid unnecessary array copies when the result is identical to the input. It works directly with OCaml arrays and preserves their identity in cases where the transformation is a no-op, improving performance in scenarios like repeated array processing or conditional updates. Concrete use cases include efficient array filtering, in-place transformations, and iterative algorithms where input and output arrays are often the same.",
      "description_length": 561,
      "index": 232,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Set.Hashcons",
      "library": "rocq-runtime.lib",
      "description": "This module implements hash-consing for sets using a customizable hash and comparison function. It provides operations to generate a hash-consing table, apply hash-consing to a set, and retrieve statistics on the table's usage. The module works with sets of elements that support the hash and comparison functions provided by the `M` module. Use this module to reduce memory usage and improve performance when working with large numbers of equivalent sets.",
      "description_length": 456,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AcyclicGraph.Make",
      "library": "rocq-runtime.lib",
      "description": "This module implements a directed acyclic graph structure for maintaining strict partial orders over abstract points, offering operations to enforce equality, inequality, and ordering constraints while ensuring acyclicity. It manages data structures like constraint nodes mapped to points, supports domain traversal, and validates invariants through path tracing to explain conflicts. Typical applications include dependency resolution systems, versioned state tracking, or constraint satisfaction problems where explicit conflict explanation and dynamic order maintenance are required.",
      "description_length": 586,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pp_diff.StringDiff",
      "library": "rocq-runtime.lib",
      "description": "Computes differences between two strings using the Rocq lexer to split text into tokens, then applies the Myers algorithm to compute the diff. It highlights changes using specific tags for added, removed, and modified text spans, including support for multi-string spans with start and end markers. Designed for use with arrays of strings, this module is ideal for displaying side-by-side comparisons of code or structured text where lexical accuracy is important.",
      "description_length": 464,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CWarnings.CoreCategories",
      "library": "rocq-runtime.lib",
      "description": "This module defines and exposes distinct warning classifications used in the `rocq-runtime` system, providing predefined categories like `tactics`, `user_warn`, and `vernacular` to group warnings by source or behavior. It operates on the `CWarnings.category` type, enabling structured configuration and handling of warnings during compilation or execution. These categories facilitate targeted suppression, reporting, or processing of warnings tied to specific language features, user interactions, or system components.",
      "description_length": 520,
      "index": 236,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "NewProfile.MiniJson",
      "library": "rocq-runtime.lib",
      "description": "Represents and prints simplified JSON values with support for integers, strings, associative lists, and nested lists. Directly handles structured data serialization for lightweight JSON-like formats. Useful for generating readable output of configuration or data structures in custom parsers and interpreters.",
      "description_length": 309,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Array",
      "library": "rocq-runtime.lib",
      "description": "This module offers comprehensive array manipulation capabilities, spanning element-level access, transformation, and aggregation operations. It supports arrays of arbitrary type `'a`, including specialized handling for float arrays and multidimensional matrices, with functions for indexed mapping, folding across multiple arrays, in-place modification, and combinatorial operations like pairwise mapping, filtering via boolean masks, and array splitting. Designed for numerical computing, data processing pipelines, and algorithms requiring index-aware operations, it also includes optimization-focused submodules for reducing memory overhead during transformations.",
      "description_length": 667,
      "index": 238,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Util.Union",
      "library": "rocq-runtime.lib",
      "description": "This module provides operations to transform, compare, and accumulate values within a union type. It supports mapping functions over either branch of a union, checking equality of two union values, and folding over the contained value using a pair of functions. These operations are useful when handling sum types where values can be in one of two distinct forms, allowing structured manipulation without explicit pattern matching.",
      "description_length": 431,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Spawn.Sync",
      "library": "rocq-runtime.lib",
      "description": "This module manages the synchronous spawning and control of external processes. It provides functions to start processes with custom environment and arguments, retrieve their input/output channels, and manipulate running processes through operations like killing, waiting, and checking status. Concrete use cases include executing shell commands and managing subprocesses with precise lifecycle control.",
      "description_length": 403,
      "index": 240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Stateid.Set",
      "library": "rocq-runtime.lib",
      "description": "This module offers operations for managing ordered sets of identifiers, supporting set algebra (union, intersection, difference), element-wise transformations (map, filter), and ordered sequence conversions. It works with sets containing `Stateid.t` elements, maintaining their natural ordering, and facilitates bidirectional conversion between sets, lists, and sequences. Typical use cases include dependency tracking, ordered collection manipulation, and algorithms requiring efficient membership checks or sorted data aggregation.",
      "description_length": 533,
      "index": 241,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Aux_file.H",
      "library": "rocq-runtime.lib",
      "description": "This module implements a persistent map data structure with integer pair keys and arbitrary value types, offering associative operations like insertion, deletion, merging, and conditional updates alongside ordered traversal capabilities. It supports bidirectional iteration, bulk conversions to and from lists and sequences, and functional transformations with filtering, partitioning, and key-based range queries. Designed for scenarios requiring immutable ordered key-value associations, it excels in hierarchical data modeling, efficient range-based processing, and functional pipelines with guaranteed persistence.",
      "description_length": 618,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Set",
      "library": "rocq-runtime.lib",
      "description": "This module implements set operations using balanced trees, providing functions for membership testing, insertion, deletion, and set algebra (union, intersection, difference). It works with elements that have a defined ordering or hashing behavior, enabling efficient data deduplication and relational operations. Concrete use cases include tracking unique identifiers, managing access control lists, and optimizing search-space reductions in combinatorial algorithms.",
      "description_length": 468,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NewProfile.Counters",
      "library": "rocq-runtime.lib",
      "description": "This module defines a data type `t` representing a collection of numeric counters. It supports operations to retrieve the current counter values, reset them to zero, add or subtract counter values, and print the results. Concrete use cases include tracking and manipulating performance metrics or resource usage statistics within a system.",
      "description_length": 339,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Aux_file.M",
      "library": "rocq-runtime.lib",
      "description": "This module implements key-value storage with ordered string keys, supporting insertion, deletion, merging, and ordered traversal via functions like `fold`, `map`, and `filter`. It provides bidirectional conversion between maps and sequences for bulk operations, along with ordered iteration (`to_rev_seq`, `to_seq_from`) and structural transformations (`split`, `partition`). Use cases include configuration management, ordered data processing, and scenarios requiring efficient aggregation or filtering of key-value pairs.",
      "description_length": 524,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Spawn.Async",
      "library": "rocq-runtime.lib",
      "description": "This module manages asynchronous process execution with precise control over spawning, signaling, and monitoring external processes. It works with Unix process identifiers and channels, offering concrete operations like `spawn` to start a process with a command and environment, `kill` to terminate it, and `wait` to retrieve its exit status. Use cases include running background tasks, managing long-lived services, and coordinating process lifecycles with custom callbacks for output handling.",
      "description_length": 495,
      "index": 246,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Empty",
      "library": "rocq-runtime.lib",
      "description": "This module defines an empty type `t` and a function `abort` that takes a value of this type and returns a value of any type `'a`. Since the empty type has no inhabitants, `abort` can never be called and is used to represent logically unreachable code paths. It is useful for exhaustiveness checking in pattern matching and ensuring certain cases are proven impossible.",
      "description_length": 369,
      "index": 247,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Compare",
      "library": "rocq-runtime.lib",
      "description": "This module supports constructing and composing comparison functions for structured data by defining a list of comparison operations. It works with tuples containing comparison functions, values to compare, and recursive comparison lists. Concrete use cases include building lexicographic orderings for records or custom data structures by chaining field-wise comparisons.",
      "description_length": 372,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map",
      "library": "rocq-runtime.lib",
      "description": "This module implements polymorphic map operations with ordered keys, supporting standard manipulations like insertion, deletion, and lookup alongside advanced combinators for merging, splitting, and symmetric difference computation. It operates on balanced tree-based maps (`'a t`) with key sets (`Set.Make(M).t`) for structural transformations, enabling efficient ordered folding, key-aware value mapping, and stateful traversals. Use cases include maintaining sorted associative data structures, performing algebraic operations on map collections, and implementing effectful transformations with monadic sequencing.",
      "description_length": 617,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CAst.Smart",
      "library": "rocq-runtime.lib",
      "description": "Performs transformations on abstract syntax tree nodes, applying a function to each node and returning a modified tree. Works with the `'a CAst.t` type, which represents structured syntax elements. Useful for rewriting or analyzing code structures during compilation or refactoring tasks.",
      "description_length": 288,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.List",
      "library": "rocq-runtime.lib",
      "description": "This module offers a comprehensive toolkit for list manipulation, emphasizing transformations (mapping, reversing, concatenating), folds (indexed and multi-list variants), filtering (predicate-based and slicing), and searching (element/index lookups, membership checks). It operates on polymorphic lists, association lists, and tuples, supporting custom equality, sorting, and set-like operations while enabling precise control over traversal, decomposition, and error handling. Key use cases include processing key-value pairs, performing order-preserving set operations, optimizing tail-recursive iterations, and managing lists with dynamic indexing or conditional transformations.",
      "description_length": 683,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Deprecation.Version",
      "library": "rocq-runtime.lib",
      "description": "This module defines specific warning categories corresponding to different version numbers, such as v8_3, v8_5, and up to v9_0. It works with the CWarnings.category type to classify deprecation warnings by version. These values are used to trigger or suppress deprecation warnings in Coq based on the current version, enabling precise control over warning behavior during code evolution.",
      "description_length": 387,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stateid.Self",
      "library": "rocq-runtime.lib",
      "description": "This module defines a type `t` as an alias for `Stateid.t` and provides a `compare` function that establishes a total ordering between values of this type. The comparison function determines equality, less-than, and greater-than relationships between pairs of values. It is used in contexts where ordered keys are needed, such as in implementing maps or sets over state identifiers.",
      "description_length": 382,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Spawn",
      "library": "rocq-runtime.lib",
      "description": "This module implements a concurrent process management system with precise control over spawning, monitoring, and terminating external processes. It works with Unix process IDs, channels, and custom request types like `req`, supporting operations such as `spawn`, `kill`, and `wait`. Concrete use cases include orchestrating background services, handling inter-process communication with structured messages, and enforcing lifecycle policies on child processes.",
      "description_length": 461,
      "index": 254,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CoqProject_file",
      "library": "rocq-runtime.lib",
      "description": "This module processes Coq project files and command-line arguments, providing structured access to project configuration. It defines types for tracking the source of arguments and handling meta-files, supporting operations like parsing project files, locating project files in a directory hierarchy, and extracting file lists filtered by suffix. Key use cases include initializing Coq projects from command-line inputs, reading and validating project files, and generating Coq top-level arguments from project settings.",
      "description_length": 519,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NewProfile",
      "library": "rocq-runtime.lib",
      "description": "This module provides profiling functionality for measuring and analyzing the execution of functions, including pausing and resuming profiling state, aggregating timing data, and generating structured output. It works with custom data types for representing profiling events, time sums, and counters, along with formatters for outputting results in human-readable formats. Concrete use cases include performance monitoring of interpreters, tracking execution time of subroutines, and exporting profiling data for analysis.",
      "description_length": 521,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Instr",
      "library": "rocq-runtime.lib",
      "description": "This module provides a function `read_counter` to retrieve the current value of a global instruction counter, returning either the count as an `Int64.t` or an error message. It is designed for measuring the number of instructions executed between two points in a program by taking the difference of two counter readings. Use this to analyze or profile the instruction-level performance of specific code segments.",
      "description_length": 412,
      "index": 257,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CErrors",
      "library": "rocq-runtime.lib",
      "description": "This module handles error creation, classification, and printing through functions like `anomaly`, `user_err`, and `print`. It works with exceptions, particularly `Anomaly` and `UserError`, and supports custom error handling via registered printers. Concrete use cases include signaling system errors, raising user-facing errors with locations, and converting exceptions into results.",
      "description_length": 384,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stateid",
      "library": "rocq-runtime.lib",
      "description": "This module manages state identifiers with operations for comparison, ordering, and set manipulation. It provides functions to create, convert, and compare identifiers, track validity, and handle exceptions associated with states. Concrete use cases include dependency management, version control of document states, and maintaining ordered collections of runtime state keys.",
      "description_length": 375,
      "index": 259,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AcyclicGraph",
      "library": "rocq-runtime.lib",
      "description": "Implements a directed acyclic graph for managing strict partial orders over abstract points with operations to add equality, inequality, and ordering constraints. Uses constraint nodes mapped to points to support domain traversal and enforce acyclicity through path tracing. Useful for dependency resolution, versioned state tracking, and constraint satisfaction systems requiring explicit conflict explanations.",
      "description_length": 412,
      "index": 260,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Loc",
      "library": "rocq-runtime.lib",
      "description": "This module handles source code locations with precision, tracking file context, line numbers, and character positions. It supports operations like merging spans, shifting positions, and embedding locations into other values, working with structured data like `Loc.t` and `source`. It is used to manage error reporting with accurate source references and track code spans during parsing or transformation tasks.",
      "description_length": 411,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UserWarn",
      "library": "rocq-runtime.lib",
      "description": "This module manages user-triggered warnings and deprecation notices from `.v` code, using structured data types like `warn` and `t` that include messages and optional categories. It provides functions to construct and emit warnings with optional locations, integrate deprecation notices, and handle warning configuration with specific status settings. Concrete use cases include raising warnings for deprecated features and emitting user-defined warnings during compilation.",
      "description_length": 474,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Aux_file",
      "library": "rocq-runtime.lib",
      "description": "This module manages auxiliary file state through key-value associations, supporting operations to load, modify, and query string-based entries with optional location tracking. It provides persistent hierarchical storage using submodules H and M for structured data modeling, and enables runtime recording of values to auxiliary files. Concrete use cases include tracking compilation metadata, persisting dynamic configuration changes, and logging structured data during program execution.",
      "description_length": 488,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CDebug",
      "library": "rocq-runtime.lib",
      "description": "This module manages conditional debug output through named components, allowing fine-grained control over which debug messages are displayed. It provides functions to create debug components, enable or disable them dynamically, and format debug messages using pretty-printing. Use cases include selectively logging internal state changes in compilers or interpreters and tracing execution paths in complex algorithms.",
      "description_length": 417,
      "index": 264,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pp_diff",
      "library": "rocq-runtime.lib",
      "description": "This module computes differences between two pretty-printed (Pp.t) structures or strings by tokenizing them using the Rocq lexer and applying the Myers diff algorithm. It highlights changes with specific tags for added, removed, and background-highlighted text spans, supporting multi-string spans with start and end markers. It is used to visually compare and display differences in structured text such as code, where lexical accuracy and precise change tracking are required.",
      "description_length": 478,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "System",
      "library": "rocq-runtime.lib",
      "description": "This module handles file system operations, binary data serialization, and time/instruction analysis. It works with Unix paths, custom types like `file_kind` and `instruction_count`, and time or duration values, supporting tasks like path resolution, marshaling, and performance metrics. Use cases include directory traversal with case-sensitive file searches, transaction result handling, and executable path analysis for program optimization.",
      "description_length": 444,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CAst",
      "library": "rocq-runtime.lib",
      "description": "This module provides functions to construct, transform, and analyze syntax tree nodes with attached location information. It supports mapping operations over `CAst.t` values, applying functions with or without access to node locations, and comparing nodes using custom equality. Concrete use cases include rewriting expressions during compilation, extracting information from parsed code, and validating or transforming structured syntax elements in refactoring tools.",
      "description_length": 468,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hook",
      "library": "rocq-runtime.lib",
      "description": "This module implements runtime-initialized hooks with single assignment semantics. It provides operations to create, retrieve, and set typed values through `make`, `get`, and `set`. Useful for deferring resolution of configuration values or dependencies until runtime while ensuring initialization safety.",
      "description_length": 305,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ObjFile",
      "library": "rocq-runtime.lib",
      "description": "This module handles reading from and writing to binary object files using OCaml's marshaling. It supports opening and closing files for input and output, marshaling data to and from specific segments identified by IDs, and accessing segment contents with digest verification. Concrete use cases include persisting typed data structures to disk and loading them back, such as caching compiled code or storing serialized state.",
      "description_length": 425,
      "index": 269,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "DAst",
      "library": "rocq-runtime.lib",
      "description": "This module wraps abstract syntax tree nodes with lazy evaluation capabilities, supporting delayed computation and location tracking. It provides operations to create, force, and map over lazily evaluated values, while preserving source location information. Used primarily for handling global constraints in a parsed form, allowing deferred resolution of syntactic constructs.",
      "description_length": 377,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CWarnings",
      "library": "rocq-runtime.lib",
      "description": "This module enables defining and managing warnings with customizable severities (disabled, enabled, error) and hierarchical classifications, supporting creation of warnings with associated messages, printers, and quickfixes. It operates on structured categories like `tactics` and `vernacular` from its CoreCategories submodule, using configuration strings and a category type to enable targeted suppression or escalation. Specific applications include runtime-wide warning control via flags, temporary warning suppression during critical operations, and handling unknown warning identifiers through override mechanisms.",
      "description_length": 620,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flags",
      "library": "rocq-runtime.lib",
      "description": "This module manages global mutable state through imperative operations on boolean and list references to control system-wide behaviors like debugging, verbosity, and warning handling. It enables temporary modifications of these flags during function execution, primarily supporting testing scenarios and configuration of output parameters such as directory paths. Key use cases include conditional execution of debug logic and scoped adjustments to system settings without persistent state changes.",
      "description_length": 498,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Quickfix",
      "library": "rocq-runtime.lib",
      "description": "This module defines a data structure for representing quick fixes associated with errors, including their location and a description. It provides operations to create, retrieve, and print quick fixes, along with a mechanism to register and compute quick fixes based on exceptions. It is used to suggest actionable corrections when errors occur during tasks like type checking or parsing.",
      "description_length": 387,
      "index": 273,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pp",
      "library": "rocq-runtime.lib",
      "description": "Supports constructing documents with operations such as string insertion, spacing, line breaks, concatenation, boxing, and tagging, all manipulating an abstract document type designed for structured, formatted output. It handles data structures like lists, arrays, optional values, and tagged spans, enabling customizable separators and layout control for nested or conditional content. This module is suited for tasks like code formatting, log generation, or document layout analysis, where precise visual structure and adaptability to different output contexts are critical.",
      "description_length": 576,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Feedback",
      "library": "rocq-runtime.lib",
      "description": "This module handles feedback generation and routing for user interfaces, supporting operations to register and remove feedback listeners, send structured feedback messages, and set default identifiers for feedback contexts. It works with typed feedback content, including messages with severity levels, processing statuses, and document dependencies, alongside identifiers for documents, routes, and state spans. Concrete use cases include notifying users of completed processes, displaying warning messages with quick fixes, and logging debug information during program execution.",
      "description_length": 581,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util",
      "library": "rocq-runtime.lib",
      "description": "This module provides operations for transforming and folding over pairs, triples, and collections like lists, arrays, sets, and maps, alongside utilities for string manipulation, functional composition, and union type handling. It supports tasks such as text processing with placeholder substitution, building data transformation pipelines using combinators, and representing logically unreachable code paths via an empty type, while also enabling file handling, exception management, and delayed evaluation.",
      "description_length": 508,
      "index": 276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Envars",
      "library": "rocq-runtime.lib",
      "description": "This module retrieves and processes environment variables and system paths used by Rocq, handling fallbacks and deprecation warnings for variables like ROCQ* and COQ*. It expands path macros, resolves user home directories, and provides access to installation directories for documentation, data, and configuration. It supports use cases like locating Coq binaries, resolving OCaml dependencies, and adhering to XDG standards for config and data storage.",
      "description_length": 454,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Deprecation",
      "library": "rocq-runtime.lib",
      "description": "This module manages deprecation metadata and warnings for Coq, providing structured handling of version-based deprecation notices. It defines operations to create and manipulate deprecation records with optional version information and replacement guidance, and to emit warnings based on these records. The module works with custom warning categories tied to Coq versions, enabling precise control over deprecation warnings during code evolution.",
      "description_length": 446,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Control",
      "library": "rocq-runtime.lib",
      "description": "This module manages global execution control in Rocq, providing functions to handle interruptions, enforce timeouts, and protect against signal preemption. It works with boolean references to control state, functions with generic types for computation, and signal handlers for asynchronous events. Concrete use cases include interrupting long-running computations via `interrupt`, yielding control with `check_for_interrupt`, and safely handling SIGALRM in critical sections using `protect_sigalrm`.",
      "description_length": 499,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xml_datatype",
      "library": "rocq-runtime.lib",
      "description": "This module defines a polymorphic type `xml` for representing XML-like data structures with key-value attributes. It supports operations to construct, traverse, and manipulate hierarchical XML nodes, including functions to add attributes, extract child elements, and fold over node trees. Concrete use cases include parsing and generating XML documents, processing configuration files, and building structured data exports.",
      "description_length": 423,
      "index": 280,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tauto_plugin",
      "library": "tauto_plugin",
      "description": "This module implements automated tautology checking for propositional logic, providing functions to determine whether a given formula is a tautology, contradiction, or contingent. It operates on logical expressions represented as terms in a custom abstract syntax tree, supporting operations like negation, implication, and conjunction. Concrete use cases include verifying logical equivalences and simplifying logical expressions during proof automation.",
      "description_length": 455,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Invfun",
      "library": "funind_plugin",
      "description": "This module defines the `invfun` tactic, which performs inversion on a quantified hypothesis in Coq proofs. It takes an optional global reference to guide the inversion process. Use it to analyze and break down complex hypotheses into simpler subgoals during interactive theorem proving.",
      "description_length": 287,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Glob_term_to_relation",
      "library": "funind_plugin",
      "description": "Converts inductive definitions into relational forms using globbed terms. It processes lists of constants, named glob constraints, and expression lists to construct relational representations within the Coq environment. Useful for transforming inductive data structures into equivalent relational encodings during proof or term manipulation tasks.",
      "description_length": 347,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Indfun_common",
      "library": "funind_plugin",
      "description": "This module supports identifier manipulation, name resolution, and list transformations with custom equality logic, operating on Coq's internal representations like identifiers (`Names.Id.t`), proof terms (`EConstr.t`), and environments (`Environ.env`). It provides functionality for managing inductive function definitions through equality constraints, tactic behavior analysis, and delayed references to global constants, while enabling term manipulations such as lambda decomposition and controlled evaluation. These tools are used in Coq plugin development for inductive reasoning, proof environment management, and tactic-driven lemma application.",
      "description_length": 652,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.G_indfun",
      "library": "funind_plugin",
      "description": "This module defines generalized arguments and entry points for tactics related to function induction and definition schemes in Coq. It handles parsing and interpretation of induction principles, function names, and sort families, supporting tactics that manipulate or generate function-based proofs and definitions. Concrete use cases include specifying induction schemes for functions, naming induction hypotheses, and defining recursive functions with custom induction principles.",
      "description_length": 482,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Gen_principle",
      "library": "funind_plugin",
      "description": "This module defines and generates principles and graphs for inductive types, issuing warnings when definitions fail. It operates on Coq's internal data structures like `fixpoints_expr`, global references, and qualified names, interacting with the declaration and vernacular expression systems. It supports interactive principle generation, scheme construction, and graph creation for case analysis and induction.",
      "description_length": 412,
      "index": 286,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Funind_plugin.Functional_principles_types",
      "library": "funind_plugin",
      "description": "This module defines core operations for computing new principle types based on relations, working with Coq's internal data structures like `Constr.t`, `Sorts.t`, and `Environ.env`. It includes the function `compute_new_princ_type_from_rel` which derives a principle type from a given relation in a specific environment and context. A concrete use case is inferring types for induction principles during proof construction or tactic execution.",
      "description_length": 442,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Indfun",
      "library": "funind_plugin",
      "description": "Performs functional induction on a given term, generating subgoals for each case. Works with Coq's `EConstr.constr` type and binding environments. Useful for proving properties about recursive functions by breaking them into structurally smaller subproblems.",
      "description_length": 258,
      "index": 288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Funind_plugin.Glob_termops",
      "library": "funind_plugin",
      "description": "This module provides utilities for constructing and transforming Gallina terms and case patterns, including operations like variable substitution, lambda/let-binding manipulation, and case expression handling. It works with `glob_constr` for representing terms and `cases_pattern` for pattern-matching structures, supporting tasks like implicit argument resolution, pattern unifiability checks, and identifier set extraction. Key use cases include term rewriting during pattern compilation, expanding `as`-bound variables, and comparing structural equality of patterns in proof automation contexts.",
      "description_length": 598,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Functional_principles_proofs",
      "library": "funind_plugin",
      "description": "This module provides tactics for proving functional induction principles for inductive structures. It operates on Coq's internal constructions, constants, and evar maps, generating proof terms for specified function schemes. It is used during the generation of induction principles for recursive functions, particularly when handling generalized inductive types.",
      "description_length": 362,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Recdef",
      "library": "funind_plugin",
      "description": "This module provides tactics and utilities for defining recursive functions in Coq, particularly handling user-defined recursion conditions and internalization of expressions. It works with Coq's proof terms, constants, and constraint expressions, supporting the construction of recursive definitions with custom induction principles. Concrete use cases include implementing user-guided recursive function synthesis and managing recursion hypotheses during interactive proof development.",
      "description_length": 487,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin",
      "library": "funind_plugin",
      "description": "This module implements core components for functional induction and recursive function definition in Coq. It provides tactics for proving induction principles, generating function schemes, performing inversion and case analysis, and manipulating Gallina terms and patterns. Key operations include functional induction on terms, inversion of hypotheses, computation of principle types from relations, and transformation of inductive definitions into relational forms, working directly with Coq's internal constructions, environments, and constraints. Concrete use cases include proving properties of recursive functions, defining functions with custom induction principles, and automating proof tasks involving inductive types and pattern matching.",
      "description_length": 747,
      "index": 292,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_plugin.Polynomial.LinPoly.MonT",
      "library": "micromega_plugin",
      "description": "This module maps monomials to unique integer identifiers, supporting operations to register, retrieve, and manage these associations. It works with linear polynomials represented as sorted association lists and monomials from the `Monomial` module. Use cases include variable management in symbolic computations and ensuring unique variable numbering during polynomial manipulation.",
      "description_length": 382,
      "index": 293,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_plugin.Polynomial.ProofFormat.Env",
      "library": "micromega_plugin",
      "description": "Stores variable mappings and coefficient data for proof generation in polynomial reasoning. It supports creating and managing environments with a specified size, enabling tracking of variables and their associated values during proof construction. Used internally to manage context when generating proofs over integer, rational, and real numbers.",
      "description_length": 346,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial.Monomial",
      "library": "micromega_plugin",
      "description": "This module represents monomials as multisets of variables with their degrees. It provides operations to compute the total degree, check subset relations, fold over variable-degree pairs, and output a textual representation. It is used for manipulating algebraic expressions in formal verification tasks.",
      "description_length": 304,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial.LinPoly",
      "library": "micromega_plugin",
      "description": "This module represents linear polynomials as sorted association lists with operations to convert polynomials to linear form, extract variables, check linearity, and perform arithmetic like product and square collection. It works with monomials mapped to integer identifiers, supporting symbolic manipulation and constraint solving. Concrete use cases include normalizing polynomials for automated reasoning and managing variable indices in linear arithmetic proofs.",
      "description_length": 465,
      "index": 296,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_plugin.Persistent_cache.PHashtable",
      "library": "micromega_plugin",
      "description": "Implements a persistent hash table that stores key-value pairs in a file, supporting operations to add, find, and memoize values based on keys. It works with a user-defined key type and ensures that bindings are written to disk immediately. Useful for caching results of expensive computations across program runs, where keys can be uniquely serialized and checked for existence without recomputation.",
      "description_length": 401,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial.ProofFormat",
      "library": "micromega_plugin",
      "description": "This module defines data structures and operations for constructing and manipulating proof terms in polynomial reasoning over integers, rationals, and reals. It includes proof rules like `AddPrf`, `MulPrf`, and `CutPrf`, and supports proof transformations such as normalization, simplification, and compilation to external proof formats. Concrete use cases include generating and processing formal proofs in automated theorem proving tools that operate on polynomial constraints.",
      "description_length": 479,
      "index": 298,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial.Poly",
      "library": "micromega_plugin",
      "description": "This module represents and manipulates polynomials with rational coefficients. It supports constructing polynomials from constants and variables, arithmetic operations like addition and multiplication, and inspecting or modifying individual monomials. Concrete use cases include symbolic algebra computations and constraint solving involving polynomial expressions.",
      "description_length": 365,
      "index": 299,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_plugin.Vect.Bound",
      "library": "micromega_plugin",
      "description": "This module represents and manipulates bounds on variables in a vector space using rational coefficients and constants. It provides conversions between bound representations and vectors, enabling precise constraint handling in arithmetic reasoning. Concrete use cases include transforming and analyzing linear constraints during proof automation in Coq.",
      "description_length": 353,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial.BoundWithProof",
      "library": "micromega_plugin",
      "description": "This module represents polynomial bounds with associated proofs. It supports constructing bounds from polynomial proofs, multiplying bounds to derive new bounded results, and extracting either the bound or the proof separately. It is used in formal verification workflows to track and manipulate polynomial constraints with their corresponding correctness evidence.",
      "description_length": 365,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial.WithProof",
      "library": "micromega_plugin",
      "description": "This module combines arithmetic operations (addition, multiplication, negation, scalar multiplication) with proof-carrying transformations (pivoting, cutting plane, substitution) on polynomials bundled with proofs of sign correctness. It operates on polynomial and proof types from the Micromega_plugin.Polynomial family, including `LinPoly.t` for polynomial representation and `prf_rule` for proof structures, while enabling constraint system manipulation via variable elimination, lexicographic sorting, and coefficient-based normalization. These features are designed for applications in formal verification where arithmetic reasoning requires certified simplifications and traceable proof artifacts.",
      "description_length": 703,
      "index": 302,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_plugin.Coq_micromega",
      "library": "micromega_plugin",
      "description": "This module provides arithmetic proof automation for integer and rational number reasoning through linear/non-linear decision procedures and sum-of-squares methods. It operates on logical formulas structured as `BFormula (Formula Q)` or `BFormula (Formula Z)`, generating verifiable proof sequences (`Psatz`, `ZArithProof`) that are integrated into Coq's proof context. Key applications include automated verification of numerical properties in formal proofs and constructing efficient arithmetic witnesses for external solver results.",
      "description_length": 535,
      "index": 303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial",
      "library": "micromega_plugin",
      "description": "This module handles polynomial arithmetic and constraint manipulation with rational coefficients, providing data structures for monomials, linear polynomials, and proof-carrying polynomial bounds. It supports operations such as addition, multiplication, degree computation, linearity checking, and proof-aware transformations like pivoting and substitution. Concrete use cases include symbolic algebra in formal verification, constraint solving for automated reasoning, and certified simplification of polynomial expressions with traceable proof artifacts.",
      "description_length": 556,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Linsolve",
      "library": "micromega_plugin",
      "description": "This module solves systems of linear equations over positive integer variables with positive coefficients, generating all possible solutions. It provides operations to construct and manipulate equation systems, set constants, merge systems, and enumerate solutions. Concrete use cases include solving small constraint systems in formal verification or combinatorial problems where explicit solution enumeration is feasible.",
      "description_length": 423,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Persistent_cache",
      "library": "micromega_plugin",
      "description": "Implements a persistent hash table with immediate disk persistence for key-value storage. Supports insertion, lookup, and memoization over user-defined key types with serialization. Enables caching of costly computations across runs by storing and retrieving bindings to disk.",
      "description_length": 276,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Simplex",
      "library": "micromega_plugin",
      "description": "This module implements a simplex-based solver for linear arithmetic constraints over polynomials. It provides functions to search for feasible points, generate unsatisfiability certificates, and solve integer constraint systems with proof output. The module tracks solver performance metrics through the `profile_info` type, including pivot statistics and success/failure counts.",
      "description_length": 379,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Certificate",
      "library": "micromega_plugin",
      "description": "This module provides functions to generate unsatisfiability proofs for linear and non-linear arithmetic constraints over integers and rationals. It supports operations like `lia` and `nlia` for integer constraints, and `linear_prover_with_cert` and `nlinear_prover` for rational constraints, producing proof objects in specific formats. These functions are used in formal verification tasks where proof certificates are required to discharge arithmetic goals in theorem proving contexts.",
      "description_length": 487,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Itv",
      "library": "micromega_plugin",
      "description": "This module represents intervals with optional rational bounds and provides operations to manipulate them, including intersection, normalization, and bound checks. It works with intervals defined by `Micromega_core_plugin.NumCompat.Q.t` values, allowing precise rational arithmetic. Concrete use cases include range analysis and constraint solving in formal verification tasks.",
      "description_length": 377,
      "index": 309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin",
      "library": "micromega_plugin",
      "description": "This module provides arithmetic proof automation and constraint solving for integers and rationals, with support for linear and non-linear decision procedures, polynomial manipulation, and simplex-based solving. It works with logical formulas, polynomial expressions, and interval structures to enable formal verification of numerical properties and certified constraint resolution. Concrete use cases include discharging arithmetic goals in theorem proving, solving combinatorial constraint systems, and generating verifiable proof artifacts for external solver results.",
      "description_length": 571,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Table.Refmap'",
      "library": "extraction_plugin",
      "description": "This module implements a map structure with globally referenced keys (`Names.GlobRef.t`) and polymorphic values, offering operations like insertion, deletion, lookup, merging, and functional transformations (`map`, `mapi`) with optional results. It is designed for managing associations between global identifiers and their values, enabling efficient querying (`find_opt`, `choose`) and predicate-based filtering in contexts such as compiler symbol tables or context-aware data processing pipelines.",
      "description_length": 499,
      "index": 311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Mlutil.Mlenv",
      "library": "extraction_plugin",
      "description": "This module manages a typed environment stack for ML type information, supporting operations to add types and retrieve them by index. It works with `ml_type` values from the `Miniml` module, maintaining an environment structure for type tracking. It is used during type processing tasks like type inference or environment manipulation in compiler or analysis tools.",
      "description_length": 365,
      "index": 312,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Extraction_plugin.Table.Refset'",
      "library": "extraction_plugin",
      "description": "This module provides functional set operations such as membership testing, union, intersection, and difference on an immutable, persistent collection of `Names.GlobRef.t` elements. It includes utilities to inspect structural properties (e.g., cardinality, element listing) and extract values without modifying the original set. These capabilities are designed for scenarios requiring non-destructive set manipulation, such as symbolic dependency analysis or static data flow tracking.",
      "description_length": 484,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Scheme",
      "library": "extraction_plugin",
      "description": "This module defines a language description for a code extraction plugin, focusing on mapping high-level constructs to a target language. It works with abstract syntax trees and language-specific metadata to facilitate code generation. Concrete use cases include translating OCaml-like expressions into equivalent code in another language, such as generating JavaScript from OCaml.",
      "description_length": 380,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.G_extraction",
      "library": "extraction_plugin",
      "description": "This module defines generalized argument types for Coq's extraction mechanism, specifically handling integer or identifier values, programming language selections, and ML module names. It provides the necessary infrastructure to parse and interpret vernacular commands related to program extraction. These argument types are used directly in declaring tactics and commands that configure extraction behavior, such as specifying target languages or module identifiers.",
      "description_length": 467,
      "index": 315,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Extraction_plugin.Extract_env",
      "library": "extraction_plugin",
      "description": "This module handles the extraction of Coq terms into ML code, providing operations to extract specific identifiers, entire libraries, or compute structures for evaluation. It works with Coq environments, global references, and ML abstract syntax trees, producing ML declarations and types. Concrete use cases include extracting and compiling Coq functions into executable ML code, generating ML structures from Coq terms, and printing extracted ML declarations for debugging or integration.",
      "description_length": 490,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Common",
      "library": "extraction_plugin",
      "description": "This module provides formatting utilities for structured data like tuples, arrays, and applied expressions, using virtual size adjustments to control layout behavior and prevent unintended horizontal placement of blocks containing newlines. It supports code extraction workflows by managing identifier renaming environments (`env`, `Names.Id.t`) and handling global references, module paths, and ML AST nodes for name resolution and visibility management in Coq's extraction plugin, with specialized treatment for native character and string representations. The `sig_type_name` string further aids in formatting",
      "description_length": 612,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Haskell",
      "library": "extraction_plugin",
      "description": "This module defines the language description for Haskell code generation, specifying how OCaml constructs are translated into equivalent Haskell syntax. It maps OCaml data types and functions to their Haskell counterparts, ensuring correct representation of algebraic data types, pattern matching, and higher-order functions. It is used during the extraction process to generate executable Haskell code from OCaml programs.",
      "description_length": 423,
      "index": 318,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Json",
      "library": "extraction_plugin",
      "description": "Binds the `json_descr` value, which defines a language description for JSON serialization in the Miniml framework. It specifies how to convert OCaml values to and from JSON format. This enables direct use of Miniml's code generation with JSON input/output, such as serializing OCaml data structures for transmission over HTTP APIs or configuration files.",
      "description_length": 354,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Ocaml",
      "library": "extraction_plugin",
      "description": "Defines an OCaml language description for code extraction, specifying how to translate terms into OCaml syntax. It includes mappings for primitive types, functions, and data constructors. Used to generate executable OCaml code from Coq definitions during extraction.",
      "description_length": 266,
      "index": 320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Miniml",
      "library": "extraction_plugin",
      "description": "This module defines core data structures and types for representing ML-like code during the extraction process, including types for ML expressions, declarations, modules, and signatures. It supports operations for constructing and manipulating abstract syntax trees, handling inductive types, and managing module structures with detailed metadata. Concrete use cases include generating OCaml or F# code from Coq terms, optimizing extracted data structures, and controlling extraction behavior through kill reasons and type annotations.",
      "description_length": 535,
      "index": 321,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Modutil",
      "library": "extraction_plugin",
      "description": "This module provides functions for analyzing and transforming ML AST structures, including searching for specific AST nodes, iterating over references in types and expressions, and extracting signatures from structures. It operates on data types such as `ml_ast`, `ml_type`, `ml_structure`, and `ml_module_type`, and supports tasks like reference tracking, type inspection, and structure optimization. Concrete use cases include implementing custom extraction passes, optimizing module structures, and analyzing ML code during compilation or transformation phases.",
      "description_length": 564,
      "index": 322,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Extraction_plugin.Mlutil",
      "library": "extraction_plugin",
      "description": "This module facilitates type manipulation, term restructuring, and AST transformations for ML type processing and program extraction. It operates on `ml_type` and `ml_ast` structures with environment management via `Mlenv`, supporting tasks like type inference, lambda removal, and AST normalization. Specific applications include compiler optimizations, type simplification, and variable handling in analysis tools.",
      "description_length": 416,
      "index": 323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Extraction",
      "library": "extraction_plugin",
      "description": "This module handles the extraction of Coq terms and declarations into ML-like structures, performing core transformations for compiling Coq code into executable ML. It processes constants, inductive types, fixpoints, and type specifications, translating them into corresponding ML declarations and types. Use cases include implementing extraction mechanisms for Coq's `Extraction` command and generating ML code from Coq definitions.",
      "description_length": 433,
      "index": 324,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Extraction_plugin",
      "library": "extraction_plugin",
      "description": "This module implements core functionalities for extracting and transforming Coq terms into ML-like code and other target languages. It provides operations for formatting structured data, managing extraction environments, handling type and term transformations, and generating abstract syntax trees for languages like OCaml, Haskell, and JSON. Concrete use cases include compiling Coq definitions into executable ML code, serializing OCaml data to JSON, and generating JavaScript from OCaml-like expressions.",
      "description_length": 507,
      "index": 325,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Declare.OblState.View.Obl",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the state of obligations during proof development, tracking whether obligations are solved and their definition status. It works with obligation data structures that include identifiers, locations, and resolution flags. Concrete use cases include updating and querying the status of obligations when saving or admitting lemmas.",
      "description_length": 347,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.OblState.View",
      "library": "rocq-runtime.vernac",
      "description": "This module provides operations to manage and query the state of obligations during proof development, including tracking solved status and definition updates. It works with obligation data structures containing identifiers, locations, and resolution flags. Concrete use cases include updating obligation states when saving or admitting lemmas and querying obligation progress during proof construction.",
      "description_length": 403,
      "index": 327,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Declare.Hook.S",
      "library": "rocq-runtime.vernac",
      "description": "This module manages actions executed when definitions or proofs are saved, handling universe constraints, obligation substitutions, and declaration metadata. It works with global references, universe states, and obligation lists to support tasks like registering coercions, updating search indices, or resolving implicit arguments. Concrete use cases include integrating custom term processing at save time, such as linking definitions to external databases or enforcing domain-specific consistency checks.",
      "description_length": 506,
      "index": 328,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Library.Intern.Provenance",
      "library": "rocq-runtime.vernac",
      "description": "This module tracks the origin of loaded libraries by associating each with a file path and checksum. It ensures consistency by verifying that the checksum of a library file matches the expected value when loaded. Use cases include validating that a compiled module (.vo file) has not been modified since compilation and resolving library dependencies with integrity checks.",
      "description_length": 373,
      "index": 329,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernacstate.Interp.System",
      "library": "rocq-runtime.vernac",
      "description": "Stores and manages the state of Coq's proof engine during tactic execution. It provides functions to manipulate proof terms, track goals, and apply tactics. This module is used internally by Coq's interpreter to maintain the dynamic context of interactive theorem proving.",
      "description_length": 272,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.Internal.Constant",
      "library": "rocq-runtime.vernac",
      "description": "This module defines constants declared in the global environment, including their logical kind and identifier. It provides operations to tag and classify constants for use in Coq's internal declaration system. Concrete use cases include registering and querying top-level constant definitions during proof development.",
      "description_length": 318,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DeclareInd.Internal",
      "library": "rocq-runtime.vernac",
      "description": "This module handles internal representations and registrations of mutual inductive definitions, including their schemes and metadata. It operates on inductive type declarations and associated objects, managing their storage and retrieval during definition registration. Used internally when declaring inductive types with associated elimination schemes, ensuring correct handling of mutual recursions and scheme attachments.",
      "description_length": 424,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.Hook",
      "library": "rocq-runtime.vernac",
      "description": "This module manages actions executed when definitions or proofs are saved, handling universe constraints, obligation substitutions, and declaration metadata. It works with global references, universe states, and obligation lists to support tasks like registering coercions, updating search indices, or resolving implicit arguments. Concrete use cases include integrating custom term processing at save time, such as linking definitions to external databases or enforcing domain-specific consistency checks.",
      "description_length": 506,
      "index": 333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Declare.OblState",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the state of obligations during proof development, providing operations to track solved status and handle definition updates. It works with obligation data structures that include identifiers, locations, and resolution flags. Use cases include updating obligation states when saving or admitting lemmas and querying obligation progress during proof construction.",
      "description_length": 382,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Classes.Event",
      "library": "rocq-runtime.vernac",
      "description": "Handles event-driven logic for class and instance declarations. Works with `Typeclasses.typeclass` and `Classes.instance` types through the `t` variant type. Used to trigger and manage events when new classes or instances are registered in the system.",
      "description_length": 251,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DebugHook.Action",
      "library": "rocq-runtime.vernac",
      "description": "This module defines actions the debugger processes in response to IDE commands, including control flow operations like stepping and continuing, breakpoint management, and variable inspection. It works with string inputs and structured data types like lists of breakpoint configurations. Concrete use cases include parsing IDE commands to trigger execution steps, updating breakpoints, retrieving stack traces, and handling debugger configuration requests.",
      "description_length": 455,
      "index": 336,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacstate.Stm",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the state of the Coq proof assistant during interactive proof editing, specifically handling the separation between proof state and non-proof state components. It provides operations to extract and set the proof state (`pstate`), compare environments for equality, and create a shallow copy of the state by dropping transient objects. Concrete use cases include checkpointing proof progress, restoring proof contexts, and efficiently managing state during tactic execution.",
      "description_length": 493,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Opaques.Summary",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the lifecycle of summary data through initialization, freezing, and unfreezing operations. It works with opaque summary structures and supports joining operations while allowing exclusion of specific futures. It is used to coordinate and merge state across distributed computations while excluding specified future identifiers.",
      "description_length": 347,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacstate.Declare",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the state of proofs in progress, providing operations to access, modify, and close proofs, as well as track proof names and goals. It works with proof objects, environments, and lemma stacks, enabling concrete tasks like retrieving the current proof, mapping over proofs, closing proofs with opacity settings, and handling proof contexts. Use cases include managing interactive proof development, handling proof termination, and coordinating proof state transitions during tactic execution.",
      "description_length": 510,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.CInfo",
      "library": "rocq-runtime.vernac",
      "description": "This module constructs and manipulates constant declaration metadata, including name, type, and implicit arguments. It works with constant information structures containing names, types, and optional argument data. Concrete use cases include building and querying constant declarations during proof development or term manipulation.",
      "description_length": 332,
      "index": 340,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernactypes.Prog",
      "library": "rocq-runtime.vernac",
      "description": "Handles program state transitions and stack manipulations during the processing of extended vernacular commands. It provides operations to push, pop, and modify states in a non-empty list-based stack structure, specifically tailored for managing obligation states in proof scripts. This module is used to track and update the context of partially completed proofs as they evolve through tactic applications.",
      "description_length": 407,
      "index": 341,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declaremods.Interp",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the declaration and management of modules and module types, supporting operations like defining modules with functor arguments, starting and ending module scopes, and registering or importing libraries. It works with module paths, module expressions, and signatures to construct and manipulate modular structures. Concrete use cases include building modular definitions in a compiler or interpreter, managing module imports with visibility filters, and handling section closures in a structured context.",
      "description_length": 523,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacstate.LemmaStack",
      "library": "rocq-runtime.vernac",
      "description": "This module manages a stack of proofs, allowing operations to push, pop, and transform proof elements. It supports direct manipulation of the stack's top element, retrieval of all proof names, and mapping functions over the stack. It is used to maintain and modify the context of active proofs during theorem proving sessions.",
      "description_length": 326,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernactypes.OpaqueAccess",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a generalized algebraic data type (`t`) with two constructors: `Ignore`, representing a no-op operation, and `Access`, which wraps a global indirect accessor. It works with existential types and is used to control access to opaque values in Coq's vernacular interpretation. Concrete use cases include managing visibility and accessibility of definitions during proof checking and tactic execution.",
      "description_length": 417,
      "index": 344,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "DebugHook.Answer",
      "library": "rocq-runtime.vernac",
      "description": "Accepts and processes debugger responses, handling output generation and state updates. Works with `Pp.t` values and structured debugger state like goals, variables, and call stacks. Used to format and return debugger prompts, goal displays, and variable listings during interactive proof sessions.",
      "description_length": 298,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacstate.Synterp",
      "library": "rocq-runtime.vernac",
      "description": "Maintains and manipulates the syntactic parsing state during Coq's vernacular processing. It provides functions to initialize, freeze, and restore the parser state, along with extracting a frozen parsing state for later use. This module is used when managing incremental parsing and state transitions during proof script processing or tactic execution.",
      "description_length": 352,
      "index": 346,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernactypes.Proof",
      "library": "rocq-runtime.vernac",
      "description": "Handles proof-related operations during the interpretation of vernacular commands. It provides functions to start, update, and conclude proofs, along with managing proof states and transformations. Works directly with `state` values representing the current proof context. Useful for implementing tactics, proof scripts, and interactive proof development features.",
      "description_length": 364,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Future.UUID",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a type `t` representing universally unique identifiers (UUIDs) and provides operations to compare, check equality, and reference an invalid UUID value. It works directly with UUID values as opaque identifiers, enabling sorting, validation, and comparison in contexts like database keys or distributed system identifiers. Concrete use cases include tracking unique entities across systems, ensuring key uniqueness in distributed databases, and handling session or transaction IDs.",
      "description_length": 499,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.Obls",
      "library": "rocq-runtime.vernac",
      "description": "This module manages obligations for program definitions and fixpoints, providing operations to prepare, add, and solve obligations with tactics. It works with identifiers, constraints, and proof states, tracking progress via remaining obligations or dependencies. Concrete use cases include handling `Program Definition` and `Program Fixpoint` declarations, solving or admitting obligations, and displaying unresolved obligations or terms.",
      "description_length": 439,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacstate.Interp",
      "library": "rocq-runtime.vernac",
      "description": "This module captures and manipulates the dynamic state of Coq's proof engine during interpretation. It provides functions to freeze and restore the interpreter state, invalidate cached results, and manage proof-related data structures such as open lemmas, program obligations, and opaque proofs. It is used to control the evolution of proof contexts during tactic application and proof development.",
      "description_length": 398,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DebugHook.Intf",
      "library": "rocq-runtime.vernac",
      "description": "This module defines an interface for interacting with a debugger, providing functions to read commands, submit answers, and check terminal status. It works with the `t` record type containing `read_cmd`, `submit_answer`, and `isTerminal`. Concrete use cases include integrating a custom debugger frontend with the Ltac engine, such as handling user input and displaying evaluation results in a REPL environment.",
      "description_length": 411,
      "index": 351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Record.Data",
      "library": "rocq-runtime.vernac",
      "description": "This module defines data structures and operations for managing record projections and their properties. It works with identifiers, projection flags, and raw data to represent record components and their behaviors. Concrete use cases include tracking coercion status, projection priorities, and locality settings during record definition and manipulation.",
      "description_length": 355,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacentries.Preprocessed_Mind_decl",
      "library": "rocq-runtime.vernac",
      "description": "This module processes and validates inductive and record type declarations, handling universe declarations, typing flags, and associated notations. It works with inductive expressions, universe constraints, and record metadata to prepare declarations for type checking. Concrete use cases include parsing and validating `Inductive` and `Record` commands before they are fed into the core type system.",
      "description_length": 400,
      "index": 353,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Record.Internal",
      "library": "rocq-runtime.vernac",
      "description": "This module defines and manages projection flags and structures for inductive types, handling operations like declaring projections with associated metadata and registering structure entries. It works with inductive type definitions, universe entries, and projection contexts, supporting concrete tasks such as managing coercions, reversibility, and canonical instances. It is used during the declaration of record projections and structure entries in the type-checking process.",
      "description_length": 478,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pvernac.Unsafe",
      "library": "rocq-runtime.vernac",
      "description": "Sets the current tactic entry point for proof mode in the vernacular system. It directly modifies the global state of the proof mode context, allowing the specification of a tactic to be used as the entry point for subsequent proofs. This is typically used during proof initialization or mode switching in interactive theorem proving.",
      "description_length": 334,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Loadpath.Error",
      "library": "rocq-runtime.vernac",
      "description": "This module defines error types for handling library resolution failures during load path operations. It includes the `LibUnmappedDir` and `LibNotFound` variants to signal specific mapping and existence issues. These errors are used when resolving logical paths against physical directories, particularly in library loading and module resolution workflows.",
      "description_length": 356,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mltop.PluginSpec",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a data type `t` representing Coq plugins identified by their OCaml library names in Findlib format. It provides operations to convert a plugin specification to its corresponding Findlib package name and to pretty-print the plugin identifier as a string. It is used to manage and display plugin identifiers when loading or referencing Coq plugins through their OCaml library dependencies.",
      "description_length": 407,
      "index": 357,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Future.UUIDSet",
      "library": "rocq-runtime.vernac",
      "description": "This set abstraction manages UUID values with ordered traversal guarantees, offering insertion, deletion, and combination operations like union and intersection. It supports functional transformations including mapping, filtering, and folding, alongside sequence conversions for ordered iteration and bulk updates. Applications include coordinating unique identifier sets in distributed systems or ensuring consistent UUID set operations in data processing pipelines.",
      "description_length": 467,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.Proof",
      "library": "rocq-runtime.vernac",
      "description": "This module provides operations for initiating interactive proofs, applying tactics to manipulate proof states, and finalizing proofs with term extraction or admission. It operates on proof state representations (`Declare.Proof.t`, `Proof.t`), metavariable mappings (`Evd.evar_map`), and section variables, while interacting with Coq's tactic system and universe constraints. Use cases include incremental proof construction through tactic scripts, managing goal contexts during proof development, and handling unresolved metavariables or delayed lemmas in incomplete proofs.",
      "description_length": 575,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Record.Record_decl",
      "library": "rocq-runtime.vernac",
      "description": "This module defines the structure and metadata for records in the system, including fields like the inductive entry, projections, universe declarations, and implementation details. It works with inductive types and universe management structures to support the declaration and handling of record types. Concrete use cases include defining and managing record-based data structures with dependent fields and projections in a type-theoretic context.",
      "description_length": 447,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.Info",
      "library": "rocq-runtime.vernac",
      "description": "This module manages shared parameters and metadata for declarations, including constants, inductive types, and interactive proofs. It provides functions to construct and configure declaration contexts with options like universes, scope, and typing flags. Concrete use cases include setting up global constants with associated notations, managing polymorphism and inline directives, and coordinating mutual inductive definitions with proper name resolution and hooks.",
      "description_length": 466,
      "index": 361,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernacstate.System",
      "library": "rocq-runtime.vernac",
      "description": "This module provides a single operation, `protect`, which executes a function and discards any changes to the system state, including `Synterp.t` and `Interp.System.t`. It is used to run computations without permanently altering the system's global state. A concrete use case is evaluating code in a temporary context, such as during auto-completion or error recovery, where side effects on the system state must be avoided.",
      "description_length": 424,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Record.Ast",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a record type for representing abstract syntax trees of record declarations, including fields, binders, and attributes. It provides operations to construct and manipulate record ASTs with precise metadata like coercion flags, sort annotations, and builder identifiers. Concrete use cases include parsing and type-checking record definitions in a formal verification system.",
      "description_length": 393,
      "index": 363,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Future.UUIDMap",
      "library": "rocq-runtime.vernac",
      "description": "This module provides a map structure with UUID keys ordered by comparison, supporting insertion, deletion, merging, and ordered traversal via functions like `find_first`, `fold`, and `map`. It enables conversion between key-value sequences with controlled iteration order and range-based processing, alongside utilities for filtering, splitting, and comparing maps. These features are ideal for applications requiring consistent key ordering, such as event stream management, time-series analysis, or serialization workflows where UUIDs serve as unique identifiers.",
      "description_length": 565,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Classes.Internal",
      "library": "rocq-runtime.vernac",
      "description": "This module provides low-level operations for registering typeclass instances, including the `add_instance` function. It works with typeclass definitions, hint information, and global references to manage instance resolution. It is used internally to support instance declaration mechanisms in the language's type system.",
      "description_length": 321,
      "index": 365,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernacentries.DefAttributes",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a record type for attributes used in definition commands, including scope, locality, polymorphism, and typing flags. It provides a default attribute value for use in Coq's vernacular command system. Concrete use cases include configuring definition behavior in proof scripts and command-line options for Coq compilation.",
      "description_length": 340,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declaremods.Synterp",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the declaration and manipulation of modules and module types within a Coq-like environment. It provides operations for starting, ending, and including modules and module types, as well as registering libraries and managing imports. Functions work with identifiers, module paths, module expressions, and signatures, supporting concrete tasks like module nesting, type enforcement, and scoped inclusion of definitions.",
      "description_length": 436,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.Internal",
      "library": "rocq-runtime.vernac",
      "description": "This module handles internal operations for declaring and managing variables, constants, and inductive types in the global environment. It works with identifiers, logical kinds, and side effects, supporting concrete tasks like name resolution and constant classification. It is used during proof completion to apply side effects and register declarations for Coq's internal tracking and reference systems.",
      "description_length": 405,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pvernac.Vernac_",
      "library": "rocq-runtime.vernac",
      "description": "This module defines entry points for parsing Coq vernacular expressions, including Gallina terms, commands, syntax, and control structures. It supports parsing of inductive and record definitions, fixpoints, reduction expressions, and hint information. These entries facilitate concrete tasks like interpreting user input, processing Coq scripts, and handling proof editing commands.",
      "description_length": 383,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComInductive.Mind_decl",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a structured representation for inductive type declarations, including metadata such as universe binders, parameters, and coercions. It supports operations to build, manipulate, and extend inductive entries with dependencies, implicits, and notations. It is used during the compilation and checking of inductive definitions in the proof assistant's kernel.",
      "description_length": 376,
      "index": 370,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ComInductive.Internal",
      "library": "rocq-runtime.vernac",
      "description": "Handles internal operations for inductive type declarations, including arity processing and parameter validation. Works with environments, evar maps, inductive names, and constructor expressions. Used to compute inductive levels and detect conflicting parameters during the definition of inductive types.",
      "description_length": 304,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Attributes.Notations",
      "library": "rocq-runtime.vernac",
      "description": "This module provides monadic operations for combining and transforming attributes, including binding (`>>=`), sequencing (`>>`), mapping (`map`), and merging (`++`). It works with attribute values that encapsulate both a computation result and associated metadata flags. These operations enable constructing complex attribute transformations while ensuring flag consistency, such as applying a sequence of attribute modifications and combining independent attributes without key conflicts.",
      "description_length": 489,
      "index": 372,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Library.Intern",
      "library": "rocq-runtime.vernac",
      "description": "This module loads and validates libraries from disk by resolving their file paths and checking integrity via checksums. It returns a result type indicating success or failure along with provenance data, which includes the file path and checksum. It is used to ensure that loaded libraries match their expected state at compile time, preventing inconsistencies during execution.",
      "description_length": 377,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RetrieveObl",
      "library": "rocq-runtime.vernac",
      "description": "This module processes existential variables in Coq's proof environment, specifically extracting and managing obligations from terms. It works with environments, evar maps, and Coq terms to generate structured obligation data, including names, types, and resolution status. It is used during proof construction to handle incomplete terms by isolating and tracking unresolved evars for later solving.",
      "description_length": 398,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RecLemmas",
      "library": "rocq-runtime.vernac",
      "description": "This module identifies mutually recursive statements in a list of contexts and terms, using an evar map and a guard checking function. It operates on Coq's internal constructions and environments, specifically `evar_map`, `rel_context`, `constr`, and `possible_guard` types. It is used during type checking to ensure recursive definitions respect guardedness constraints.",
      "description_length": 371,
      "index": 375,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mltop",
      "library": "rocq-runtime.vernac",
      "description": "This module manages OCaml toplevel operations and ML plugin loading within Coq. It provides functions to load plugins by Findlib name, add directories to search paths, run the OCaml toplevel loop, and declare initialization routines for ML modules. It supports dynamic linking, module caching, and integrates ML module declarations with Coq's vernacular commands.",
      "description_length": 363,
      "index": 376,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Canonical",
      "library": "rocq-runtime.vernac",
      "description": "Declares a canonical structure for a given global reference, optionally marking it as local. This operation associates a preferred structure with a name for resolution purposes. Useful when managing multiple implementations of a module type, ensuring consistent resolution during type checking.",
      "description_length": 294,
      "index": 377,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Prettyp",
      "library": "rocq-runtime.vernac",
      "description": "This module supports operations to format and locate Coq's internal structures, such as environments, evar maps, and global references, using pretty-printing and context-aware rendering. It handles data types like coercions, typeclasses, and located identifiers, enabling human-readable output for complex terms and definitions. These capabilities are primarily used in vernacular commands like Print and Locate to aid user interaction with Coq's logical state.",
      "description_length": 461,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Search",
      "library": "rocq-runtime.vernac",
      "description": "This module implements search operations over Coq's global environment and proof goals, supporting pattern matching, module restrictions, and customizable filtering. It processes glob search requests using data types like `glob_search_item`, `glob_search_request`, and `search_constraint`, enabling precise queries based on names, types, or module locations. Concrete use cases include searching for lemmas matching a specific term pattern, filtering declarations by module membership, and prioritizing results for relevance in interactive proof contexts.",
      "description_length": 555,
      "index": 379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Record",
      "library": "rocq-runtime.vernac",
      "description": "This module processes record declarations and projections in a type-theoretic system, offering functions to build and interpret abstract syntax trees, manage projection metadata, and declare record structures with universe and coercion handling. It operates on inductive types, universe declarations, and projection contexts, supporting concrete tasks like parsing, type-checking, and managing canonical instances of records. Use cases include defining dependent record types with projections, tracking coercion status, and implementing structure-based reasoning in formal verification.",
      "description_length": 586,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printmod",
      "library": "rocq-runtime.vernac",
      "description": "This module provides functions to pretty-print Coq's mutual inductive definitions and module-related constructs. It operates on environments, module paths, and inductive body declarations, producing formatted output for debugging or user-facing display. Concrete use cases include printing the structure of inductive types and modules during development or error reporting.",
      "description_length": 373,
      "index": 381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare",
      "library": "rocq-runtime.vernac",
      "description": "This module manages operations for declaring and registering definitions, inductive types, and proofs within Coq's global environment, while handling associated metadata like implicit arguments, universe constraints, and obligation tracking. It operates on data structures such as `evar_maps`, `proof_entries`, and `universe_states`, alongside identifiers and logical kinds, to ensure consistency during declaration updates. Specific applications include defining inductive types with dependent parameters, resolving names via `Nametab`, and managing side-effects during tactic-based proof construction.",
      "description_length": 603,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "G_redexpr",
      "library": "rocq-runtime.vernac",
      "description": "This module defines parsing entries for various reduction-related expressions, including integer or variable inputs, pattern and unfolding occurrences, and reduction flags. It operates on data types like `r_trm`, `r_cst`, `r_pat`, and `occurrences_expr`, primarily used in tactic definition and term manipulation. Concrete use cases include specifying reduction strategies and occurrence selections in proof scripts.",
      "description_length": 416,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Auto_ind_decl",
      "library": "rocq-runtime.vernac",
      "description": "This module provides operations to automatically generate boolean equality and decidability of equality schemes for mutual inductive types. It works with inductive type definitions and produces functions that compare values for equality, returning either a boolean result or a decidable proof. These are used in formal verification tasks where automated reasoning about inductive data structures is required.",
      "description_length": 408,
      "index": 384,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Himsg",
      "library": "rocq-runtime.vernac",
      "description": "This module formats detailed error messages for type-checking and pretyping errors, including unguarded recursive definitions. It operates on environments, evar_maps, and specific error types like type_error, pretype_error, and refiner_error. It is used to generate human-readable explanations of type inference and checking failures during compilation.",
      "description_length": 353,
      "index": 385,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Loadpath",
      "library": "rocq-runtime.vernac",
      "description": "This module manages associations between physical file system paths and logical Rocq module hierarchies. It provides operations to register, query, and remove these associations, supporting file resolution based on logical paths and physical directories. Concrete use cases include locating compiled libraries and resolving dependencies during module loading.",
      "description_length": 359,
      "index": 386,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComCoercion",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the declaration and manipulation of coercions and subclasses within a type system. It provides operations to add coercions between types, declare identity coercions, and handle coercion hooks, working with global references and class types. Use cases include enabling implicit type conversions and structuring type hierarchies through subclass relationships.",
      "description_length": 378,
      "index": 387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacentries",
      "library": "rocq-runtime.vernac",
      "description": "This module processes vernacular commands like `Require` and `Import`, translating high-level syntax into the internal vernacular DSL. It handles environment checks, attribute configuration, and inductive/record declaration preprocessing for type checking. Concrete use cases include parsing `Inductive` and `Record` definitions, managing module imports, and enforcing evaluation rules during command translation.",
      "description_length": 413,
      "index": 388,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Opaques",
      "library": "rocq-runtime.vernac",
      "description": "This module manages opaque proof terms and their associated state, providing operations to declare, retrieve, and update opaque constants and their disk representations. It works with opaque handles, proof terms, and context sets to support the storage and retrieval of partially defined or private constants during proof processing. It is used to coordinate the persistence and merging of opaque values across distributed proof states while excluding specified futures.",
      "description_length": 470,
      "index": 389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComHints",
      "library": "rocq-runtime.vernac",
      "description": "Converts hint expressions into a structured format for proof automation. It processes Coq vernacular hint syntax into a typed representation used by the tactic system. Useful when implementing or extending hint-based tactics in Coq plugins.",
      "description_length": 240,
      "index": 390,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Assumptions",
      "library": "rocq-runtime.vernac",
      "description": "This module provides functions to analyze dependencies in Coq terms by traversing their structure and collecting assumptions. It works with global references, terms, and environments to extract direct and indirect dependencies, including opaque or transparent definitions based on provided flags. Concrete use cases include dependency tracking for proof terms and analyzing term assumptions in a given context.",
      "description_length": 410,
      "index": 391,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Synterp",
      "library": "rocq-runtime.vernac",
      "description": "This module processes Coq vernacular commands during the syntactic interpretation phase, converting high-level command representations into structured control entries. It operates on data types like `vernac_control`, `vernac_control_entry`, and various module-related structures such as `module_entry` and `synterp_entry`. Concrete use cases include interpreting `Require`, `Import`, `Module`, and `Notation` commands, handling module locality, and managing import filters and export flags during Coq script parsing.",
      "description_length": 516,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComExtraDeps",
      "library": "rocq-runtime.vernac",
      "description": "This module tracks additional dependencies between files in a build system. It allows declaring a dependency from a source directory on a specific file, optionally associated with an identifier, and querying the file path linked to a given identifier. Use it to manage auxiliary file relationships in compilation workflows.",
      "description_length": 323,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Classes",
      "library": "rocq-runtime.vernac",
      "description": "This module manages typeclass instance declarations and related operations, working with `Typeclasses.typeclass` and `Classes.instance` data structures. It provides functions to declare, register, and refine instances, supporting features like hint locality, transparency settings, and event-driven handling through observers. Concrete use cases include defining new typeclass instances interactively, setting resolution behavior for classes, and managing instance visibility during proof construction.",
      "description_length": 502,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacinterp",
      "library": "rocq-runtime.vernac",
      "description": "This module evaluates Coq vernacular expressions using a stateful interpreter, supporting operations like `interp` for processing controlled vernacular commands and `interp_entry` for interpreting syntactic entries. It works with data types such as `Vernacstate.t` for maintaining interpreter state, `vernac_control` for structured commands, and `proof_object` for handling proof terms. Concrete use cases include executing top-level commands in Coq scripts, managing proof construction with delayed proof validation, and integrating file-based library loading via the filesystem intern mechanism.",
      "description_length": 597,
      "index": 395,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Future",
      "library": "rocq-runtime.vernac",
      "description": "This module implements a future-based computation model with explicit state management, supporting creation, delegation, and resolution of asynchronous values. It works with computations that yield values or exceptions, identified and tracked using UUIDs for coordination and debugging. Concrete use cases include managing deferred computations in concurrent systems, handling session state in distributed applications, and coordinating task dependencies in workflow engines.",
      "description_length": 475,
      "index": 396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Egramml",
      "library": "rocq-runtime.vernac",
      "description": "This module defines and extends grammar productions for parsing vernacular commands, mapping them to executable actions in camlp5. It operates on grammar entries, extension names, and production rules, enabling the integration of custom syntax into the system. Concrete use cases include declaring new command grammars, extending existing ones, and retrieving or modifying grammar rules for parsing custom vernacular expressions.",
      "description_length": 429,
      "index": 397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComArguments",
      "library": "rocq-runtime.vernac",
      "description": "Handles the parsing and processing of arguments in Coq vernacular commands, specifically managing section-local declarations, qualified identifiers, and argument status. Works with lists of names and binding kinds, and modifies arguments using a set of modifiers. Used to define and manipulate command-specific argument structures in Coq's interactive proof environment.",
      "description_length": 370,
      "index": 398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "G_proofs",
      "library": "rocq-runtime.vernac",
      "description": "This module defines parsers for theorem declarations and hint expressions in a proof system. It processes tokens representing theorem kinds and hint expressions used during proof construction. It is used to interpret and validate proof scripts in a formal verification context.",
      "description_length": 277,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Egramrocq",
      "library": "rocq-runtime.vernac",
      "description": "This module extends the parsing system with term notation rules and manages custom grammar entries. It supports adding notations for terms, creating and checking custom parsing entries with locality flags. Concrete use cases include defining custom syntax for terms and tactics, and querying existing entries to avoid duplicates or check their properties.",
      "description_length": 355,
      "index": 400,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernactypes",
      "library": "rocq-runtime.vernac",
      "description": "This component provides operations for handling proof state transitions, program obligation management, and opaque value access in Coq's command processing system. It works with typed vernacular commands (`typed_vernac`), proof states (`Declare.Proof.t`), and obligation states (`Declare.OblState.t`) to enable tasks like interactive proof manipulation, structured program definition, and controlled access to opaque terms during proof checking.",
      "description_length": 445,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacprop",
      "library": "rocq-runtime.vernac",
      "description": "This module provides predicates to inspect Coq's vernacular expressions and control structures. It includes checks for query commands, navigation directives, reset, debug, and undo operations. These functions are used to analyze and classify Coq script commands during parsing or execution.",
      "description_length": 290,
      "index": 402,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Library",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the loading, validation, and saving of disk-based libraries, ensuring integrity via checksums from the `Digest` module. It operates on `library_t` and `DirPath.t`, handling file paths and provenance data to verify consistency between compiled files. Concrete use cases include loading trusted libraries at compile time, saving compiled libraries to `.vo` or `.vos` files, and checking loaded or compiled library states during module resolution.",
      "description_length": 464,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pvernac",
      "library": "rocq-runtime.vernac",
      "description": "This module manages proof modes and parsing entry points for Coq vernacular expressions, including support for defining tactics, inductive types, and commands. It works with proof mode identifiers and vernacular syntax trees, enabling tasks like switching proof contexts and interpreting user-defined commands. Direct use cases include setting up custom tactic entry points and parsing Coq scripts during interactive theorem proving sessions.",
      "description_length": 442,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComInductive",
      "library": "rocq-runtime.vernac",
      "description": "This module processes inductive and coinductive type declarations, handling universe constraints, parameter unification, and template polymorphism checks. It works with inductive expressions, universe binders, and variance entries to compile and validate inductive definitions, including mutual inductives and their constructors. Concrete use cases include elaborating inductive type declarations from user input, computing universe levels for template polymorphic inductives, and unifying non-uniform parameters during type checking.",
      "description_length": 534,
      "index": 405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Attributes",
      "library": "rocq-runtime.vernac",
      "description": "This module processes structured metadata for Coq vernacular commands through operations that parse, validate, and transform attributes. It works with `vernac_flags` (lists of named flags with optional values) and location-aware constructs, offering parsers for boolean, key-value, and payload attributes alongside combinators for composing complex configurations. These capabilities are applied in scenarios like enabling universe polymorphism, managing deprecation notices, and controlling hint locality within command definitions.",
      "description_length": 533,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DeclareUniv",
      "library": "rocq-runtime.vernac",
      "description": "This module manages universe declarations and constraints in Coq's type system. It provides operations to bind universe variables to global references, declare universe names, and handle universe constraints with support for both monomorphic and polymorphic contexts. Key data structures include universe levels, named universe entries, and constraint sets, with functions used during Coq's kernel operations for inductive and constant declarations.",
      "description_length": 449,
      "index": 407,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ComPrimitive",
      "library": "rocq-runtime.vernac",
      "description": "Handles the application of primitive operations during term construction, including universe declarations and optional result type annotations. Works with identifiers, universe expressions, and primitive operators or types. Used to implement low-level primitives like arithmetic operations or type-level computations in the core language.",
      "description_length": 338,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacoptions",
      "library": "rocq-runtime.vernac",
      "description": "This module provides operations to set, add, remove, check, and print Coq's global options, typically used to configure system behavior during proof development. It works with option names, locality settings, and table values, interacting directly with Coq's option system. Concrete use cases include enabling or disabling proof checking stages, controlling output verbosity, and managing persistent configuration settings.",
      "description_length": 423,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComDefinition",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the internalization and declaration of definitions in both program and interactive modes. It processes local binders, type annotations, and reduction expressions to construct and register new definitions in the environment. Key operations include `interp_definition` for parsing and type-checking definitions, `do_definition` for declaring them, and specialized variants for program mode and interactive proofs.",
      "description_length": 431,
      "index": 410,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "DebugHook",
      "library": "rocq-runtime.vernac",
      "description": "This module implements an Ltac debugger interface for IDE integration, enabling control flow operations like stepping and breakpoint management through structured command parsing. It handles debugger state updates, output formatting, and interactive session management using data types like `Pp.t` and breakpoint configurations. Concrete use cases include building custom debugging frontends that process IDE commands, display evaluation contexts, and manage runtime inspection in proof assistants.",
      "description_length": 498,
      "index": 411,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DeclareInd",
      "library": "rocq-runtime.vernac",
      "description": "Handles registration of mutual inductive definitions along with their elimination schemes, working directly with inductive type declarations, universe entries, and implicit argument specifications. Provides operations to declare inductive types with customizable elimination behaviors, including support for primitive projections and dependency tracking. Used specifically during the definition of inductive families where associated schemes and mutual recursion must be explicitly attached and managed.",
      "description_length": 503,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacexpr",
      "library": "rocq-runtime.vernac",
      "description": "This module provides types for parsing and processing Coq's top-level vernacular commands, focusing on proof management, syntax manipulation, and program development. It operates on abstract syntax trees and name representations to handle operations like defining notations, declaring inductive types, specifying recursive functions, and controlling proof state interactions. Key use cases include lemma searching, proof term printing, tactic execution, and module system operations within Coq's interactive theorem proving environment.",
      "description_length": 536,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Topfmt",
      "library": "rocq-runtime.vernac",
      "description": "This module offers operations to configure console formatting parameters (e.g., margins, depth limits), manage output formatters for contexts like error reporting or deep inspection, and control colored/styled logging with terminal-specific behaviors. It operates on formatters, output channels, structured documents (`Pp.t`), and execution phases, enabling use cases such as interactive theorem proving environments, Emacs integration via custom output routing, and phase-aware logging with dynamic redirection to files or error streams.",
      "description_length": 538,
      "index": 414,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Indschemes",
      "library": "rocq-runtime.vernac",
      "description": "This module implements induction and rewriting scheme generation for inductive types, including mutual induction, congruence, and equality schemes. It operates on inductive type definitions represented via identifiers, constants, and environments, producing associated elimination principles and registered schemes. Concrete use cases include automatically deriving induction principles for custom inductive types and building combined schemes for multiple inductive definitions.",
      "description_length": 479,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proof_using",
      "library": "rocq-runtime.vernac",
      "description": "This module processes `using` expressions in definitions to determine sets of identifiers that influence proof terms, specifically handling section variables and constants. It provides functions to extract and suggest identifiers based on environment context, and supports parsing and storing `using` clauses from strings or default settings. Concrete use cases include managing dependencies in Coq proofs and ensuring correct term scoping during proof construction.",
      "description_length": 466,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernac_classifier",
      "library": "rocq-runtime.vernac",
      "description": "This module classifies vernacular commands and provides string representations of those classifications. It works with `vernac_control` and `vernac_classification` types to determine the effect of a vernacular command, such as starting a proof or modifying the environment. It is used to control proof nesting behavior and command processing in the Coq interactive environment.",
      "description_length": 377,
      "index": 417,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "G_vernac",
      "library": "rocq-runtime.vernac",
      "description": "This module provides parsing and processing capabilities for Coq's vernacular commands, focusing on proof-related operations, declarations, and syntactic constructs. It operates on Coq's internal syntax trees and parsing structures to support tasks like proof state manipulation, identifier pattern recognition (e.g., variance, pluralization), goal selector parsing, and syntax customization through modifiers and delimiters.",
      "description_length": 425,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppvernac",
      "library": "rocq-runtime.vernac",
      "description": "This module provides functions to pretty-print Coq's vernacular expressions and related components, such as syntax modifiers, recursive definitions, and proof using clauses. It operates on data types like `vernac_expr`, `syntax_modifier`, `recursive_expr_gen`, and `scheme`, producing formatted output suitable for display or logging. Use cases include rendering Coq commands for user feedback, pretty-printing proof scripts, and generating readable representations of internal syntax structures.",
      "description_length": 496,
      "index": 419,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ComSearch",
      "library": "rocq-runtime.vernac",
      "description": "This module processes Coq's search commands by interpreting search requests and restrictions into a form suitable for execution. It translates high-level vernacular expressions into internal representations involving global identifiers and directory paths. Concrete use cases include handling `Search` and `SearchAbout` commands in the Coq interpreter, enabling users to locate definitions, lemmas, or modules based on patterns or identifiers.",
      "description_length": 443,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacextend",
      "library": "rocq-runtime.vernac",
      "description": "This module defines data structures and functions for extending Coq's vernacular language, including classification of commands (proof steps, queries, side effects), handling of proof modes, and management of command extensions. It supports parsing, typing, and execution classification of custom vernacular commands through static and dynamic extension mechanisms. Concrete use cases include defining new top-level commands, extending existing vernacular syntax, and integrating plugin-provided language constructs with Coq's proof engine.",
      "description_length": 540,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComTactic",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the interpretation and execution of tactics within a proof state, supporting both sequential and parallel solving strategies. It works with proof states, tactic interpreters, and goal selectors, enabling concrete operations like registering tactic interpreters, solving selected goals, and configuring parallel execution behavior. It is used to implement tactic evaluation in proof assistants, allowing for interactive proof development with precise goal manipulation and parallel strategy customization.",
      "description_length": 524,
      "index": 422,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ComRewriteRule",
      "library": "rocq-runtime.vernac",
      "description": "This module processes symbolic expressions and rewrite rules for Coq's vernacular commands. It handles operations like unfolding fixpoints and applying coercion flags to lists of identifiers and constraint expressions. The primary use case involves transforming and rewriting terms during proof or definition processing.",
      "description_length": 320,
      "index": 423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComAssumption",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the declaration and interpretation of assumptions and contexts in Coq's vernacular language. It provides operations for declaring local and global variables, axioms, and definitions, along with interpreting context binders and assumption blocks into internal types and constraints. It works directly with Coq's internal syntax trees, environments, and evar_maps, producing global references and universe instances as part of declaration results.",
      "description_length": 465,
      "index": 424,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metasyntax",
      "library": "rocq-runtime.vernac",
      "description": "This module enables syntax extension and manipulation through operations like notation declaration, scope management, and grammar customization, working with types such as syntax rules, notation interpretations, and scope identifiers. It supports validation of custom syntax entries and pretty-printing of structured notations, serving use cases such as defining domain-specific languages, modular syntax scoping, and ensuring grammatical correctness in Coq extensions.",
      "description_length": 469,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "VernacControl",
      "library": "rocq-runtime.vernac",
      "description": "This module manages control flow and state transitions for executing vernacular commands, handling timeouts, and propagating effects like exceptions or final messages. It works with control flags, location information, and state wrappers to sequence command phases and determine post-execution behavior. Concrete use cases include running commands under controlled evaluation contexts, applying default timeouts, and finalizing command outcomes by printing messages or raising exceptions.",
      "description_length": 488,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComFixpoint",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the declaration and type-checking of recursive and corecursive functions in Coq. It processes fixpoint and cofixpoint definitions, resolving mutual recursion and generating obligations for dependent pattern matching. Concrete use cases include defining recursive functions with `Fixpoint` and corecursive values with `CoFixpoint`, ensuring termination or productivity constraints are met.",
      "description_length": 408,
      "index": 427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacstate",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the combined syntactic and semantic state of Coq's vernacular processing. It supports freezing and restoring the full system state, handling incremental parsing, proof context transitions, and state manipulation during tactic execution. Concrete use cases include checkpointing and restoring proof contexts, running stateful computations without permanent side effects, and managing proof stacks during interactive theorem proving.",
      "description_length": 451,
      "index": 428,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Firstorder_plugin.G_ground",
      "library": "firstorder_plugin",
      "description": "This module defines a generalized argument type and entry point for invoking first-order logic tactics with specified hypotheses and variables. It works with lists of qualified identifiers, located references, and tactic arguments. It is used to implement the `firstorder` tactic with custom hypothesis selection in proof scripts.",
      "description_length": 330,
      "index": 429,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Firstorder_plugin",
      "library": "firstorder_plugin",
      "description": "This module implements the core machinery for executing first-order logic tactics, centered around hypothesis selection and variable handling. It operates on lists of qualified identifiers, located references, and tactic arguments to enable precise control over logical reasoning steps. It is directly used to implement the `firstorder` tactic with customizable hypothesis management in proof scripts.",
      "description_length": 401,
      "index": 430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssrmatching_plugin.Ssrmatching.Internal",
      "library": "ssrmatching_plugin",
      "description": "This module handles the construction, transformation, and interpretation of pattern-matching structures used in proof scripting. It defines operations for substituting, globbing, and printing patterns and terms, along with utilities for building and processing pattern expressions in both concrete and internal forms. It is used during tactic execution to manipulate match patterns and embedded terms within the proof context.",
      "description_length": 426,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssrmatching_plugin.G_ssrmatching",
      "library": "ssrmatching_plugin",
      "description": "This module defines parsing entries and argument types for pattern matching constructs used in proof scripting. It supports concrete syntax for patterns like function applications, in-binding, and as-binding in both closed and open scopes. These are used to implement tactics that match and destructure terms in Coq proofs.",
      "description_length": 323,
      "index": 432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssrmatching_plugin",
      "library": "ssrmatching_plugin",
      "description": "This module provides functions for parsing and handling pattern matching constructs in proof scripts, supporting operations like function application, in-binding, and as-binding. It works with Coq's term and pattern data structures to enable precise term matching and destructuring during proof automation. Concrete use cases include implementing custom tactics that analyze and transform proof goals based on specific term structures.",
      "description_length": 435,
      "index": 433,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Btauto_plugin.Refl_btauto.Btauto",
      "library": "btauto_plugin",
      "description": "This module implements a reflexive tactic for solving equations in a Boolean algebra structure. It works with propositional formulas represented as terms in a Coq proof context. The `tac` function applies a decision procedure to automatically prove equalities that hold in all Boolean algebras.",
      "description_length": 294,
      "index": 434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Btauto_plugin.Refl_btauto",
      "library": "btauto_plugin",
      "description": "This module implements a reflexive tactic for solving Boolean algebra equations using a decision procedure. It operates on propositional formulas encoded as Coq terms, enabling automatic proof of equalities valid in all Boolean algebras. A concrete use case is automating proofs of logical equivalences in formal verification tasks.",
      "description_length": 332,
      "index": 435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Btauto_plugin",
      "library": "btauto_plugin",
      "description": "This module provides a reflexive tactic for solving Boolean algebra equations using a decision procedure. It operates on propositional formulas encoded as Coq terms, enabling automatic proof of equalities valid in all Boolean algebras. A concrete use case is automating proofs of logical equivalences in formal verification tasks.",
      "description_length": 330,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logic_monad.Logical.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations for logical computations, including mapping, folding, and filtering over lists with left-to-right or right-to-left effect sequencing. It supports operations on single lists and pairs of lists, such as `map`, `fold_left`, `fold_right`, and `map_filter`, all returning results in a logical monad. Concrete use cases include transforming and accumulating values across lists while threading logical effects like backtracking, and comparing or combining elements from two lists of equal length.",
      "description_length": 535,
      "index": 437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.MonadR.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations for working with computations that carry a unification state. It supports mapping, folding, and filtering over lists with left-to-right or right-to-left effect ordering, and includes specialized functions for iterating over two lists in parallel. These operations are designed for manipulating lists of values within the `Evd.MonadR` context, such as processing evar-related data or handling conversion constraints in the tactic engine.",
      "description_length": 481,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logic_monad.Logical.Unsafe",
      "library": "rocq-runtime.engine",
      "description": "This module provides low-level monadic operations for manipulating and composing backtracking computations that operate over a state type `state`. It includes functions like `make` and `repr` for wrapping and unwrapping stateful computations that involve backtracking, proof manipulation, and exception handling. Concrete use cases include implementing tactics that require fine-grained control over state transitions and failure recovery during proof search.",
      "description_length": 459,
      "index": 439,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.MiniEConstr.EInstance",
      "library": "rocq-runtime.engine",
      "description": "This module provides direct operations for creating and manipulating lightweight instance representations used during unification in the tactic engine. It works with `EInstance.t`, a minimal structure wrapping `UVars.Instance.t`, and supports concrete tasks like instance construction, inspection, and emptiness checks. It is used internally during the bootstrapping of `EConstr` to manage variable instantiations efficiently.",
      "description_length": 426,
      "index": 440,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.Logical.Unsafe",
      "library": "rocq-runtime.engine",
      "description": "This module provides low-level operations for manipulating the internal state of the tactic monad, including direct access and modification of proof state components like e, u, w, and s. It works with monadic values that carry this structured state and supports operations that require explicit state threading or inspection. Concrete use cases include implementing custom tactic combinators that need to query or update specific parts of the proof state during tactic execution.",
      "description_length": 479,
      "index": 441,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Logic_monad.NonLogical.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations such as mapping, filtering, and folding, where each function threads non-logical effects through computations. It works with lists of arbitrary types and monadic functions that return values wrapped in the non-logical monad. These functions are used for tasks like transforming and reducing lists while performing I/O or modifying persistent state, such as logging elements during traversal or accumulating results in a fixed order.",
      "description_length": 477,
      "index": 442,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview.Monad.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations for tactics, including mapping, folding, and filtering over lists with left-to-right or right-to-left traversal. It supports list-based iteration and transformation while threading monadic effects through tactic computations. Use cases include applying tactics to each goal in sequence, accumulating results across multiple goals, or conditionally transforming goal lists within proof scripts.",
      "description_length": 438,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.Logical.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides list traversal and transformation functions within the `Proofview_monad.Logical` context, including mapping, filtering, and left/right folding operations. It works with lists of values wrapped in the `Proofview_monad.Logical.t` effect, allowing sequential composition of tactics over list elements. It is used to manipulate lists of proof-related data, such as goals or hypotheses, in a monadic workflow.",
      "description_length": 425,
      "index": 444,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evd.MiniEConstr.ERelevance",
      "library": "rocq-runtime.engine",
      "description": "This module provides functions to create and inspect relevance values for use in unification and type checking, specifically handling the conversion between `Evd.MiniEConstr.ERelevance.t` and `Sorts.relevance`. It operates on the `evar_map` unification state and relevance markers to track whether a term should be considered relevant or irrelevant during inference. Concrete use cases include managing erasure and relevance annotations in Coq's type theory during tactic execution and unification.",
      "description_length": 498,
      "index": 445,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.Monad.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations for working with the unification state, including mapping, folding, and filtering over lists with effects in the `Evd.Monad`. It supports left-to-right and right-to-left traversal, tail-recursive iterations, and two-list folds, all while threading the unification state through computations. Use cases include transforming or inspecting lists of existential variables, constraints, or proof terms within the tactic engine.",
      "description_length": 467,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.MiniEConstr.ESorts",
      "library": "rocq-runtime.engine",
      "description": "This module provides direct conversions between `Sorts.t` and an abstract representation of sort values, primarily through `make` and `unsafe_to_sorts`. It operates on the `evar_map` and `Sorts.t` types, enabling low-level manipulation of sort information within unification states. It is used during the early stages of constructing and deconstructing constrained sort values in unification processes.",
      "description_length": 402,
      "index": 447,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview.NonLogical.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations for executing non-logical effects within the proofview tactic system. It supports mapping, folding, and iteration over single and paired lists, preserving left-to-right or right-to-left evaluation order and handling effectful computations in tactics. Concrete use cases include transforming and filtering goal lists with side effects, accumulating state across multiple goals, and synchronizing operations on parallel lists during proof manipulation.",
      "description_length": 495,
      "index": 448,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview.NonLogical",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic operations for executing non-logical effects such as I/O, mutable state manipulation, and exception handling within tactics. It works with the `'a t` monad representing effectful computations, and includes utilities for sequencing, mapping, references, printing, and exception control. Concrete use cases include logging debug information, reading user input during proof manipulation, and managing mutable state across tactic executions.",
      "description_length": 467,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EConstr.EInstance",
      "library": "rocq-runtime.engine",
      "description": "This module represents and manipulates evar instances in the context of Coq's elaboration process. It provides operations to create, inspect, and check empty instances using the `UVars.Instance.t` type. Concrete use cases include handling existential variable instantiations during type inference and tactic execution.",
      "description_length": 318,
      "index": 450,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview.Goal",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations to inspect and manipulate individual proof goals within a tactic context. It supports data types like `t` for representing goals, along with functions to access their conclusion, hypotheses, environment, and existential variable map. Use cases include writing custom tactics that analyze or transform specific goals, checking whether a goal is solved, or applying goal-specific operations across multiple goals.",
      "description_length": 443,
      "index": 451,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evd.MiniEConstr",
      "library": "rocq-runtime.engine",
      "description": "This module provides low-level conversion utilities between constrained and unconstrained term representations, focusing on bootstrapping operations for existential variable management. It operates on evar_map structures and econstr terms, handling context-sensitive data like declarations, case analysis primitives, and instance parameters through both safe and unsafe transformation functions. Its primary role supports unification state initialization in Coq's tactic engine, particularly during EConstr setup where direct manipulation of existential variable metadata and conversion constraints is required.",
      "description_length": 611,
      "index": 452,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.StateStore",
      "library": "rocq-runtime.engine",
      "description": "This module implements a key-value store for managing dynamic fields within the tactic monad's state. It supports creating, setting, retrieving, and merging typed fields in a state container. It is used to track and manipulate per-state data like proof context extensions or tactic-specific metadata during proof construction.",
      "description_length": 326,
      "index": 453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logic_monad.Logical",
      "library": "rocq-runtime.engine",
      "description": "This module implements monadic primitives for composing logical computations with backtracking, including bind (`>>=`), sequencing (`>>`), and state manipulation operations (`get`, `set`, `modify`) over abstract state types `P.s`, `P.w`, and `P.e`. It provides control flow mechanisms like non-deterministic choice (`plus`, `zero`), exception handling, and state transitions, alongside utilities to lift non-logical effects into logical contexts. These features enable advanced proof search strategies, stateful execution with backtracking, and robust handling of exceptions in domains like automated reasoning or tactic-based theorem proving.",
      "description_length": 643,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.Abstraction",
      "library": "rocq-runtime.engine",
      "description": "This module manages a list of abstraction markers used to track evar unification strategies during tactic execution. It provides operations to create an identity abstraction list and extend it by adding a new abstraction marker at the end. These abstractions influence how existential variables are instantiated in the unification process, particularly in higher-order pattern unification scenarios.",
      "description_length": 399,
      "index": 455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview.UnsafeRepr",
      "library": "rocq-runtime.engine",
      "description": "This module exposes low-level operations for manipulating the internal state of the proof monad, allowing direct access to the underlying computation structure of tactics. It provides functions to convert between abstract tactics and their concrete monadic representations, working with the `state` type that encapsulates the proof environment's mutable context. Use cases include advanced tactic manipulation, debugging, and building custom control structures that interact with the proof state at a granular level.",
      "description_length": 516,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview.Notations",
      "library": "rocq-runtime.engine",
      "description": "This module provides infix operators for composing tactics and sequencing their effects within the proof state. It supports operations like binding (`>>=`) to chain tactics with value passing, sequential application (`<*>`), and alternative execution (`<+>`). These combinators are used to build complex proof scripts by combining simpler tactics that manipulate goals and existential variables.",
      "description_length": 395,
      "index": 457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evarutil.VarSet",
      "library": "rocq-runtime.engine",
      "description": "This module represents sets of variables and supports operations like union, intersection, and membership testing. It works with variable sets in the context of environments and evar management. Concrete use cases include tracking variables in a context or determining dependencies in evar resolution.",
      "description_length": 301,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.Comb",
      "library": "rocq-runtime.engine",
      "description": "This module provides direct access to the list of focused goals within the tactic monad, allowing retrieval, modification, and replacement of the current goal state. It operates specifically on lists of `goal_with_state` values, enabling precise control over goal manipulation during proof construction. Concrete use cases include inspecting the current list of goals, updating goal states, or transforming the structure of pending goals in response to tactic application.",
      "description_length": 472,
      "index": 459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.Trace",
      "library": "rocq-runtime.engine",
      "description": "This module builds and manipulates trace structures during tactic execution, primarily for logging and debugging. It provides operations to open and close hierarchical trace nodes, and to convert incremental traces into forest representations. These operations work with the `'a incr` and `'a forest` types, enabling structured tracing of tactic steps with named tags.",
      "description_length": 368,
      "index": 460,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview.Progress",
      "library": "rocq-runtime.engine",
      "description": "This module tracks and manages progress during proof construction by comparing goals and proof states. It provides functions to determine when a goal has been simplified or transformed, using precise equality checks on existential variables and their associated constraints. It works with proofview states, evar_maps, and individual goals, enabling tactics to detect whether they have made progress toward solving a goal.",
      "description_length": 421,
      "index": 461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nameops.Name",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations for constructing, inspecting, and transforming identifiers that may be anonymous. It works with the variant type `t` representing names, which are either `Anonymous` or wrapped `Names.Id.t`. Concrete use cases include handling bound variables in formal logic systems, managing optional identifiers in abstract syntax trees, and supporting transformations that preserve or modify name information.",
      "description_length": 428,
      "index": 462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EConstr.ERelevance",
      "library": "rocq-runtime.engine",
      "description": "This module represents and manipulates the relevance of terms in the context of existential variables. It provides operations to create, compare, and check relevance values, specifically working with `Sorts.relevance` and `EConstr.ERelevance.t`. Use cases include tracking whether a term should be considered relevant during proof search or type inference.",
      "description_length": 356,
      "index": 463,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UnivMinim.UPairSet",
      "library": "rocq-runtime.engine",
      "description": "This library handles collections of unordered pairs of universe levels, enabling efficient set operations like union, intersection, and difference while preserving element ordering. It supports transformations, filtering, and ordered traversal over these pairs, with utilities for sequence-based construction and iteration. Such functionality is useful in formal verification or type systems where managing symmetric relationships between hierarchical type universes is required.",
      "description_length": 479,
      "index": 464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Termops.Internal",
      "library": "rocq-runtime.engine",
      "description": "This module provides low-level term and context printing utilities for debugging and specialized output scenarios. It operates on Coq's internal term representations, including `EConstr.constr`, `Constr.rel_declaration`, and environments paired with evar maps. Functions like `debug_print_constr` and `print_named_context` are used to inspect raw or partially substituted terms and contexts during development or error reporting.",
      "description_length": 429,
      "index": 465,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview_monad.Solution",
      "library": "rocq-runtime.engine",
      "description": "This module provides direct access to the `evar_map` within the proofview state, allowing retrieval, modification, and replacement of existential variable mappings during tactic execution. It supports operations like updating unification variables or querying current variable assignments. Concrete use cases include implementing custom tactics that manipulate or inspect the state of existential variables during proof construction.",
      "description_length": 433,
      "index": 466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UState.Internal",
      "library": "rocq-runtime.engine",
      "description": "Handles low-level universe unification state manipulations, including operations for merging and comparing universe constraints. Works directly with universe states and environment data structures to manage complex unification scenarios. Used internally during type inference and unification in the presence of universe polymorphism and program mode features.",
      "description_length": 359,
      "index": 467,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nameops.Fresh",
      "library": "rocq-runtime.engine",
      "description": "This module manages the generation of fresh identifiers by tracking used names and ensuring uniqueness. It provides operations to add, remove, and check used names, as well as generate new unique names based on existing ones. It works with identifier sets, lists, and context values to support tasks like variable renaming and name resolution in formal verification or compiler pipelines.",
      "description_length": 388,
      "index": 468,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Namegen.Generator",
      "library": "rocq-runtime.engine",
      "description": "This module manages the generation of fresh names and tracks identifier usage. It provides operations to produce unique identifiers, retrieve current identifier sets, and compute name mappings with subscript tracking. Concrete use cases include avoiding name collisions during code generation and managing identifier states in transformations.",
      "description_length": 343,
      "index": 469,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.Pv",
      "library": "rocq-runtime.engine",
      "description": "This module provides direct access to the internal proofview state within the tactic monad, allowing retrieval, modification, and replacement of the current proofview. It operates on the `proofview` type, using monadic actions to interact with the logical context. Concrete use cases include inspecting or altering the current proof state during tactic execution, such as adjusting goals or hypotheses programmatically.",
      "description_length": 419,
      "index": 470,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.P",
      "library": "rocq-runtime.engine",
      "description": "This module defines specialized monadic operations for managing proof states and environment interactions within the tactic monad. It works with data types like `s` (proofview and environment pairs), `w` (used for tracking warnings), and `e` (tactic metadata including trace flags and names). Concrete use cases include composing tactics with warning handling, tracking tactic execution state, and managing proof-specific context during interactive theorem proving.",
      "description_length": 465,
      "index": 471,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.Store",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations to manage a key-value store for attaching arbitrary data to unification states. It supports creating, setting, retrieving, and merging typed fields within a store, enabling efficient storage and retrieval of structured information. Concrete use cases include tracking solver-specific metadata, caching intermediate results during proof search, or associating custom annotations with existential variables.",
      "description_length": 437,
      "index": 472,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Logic_monad.BackState",
      "library": "rocq-runtime.engine",
      "description": "This module implements a backtracking state monad that supports logical operations with stateful computations, where changes to the state can be rolled back upon failure. It provides functions for binding, mapping, state manipulation (get, set, modify), error handling (zero, plus, interleave), and control operators (once, break) over a polymorphic state and error type. Concrete use cases include implementing tactics in proof assistants that require backtracking and state management, such as theorem proving or constraint solving.",
      "description_length": 534,
      "index": 473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.InfoL",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations to manipulate and annotate the info trace within the tactic monad, including opening and closing trace tags, tagging computations, and updating trace state. It works directly with the `Proofview_monad.Info.state` and `Proofview_monad.Info.tag` types to structure and annotate proof execution traces. Concrete use cases include logging structured metadata during tactic execution and tracking nested proof steps via tagged regions in the trace.",
      "description_length": 475,
      "index": 474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview.Trace",
      "library": "rocq-runtime.engine",
      "description": "This module handles tracing and logging within proof scripts, providing functions to record tactic execution traces, log messages, and format trace output. It operates on tactics, environments, and evar_maps, allowing messages to be attached to specific proof steps. Concrete use cases include debugging tactic behavior by inspecting recorded traces and printing structured trace information during proof development.",
      "description_length": 417,
      "index": 475,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.Logical",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic operations for managing structured proof states, including state manipulation (e.g., `get`, `set`, `modify`), backtracking control (e.g., `zero`, `plus`), and exception handling. It operates on the internal proof state composed of environment, universes, warnings, and section variables, with utilities for list processing and low-level state threading. It is used to implement tactics and custom combinator logic requiring explicit state management or non-standard control flow in proof scripts.",
      "description_length": 525,
      "index": 476,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nameops.Subscript",
      "library": "rocq-runtime.engine",
      "description": "Handles subscript incrementing and ordering with string-based numeric representations. Works with the abstract type `t` representing subscripts, supporting operations like `succ` for incrementing and `compare` for ordering. Useful for generating ordered identifiers in contexts like document versions or sequence numbering where subscripts must follow specific string-based numeric rules.",
      "description_length": 388,
      "index": 477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.Status",
      "library": "rocq-runtime.engine",
      "description": "This module provides a single operation, `put`, which updates the tactic status (safe or unsafe) within the logical monad. It works with boolean values to indicate the safety state of a tactic. Use this to mark a tactic as unsafe when performing operations that may affect proof validity.",
      "description_length": 288,
      "index": 478,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.FutureGoals",
      "library": "rocq-runtime.engine",
      "description": "This module manages a collection of future goals represented as existential variables (Evar.t). It provides operations to transform and filter these goals using functions like `map_filter` and `filter`, enabling precise manipulation of the goal set based on custom logic. Common use cases include selectively processing or updating specific goals during proof construction or tactic application.",
      "description_length": 395,
      "index": 479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.Expand",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations for expanding existential variables and instances within a unification state, working directly with `evar_map` and `econstr` types. It includes functions for lifting handles, determining term kinds during expansion, and handling undefined evar instantiations. Concrete use cases include resolving metavariables during tactic execution and normalizing terms with partially applied existentials.",
      "description_length": 425,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EConstr.Vars",
      "library": "rocq-runtime.engine",
      "description": "This module implements substitution, lifting, and variable occurrence checking operations for terms and relativized contexts in Coq's extended constructions. It operates on `EConstr.t` terms, `rel_declaration` values, and `rel_context` structures, supporting transformations under binding environments through instance substitutions, offset adjustments, and universe management. Key use cases include managing bound variables during type inference, normalizing terms under binders, and maintaining context consistency in proof term manipulations.",
      "description_length": 546,
      "index": 481,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview_monad.Info",
      "library": "rocq-runtime.engine",
      "description": "This module manages trace information for tactic execution, providing structured logging through tags like messages, tactic calls, and dispatch markers. It supports operations to collapse nested tactic traces and print formatted output using environment and evar map contexts. Concrete use cases include inspecting proof script behavior and debugging tactic application steps.",
      "description_length": 376,
      "index": 482,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EConstr.Unsafe",
      "library": "rocq-runtime.engine",
      "description": "This module directly converts between EConstr and Constr types with physical identity, handling binders, contexts, and relevance annotations without normalization or evar expansion. It supports unsafe, low-level casts for performance-critical paths in proof term manipulation. Concrete use cases include optimizing conversion checks and working with unnormalized terms in tactic development.",
      "description_length": 391,
      "index": 483,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ftactic.Notations",
      "library": "rocq-runtime.engine",
      "description": "This module provides infix operators for sequencing and combining tactic computations. It works with values of type `'a Ftactic.t`, enabling chaining of tactics where the output of one determines the next step. Concrete use cases include building complex proof automation scripts by composing simpler tactics in a linear, readable flow.",
      "description_length": 336,
      "index": 484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EConstr.Expand",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations for inspecting and manipulating expanded representations of existential variables in Coq's term language. It works with types like `t`, `kind`, and `handle`, which represent terms, term kinds, and references to expanded terms, respectively. Concrete use cases include traversing term structures with `iter` and `iter_with_binders`, expanding instances with `expand_instance`, and reconstructing terms with `repr`.",
      "description_length": 445,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.MonadR",
      "library": "rocq-runtime.engine",
      "description": "This module implements a monad for computations that manipulate unification states, supporting operations like `return`, bind (`>>=`), and sequencing (`>>`). It works with values wrapped in the monadic type `t`, which represents stateful computations over `evar_map`. Use it to compose tactic engine operations that require propagating and modifying unification state, such as solving existential variables or managing conversion constraints.",
      "description_length": 442,
      "index": 486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.Monad",
      "library": "rocq-runtime.engine",
      "description": "This module implements monadic operations for composing computations that manipulate the unification state. It provides bind (`>>=`), sequence (`>>`), return, and map functions, enabling effectful computations that thread an `evar_map` through each operation. These are used to build complex tactic logic that safely propagates changes to existential variables, constraints, and metavariables across steps, such as solving evars, applying conversions, or accumulating proof terms.",
      "description_length": 480,
      "index": 487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EConstr.UnsafeMonomorphic",
      "library": "rocq-runtime.engine",
      "description": "This module directly constructs EConstr terms from constants, inductive types, and constructors. It operates on basic Coq kernel data structures like Names.Constant.t, Names.inductive, and Names.constructor. Use it when building raw terms for proof automation or term manipulation without higher-level abstractions.",
      "description_length": 315,
      "index": 488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logic_monad.NonLogical",
      "library": "rocq-runtime.engine",
      "description": "This module provides a monadic interface for non-backtrackable effects like I/O and persistent state manipulation. It supports operations such as sequencing, mapping, and exception handling, along with imperative references and logging functions that integrate with the proof system's output mechanisms. It is used for tasks like reading input, printing debug information, and managing global state that must persist across tactic failures.",
      "description_length": 440,
      "index": 489,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview.Monad",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic operations for composing tactics, including binding, sequencing, and mapping over values within the tactic monad. It works with the `'a tactic` type, enabling chaining of stateful proof manipulations that return values. Concrete use cases include structuring complex tactic logic by combining simpler tactics, transforming results between steps, and handling control flow such as error propagation or conditional execution within proof scripts.",
      "description_length": 473,
      "index": 490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ftactic.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations for composing effectful computations over lists, including mapping, folding, and filtering with left-to-right or right-to-left traversal. It supports list iteration with sequencing of tactics, allowing transformations and accumulations where each step can produce a tactic effect. These functions are used to build complex goal-directed operations in proof automation, where each list element triggers a tactic that may affect the proof state or depend on prior steps.",
      "description_length": 513,
      "index": 491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.Env",
      "library": "rocq-runtime.engine",
      "description": "This module provides direct access and manipulation of the global environment within the tactic monad. It supports operations to retrieve, update, or modify the environment using `get`, `set`, and `modify`. Concrete use cases include managing proof contexts, loading or unloading definitions, and maintaining global state during tactic execution.",
      "description_length": 346,
      "index": 492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnivProblem.Set",
      "library": "rocq-runtime.engine",
      "description": "This module enables efficient manipulation of ordered collections with unique elements, using a custom comparison function to maintain sorted order. It supports standard set operations like union, intersection, and difference, along with advanced querying via monotonic predicates, ordered iteration, and transformations such as `map`, `filter`, and `split`. Designed for scenarios requiring constraint normalization, sorted sequence conversions, and precise membership tests, it serves domains like constraint satisfaction problems or ordered data processing where uniqueness and traversal order are critical.",
      "description_length": 610,
      "index": 493,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview.Unsafe",
      "library": "rocq-runtime.engine",
      "description": "This module directly manipulates the proof state with low-level operations, exposing functions to set and retrieve goals, modify the evar map, update the environment, and control shelved goals. It works with data types such as `Evd.evar_map`, `Environ.env`, `Proofview_monad.goal_with_state`, and `Evar.t`. These operations are used in advanced scenarios like synchronizing the proof engine with the pretyper or handling goal transformations during tactic execution.",
      "description_length": 466,
      "index": 494,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EConstr.ESorts",
      "library": "rocq-runtime.engine",
      "description": "This module represents and manipulates sort expressions in a way that supports up-to-sort reasoning. It provides operations to construct sorts, query their properties (such as whether they are `Prop`, `SProp`, `Set`, or small), compare them under an evar map, and derive related values like relevance and family. Use cases include managing sort constraints during type inference and checking sort compatibility in unification problems.",
      "description_length": 435,
      "index": 495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.Filter",
      "library": "rocq-runtime.engine",
      "description": "This module implements boolean filters used to selectively process elements in lists, arrays, and sparse lists, where each filter is represented as a sequence of boolean flags. It supports operations like filtering collections, extending and composing filters, and mapping functions over filters and lists. These filters are used to track and manipulate subsets of existential variables or related data structures during unification in the tactic engine.",
      "description_length": 454,
      "index": 496,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Logic_monad",
      "library": "rocq-runtime.engine",
      "description": "This module implements a layered monadic system for managing logical and non-logical effects in proof-related computations. It provides separate interfaces for handling non-backtrackable effects like I/O and persistent state, and for composing backtrackable logical operations with stateful computations. It is used to implement tactics in proof assistants where state changes must roll back on failure, and where non-deterministic search and exception handling are required.",
      "description_length": 475,
      "index": 497,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnivFlex",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations to manipulate flexible universe levels, including defining, constraining, normalizing, and substituting levels within a dynamic hierarchy. It works with universe variables, algebraic constraints, and substitution contexts, tracking both defined and undefined levels in a `UnivFlex.t` structure. These capabilities are used to manage complex universe hierarchies during type checking and to format universe-level diagnostics for debugging or user output.",
      "description_length": 485,
      "index": 498,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evd",
      "library": "rocq-runtime.engine",
      "description": "This module provides low-level operations for managing existential variables (evars) and their metadata\u2014including types, contexts, and constraints\u2014within a unification state (`evar_map`). It supports functionalities like evar creation, modification, and querying, alongside handling universe polymorphism, conversion constraints, and goal shelving, primarily used in Coq's tactic engine for unification and proof automation. Additional features include side effect tracking, future goal management, and context-sensitive instantiation of inductive types and global references.",
      "description_length": 576,
      "index": 499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evarutil",
      "library": "rocq-runtime.engine",
      "description": "This module facilitates creation, normalization, and unification of existential variables (evars) in Coq's type theory, offering utilities for generating evars, resolving constraints, and managing dependencies through variable sets and naming strategies. It operates on evar_maps, universe instances, and contexts, supporting tasks like type inference and proof automation via recursive normalization of terms, judgments, and environments. Key capabilities include dependency tracking, context generalization, and universe subtyping to handle metavariable resolution in dependent type checking.",
      "description_length": 594,
      "index": 500,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnivMinim",
      "library": "rocq-runtime.engine",
      "description": "This module manages universe level constraints using unordered pairs and sets, providing operations for merging, normalizing, and simplifying contexts with respect to universe hierarchies. It works with custom types like `extra`, which includes a set of weak constraints and a set of levels above `Prop`. It is used during type inference and checking to resolve universe levels while ensuring consistency and minimality in Coq's type system.",
      "description_length": 441,
      "index": 501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad",
      "library": "rocq-runtime.engine",
      "description": "This module manages the internal state of a tactic monad in an interactive theorem prover, focusing on structured tracing, dynamic data storage, and precise manipulation of proof states. It operates on specialized state types that track goals, existential variables, and warnings, while supporting environment management, tactic safety status updates, and trace annotations. Key use cases include coordinating tactic execution, persisting transient data across proof states, and generating detailed execution traces for debugging and analysis.",
      "description_length": 543,
      "index": 502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Namegen",
      "library": "rocq-runtime.engine",
      "description": "This module provides facilities to generate fresh, non-clashing identifiers and manage name contexts during proof or term construction, particularly in Coq's type theory. It operates on environments, evar maps, constructor terms, and identifier sets, using a dedicated generator to track unique name assignments. Key applications include avoiding name capture in lambda/product expressions, handling binding constructs in goal contexts, and supporting customizable renaming strategies for global or module-scoped declarations.",
      "description_length": 526,
      "index": 503,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UnivGen",
      "library": "rocq-runtime.engine",
      "description": "This module specializes in generating and manipulating universe levels, sort variables, and global constants within type-theoretic contexts. It operates on environments, global references, and terms to support type checking and tactic development, with utilities for instantiating monomorphic constants while enforcing constraints against polymorphic constructs. Key use cases include managing universe hierarchies, diffing sort contexts, and safely constructing terms with fresh universe instances.",
      "description_length": 499,
      "index": 504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evar_kinds",
      "library": "rocq-runtime.engine",
      "description": "This module defines types and constructors for representing different kinds of existential variables and related metadata used during type inference and proof construction. It includes specific variants for implicit arguments, holes, pattern variables, and obligation handling, along with structured data for record fields and question mark annotations. These types are used to track and resolve incomplete terms, guide unification, and manage definitional constraints in the elaboration process.",
      "description_length": 496,
      "index": 505,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnivProblem",
      "library": "rocq-runtime.engine",
      "description": "This module directly handles universe-level constraints and quality comparisons for type inference, supporting operations like equality, subtyping, and least upper bound enforcement between sorts and universe levels. It works with constraint types such as `QEq`, `QLeq`, `UEq`, `ULe`, `ULub`, and `UWeak`, and includes functions to check level equivalence and enforce instance constraints. Concrete use cases include resolving universe polymorphism during type checking and normalizing constraints in the presence of cumulative inductive types.",
      "description_length": 544,
      "index": 506,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EConstr",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations for constructing, inspecting, and transforming Coq's extended terms (`EConstr.t`), including syntactic primitives like lambda abstractions, applications, inductive types, and case analysis, alongside utilities for handling existential variables (evars), binder annotations, and universe constraints. It works with terms parameterized over relevance information and interacts with environments (`Environ.env`), evar maps (`Evd.evar_map`), and contexts (named or relational) to support type checking, proof term manipulation, and tactic development. Specific use cases include term decomposition for proof search, arity normalization, and low-level term reconstruction during elaboration or Qed closure.",
      "description_length": 733,
      "index": 507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnivSubst",
      "library": "rocq-runtime.engine",
      "description": "This module handles substitutions and constraints for universes and quality variables in a type theory context. It provides functions to map and normalize universes and qualities within terms, enforce equality and ordering constraints between universes, and print universe substitutions. Concrete use cases include universe polymorphism, constraint solving during type checking, and normalizing terms with respect to universe instantiations.",
      "description_length": 441,
      "index": 508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nameops",
      "library": "rocq-runtime.engine",
      "description": "This module manipulates identifiers and names with operations like suffix/prefix addition, subscript handling, and name freshness. It works with identifier types, strings, and subscript modules to manage naming in formal logic systems and compilers. Concrete use cases include variable renaming, document versioning, and sequence numbering with strict naming rules.",
      "description_length": 365,
      "index": 509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Profile_tactic",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations for profiling and timing tactics, including starting and stopping timers, resetting profiling data, and printing detailed performance results. It works with tactic values and a tree-like data structure (`treenode`) to represent profiling results hierarchically. Concrete use cases include measuring execution time of specific tactics, analyzing performance bottlenecks in proof scripts, and exporting profiling data for external analysis.",
      "description_length": 470,
      "index": 510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ftactic",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic operations for building and composing focussing tactics that interact with proof goals. It supports data types such as tactic values (`'a Ftactic.t`) and integrates with proof environments and goal states through operations like `enter` and `with_env`. Concrete use cases include implementing proof automation where tactics selectively focus on goals, sequence operations with `>>=`, and apply list-based transformations to multiple goals using left-to-right tactic sequencing.",
      "description_length": 506,
      "index": 511,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Termops",
      "library": "rocq-runtime.engine",
      "description": "This module supports term construction, substitution, and structural analysis in Coq, focusing on operations involving binders, metavariables, and context manipulations like extension, traversal, and name resolution. It operates on Coq terms (`EConstr.constr`), environments, evar_maps, and both named and relational contexts to enable tasks such as occurrence checking, reduction (e.g., eta-expansion), and debugging constraint displays. These utilities are critical for proof automation, type elaboration, and term inspection workflows that require precise variable binding or context management.",
      "description_length": 598,
      "index": 512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnivNames",
      "library": "rocq-runtime.engine",
      "description": "This module manages mappings between universe levels and their corresponding identifiers, providing operations to convert between local universe names and global levels. It works with data structures like `universe_binders` and `rev_binders`, which associate universe levels with qualified variables or identifiers. Concrete use cases include pretty-printing universe levels with global names and resolving qualified identifiers from universe levels during type checking or error reporting.",
      "description_length": 490,
      "index": 513,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations for managing hierarchical proof states with mutable goals and existential variables, supporting tactics that transform these states through composition, focusing, and backtracking. It works with structured goals and evar maps, enabling use cases like interactive theorem proving, tactic scripting with progress tracking, and IDE integrations requiring goal navigation or time-constrained execution. Key capabilities include dependency-aware goal manipulation, shelving, and non-linear proof flow control via monadic combinators.",
      "description_length": 560,
      "index": 514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Autorewrite.RewRule",
      "library": "rocq-runtime.tactics",
      "description": "This module defines and manipulates rewriting rules used by the autorewrite tactic. It provides access to the lemma, direction (left-to-right or right-to-left), and optional tactic associated with each rule. These rules are applied to terms during automated rewriting to simplify or transform expressions based on predefined equivalences.",
      "description_length": 338,
      "index": 515,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hints.Hint_db",
      "library": "rocq-runtime.tactics",
      "description": "This module manages a database of proof hints, supporting operations to query hints by reference, pattern, or mode constraints, and to manipulate hint entries such as adding, removing, or transforming them. It works with hint databases (`t`), global references, section variables, and environments, and includes functions for filtering hints based on transparency and discrimination nets. Concrete use cases include retrieving applicable hints during proof search, updating hint sets for specific symbols, and managing hint modes and unfoldings in automated tactics.",
      "description_length": 566,
      "index": 516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Btermdn.Make",
      "library": "rocq-runtime.tactics",
      "description": "This module implements discrimination nets for efficient pattern matching and action retrieval based on terms. It supports operations to construct and manipulate patterns using environments, evar maps, and transparency states, with functions to add, remove, and look up actions associated with patterns. It is used to register and query tactics based on term structures, handling both rigid and existential variables.",
      "description_length": 417,
      "index": 517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Redexpr.Intern",
      "library": "rocq-runtime.tactics",
      "description": "Interns raw reduction expressions into generalized forms using a context-aware environment. It processes `raw_red_expr` structures into typed `red_expr_gen` values, resolving variables and constants. This supports concrete tasks like normalizing expressions during evaluation or compiling high-level reduction rules into executable forms.",
      "description_length": 338,
      "index": 518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Class_tactics.Search",
      "library": "rocq-runtime.tactics",
      "description": "This module provides a tactic for automatically solving goals using a collection of hints and customizable search strategies. It operates on goals in a proof context, applying typeclass resolution with support for modes, transparency states, and dependency tracking. Concrete use cases include discharging proof obligations involving typeclass instances, such as resolving implicit constraints or proving interface implementations.",
      "description_length": 431,
      "index": 519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rewrite.Internal",
      "library": "rocq-runtime.tactics",
      "description": "Implements internal helpers for constructing and manipulating term signatures and morphisms during rewriting. Works with environments, evar maps, and constr expressions to build and transform logical structures. Used to support higher-level rewriting operations by generating appropriate term transformations and handling metavariables.",
      "description_length": 336,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hints.FullHint",
      "library": "rocq-runtime.tactics",
      "description": "This module defines a type `t` representing fully elaborated hints used in proof automation. It provides access to hint properties such as priority, matching pattern, source database, and name, along with functions to execute and print hints in a proof context. It is used to manage and apply user-defined or system-generated proof hints during tactic execution.",
      "description_length": 362,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Redexpr.Interp",
      "library": "rocq-runtime.tactics",
      "description": "Interprets reduction expressions in environments with support for evaluating terms, handling evar maps, and expanding redexes. Works with constr, evref, and pat types, along with red_expr_gen structures. Used to implement reduction strategies like HNF or CBV in Coq's evaluation pipeline.",
      "description_length": 288,
      "index": 522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ind_tables.Locmap",
      "library": "rocq-runtime.tactics",
      "description": "This module maps inductive types to their associated locations using a structured table. It provides operations to create and query location mappings for mutual and individual inductive schemes. Use it to track source location information for inductive definitions during scheme generation.",
      "description_length": 290,
      "index": 523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dn.Make",
      "library": "rocq-runtime.tactics",
      "description": "This module implements a structured table for associating decomposable tree-like objects with information values. It supports adding, removing, and querying entries using a decomposition function that breaks down a term into its root label and subterms. Concrete use cases include building and querying term-indexed data structures, such as matching terms against patterns derived from their syntactic structure.",
      "description_length": 412,
      "index": 524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tactics.Simple",
      "library": "rocq-runtime.tactics",
      "description": "This module provides basic proof manipulation tactics such as introducing hypotheses, applying lemmas, and performing case analysis. It operates on Coq's proof state using identifiers and constructed terms to modify goals and hypotheses directly. These tactics are used to build and manipulate proofs interactively or in scripts, particularly in contexts like theorem proving and goal refinement.",
      "description_length": 396,
      "index": 525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tactics.Internal",
      "library": "rocq-runtime.tactics",
      "description": "This module handles introduction patterns and variable management in proof tactics, providing operations for checking name uniqueness, clearing variables, and destructuring introduction patterns. It works with data types like `intro_pattern_expr`, `Id.t`, `lident`, and `named_context_val`, alongside environments and evar maps. Concrete use cases include processing tactic arguments for variable binding, managing variable visibility in proofs, and handling pattern-based introductions in logical goals.",
      "description_length": 504,
      "index": 526,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elimschemes",
      "library": "rocq-runtime.tactics",
      "description": "This module implements induction and recursion schemes for generating case analysis primitives in a type system. It provides functions to construct elimination schemes for inductive types, supporting both dependent and non-dependent cases, as well as specialized variants for different handling of parameters. These operations are used during type checking to derive induction principles and recursion combinators for user-defined inductive data types.",
      "description_length": 452,
      "index": 527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DeclareScheme",
      "library": "rocq-runtime.tactics",
      "description": "This module manages the registration and lookup of inductive scheme constants. It provides operations to declare a scheme with a given name and inductive type, retrieve a scheme by name and inductive type, and list all registered schemes. The core data structures are maps from strings and inductive types to constants, supporting efficient scheme resolution during proof construction or term processing.",
      "description_length": 404,
      "index": 528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eqdecide",
      "library": "rocq-runtime.tactics",
      "description": "This module implements tactics for comparing terms and deciding equality goals in Coq's proof engine. It operates on `EConstr.t` values, which represent terms in the extended calculus of constructions. Use cases include implementing custom equality checks and automating proofs involving term comparison.",
      "description_length": 304,
      "index": 529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genredexpr",
      "library": "rocq-runtime.tactics",
      "description": "This module processes reduction expressions in both raw and globally resolved forms, supporting operations like normalization and head reduction. It works with intermediate types such as `red_atom`, `raw_red_expr`, and `glob_red_expr`, which involve constraint expressions, patterns, and loci. It is used during tactic parsing and execution to specify and apply reduction strategies in proof terms.",
      "description_length": 398,
      "index": 530,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Redops",
      "library": "rocq-runtime.tactics",
      "description": "This module handles reduction expressions and flags for custom data structures, providing operations to construct and transform reduction expressions. It works with generalized reduction expressions (`red_expr_gen`) and global reduction flags (`glob_red_flag`), allowing mapping over their components. Concrete use cases include defining reduction strategies for symbolic computation or optimizing expression traversal in domain-specific languages.",
      "description_length": 448,
      "index": 531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hipattern",
      "library": "rocq-runtime.tactics",
      "description": "This component provides second-order pattern matching and logical structure decomposition for Coq terms, focusing on detecting inductive forms (non-recursive types, conjunctions, disjunctions, equality) and analyzing binder-preserving term relationships. It operates on `EConstr.constr` terms within environments and evar maps, using free-variable analysis to handle ad-hoc type definitions and second-order metavariables. Common applications include logical term deconstruction (e.g., extracting Leibniz equality arguments, identifying negations as implications to `False`), and supporting tactic development through generic recognition of sigma types, homogeneous relations, and user-defined inductive forms without relying on type names.",
      "description_length": 740,
      "index": 532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Equality",
      "library": "rocq-runtime.tactics",
      "description": "This module provides tactics for equality manipulation, including directional rewriting, injection, substitution, and equality destruction, enabling precise control over proof transformations. It operates on Coq proof terms (`EConstr.constr`), hypotheses (`Names.Id.t`), and clauses, with support for dependency preservation and evar instantiation. These tools are used to manage equality reasoning in proofs, such as transforming hypotheses or conclusions, handling conditional equalities, and performing substitutions while maintaining or discarding proof obligations as needed.",
      "description_length": 580,
      "index": 533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cbn",
      "library": "rocq-runtime.tactics",
      "description": "Implements weak-head and full normalization variants of the cbn reduction strategy for Coq's kernel-level terms. Operates on `EConstr.constr` values under a given environment, evar map, and reduction flags. Used during type checking and proof normalization to compute canonical forms of expressions according to the cbn evaluation order.",
      "description_length": 337,
      "index": 534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ind_tables",
      "library": "rocq-runtime.tactics",
      "description": "This module manages the declaration and generation of inductive scheme objects, supporting both mutual and individual inductive types. It provides functions to define, retrieve, and look up schemes based on their kind, with support for dependencies and location tracking through the `Locmap` submodule. Use it to generate and cache induction or case analysis schemes for inductive types during proof or term construction tasks.",
      "description_length": 427,
      "index": 535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dn",
      "library": "rocq-runtime.tactics",
      "description": "This module handles domain name parsing, manipulation, and validation. It provides functions for converting domain names between string and structured representations, checking their validity, and extracting components like subdomains and TLDs. Use cases include URL processing, DNS-related logic, and domain normalization for comparison or storage.",
      "description_length": 349,
      "index": 536,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Auto",
      "library": "rocq-runtime.tactics",
      "description": "This module implements automated proof search tactics, primarily focusing on unification-based resolution and pattern matching. It operates on proof goals, hint databases, and constructor patterns to automatically apply lemmas and hints during proof construction. Concrete use cases include the `auto` tactic for solving goals using predefined hint databases and customizable search depth, and `unify_resolve` for attempting unification with specific hints followed by applying them.",
      "description_length": 483,
      "index": 537,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hints",
      "library": "rocq-runtime.tactics",
      "description": "This component provides operations for decomposing proof terms, managing hint databases, and manipulating hint execution properties through path-based filtering and mode constraints. It operates on Coq's proof terms, global references, transparency states, and discrimination nets, enabling automated tactics to resolve, unfold, or apply hints dynamically during proof search. Key use cases include tracking non-imported hints, generating fresh hint entries, and maintaining context-sensitive databases for efficient tactic execution.",
      "description_length": 534,
      "index": 538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Contradiction",
      "library": "rocq-runtime.tactics",
      "description": "This module implements tactics for handling contradictions in proof terms. It provides `absurd`, which takes a proof term and applies an absurdity tactic to derive a contradiction, and `contradiction`, which attempts to derive a contradiction from an optional bound proof term. These tactics are used in proof automation to discharge goals by showing inconsistency in the hypotheses.",
      "description_length": 383,
      "index": 539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elim",
      "library": "rocq-runtime.tactics",
      "description": "This module provides tactics for performing case analysis and decomposition of inductive types. It operates on proof goals by breaking down complex inductive structures into simpler components, using functions like `case_tac` for case analysis and `h_decompose` variants for splitting conjunctions and disjunctions. These tactics directly manipulate proof states, inductive terms, and constructor patterns to guide proof construction in specific cases.",
      "description_length": 452,
      "index": 540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rewrite",
      "library": "rocq-runtime.tactics",
      "description": "This module facilitates rewriting strategies through combinators (unary, binary, n-ary) and manages term transformations in logical contexts, leveraging constructions, environments, and evar_maps. It enables proof-centric operations like rewrite proof generation, tactic execution, and setoid relation handling (e.g., symmetry, transitivity) while supporting advanced transformations via logical morphisms and signatures. Key use cases include parsing and applying rewrite strategies, tracking transformation results, and interacting with metavariables in Coq's internal term structures.",
      "description_length": 587,
      "index": 541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Class_tactics",
      "library": "rocq-runtime.tactics",
      "description": "This module provides tactics for automated typeclass resolution in proof contexts, supporting customizable search strategies like depth-first and breadth-first search. It operates on goals involving typeclass constraints, using hint databases and configurable parameters such as depth limits and transparency states. Concrete use cases include resolving implicit typeclass instances and proving interface implementations during proof construction.",
      "description_length": 447,
      "index": 542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Redexpr",
      "library": "rocq-runtime.tactics",
      "description": "This module processes and evaluates reduction expressions using environment contexts, supporting operations like normalization and expansion of terms through functions such as `eval_red_expr` and `reduction_of_red_expr_val`. It works with data types including `red_expr`, `red_expr_val`, and structures from `Genredexpr`, handling substitutions, internment, and interpretation of reduction rules. Concrete use cases include implementing call-by-value reduction via `cbv_vm`, declaring custom reductions with `declare_reduction`, and setting expansion strategies for constants with `set_strategy`.",
      "description_length": 596,
      "index": 543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppred",
      "library": "rocq-runtime.tactics",
      "description": "This module provides functions for pretty-printing reduction-related constructs, such as red flags, occurrences, and reduction expressions. It operates on data types like `Genredexpr.glob_red_flag`, `Genredexpr.red_expr_gen`, and `Locus.occurrences_gen`, typically used in the context of Coq's reduction mechanisms. Concrete use cases include formatting reduction strategies and occurrence annotations for display or debugging in proof assistants.",
      "description_length": 447,
      "index": 544,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evar_tactics",
      "library": "rocq-runtime.tactics",
      "description": "This module provides tactics for instantiating existential variables and introducing local definitions during proof construction. It operates on proof goals by manipulating hypotheses and evars, using identifiers, names, and pretyped constructions. Concrete use cases include refining incomplete proof terms by assigning values to existential variables or binding local constants with `let` definitions.",
      "description_length": 403,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Inv",
      "library": "rocq-runtime.tactics",
      "description": "This module implements tactics for performing inversion on hypotheses in a proof context, supporting both simple and full inversion with optional clearing of dependencies. It operates on quantified hypotheses and uses custom patterns for introducing results, handling dependencies via optional constraints and identifiers. Concrete use cases include reasoning about inductive types by breaking down hypotheses into their constituent parts, particularly in proof scripts requiring case analysis or elimination of existential variables.",
      "description_length": 534,
      "index": 546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Induction",
      "library": "rocq-runtime.tactics",
      "description": "This module implements elimination tactics for case analysis and induction, centered around the `elim_scheme` type that encodes the structure of elimination principles. It provides functions like `induction` and `destruct` to perform inductive reasoning and case splitting on terms, working directly with Coq's `EConstr` types for goals and hypotheses. Concrete use cases include automating proof steps by applying induction schemes to inductive data types like natural numbers, lists, or custom algebraic data types.",
      "description_length": 517,
      "index": 547,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Autorewrite",
      "library": "rocq-runtime.tactics",
      "description": "This module implements automated rewriting functionality using predefined rules, supporting operations to add rules to a database, search for applicable rules, and apply them in proof contexts. It works with rewriting rules composed of lemmas, directions, and optional tactics, and operates on logical terms during proof automation. Concrete use cases include simplifying expressions in proofs by applying equivalence transformations automatically, either globally or within specific clauses.",
      "description_length": 492,
      "index": 548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stdarg",
      "library": "rocq-runtime.tactics",
      "description": "This component provides operations for parsing, type-checking, and executing generic arguments in Coq, with support for values like integers, strings, identifiers, and Coq expressions. It introduces typed wrappers to ensure uniform handling of these arguments across tactic frameworks and command systems, enabling precise interpretation and location tracking. Key use cases include constructing domain-specific tactics that require structured argument processing and manipulating Coq terms with validated type information.",
      "description_length": 523,
      "index": 549,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Generalize",
      "library": "rocq-runtime.tactics",
      "description": "This module provides tactics for generalizing terms and hypotheses in proof contexts. It operates on constructions, named contexts, and identifiers, enabling precise manipulation of proof goals by abstracting or reintroducing variables and dependencies. Concrete use cases include restructuring proof states by reverting hypotheses, generalizing subterms with or without dependencies, and abstracting identifiers while controlling variable and let-binding behavior.",
      "description_length": 465,
      "index": 550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tacticals",
      "library": "rocq-runtime.tactics",
      "description": "This module provides combinators for sequencing, branching, and error handling in tactic execution, with support for backtracking and goal-local effects. It operates on tactics within the `Proofview` monad, manipulating goals, evar maps, and proof contexts to enable structured control flow. These combinators are used to build complex proof strategies that handle failure recovery, conditional execution, and iterative refinement of subgoals in Coq's proof engine.",
      "description_length": 465,
      "index": 551,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tactics",
      "library": "rocq-runtime.tactics",
      "description": "This module provides foundational tactics for proof construction and manipulation in Coq, encompassing hypothesis management (introduction, renaming, clearing), term transformation (reduction, unfolding, substitution), and logical reasoning (equality handling, lemma application). It operates on proof terms (`EConstr.constr`), environments, identifiers (`Id.t`), and evar maps, supporting operations like controlled term normalization, pattern-directed introductions, and case analysis. Specific use cases include interactive proof scripting with tactics like `split`, `elim`, and `reflexivity`, as well as goal-directed term simplification via `simpl` or `unfold` in both conclusions and hypotheses.",
      "description_length": 701,
      "index": 552,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Abstract",
      "library": "rocq-runtime.tactics",
      "description": "This module provides tactics for abstracting terms during proof construction, allowing cached results to be reused based on tactic application. It operates on proof terms and environments, supporting operations like delayed solving and side-effect management. Concrete use cases include optimizing proof scripts by isolating and reusing complex subproofs without re-executing tactics.",
      "description_length": 384,
      "index": 553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EClause",
      "library": "rocq-runtime.tactics",
      "description": "This module implements evar-based clause construction and solving, working with existential variables (`evar`) in Coq's refinement monad. It provides `make_evar_clause` to generate clauses by instantiating binders with fresh evars, and `solve_evar_clause` to resolve those evars with bindings, handling coercions and dependencies. Concrete use cases include building and solving partial proof terms during tactic execution, particularly when precise evar management and delayed instantiation are required.",
      "description_length": 505,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Btermdn",
      "library": "rocq-runtime.tactics",
      "description": "This module implements discrimination nets for efficient pattern matching and action retrieval based on terms. It supports operations to construct and manipulate patterns using environments, evar maps, and transparency states, with functions to add, remove, and look up actions associated with patterns. It is used to register and query tactics based on term structures, handling both rigid and existential variables.",
      "description_length": 417,
      "index": 555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eqschemes",
      "library": "rocq-runtime.tactics",
      "description": "This module defines scheme kinds for constructing equality-based inductive types, including left-to-right and right-to-left rewriting schemes, symmetry, and congruence schemes. It works with inductive types representing equality, particularly in the context of dependent and non-dependent equalities. Concrete use cases include generating induction principles for equality proofs, supporting reasoning about term equivalence and symmetry in formal verification tasks.",
      "description_length": 467,
      "index": 556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eauto",
      "library": "rocq-runtime.tactics",
      "description": "This module provides tactics for automated proof search and term unfolding in a theorem proving context. It includes functions for exact proof term application, eauto-style search with customizable depth and hint databases, and unfolding definitions based on hint databases. These tactics operate on proof goals, clauses, and hint databases, and are used to automate routine proof steps and simplify expressions during proof construction.",
      "description_length": 438,
      "index": 557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Clenv.Internal",
      "library": "rocq-runtime.proofs",
      "description": "Handles legacy operations for refining and manipulating open terms in the proof engine. Works with deprecated clausenv structures representing incomplete proofs. Used internally for backward compatibility with older proof scripts.",
      "description_length": 230,
      "index": 558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proof",
      "library": "rocq-runtime.proofs",
      "description": "This module provides operations for managing proof states in theorem proving, including starting proofs, manipulating goals through focusing and unfocusing, applying tactics, and solving subgoals. It works with proof terms (`Proof.t`), environments (`Environ.env`), existential variables (`Evar.t`), and associated data like evar_maps and universe constraints. These functions support use cases such as structured goal management, tactic-driven proof development, and extracting context information during interactive theorem proving sessions.",
      "description_length": 543,
      "index": 559,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tactypes",
      "library": "rocq-runtime.proofs",
      "description": "This module defines core tactic-related types used in Coq's proof engine, including structures for introduction patterns, hypothesis naming, and delayed constraint handling. It supports operations for managing logical connectives and quantifiers during proof construction, working with types like `intro_pattern`, `or_and_intro_pattern`, and `quantified_hypothesis`. These types are used internally by tactics to manipulate proof goals and hypotheses in a structured way.",
      "description_length": 471,
      "index": 560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Clenv",
      "library": "rocq-runtime.proofs",
      "description": "The operations focus on managing environments for open terms in a proof engine, including evar_map manipulation, metavariable instantiation, and constraint resolution via unification tactics. They work with deprecated clausenv structures and evar_maps to handle existential variables and term bindings. These tools were used in legacy workflows for backward compatibility with older proof scripts and debugging unresolved term data during development.",
      "description_length": 451,
      "index": 561,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goal_select",
      "library": "rocq-runtime.proofs",
      "description": "This module defines goal selection strategies in proof scripts, supporting operations like selecting a specific goal by index, a range of goals, an identifier, or all goals. It provides functions to print goal selectors, retrieve a default selector, and apply a selected goal to a tactic. Concrete use cases include directing proof automation to specific subgoals in Coq proofs, such as focusing on the third goal with `SelectNth 3` or selecting all goals with `SelectAll`.",
      "description_length": 473,
      "index": 562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Miscprint",
      "library": "rocq-runtime.proofs",
      "description": "This module handles the pretty-printing of Coq tactic expressions, specifically for introduction patterns, bindings, and naming constructs. It provides functions to convert complex tactic data structures like `intro_pattern_expr`, `or_and_intro_pattern_expr`, and `bindings` into human-readable `Pp.t` documents. These operations are used when displaying proof state transformations, tactic applications, and variable binding information during interactive theorem proving.",
      "description_length": 473,
      "index": 563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proof_bullet",
      "library": "rocq-runtime.proofs",
      "description": "This module defines bullet behaviors for proof structuring, supporting operations to focus or defocus proof goals using bullet symbols like dash, star, or plus. It works with proof states and formatting utilities, enabling concrete interactions such as updating the proof context when a bullet is applied or generating suggested feedback for users. A typical use case involves registering custom bullet behavior that alters how subgoals are displayed or processed during proof construction.",
      "description_length": 490,
      "index": 564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Refine",
      "library": "rocq-runtime.proofs",
      "description": "This module implements the core refine tactic for filling proof holes in interactive theorem proving, supporting the creation of partial proof terms with unification variables. It provides operations to apply refinement steps, handle constraint solving, and manage subgoals derived from incomplete terms. Use cases include constructing proofs incrementally by specifying partial terms and resolving unification constraints during tactic execution.",
      "description_length": 447,
      "index": 565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logic",
      "library": "rocq-runtime.proofs",
      "description": "This module implements legacy proof engine operations for hypothesis manipulation and type checking in a logical context. It provides functions like `convert_hyp`, `move_hyp_in_named_context`, and `insert_decl_in_named_context` that operate on named contexts, declarations, and identifiers, enforcing constraints such as name uniqueness, type convertibility, and scope correctness. It is used for tasks like introducing hypotheses, reordering context declarations, and handling errors such as unresolved bindings or non-linear proofs.",
      "description_length": 534,
      "index": 566,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tacmach",
      "library": "rocq-runtime.proofs",
      "description": "This module supports inspecting and transforming proof goals through type checking, conversion, and computation on Coq terms, along with pretty-printing functions for goal display. It operates on structures like `Proofview.Goal.t`, `EConstr`, and `Environ.env`, facilitating automation tasks such as tactic implementation and debugging in local typing contexts.",
      "description_length": 361,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_ltac1_plugin.Tac2core_ltac1",
      "library": "ltac2_ltac1_plugin",
      "description": "This module handles the embedding and evaluation of Ltac2 expressions within Ltac1, supporting quotations that mix Ltac2 syntax in Ltac1 code. It provides mechanisms to bind identifiers, intern Ltac2 expressions into Ltac1 closures, and manage type-correct argument passing between the two tactic languages. Concrete use cases include writing Ltac1 functions that inline Ltac2 logic, and converting Ltac2 expressions that return or manipulate Ltac1 values.",
      "description_length": 456,
      "index": 568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_ltac1_plugin.Tac2quote_ltac1",
      "library": "ltac2_ltac1_plugin",
      "description": "This module provides two quotation mechanisms for embedding Ltac1 syntax within Ltac2 code. It supports converting and manipulating Ltac1 tactic expressions and identifier lists, handling both tactic and value-returning forms. These quotations are used to write Ltac2 functions that generate or transform Ltac1 code, enabling gradual migration or interoperability between the two languages.",
      "description_length": 390,
      "index": 569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_ltac1_plugin",
      "library": "ltac2_ltac1_plugin",
      "description": "This module enables seamless interoperability between Ltac2 and Ltac1 by providing functions to embed, evaluate, and convert expressions between the two languages. It supports quotation mechanisms for mixing Ltac2 syntax in Ltac1 code and vice versa, along with utilities for managing type-correct bindings and closures. Concrete use cases include writing Ltac1 tactics that inline Ltac2 logic, and developing Ltac2 functions that generate or manipulate Ltac1 code for gradual migration or hybrid tactic development.",
      "description_length": 516,
      "index": 570,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Boot.Env.Path",
      "library": "rocq-runtime.boot",
      "description": "This module represents and manipulates filesystem paths within Rocq's runtime environment. It supports operations such as constructing relative paths, checking file existence, and converting paths to strings. It is used to manage Rocq's standard directories and support files during runtime initialization and access.",
      "description_length": 317,
      "index": 571,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Boot.Util",
      "library": "rocq-runtime.boot",
      "description": "This module retrieves environment variables with support for legacy Coq variable names, issuing deprecation warnings when old names are used. It allows setting a custom handler for deprecation warnings and provides a function to resolve file paths with a fallback mechanism. It operates on strings and environment variables, handling cases where variables may not exist or have deprecated names. Use cases include backward-compatible environment configuration and file path resolution during initialization.",
      "description_length": 507,
      "index": 572,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Boot.Usage",
      "library": "rocq-runtime.boot",
      "description": "This module provides functions to print version information and usage instructions for executables. It defines a `specific_usage` record to include additional arguments and options when displaying usage, and prints both generic and specific parts to an output channel. It is used to format and output version strings and help messages with structured, executable-specific details.",
      "description_length": 380,
      "index": 573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Boot.Env",
      "library": "rocq-runtime.boot",
      "description": "This module initializes and manages the Rocq runtime environment, providing access to standard directories such as the standard library, plugins, and user contributions. It uses the `Path` submodule to represent and manipulate filesystem paths, enabling operations like retrieving tool-specific directories or locating native compilation files. Concrete use cases include setting up the environment for Rocq tools and resolving paths to support files during execution.",
      "description_length": 468,
      "index": 574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Boot.Path",
      "library": "rocq-runtime.boot",
      "description": "This module provides operations to construct and manipulate file paths. It supports creating relative paths from existing ones, checking if a file exists, and converting paths to their string representation. Concrete use cases include navigating directory structures, validating file presence, and generating path strings for system interactions.",
      "description_length": 346,
      "index": 575,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Boot",
      "library": "rocq-runtime.boot",
      "description": "This module initializes the Rocq runtime environment, resolves filesystem paths, and prints usage information for executables. It works with strings, environment variables, and file paths to support tasks like setting up tool directories, locating support files, and formatting help messages. Concrete use cases include configuring Rocq tools at startup, validating file existence, and displaying version details with structured command-line arguments.",
      "description_length": 452,
      "index": 576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.BinOpSpec",
      "library": "zify_plugin",
      "description": "Registers and prints binary operator specifications for hints in a local or global context. Works with hint locality and qualified identifier data types. Used to define and display custom binary operators that influence tactic behavior during proof automation.",
      "description_length": 260,
      "index": 577,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.UnOpSpec",
      "library": "zify_plugin",
      "description": "This module maps unary operators to hint localities and associates them with qualified identifiers. It provides operations to register these associations and print the current mappings. Useful for managing operator-specific hints in proof automation.",
      "description_length": 250,
      "index": 578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.CstOp",
      "library": "zify_plugin",
      "description": "This module registers and prints custom hint locality identifiers for tactics in proof scripts. It operates on hint locality values and qualified identifiers, typically used to control the scope of tactic hints. Concrete use cases include extending tactic hint databases with specific localities and inspecting registered localities during proof development.",
      "description_length": 358,
      "index": 579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.BinOp",
      "library": "zify_plugin",
      "description": "This module maps binary operations to hints for use in proof automation, specifically handling their registration and display. It works with binary operations defined in the logic and associates them with qualified identifiers. Concrete use cases include extending automation tactics with user-defined binary operation hints and inspecting registered hints during proof development.",
      "description_length": 382,
      "index": 580,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.InjTable",
      "library": "zify_plugin",
      "description": "Maintains a table of injectivity hints for identifiers, allowing registration of hint locality and qualified names. Provides operations to register new entries and print the current table contents. Useful for tracking and debugging injectivity information in a proof context.",
      "description_length": 275,
      "index": 581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.PropBinOp",
      "library": "zify_plugin",
      "description": "This module maps propositional binary operators to hint locality and associates them with qualified identifiers. It provides operations to register these associations and print the current mappings. Useful for managing and inspecting logical operator bindings in proof automation contexts.",
      "description_length": 289,
      "index": 582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.Saturate",
      "library": "zify_plugin",
      "description": "Registers and prints hint locality for qualified identifiers. Works with hint locality values and qualified names. Useful for managing and displaying context-specific hints in proof automation.",
      "description_length": 193,
      "index": 583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.UnOp",
      "library": "zify_plugin",
      "description": "This module registers unary operations for use in proof automation and provides a command to display registered operations. It works with hint localities and qualified identifiers to associate unary functions with automated reasoning. Use it to extend tactic behavior with custom unary operators or inspect existing registrations.",
      "description_length": 330,
      "index": 584,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zify_plugin.Zify.PropUnOp",
      "library": "zify_plugin",
      "description": "This module maps propositional operators to their if-then-else equivalents to support Z3 encoding. It provides operations to register hint locality and qualified identifiers for propositional operator transformations, and to print internal mapping information. The module works with propositional logic expressions represented as Coq terms, specifically targeting univariate logical operators.",
      "description_length": 393,
      "index": 585,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.BinRel",
      "library": "zify_plugin",
      "description": "This module maps binary relations to their corresponding logical equivalences, enabling automated rewriting in proofs. It works with hint databases and qualified identifiers to register and print relation mappings. Use it to extend the set of relations understood by the `zify` tactic for specific libraries or theories.",
      "description_length": 320,
      "index": 586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify",
      "library": "zify_plugin",
      "description": "Registers and manages injectivity hints, unary and binary operations, and propositional logic mappings for proof automation. Works with hint localities, qualified identifiers, and Coq terms to control tactic behavior. Supports extending automation tactics with custom operators, tracking injectivity, and rewriting using registered relation mappings.",
      "description_length": 350,
      "index": 587,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin",
      "library": "zify_plugin",
      "description": "Registers and manages injectivity hints, unary and binary operations, and propositional logic mappings for proof automation. Works with hint localities, qualified identifiers, and Coq terms to control tactic behavior. Supports extending automation tactics with custom operators, tracking injectivity, and rewriting using registered relation mappings.",
      "description_length": 350,
      "index": 588,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printer.ContextObjectMap.Monad",
      "library": "rocq-runtime.printing",
      "description": "This module provides monadic traversal and transformation operations over a context object map. It supports `fold`, `mapi`, `fold_left`, and `fold_right`, which allow accumulating values or mapping entries while sequencing effects through the monad `M`. It works specifically with `Printer.ContextObjectMap.t`, a map from context object keys to values, enabling use cases like collecting or transforming printed context entries with monadic effects.",
      "description_length": 449,
      "index": 589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printer.ContextObjectMap.Smart",
      "library": "rocq-runtime.printing",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve sharing when transforming values in a `ContextObjectMap`. It operates on `ContextObjectMap.t`, applying functions to values while maintaining structural identity where possible. Use it when you need to efficiently update mapped values without duplicating shared structure, such as in term or context transformations during pretty-printing.",
      "description_length": 413,
      "index": 590,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printer.ContextObjectSet.List",
      "library": "rocq-runtime.printing",
      "description": "This module operates on lists of context object sets, providing functions to combine and manipulate these sets. It supports operations like union across a list of sets to aggregate context objects. Use it to merge multiple context object sets into a single set for analysis or processing.",
      "description_length": 288,
      "index": 591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printer.ContextObjectMap",
      "library": "rocq-runtime.printing",
      "description": "This module provides associative map operations for managing polymorphic values indexed by context objects, supporting both standard transformations and ordered combination of mappings. It works with key-value pairs where keys are context objects and values can be arbitrary data, enabling efficient querying, filtering, and structural preservation during operations like merging or splitting maps. The design accommodates use cases requiring ordered traversal, effectful processing with monadic folds, and optimized transformations in scenarios like pretty-printing where maintaining shared structures is critical.",
      "description_length": 615,
      "index": 592,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printer.Debug",
      "library": "rocq-runtime.printing",
      "description": "This module provides a function `pr_goal` that converts a proof goal into a pretty-printable term for debugging purposes. It operates on data structures from the `Proofview.Goal` module, specifically the goal type. A concrete use case is inspecting the internal state of a proof goal during tactic development or debugging.",
      "description_length": 323,
      "index": 593,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printer.ContextObjectSet",
      "library": "rocq-runtime.printing",
      "description": "This module implements an immutable set abstraction for managing collections of `Printer.context_object` values, supporting standard operations like membership testing, union/intersection/difference, and comparison. It provides utilities for converting sequences of elements into sets, aggregating lists of sets, and performing iterative transformations while maintaining functional purity. Typical use cases involve tracking unique context objects across different scopes, merging hierarchical contexts, or analyzing relationships between term-printing environments.",
      "description_length": 567,
      "index": 594,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printer",
      "library": "rocq-runtime.printing",
      "description": "This module enables precise rendering of Coq's internal terms, types, and proof states into human-readable formats, leveraging environment and evar map contexts to resolve bindings and constraints. It operates on core structures like `Constr`, `EConstr`, `Environ.env`, and `Evd.evar_map`, supporting specialized printing of logical contexts, universes, and existential variables with customizable formatting for scopes, compactness, and naming. Key applications include proof goal visualization during tactic development, debugging proof states, and generating structured output for interactive theorem proving workflows.",
      "description_length": 622,
      "index": 595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pputils",
      "library": "rocq-runtime.printing",
      "description": "This module provides functions for pretty-printing structured values like located terms, identifiers, and generic arguments, using Coq's environment and evar_map. It handles data types such as `lident`, `lname`, `or_var`, and `or_by_notation`, often wrapping or formatting them with location or comment information. Concrete use cases include printing AST nodes with comments, beautifying identifiers, and rendering raw or global-level generic arguments for debugging or output.",
      "description_length": 478,
      "index": 596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppextend",
      "library": "rocq-runtime.printing",
      "description": "This module defines data types and functions for controlling the layout of pretty-printed output, including boxes and cuts that dictate line breaks and indentation. It supports the creation of structured formatting rules for notations, such as those used in Coq's concrete syntax, allowing precise control over how expressions are displayed. Key use cases include defining custom printing rules for terms, enforcing consistent formatting in proof output, and handling complex layout scenarios in generated code or documentation.",
      "description_length": 528,
      "index": 597,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppconstr",
      "library": "rocq-runtime.printing",
      "description": "This module provides context-aware pretty-printing operations for Coq's abstract syntax tree elements, including expressions, binders, and patterns, using environment and evar_map parameters for contextual resolution. It supports modular printer construction through combinators and configurable entry levels, handling tasks like formatting expressions, records, and annotated terms. These operations are used in Coq development tools to generate readable proof scripts, error messages, or debugging output during type-checking and proof engineering workflows.",
      "description_length": 560,
      "index": 598,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Genprint",
      "library": "rocq-runtime.printing",
      "description": "This module handles the printing of generic arguments at various levels\u2014raw, glob, and top\u2014using environment and evar map contexts to produce pretty-printed output. It works with printer functions that may or may not require a printing level, and supports registration of printers for different argument types, including vernacular and interpreted values. Concrete use cases include formatting Coq terms, commands, and values during pretty-printing passes in the interpreter or during error message generation.",
      "description_length": 510,
      "index": 599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proof_diffs",
      "library": "rocq-runtime.printing",
      "description": "This module implements functionality for comparing proof states, including goals and hypotheses, and generating human-readable diffs with optional color highlighting. It works with proof objects, goals, and hypothesis maps to detect and display changes between different versions of a proof. Concrete use cases include showing differences in proof goals and hypotheses when tracking changes in Coq developments.",
      "description_length": 411,
      "index": 600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ring_plugin.G_ring",
      "library": "ring_plugin",
      "description": "This module defines and manipulates ring and field structures in Coq's syntax tree, providing direct access to ring and field axioms and operations as first-class values. It works with `ring_mod`, `field_mod`, and their list counterparts, representing algebraic structures with associated operations and properties. Concrete use cases include parsing and constructing ring and field expressions for proof automation and tactic development.",
      "description_length": 439,
      "index": 601,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ring_plugin.Ring_ast",
      "library": "ring_plugin",
      "description": "This module defines abstract syntax trees for ring and field tactic specifications, including detailed metadata about their structure and behavior. It provides data types for representing tactic expressions, qualified identifiers, and algebraic properties such as morphisms, lemmas, and setoids. These structures are used to implement and manipulate algebraic reasoning tactics in Coq, particularly for automated simplification and proof automation in ring and field theories.",
      "description_length": 476,
      "index": 602,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ring_plugin.Ring",
      "library": "ring_plugin",
      "description": "This module provides tactics for working with ring and field theories, including registering and printing ring/field structures, and performing lookups during proof. It operates on Coq's internal constructions and tactic state, handling expressions and constraints over rings and fields. Concrete use cases include implementing algebraic simplifications, validating ring/field morphisms, and automating proofs involving algebraic structures.",
      "description_length": 441,
      "index": 603,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ring_plugin",
      "library": "ring_plugin",
      "description": "This module provides operations for defining, manipulating, and automating algebraic reasoning over ring and field structures in Coq. It works with abstract syntax trees, tactic expressions, and internal Coq constructions to represent and process algebraic properties and morphisms. Concrete use cases include parsing ring and field expressions, implementing simplification tactics, and automating proofs involving algebraic identities and morphism validations.",
      "description_length": 461,
      "index": 604,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nsatz_core_plugin.Ideal.Monomial",
      "library": "nsatz_core_plugin",
      "description": "This module represents monomials as integer arrays, where each element corresponds to the exponent of a variable. It provides functions to create a monomial from an array of exponents and to retrieve the underlying array representation. It is used in algebraic computations involving polynomials, particularly in manipulating terms within ideals.",
      "description_length": 346,
      "index": 605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_core_plugin.Polynom.Make",
      "library": "nsatz_core_plugin",
      "description": "This module provides algebraic manipulation operations for polynomials with integer variables and ring-based coefficients, including arithmetic (addition, multiplication, division), normalization, derivation, and coefficient extraction. It works with a polynomial data structure (`t`) and a hash table implementation (`Hashpol`) for efficient storage, supporting variable-specific computations and operations like GCD calculation. Designed for symbolic mathematics or formal verification tasks requiring efficient polynomial manipulation and hash-based optimization.",
      "description_length": 566,
      "index": 606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_core_plugin.Ideal.Make",
      "library": "nsatz_core_plugin",
      "description": "This module implements polynomial arithmetic and ideal membership checking for a specific coefficient domain. It supports operations like addition, multiplication, exponentiation, and equality testing on polynomials, along with generating certificates of membership in polynomial ideals. The module is used in formal verification tasks requiring algebraic reasoning, such as proving equalities in ring structures using Gr\u00f6bner bases.",
      "description_length": 433,
      "index": 607,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nsatz_core_plugin.Ideal",
      "library": "nsatz_core_plugin",
      "description": "This module handles algebraic computations involving polynomials and monomials, with support for polynomial arithmetic, ideal membership checking, and monomial manipulation via exponent arrays. It is used in formal verification for proving algebraic identities and checking polynomial equalities in ring structures using Gr\u00f6bner bases. The module includes configuration for term ordering and maintains metadata for variable naming.",
      "description_length": 431,
      "index": 608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_core_plugin.Polynom",
      "library": "nsatz_core_plugin",
      "description": "This module implements algebraic operations for polynomials with integer variables and ring-based coefficients, including addition, multiplication, division, normalization, derivation, and coefficient extraction. It uses a polynomial data structure (`t`) and a hash table (`Hashpol`) for efficient storage and variable-specific computations, supporting tasks like symbolic mathematics and formal verification requiring efficient polynomial manipulation.",
      "description_length": 453,
      "index": 609,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_core_plugin.Nsatz",
      "library": "nsatz_core_plugin",
      "description": "This module provides the `nsatz_compute` tactic, which performs computational checks for algebraic reasoning in proofs. It operates on Coq's `Constr.t` type, representing terms in the proof context. A concrete use case is verifying equalities in polynomial expressions during interactive theorem proving.",
      "description_length": 304,
      "index": 610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_core_plugin.Utile",
      "library": "nsatz_core_plugin",
      "description": "This module provides low-level debugging and logging operations through functions that print messages or values to the console. It works directly with strings and generic values via the `pr`, `prt0`, `info`, and `sinfo` functions. Concrete use cases include tracing execution flow, inspecting variable states, and logging diagnostic information during development.",
      "description_length": 364,
      "index": 611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_core_plugin",
      "library": "nsatz_core_plugin",
      "description": "This module provides core components for algebraic reasoning and polynomial computation in formal verification. It includes efficient polynomial arithmetic, ideal membership checking, and monomial manipulation using Gr\u00f6bner bases, along with a tactic for algebraic proof automation in Coq. Use cases include verifying polynomial equalities, symbolic computation, and interactive theorem proving in ring structures.",
      "description_length": 414,
      "index": 612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_byte_config",
      "library": "byte_config",
      "description": "This module provides functions for handling configuration and execution in a byte-code environment. It includes operations for silently loading files in the top-level loop and managing exit behaviors with specific status codes. The module works with standard formatting and unit functions, typically used in compiler or interpreter setup scenarios.",
      "description_length": 348,
      "index": 613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Reductionops.ReductionBehaviour.Db",
      "library": "rocq-runtime.pretyping",
      "description": "Stores and manages reduction behavior settings for constants, including policies for unfolding and inlining. It uses a database-like structure to associate constants with their reduction rules, enabling selective control over evaluation strategies. This module is used to configure how specific constants behave during reduction, such as marking them to never be unfolded.",
      "description_length": 372,
      "index": 614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coercionops.ClTypSet.List",
      "library": "rocq-runtime.pretyping",
      "description": "This module operates on lists of sets, providing functions to compute unions and handle set aggregations. It works with `Coercionops.ClTypSet.t list` data structures, enabling efficient combination of multiple sets into a single set. A typical use case involves merging a list of type sets to determine a unified type representation in type inference systems.",
      "description_length": 359,
      "index": 615,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unification.Metamap.Smart",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve sharing when possible, operating on `Unification.Metamap.t` structures. It is useful for efficiently transforming values in a key-value map without unnecessary duplication, particularly in scenarios involving large or deeply nested maps.",
      "description_length": 311,
      "index": 616,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unification.Metamap.Monad",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides monadic traversal and transformation operations over metamaps, which are maps from keys to values in a monadic context. It supports operations like `fold`, `mapi`, `fold_left`, and `fold_right`, allowing accumulation and per-binding transformations while sequencing monadic effects. It is useful for tasks such as propagating substitutions in type inference or accumulating state during constraint solving.",
      "description_length": 427,
      "index": 617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unification.Metaset",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages ordered sets of Constr.metavariable elements, supporting standard set operations like union, intersection, and difference, alongside ordered iteration and transformations. It provides efficient membership checks, set comparisons, and conversions between lists and sequences, leveraging a total ordering for optimized traversal and manipulation. Such functionality is particularly useful in unification algorithms requiring precise handling of metavariable dependencies and ordered data processing.",
      "description_length": 517,
      "index": 618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Structures.Instance",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages the creation and registration of canonical instances for structures, handling conversions between record components and structure projections. It operates on the abstract type `t`, using environment and evar_map contexts to validate and store instances. Concrete use cases include declaring and registering canonical representations of records within a proof context.",
      "description_length": 387,
      "index": 619,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Reductionops.ReductionBehaviour",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines reduction behavior policies for constants, such as whether and when they should be unfolded during evaluation. It works with constants and flags that control reduction strategies, allowing selective inlining or blocking of specific terms. It is used to configure and query custom reduction rules, such as marking a constant to never unfold or to unfold only under certain conditions.",
      "description_length": 403,
      "index": 620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genarg.ArgT",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines and manipulates typed generic arguments used in Coq's tactic and vernacular extensions. It provides operations to register and retrieve argument types with their associated printers, grammar, and interpretation tags, ensuring correct parsing, globalization, and evaluation. Concrete use cases include defining custom tactic arguments that can be parsed from user input, safely interpreted during tactic execution, and printed for debugging or error messages.",
      "description_length": 478,
      "index": 621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Geninterp.TacStore",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages a store of dynamically typed fields, allowing creation, setting, retrieval, and merging of named values. It works with a polymorphic field type that associates string keys to arbitrary typed values. It is used to pass and manipulate interpreted Ltac values within Coq's tactic system, such as storing intermediate results or configuration during tactic execution.",
      "description_length": 383,
      "index": 622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unification.Meta",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages metavariables and their assignments during unification, providing operations to declare, assign, and query metas, including their types and naming. It works with metavariables, environments, and unification state, supporting tasks like type checking and constraint solving. Concrete use cases include handling incomplete terms during proof search, tracking meta instantiations, and merging meta states from different unification branches.",
      "description_length": 458,
      "index": 623,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Structures.Structure",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines and manipulates inductive structures, primarily through operations that create, register, and query structure projections. It works with inductive types and constants, tracking projection metadata such as field names, definitional status, and canonical usage. Concrete use cases include resolving projections to their parent structures, determining projection positions within structures, and managing substitution and rebuilding of structures during compilation or transformation phases.",
      "description_length": 508,
      "index": 624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unification.Metamap",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides functional maps for managing immutable key-value associations with metavariables as keys, supporting standard operations like insertion, deletion, and traversal alongside advanced merging and splitting. It enables structured transformations through predicate-based filtering, value mapping, and set-like operations, while its monadic traversal capabilities handle effectful processing of bindings in contexts like error handling or state accumulation. Designed for use cases requiring precise metavariable tracking, such as unification algorithms with dynamic constraint propagation or symbolic computation workflows.",
      "description_length": 638,
      "index": 625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Detyping.PrintingInductiveMake",
      "library": "rocq-runtime.pretyping",
      "description": "This module encodes qualified identifiers into inductive types, supports substitution and locality checks, and provides pretty-printing for inductive structures. It works with environments, substitutions, and inductive type definitions. It is used to display inductive type information and manage their properties during proof processing.",
      "description_length": 338,
      "index": 626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genarg.Register",
      "library": "rocq-runtime.pretyping",
      "description": "This module registers and retrieves type-specific manipulation functions for generic arguments, working with `genarg_type` and `M.obj` data structures. It ensures that operations like parsing, printing, and interpretation are correctly associated with their respective stages (`raw`, `glob`, `top`). Concrete use cases include setting up argument behavior for Coq tactics and vernacular extensions, where precise type handling is required during parsing, globalization, and evaluation.",
      "description_length": 485,
      "index": 627,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Reductionops.Stack",
      "library": "rocq-runtime.pretyping",
      "description": "This module implements stack-based operations for representing and manipulating reduction contexts in terms of applications, projections, case analysis, fixpoints, and primitives. It supports concrete operations like appending argument arrays or lists, stripping applicative prefixes, decomposing stacks, and zipping stacks with terms under an evar map. Use cases include managing reduction steps in conversion checking, normalizing terms, and handling pattern-matching compilation through case stacks.",
      "description_length": 502,
      "index": 628,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Structures.CanonicalSolution",
      "library": "rocq-runtime.pretyping",
      "description": "This module represents and manipulates canonical solutions for problems involving constants, abstractions, and constructor-based bodies. It provides operations to find solutions that equate a projected value with a structured body, supporting evarconv by decomposing terms into usable components. Functions include solution lookup, checking for open canonical projections, and pretty-printing solutions for debugging.",
      "description_length": 417,
      "index": 629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coercionops.ClTypSet",
      "library": "rocq-runtime.pretyping",
      "description": "This module implements a functional set interface for managing collections of `cl_typ` elements, supporting operations like union, intersection, difference, and membership checks with immutable semantics. It provides utilities for converting between sets, lists, and sequences, along with aggregation functions to combine multiple type sets, emphasizing use cases in type inference workflows where precise set manipulation is critical. The API includes both safe and unsafe variants for element retrieval, iteration, and folding, alongside cardinality tracking and extremum selection.",
      "description_length": 584,
      "index": 630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Structures.CSTable",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides direct access to the Canonical Structure database, allowing retrieval of entries that map projections to values and their corresponding solutions. It works with structured entries containing global references for projection, value patterns, and solution references. Use this module to query all canonical entries or filter them by a specific projection to resolve canonical structures during type class inference or unification.",
      "description_length": 449,
      "index": 631,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Geninterp.ValTMap",
      "library": "rocq-runtime.pretyping",
      "description": "This module implements a type-safe key-value map with polymorphic keys and values, supporting standard operations like insertion, lookup, modification, and filtering. It works with abstract key and value types provided by the `Value` module, enabling heterogeneous storage and transformation of interpreted values. Concrete use cases include managing dynamic configurations, tracking state changes, and selectively applying transformations to stored entries.",
      "description_length": 458,
      "index": 632,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evarsolve.AllowedEvars",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages sets of existential variables (evars) that can be defined during type inference or proof search. It provides operations to check membership, create sets from predicates, exclude specific evars, and remove individual evars from existing sets. It is used to control which evars are modifiable in contexts like unification and tactic execution.",
      "description_length": 361,
      "index": 633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Structures.ValuePattern",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines a data type for patterns that describe the structure of terms in canonical forms, including constants, projections, products, sorts, and defaults. It provides operations to compare, print, and convert terms into these patterns, along with checking their equality in a given environment. It is used to query and match canonical instance data in proof automation and term processing.",
      "description_length": 401,
      "index": 634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Geninterp.Val",
      "library": "rocq-runtime.pretyping",
      "description": "This module creates and manipulates typed values for Ltac interpretation, supporting operations to inject values into a dynamic type, compare types for equality, and retrieve string representations of types. It works with a GADT type `t` that wraps values of any type along with their corresponding type descriptor, and with type constructors for lists, options, and pairs. Concrete use cases include representing Ltac values with their types in Coq's tactic system and handling heterogeneous data during tactic execution.",
      "description_length": 522,
      "index": 635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Structures.PrimitiveProjections",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages mappings between constants and primitive projections, providing operations to register, check existence, and retrieve projections associated with constants. It works with data types such as `Names.Constant.t`, `Names.Projection.Repr.t`, and `EConstr.EInstance.t`. Concrete use cases include resolving primitive projections during term manipulation and checking the transparency of constants within a given state.",
      "description_length": 432,
      "index": 636,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Reductionops.CredNative",
      "library": "rocq-runtime.pretyping",
      "description": "Handles native reduction of primitive operations in a Coq-like environment. It provides `red_prim`, which evaluates primitive constants by applying native computation rules to arguments in a given evar_map and universe instance. Works with `EConstr.t` elements, `Evd.evar_map`, and `CPrimitives.t`, specifically for reducing primitive terms during type checking or evaluation. Useful for implementing efficient reductions of built-in Coq primitives like arithmetic or boolean operations.",
      "description_length": 487,
      "index": 637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Inductiveops",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides operations for querying and transforming inductive types and their constructors, including retrieving arities, parameters, and elimination constraints, applying substitutions and liftings, and handling case analysis and projections. It works with inductive types, environments, universe-polymorphic terms (`EConstr`), and Coq kernel structures (`Evd.evar_map`) to support tasks like type checking, dependent type manipulation, and universe constraint management. Specific use cases include analyzing mutual recursion, instantiating constructors, and verifying elimination sort properties in Coq's internal representation.",
      "description_length": 642,
      "index": 638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Locus",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines data structures and operations for specifying and manipulating positions of hypotheses and goals in proof terms, including precise control over occurrences and locations. It supports concrete and abstract representations of clauses for targeting specific parts of a proof, such as hypotheses or conclusions, with options to restrict matches to types, values, or both. Use cases include implementing tactics that need to focus on specific hypotheses or occurrences within Coq proofs, such as rewriting or simplification strategies.",
      "description_length": 550,
      "index": 639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coercion",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles type coercions and conversions during type checking, providing operations to insert coercions into terms to match expected types, such as coercing to a sort or a base type. It works with judgments, types, and coercion traces, supporting concrete tasks like pattern coercion in case expressions and handling subset types in program mode. Specific use cases include type-directed coercion of expressions, conversion of subset types to base types, and dynamic registration of coercion hooks for plugins.",
      "description_length": 520,
      "index": 640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Reductionops",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides reduction and decomposition functions for normalizing Coq terms, including beta, zeta, delta, and weak head normalization, alongside conversion checking and term structure inspection. It operates on Coq's internal term representations (`EConstr.constr`, `types`) within environments and evar_maps, handling metavariables and universe constraints. These operations are critical for proof checking, tactic execution, and type-checking built-in or user-defined terms during evaluation.",
      "description_length": 503,
      "index": 641,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cbv",
      "library": "rocq-runtime.pretyping",
      "description": "This module implements call-by-value normalization for Coq terms, providing a function to normalize expressions using a specified reduction strategy. It operates on `cbv_infos` structures, which encapsulate environment, evar map, and reduction flags, and works with `EConstr.constr` terms. It is used during tactic execution and term simplification to evaluate expressions to weak head normal form under call-by-value semantics.",
      "description_length": 428,
      "index": 642,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Typeclasses",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages typeclass hierarchies and instance resolution within Coq's type system, offering operations to register, query, and resolve typeclass instances with support for context-aware unification and universe polymorphism. It works directly with typeclass structures (including methods, constraints, and properties) and existential variables arising during resolution, employing pattern matching, priority-based hints, and customizable unification strategies. Key use cases include resolving ambiguous instance goals, filtering obligations during type inference, and dynamically adjusting resolution behavior for complex typeclass hierarchies.",
      "description_length": 654,
      "index": 643,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evarsolve",
      "library": "rocq-runtime.pretyping",
      "description": "This component provides mechanisms for solving and managing existential variables during type inference and proof search. It operates on evar_maps (collections of existential variables) alongside environments and Coq terms, offering unification, constraint resolution, and alias handling while enforcing conversion rules. Key applications include equation solving under contextual constraints and controlled instantiation of unresolved variables in proof assistants or type systems.",
      "description_length": 482,
      "index": 644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Detyping",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles the conversion of typed terms into untyped representations, supporting operations like substitution, pattern factorization, and detyping of constraints, sorts, and contexts. It works with environments, evar_maps, glob_constr, cases patterns, and inductive definitions, including handling disjunctive patterns and managing variable naming during detyping. Concrete use cases include pretty-printing proof terms, simplifying match expressions during display, and preparing terms for user-facing output in Coq's interactive environment.",
      "description_length": 553,
      "index": 645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Heads",
      "library": "rocq-runtime.pretyping",
      "description": "Computes approximations of head symbols for constants and local definitions, determining whether terms reduce to a rigid head. Uses environments, evar maps, and constr terms as inputs. Useful for analyzing term structure in proof automation and tactic development.",
      "description_length": 264,
      "index": 646,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Indrec",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles the construction and validation of elimination schemes for inductive types, including case analysis and induction principles. It works with inductive types, sorts, and global references to manage eliminator generation and naming. Concrete use cases include building dependent case analysis predicates, mutual induction schemes, and resolving eliminator names based on type families.",
      "description_length": 402,
      "index": 647,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tacred",
      "library": "rocq-runtime.pretyping",
      "description": "This module implements reduction strategies and normalization procedures for Coq terms, focusing on operations like simplification, head-normal form computation, unfolding, and reducibility control during tactic execution. It operates on environments, global references, and internal term representations (`EConstr.constr`, etc.), supporting tasks such as normalizing terms to atomic inductive forms, evaluating quantified inductives without full normalization, and enforcing privacy constraints in pattern-matching contexts.",
      "description_length": 525,
      "index": 648,
      "embedding_norm": 1.0
    },
    {
      "module_path": "GlobEnv",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages environments extended with naming and Ltac interpretation data, primarily supporting type inference and term elaboration. It provides operations to register interpretation functions, push declarations, create existential variables, and handle variable bindings with renaming, specifically for Coq's pretyping and tactic systems. Concrete use cases include resolving Ltac variables during term interpretation, managing binder renaming in pattern matching, and handling evar declarations in proof contexts.",
      "description_length": 524,
      "index": 649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Arguments_renaming",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles renaming and type-checking operations for global references and constructions. It provides functions to set or retrieve argument names for global references, rename types using specified names, and perform type-checking with kernel inference. These operations are used when manipulating terms and types in the context of proof assistants or formal verification tasks.",
      "description_length": 387,
      "index": 650,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Structures",
      "library": "rocq-runtime.pretyping",
      "description": "This module suite implements core functionality for managing inductive structures, canonical instances, and projections in a proof assistant or term manipulation system. It supports operations such as declaring structures, registering canonical instances, matching value patterns, solving for structured bodies, querying the canonical structure database, and resolving primitive projections. These modules work with inductive types, constants, projections, and environments to enable advanced type class resolution, unification, and proof automation mechanisms.",
      "description_length": 561,
      "index": 651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "TemplateArity",
      "library": "rocq-runtime.pretyping",
      "description": "This module processes and analyzes the structure of inductive type arities in the context of template polymorphism. It provides operations to retrieve and deconstruct the components of inductive types, including parameters, constructors, and universe levels. Concrete use cases include type checking and elaboration of inductive definitions with template arguments in Coq's kernel.",
      "description_length": 381,
      "index": 652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nativenorm",
      "library": "rocq-runtime.pretyping",
      "description": "Performs normalization of Coq terms by evaluating them into OCaml code. It takes a term and its type, along with environment and evar_map, and returns the normalized term. Useful for implementing efficient reduction strategies in Coq's tactic system.",
      "description_length": 250,
      "index": 653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Typing",
      "library": "rocq-runtime.pretyping",
      "description": "This module implements type inference, validation, and existential variable resolution for dependent type systems, operating on terms (`EConstr.constr`) and types (`EConstr.types`) within environments (`Environ.env`) and evar maps (`Evd.evar_map`). It supports constraint checking, universe management, and inductive type handling, enabling use cases like type-directed term reconstruction and universe-polymorphic program verification. Key operations include judgment synthesis, application of typed constructions, and solving implicit variables during type-checking workflows.",
      "description_length": 578,
      "index": 654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Typeclasses_errors",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines error types for handling typeclass-related issues, including `NotAClass` for non-class constraints and `UnboundMethod` for missing method references. It provides functions to raise these errors within the context of an environment and evar map, using Coq's constraint and reference types. Concrete use cases include reporting invalid typeclass instances and unresolved method bindings during typechecking or elaboration.",
      "description_length": 440,
      "index": 655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_pretype",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages mappings of pattern variables during tactic preprocessing, handling terms in contexts with binders. It supports operations for matching and substituting terms while preserving variable scoping and avoiding conflicts. Concrete use cases include processing Ltac expressions that involve bound variables and ensuring correct variable resolution in tactic-based proofs.",
      "description_length": 385,
      "index": 656,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evardefine",
      "library": "rocq-runtime.pretyping",
      "description": "This module manipulates existential variables (`evar`) within a type-checking environment, providing operations to instantiate, split, and transform them during unification or type inference. It works with environments (`env`), evar maps (`evar_map`), and constraints on types and values (`type_constraint`, `val_constraint`), often involving constructions like products, lambdas, and sorts. Concrete use cases include absorbing applied arguments into evar contexts, defining evars as lambda or product expressions, and extracting or transforming array-like type constraints for coercion.",
      "description_length": 588,
      "index": 657,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Combinators",
      "library": "rocq-runtime.pretyping",
      "description": "This module constructs right-associated nested sigma-types and tuples from environments and contexts, encapsulating values with their free variables into dependent pairs. It supports operations on `EConstr` types and terms, including case-splitting on inductive values to produce specialized or default results. Concrete use cases include building dependent telescopes for proof terms and generating tuple-like structures with inferred types.",
      "description_length": 442,
      "index": 658,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Genarg",
      "library": "rocq-runtime.pretyping",
      "description": "The module provides operations to parse, embed, type-check, and extract generic arguments across raw, globalized, and interpreted stages, ensuring correctness through phantom-typed descriptors and structured transformations. It handles parameterized types like lists, options, and pairs, while integrating with grammar registration and interpreter tagging systems to support tactic and vernacular extensions that require precise argument processing across multiple evaluation phases.",
      "description_length": 483,
      "index": 659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constr_matching",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides functions for pattern-matching on Coq terms, supporting both full and partial matches, with operations like `matches`, `matches_head`, and `match_subterm` that return assignments of metavariables and bound variables. It works with data types such as `constr_pattern`, `constr`, `patvar_map`, and `context`, and handles binding structures and evar_maps from the Coq environment. Concrete use cases include implementing tactics that analyze or transform proof terms based on syntactic patterns, such as rewriting or inversion.",
      "description_length": 545,
      "index": 660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Patternops",
      "library": "rocq-runtime.pretyping",
      "description": "This module implements operations for constructing, transforming, and comparing patterns, primarily working with `constr_pattern` and `glob_constr` types. It supports substitution, equality checking, head symbol extraction, and conversion between patterns and terms, with specific handling for metavariables and evar maps. Concrete use cases include pattern matching compilation, tactic argument parsing, and term analysis in proof automation.",
      "description_length": 443,
      "index": 661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vnorm",
      "library": "rocq-runtime.pretyping",
      "description": "Performs call-by-value reduction using a virtual machine, operating on Coq's internal terms and types. It takes an environment, evar map, term, and type, returning the normalized term. Useful for efficient evaluation of terms during proof checking or tactic execution.",
      "description_length": 268,
      "index": 662,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gensubst",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles substitution operations for generalized arguments in Coq's internal term manipulation. It provides functions to apply substitutions to terms, perform generic substitutions across different argument types, and register custom substitution functions for specific argument types. Concrete use cases include implementing tactics that modify proof terms by substituting variables or expressions during proof construction or term rewriting.",
      "description_length": 454,
      "index": 663,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pretype_errors",
      "library": "rocq-runtime.pretyping",
      "description": "This module introduces error variants and reporting utilities for type-checking and unification errors in proof assistants. It operates on environments, evar maps, and Coq terms, addressing scenarios like unification failures, occur checks, constraint violations, and unsolvable implicits during pretyping and type inference phases.",
      "description_length": 332,
      "index": 664,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Glob_term",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides operations for constructing and manipulating untyped intermediate terms during Coq's globbing phase, focusing on resolving names, inserting implicit argument placeholders, and handling notations. It works with generalized, extensible data structures like `glob_constr_g` and `cases_pattern_g` that represent expressions, declarations, and pattern-matching constructs using polymorphic variants for syntactic flexibility. These types are specifically used to model partially resolved Coq terms before type checking, supporting features like disjunctive patterns, local binders, and placeholder constraints.",
      "description_length": 626,
      "index": 665,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coercionops",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides operations for handling coercion and class type manipulations in Coq's type theory, including equality checks, substitution under environments, and path-based coercion resolution. It works with class types (`cl_typ`), coercion metadata (`coe_info_typ`), and inheritance paths to model type relationships. Key use cases include resolving coercion chains between types, verifying path reversibility, and managing inheritance hierarchies via set-theoretic operations on class type collections.",
      "description_length": 511,
      "index": 666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Keys",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages key equivalence declarations and checks, using a `key` type to represent symbolic identifiers. It supports computing head keys of terms in a given environment and provides operations to declare and test key equivalence. Concrete use cases include tracking equivalent identifiers during term processing and normalizing keys in proof or term manipulation tasks.",
      "description_length": 379,
      "index": 667,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evaluable",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines a sum type representing references that can be evaluated, including variables, constants, and projections. It provides operations to map over and compare these references, transforming their components while preserving structure. The module is used to track and manipulate evaluable entities in a context where their transparency (visibility during evaluation) matters, such as in conversion checking or kernel-level operations.",
      "description_length": 448,
      "index": 668,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cases",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles the compilation and validation of pattern-matching constructs in a type-checking context. It provides functions to detect and report pattern-matching errors such as incorrect constructor or inductive argument counts, non-exhaustive or unused clauses, and predicate inference failures. It operates on data types including inductive types, constructors, global environments, and evar maps, and is used during the elaboration of match expressions in a dependently typed language. Concrete use cases include compiling pattern-matching into case abstractions, checking pattern irrefutability, and constructing return predicates for case analysis.",
      "description_length": 661,
      "index": 669,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Geninterp",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles dynamic interpretation of generic arguments and Ltac values, providing typed value manipulation, type-safe storage, and interpretation functions. It works with GADTs for typed values, polymorphic maps, and tactic-specific data structures to support heterogeneous data handling. Concrete use cases include interpreting and storing Coq tactic arguments with their types, managing dynamic tactic state, and enabling type-preserving transformations during tactic execution.",
      "description_length": 489,
      "index": 670,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pattern",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines data structures and operations for representing and manipulating patterns in Coq's term language, including variables, case analysis metadata, and extensible pattern matching constructs. It supports working with inductive types and provides specific forms for expressing incomplete or extensible patterns in match expressions. Concrete use cases include building and deconstructing match patterns during tactic execution and term transformation passes.",
      "description_length": 472,
      "index": 671,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pretyping",
      "library": "rocq-runtime.pretyping",
      "description": "Implements type inference and constraint resolution for converting untyped terms (`glob_constr`) into typed representations (`constr`, `EConstr.t`), prioritizing resolution of implicit arguments, coercion insertion, and decomposition of complex pattern-matching constructs. Manages bidirectional type-checking hints, guard indices for recursive definitions, and configurable processing of typeclasses, unification variables, and existential metavariables during elaboration in proof-assistant contexts.",
      "description_length": 502,
      "index": 672,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evarconv",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides unification and existential variable resolution operations with customizable heuristics, supporting constraint solving and type inference in dependent type systems. It operates on environments, evar maps, conversion problems, and terms, offering precise control over unification strategies through occurrence selection, second-order matching, and constraint enforcement. Key applications include resolving canonical structures, decomposing projections, and managing delayed unification in interactive theorem proving workflows.",
      "description_length": 548,
      "index": 673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Glob_ops",
      "library": "rocq-runtime.pretyping",
      "description": "This component provides structural manipulation, transformation, and analysis of Coq's global term syntax, focusing on sorts, constructions, and case patterns. It operates on term representations like `glob_constr` and `cases_pattern_g`, enabling binder-aware mappings, equality checks, variable occurrence analysis, and conversions between pattern forms. These operations support proof elaboration tasks such as term rewriting, binding structure adjustments, and case pattern normalization in the Calculus of Constructions.",
      "description_length": 524,
      "index": 674,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unification",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides unification operations for managing metavariables, existential constraints, and term matching in type theory systems. It works with sets (Metaset) and maps (Metamap) to track metavariables, alongside environments (Environ.env), constraint maps (Evd.evar_map), and typed terms (EConstr.constr), supporting tasks like subterm matching, coercion, and abstraction. These tools are used in proof assistants to resolve type constraints, infer missing terms, and transform expressions during type-checking pipelines.",
      "description_length": 530,
      "index": 675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Locusops",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides operations for traversing and transforming logical clauses and their occurrence selections in Coq's tactic system, focusing on types like `or_var`, `occurrences_gen`, and `clause_expr`. It includes utilities for extracting occurrence data from hypotheses and goals, checking context selection patterns, and constructing clauses with generic or specific occurrence constraints. These tools are used in Ltac to implement precise rewriting, hypothesis manipulation, and goal-directed proof automation.",
      "description_length": 519,
      "index": 676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Find_subterm",
      "library": "rocq-runtime.pretyping",
      "description": "This module supports finding and replacing subterms within Coq's extended constructions, using customizable unification tests. It operates on `EConstr.constr` and `EConstr.named_declaration`, enabling precise term manipulation at specified occurrences. Concrete use cases include substituting closed terms in expressions or hypotheses while managing universe constraints, such as replacing a specific subterm with a de Bruijn index during tactic execution.",
      "description_length": 456,
      "index": 677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Retyping",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides functions to recompute the type of terms without full type-checking, assuming the input is well-typed. It operates on terms and types in Coq's kernel, handling metavariables, projections, and sort information. Use cases include type reconstruction during proof elaboration, extraction, and internal term manipulation where performance is prioritized over full correctness checks.",
      "description_length": 400,
      "index": 678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto2_plugin.Counter",
      "library": "tuto2_plugin",
      "description": "Tracks and updates an internal integer counter. Provides `increment` to increase the counter by one and `value` to retrieve the current count. Useful for scenarios requiring a persistent count state, such as tracking event occurrences or managing unique identifiers.",
      "description_length": 266,
      "index": 679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto2_plugin.Custom",
      "library": "tuto2_plugin",
      "description": "Defines a custom enumerated type `custom_type` with two distinct values, `Foo` and `Bar`. Directly supports pattern matching and value discrimination in logic branches. Useful for representing binary state flags or simple disjoint cases in domain models.",
      "description_length": 254,
      "index": 680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto2_plugin.Persistent_counter",
      "library": "tuto2_plugin",
      "description": "Tracks and manages a persistent integer counter across program runs. It provides `increment` to increase the counter by one and `value` to retrieve the current count. Useful for scenarios like unique ID generation or usage tracking in stateful applications.",
      "description_length": 257,
      "index": 681,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto2_plugin.G_tuto2",
      "library": "tuto2_plugin",
      "description": "This module defines a custom argument type and entry point for parsing and processing a specific custom type in the context of Coq's plugin system. It enables the integration of user-defined syntax and logic into Coq's vernacular commands and tactic extensions. Direct use cases include extending Coq with domain-specific notations or proof constructs that require custom parsing and execution behavior.",
      "description_length": 403,
      "index": 682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto2_plugin",
      "library": "tuto2_plugin",
      "description": "This module includes components for managing both transient and persistent integer counters, defining simple enumerated types for state representation, and integrating custom syntax and logic into Coq's plugin system. It works with integers, enumerated types, and Coq-specific extension mechanisms. Concrete use cases include tracking event counts, modeling binary states, and extending Coq with domain-specific proof constructs.",
      "description_length": 429,
      "index": 683,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.SpecificNotationMap.Monad",
      "library": "rocq-runtime.interp",
      "description": "This module provides monadic traversal and transformation operations over a specific notation map structure. It supports keyed folding with `fold`, `fold_left`, and `fold_right`, allowing stateful computations across key-value entries, and `mapi` for monadic, key-aware value transformations. It is used to process maps where each entry must be handled in sequence with effects encapsulated in the monad `M`, such as error handling or state updates.",
      "description_length": 449,
      "index": 684,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Notation.SpecificNotationMap.Smart",
      "library": "rocq-runtime.interp",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve structural sharing when transforming values in a specific notation map. It operates on maps where keys are specific notations and values are of a uniform type. Useful for efficiently updating syntax or semantic annotations in parsed structures without unnecessary duplication.",
      "description_length": 350,
      "index": 685,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.NotationSet.List",
      "library": "rocq-runtime.interp",
      "description": "This module operates on lists of sets, providing functions to compute unions and handle collections of notations. It works with `Notation.NotationSet.t list` data structures, enabling aggregation of multiple sets into a single set. A typical use case involves combining results from multiple notation sets into one unified set for further processing.",
      "description_length": 350,
      "index": 686,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Notation.NotationMap.Monad",
      "library": "rocq-runtime.interp",
      "description": "This module implements monadic traversal and transformation operations over maps with key-value pairs. It provides `fold`, `mapi`, `fold_left`, and `fold_right` to process map entries in different orders, producing monadic results. These functions are used to integrate map processing with effectful computations such as error handling or state manipulation.",
      "description_length": 358,
      "index": 687,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.SpecificNotationSet.List",
      "library": "rocq-runtime.interp",
      "description": "This module operates on lists of sets, providing a `union` function to combine multiple sets into a single set. It works with `Notation.SpecificNotationSet.t` values stored in a list structure. A typical use case involves merging disjoint sets of notation elements into a unified set for further processing.",
      "description_length": 307,
      "index": 688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.NotationMap.Smart",
      "library": "rocq-runtime.interp",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve sharing when possible, operating specifically on values of type `'a Notation.NotationMap.t`. These functions are useful when transforming map values while minimizing unnecessary allocations, particularly in performance-sensitive contexts where structural sharing can reduce memory usage. They are ideal for scenarios like incremental updates to large maps in compilers or data-processing pipelines.",
      "description_length": 472,
      "index": 689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NumTok.SignedNat",
      "library": "rocq-runtime.interp",
      "description": "Handles conversion and classification of signed natural numbers represented as raw strings with optional underscores. Works with signed number literals, preserving their exact form for precise notation matching. Useful for parsing and pretty-printing numbers in a notation-sensitive context, such as formal verification or domain-specific language interpreters.",
      "description_length": 361,
      "index": 690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.NotationSet",
      "library": "rocq-runtime.interp",
      "description": "This module implements a functional set interface for managing collections of `Constrexpr.notation` elements, offering operations like union, intersection, difference, membership testing, and higher-order transformations (folding, filtering). It supports set construction from sequences (`Stdlib.Seq.t`) and aggregation of multiple sets, while providing utilities for cardinality checks, extremum extraction, and bidirectional conversions with lists. Typical use cases involve analyzing or combining notation sets from different contexts, such as merging imported notations or resolving naming conflicts in a modular system.",
      "description_length": 624,
      "index": 691,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genintern.Store",
      "library": "rocq-runtime.interp",
      "description": "This module implements a type-safe key-value store where each key is associated with a specific value type. It supports creating fields, setting and retrieving typed values, removing fields, and merging stores. It is used to manage heterogeneous collections of values indexed by named fields, such as configuration settings or dynamic data records.",
      "description_length": 348,
      "index": 692,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Notation.NotationMap",
      "library": "rocq-runtime.interp",
      "description": "The module implements a balanced tree-based map structure with `Constrexpr.notation` keys, supporting associative operations like insertion, deletion, and lookup alongside advanced merging, splitting, and ordered traversal. It provides both functional transformations for key-value pairs and monadic workflows that integrate effectful computations with structural manipulations, optimized for preserving sharing during updates. This enables use cases such as managing hierarchical notation mappings, analyzing domain differences, and sequencing stateful map transformations with precise control over key ordering.",
      "description_length": 613,
      "index": 693,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NumTok.Signed",
      "library": "rocq-runtime.interp",
      "description": "This module handles signed numbers represented as structured tuples combining explicit sign flags with unsigned components, preserving exact string forms like \"2e1\" or \"-00\" for Coq notation compatibility. It supports precise parsing, conversion to OCaml numeric types, and bounded comparisons between signed integers and unsigned natural numbers, enabling use cases like validating notation matches (e.g., distinguishing \"0\" from \"00\") or checking integer bounds against natural numbers in formal verification contexts.",
      "description_length": 520,
      "index": 694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.SpecificNotationSet",
      "library": "rocq-runtime.interp",
      "description": "This module implements set-theoretic operations like union, intersection, and difference for collections of `Constrexpr.specific_notation` values, supporting both imperative-style modifications and functional transformations. It works directly with sets (`t` type) and provides bidirectional conversion to lists and sequences, alongside safe (option-returning) and unsafe variants for element access and search operations. Typical use cases include managing disjoint notation sets from multiple sources, validating notation membership in grammatical constructs, and aggregating or normalizing notation definitions during parsing or compilation stages.",
      "description_length": 651,
      "index": 695,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NumTok.UnsignedNat",
      "library": "rocq-runtime.interp",
      "description": "This module handles unsigned natural numbers represented as raw strings of decimal or hexadecimal digits, preserving their original formatting, including leading zeros and underscores. It supports parsing from strings, conversion to normalized string representations, and comparison operations. Use cases include maintaining precise number formatting for notations, checking structural equality, and ensuring accurate number classification in contexts where exact string representation matters.",
      "description_length": 494,
      "index": 696,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Notation.SpecificNotationMap",
      "library": "rocq-runtime.interp",
      "description": "This module implements a polymorphic map structure associating `Constrexpr.specific_notation` keys with arbitrary values, supporting standard associative operations like insertion, deletion, and lookup alongside advanced transformations via monadic traversal and stateful accumulation. It enables efficient folding, filtering, and keyed access while preserving structural sharing, optimized for scenarios requiring ordered processing of notation-bound data with effect tracking. Typical applications include compiler passes or interpreters where notation-specific values must be dynamically manipulated and composed within a monadic context.",
      "description_length": 641,
      "index": 697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NumTok.Unsigned",
      "library": "rocq-runtime.interp",
      "description": "This module handles unsigned number tokens with optional fractional parts and exponents, preserving their exact string representation. It provides parsing from character streams and strings, classification, and conversion to natural number strings. Use cases include parsing and printing numeric literals in a notation-sensitive context where exact string forms carry specific meanings.",
      "description_length": 386,
      "index": 698,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constrexpr",
      "library": "rocq-runtime.interp",
      "description": "This module provides operations for constructing and manipulating Coq's internal syntax representations, focusing on universe-level management, notation declaration, and pattern-matching constructs. It works with data structures like universe polymorphic expressions, notation entries with custom parsing levels, and module ASTs, supporting precise handling of sort constraints and relevance annotations. Key use cases include parsing Coq terms with custom notations, managing universe polymorphism in definitions, and generating module structures during term elaboration.",
      "description_length": 572,
      "index": 699,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation_term",
      "library": "rocq-runtime.interp",
      "description": "This module defines a subset of Coq's global syntax tree used specifically for parsing and printing notations. It includes constructors for variables, constants, applications, projections, and basic control structures like conditionals and let bindings, while excluding complex terms like fixpoints. It supports notation-specific features such as binder handling, type-directed interpretation, and scoped substitution, enabling precise and context-aware notation expansion and parsing.",
      "description_length": 485,
      "index": 700,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Genintern",
      "library": "rocq-runtime.interp",
      "description": "This module provides functions for internalizing raw syntax into typed global terms, handling variable binding and notation substitution. It operates on data structures like `glob_sign`, `intern_variable_status`, and `glob_constr_and_expr`, supporting operations such as `intern`, `generic_intern`, and `substitute_notation`. It is used during Coq's parsing and tactic processing to convert user input into well-typed internal representations while managing variable scopes and notations.",
      "description_length": 488,
      "index": 701,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Modintern",
      "library": "rocq-runtime.interp",
      "description": "This module handles the internalization and interpretation of module expressions during compilation, converting abstract syntax trees into typed module entries. It works with module kinds, structured module expressions, and qualified identifiers, producing paths and context sets. Concrete use cases include processing module definitions and applications in the language's module system.",
      "description_length": 387,
      "index": 702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impargs",
      "library": "rocq-runtime.interp",
      "description": "This module manipulates implicit argument modes (strict, strongly strict, reversible pattern, contextual, maximal) and manages their statuses for Coq's global terms, providing operations to determine binding kinds, check inferability, and compute or declare implicits. It operates on types like `implicit_status`, `implicits_list`, and `manual_implicits`, interfacing with Coq's environments and global references to support use cases such as contextual implicit declarations, parameter-based selection for inductive blocks, and balancing manual versus",
      "description_length": 552,
      "index": 703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Smartlocate",
      "library": "rocq-runtime.interp",
      "description": "This module resolves global references in Coq, handling aliasing through notations, and extracting specific kinds of global entities like constants, inductives, and constructors. It works with qualified identifiers and extended global references, returning precise typed values or raising specific errors when references are ambiguous or invalid. Concrete use cases include resolving notation-bound globals during term parsing and validating syntactic definitions that must correspond to actual references.",
      "description_length": 506,
      "index": 704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Reserve",
      "library": "rocq-runtime.interp",
      "description": "This module associates logical identifiers with notation constructors, enabling type declarations and lookups. It works with identifier lists and notation terms to manage reserved type representations. Used during parsing and type-checking to resolve syntactic forms into internal type structures.",
      "description_length": 297,
      "index": 705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Decls",
      "library": "rocq-runtime.interp",
      "description": "This module defines types for classifying theorems, definitions, and assumptions in a formal logic context, along with operations to associate and query metadata about logical variables. It works with identifiers and qualified names to track variable properties such as opacity and logical role. Concrete use cases include managing declarations in a proof assistant's environment and determining the status of a variable during type checking or proof processing.",
      "description_length": 462,
      "index": 706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constrextern",
      "library": "rocq-runtime.interp",
      "description": "This module translates Coq's internal terms, patterns, and constructions into printable syntax trees while preserving binding contexts and implicit arguments, using environments and evar_maps to guide resolution. It enables customization of term rendering through reference resolution, universe display, and notation suppression, with callbacks controlling metavariable representation. Key use cases include pretty-printing proof terms, generating human-readable output with contextual bindings, and selectively hiding or exposing implicit syntactic elements.",
      "description_length": 559,
      "index": 707,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Implicit_quantifiers",
      "library": "rocq-runtime.interp",
      "description": "This module manages generalizable variables and implicit arguments in Coq's term language. It provides operations to identify free variables, declare avoidable identifiers, generate fresh names, and extract implicits from terms. Concrete use cases include handling variable capture during term substitution and automating argument inference in function applications.",
      "description_length": 366,
      "index": 708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Abbreviation",
      "library": "rocq-runtime.interp",
      "description": "This module manages abbreviations in a proof assistant environment, allowing users to declare, search, import, and toggle abbreviations. It operates on global references, identifiers, and notation interpretations, supporting context-specific activation or deactivation. Concrete use cases include defining shorthand notations for terms, querying existing abbreviations, and controlling abbreviation visibility during parsing or printing.",
      "description_length": 437,
      "index": 709,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Notationextern",
      "library": "rocq-runtime.interp",
      "description": "This module defines equality checks for various notation-related types like `notation_entry`, `notation`, and `interpretation`. It provides functions to declare and remove uninterpretation rules, determine applicative status of notations, and retrieve possible notation rules for terms, inductive types, and case patterns. It supports operations for managing notation usage during both parsing and printing phases.",
      "description_length": 414,
      "index": 710,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Constrintern",
      "library": "rocq-runtime.interp",
      "description": "This component translates high-level Coq syntax into untyped global terms and kernel-level representations, resolving implicit arguments, metavariables, and binder scopes during elaboration. It processes abstract syntax trees (`constr_expr`, `cases_pattern_expr`), environments (`env`, `evar_map`), and universe constraints to enable type-checking workflows, particularly for implicit resolution and universe polymorphism consistency. Key operations include pattern interpretation, reference resolution, and context processing, with specialized handling for universes in mutual/record definitions.",
      "description_length": 597,
      "index": 711,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dumpglob",
      "library": "rocq-runtime.interp",
      "description": "This component facilitates the creation and management of `.glob` files, which track Coq object definitions and references to enable documentation tools. It processes metadata for global entities like constants, modules, and notations using Coq's naming and declaration systems, supporting operations such as constraint logging, type serialization, and logical kind registration. These files are consumed by tools like `coqdoc` and `coq2html` to generate cross-referenced documentation and semantic annotations in Coq projects.",
      "description_length": 527,
      "index": 712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation_ops",
      "library": "rocq-runtime.interp",
      "description": "This module defines comparison and substitution operations for `notation_constr` and `interpretation` values, supporting refinement checks and variable binding management. It facilitates translation between `glob_constr` and `notation_constr`, including handling of recursive patterns and binder transformations. It also provides matching functions for aligning notation interpretations with glob constructions, cases patterns, and inductive patterns, used in Coq's notation system for parsing and printing terms.",
      "description_length": 513,
      "index": 713,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "NumTok",
      "library": "rocq-runtime.interp",
      "description": "This module processes numeric literals in various formats, including signed and unsigned integers and decimals with exponents, preserving their exact string representation. It works with raw strings containing digits, signs, underscores, and fractional or exponent parts, structured into types that track sign and classification. It supports parsing from strings and character streams, normalization, classification, and comparison operations, specifically for contexts where exact number notation matters, such as formal verification systems or DSLs with custom numeric syntax.",
      "description_length": 578,
      "index": 714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constrexpr_ops",
      "library": "rocq-runtime.interp",
      "description": "This module provides utilities for constructing, comparing, and analyzing Coq's abstract syntax trees, focusing on operations like term creation (e.g., lambdas, applications, let-bindings), binder management, and variable substitution. It works with concrete syntax types such as `constr_expr`, `sort_expr`, and `local_binder_expr`, enabling tasks like source location extraction, notation error handling, and syntactic validation. Key use cases include building and transforming Coq terms while preserving structural integrity, checking variable occurrences, and processing pattern-matching constructs.",
      "description_length": 603,
      "index": 715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.NumCompat.Q.Notations",
      "library": "micromega_core_plugin",
      "description": "This module defines arithmetic operations and comparisons for rational numbers, including addition, subtraction, multiplication, division, and standard ordering relations. It works directly with the `Q.t` type representing rational numbers. These operations support precise numerical computations in formal verification tasks involving rational arithmetic.",
      "description_length": 356,
      "index": 716,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.IMap.Monad",
      "library": "micromega_core_plugin",
      "description": "This module implements monadic operations for traversing and transforming integer maps. It provides functions like `fold`, `mapi`, `fold_left`, and `fold_right`, which allow mapping and folding over key-value pairs in an integer map with monadic effects. These operations are useful for tasks such as accumulating results, transforming values, or filtering entries based on computations that involve effects like state or error handling.",
      "description_length": 437,
      "index": 717,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.IMap.Smart",
      "library": "micromega_core_plugin",
      "description": "This module provides optimized versions of `map` and `mapi` functions that operate on integer-indexed maps (`IMap.t`), preserving structural sharing to improve efficiency. These functions apply a transformation to each value in the map, with `mapi` also exposing the corresponding key to the transformation function. It is useful when working with large maps where maintaining performance and memory usage is critical, such as in symbolic computation or constraint solving.",
      "description_length": 473,
      "index": 718,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_core_plugin.Micromega.N",
      "library": "micromega_core_plugin",
      "description": "This module defines a function `of_nat` that converts values from the `nat` type (natural numbers) into the `n` type, which represents integers. It is used to bridge arithmetic operations between natural numbers and integers within the Micromega framework. A concrete use case is translating natural number expressions into integer expressions for use in arithmetic reasoning or proof automation.",
      "description_length": 396,
      "index": 719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.IMap",
      "library": "micromega_core_plugin",
      "description": "This module provides operations for creating, modifying, and querying integer-indexed maps with polymorphic values, including insertion, deletion, merging, filtering, and ordered traversal. It supports structural-sharing optimizations through the `Smart` submodule for efficient updates and monadic effects via the `Monad` submodule to handle computations with side effects. These maps are particularly suited for symbolic computation and constraint solving tasks requiring ordered key processing and combined fold-map transformations.",
      "description_length": 535,
      "index": 720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.CoqToCaml",
      "library": "micromega_core_plugin",
      "description": "This module converts Coq numeric and index types to OCaml equivalents, handling big integers, rationals, and positive/natural numbers. It provides direct mappings from Coq's `z`, `q`, `positive`, `n`, and `nat` types to OCaml's `Big_int`, `Q.t`, and `int` representations. These conversions are used when translating Coq expressions to OCaml for evaluation or proof automation.",
      "description_length": 377,
      "index": 721,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.TagSet",
      "library": "micromega_core_plugin",
      "description": "This module provides set operations for managing collections of unique `Tag.t` values, supporting membership checks, element insertion/removal, and set algebra (union, intersection, difference). It works with a tagged set structure that allows iteration, filtering, and conversion from sequences, while enabling efficient queries for cardinality, extremal elements, or subset relationships. Typical use cases include tracking disjoint tag groups, merging tag metadata, or analyzing hierarchical tag relationships in formal verification contexts.",
      "description_length": 545,
      "index": 722,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.CamlToCoq",
      "library": "micromega_core_plugin",
      "description": "This module converts OCaml numeric types to their Coq equivalents, handling integers, natural numbers, rationals, and big integers. It provides direct mappings from OCaml `int` and `Z.t` to Coq's `positive`, `z`, `n`, `nat`, and `q` types. Useful for translating arithmetic expressions into Coq's internal representation during proof generation or tactic execution.",
      "description_length": 365,
      "index": 723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Micromega.Coq_Pos",
      "library": "micromega_core_plugin",
      "description": "This module implements arithmetic operations (addition, subtraction with carry, multiplication, GCD) and comparisons (ordering, maximum) for a custom `positive` integer type, which represents numbers in a one-based binary format. It also supports conversions from Coq's zero-based `nat` type to `positive`, enabling interoperability between zero-aware and strictly positive numeric representations. These capabilities are particularly useful in formal verification contexts where precise handling of arithmetic edge cases, carry propagation, or number-theoretic properties is required, with internal `mask` operations facilitating efficient implementation of carry-aware computations.",
      "description_length": 684,
      "index": 724,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.ISet",
      "library": "micromega_core_plugin",
      "description": "This module implements an immutable set data structure for integers, supporting operations like union, intersection, and difference, as well as element queries (e.g., min, max), transformations (map, filter), and subset checks. It works with integer sets and sequences, enabling conversions between them for iteration or bulk updates, and follows functional programming patterns with non-destructive updates.",
      "description_length": 408,
      "index": 725,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.Hash",
      "library": "micromega_core_plugin",
      "description": "This module implements equality checks and hash functions for various algebraic and arithmetic types, including integers, rationals, polynomials, and operation primitives. It supports precise structural comparisons and efficient hashing for data structures like polynomials with custom coefficients. Concrete use cases include hashing expressions for caching, comparing arithmetic terms for deduplication, and supporting hash-based collections in symbolic computation tasks.",
      "description_length": 474,
      "index": 726,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Micromega.Pos",
      "library": "micromega_core_plugin",
      "description": "This module defines a type `mask` that represents the sign of a number, with constructors for zero, positive, and negative values. It provides operations to compare and manipulate these sign values, enabling precise handling of arithmetic expressions in formal verification tasks. Concrete use cases include symbolic reasoning and constraint solving in proof assistants.",
      "description_length": 370,
      "index": 727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.Cmp",
      "library": "micromega_core_plugin",
      "description": "Implements comparison operations for lists using a provided element comparison function. Handles both direct list comparisons and lexicographical ordering through a list of comparison thunks. Useful for defining ordered collections or sorting heterogeneous list structures where custom comparison logic is required.",
      "description_length": 315,
      "index": 728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Micromega.Z",
      "library": "micromega_core_plugin",
      "description": "This module implements arithmetic operations (addition, multiplication, exponentiation), comparison logic, and Euclidean division for integers (`z`) and positive numbers (`positive`), supporting both signed and natural number representations. It includes functions for absolute value, quotient-remainder decomposition, and greatest common divisor computation, enabling precise numerical manipulations. These capabilities are suited for formal verification tasks requiring exact integer arithmetic, such as proving number-theoretic properties or solving Diophantine equations.",
      "description_length": 575,
      "index": 729,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.Tag",
      "library": "micromega_core_plugin",
      "description": "This module provides operations for managing and comparing tag values used in proof automation, such as incrementing tags, converting between integers and tags, and comparing or selecting the maximum of two tags. It works with a concrete abstract type `t` representing tags, which are typically used to track or order logical constraints. Concrete use cases include tag-based prioritization in constraint solving and ensuring correct ordering during proof reconstruction.",
      "description_length": 471,
      "index": 730,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.NumCompat.Z",
      "library": "micromega_core_plugin",
      "description": "This module implements arbitrary-precision integer arithmetic with operations including addition, subtraction, multiplication, division, modulus, exponentiation, and greatest common divisor. It works with the abstract type `t` representing integers and provides constants like zero, one, and two. Concrete use cases include symbolic computation, formal verification tasks, and exact arithmetic in theorem proving contexts.",
      "description_length": 422,
      "index": 731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.McPrinter",
      "library": "micromega_core_plugin",
      "description": "This module provides functions to print low-level arithmetic types such as `nat`, `positive`, `z`, and proof structures like `pol`, `psatz`, and `zArithProof` to an output channel. It supports pretty-printing of both numeric values and proof-related data used in arithmetic reasoning. These operations are used to display intermediate or final results during proof processing or debugging of arithmetic constraints.",
      "description_length": 415,
      "index": 732,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils",
      "library": "micromega_core_plugin",
      "description": "This module implements integer sets and maps with rich algebraic operations, tag management for proof automation, and utilities for list manipulation, comparison, and conversion between numeric representations. It provides precise data structures for handling arithmetic expressions, proof terms, and constraint systems with support for Coq interoperability and custom ordering. Key use cases include symbolic computation, constraint solving, and proof processing with structured numeric and logical data.",
      "description_length": 505,
      "index": 733,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Sos",
      "library": "micromega_core_plugin",
      "description": "This module represents and manipulates polynomials for use in Sums-Of-Squares (SOS) reasoning. It supports operations such as polynomial multiplication, negation, exponentiation, and conversion to and from terms, working with types like `poly` and `term`, and rational numbers via `NumCompat.Q`. It is used to implement decision procedures for real arithmetic based on the Positivstellensatz theorem, enabling proof generation and polynomial normalization in formal verification tasks.",
      "description_length": 485,
      "index": 734,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_core_plugin.NumCompat",
      "library": "micromega_core_plugin",
      "description": "This module defines arithmetic interfaces for integer and rational number operations. It includes submodules implementing arbitrary-precision integer arithmetic with operations like addition, multiplication, division, modulus, and GCD, working on abstract types representing integers and rationals. It supports exact computations in symbolic mathematics, formal verification, and theorem proving workflows.",
      "description_length": 406,
      "index": 735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Sos_types",
      "library": "micromega_core_plugin",
      "description": "This module defines algebraic expressions and proof terms used in Satisfiability Modulo Theories (SMT) solvers, specifically for handling arithmetic constraints. It includes operations to construct and output terms representing numbers, variables, and arithmetic operations, as well as proof structures based on the Positivstellensatz theorem. These data types and functions support formal verification tasks, such as proving inequalities and equalities in logical formulas.",
      "description_length": 474,
      "index": 736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Micromega",
      "library": "micromega_core_plugin",
      "description": "This module provides symbolic arithmetic operations on natural numbers, integers, and rational numbers, supporting polynomial construction, normalization, and algebraic manipulations like exponentiation and sign-aware computations. It works with logical formulas and algebraic structures such as polynomials, CNF clauses, and parametric expressions, enabling tasks like constraint solving, tautology checking, and automated theorem proving in formal verification contexts. Key use cases include polynomial reasoning for proof assistants, arithmetic formula normalization, and generating proof traces for logical transformations in micromega-based solvers.",
      "description_length": 655,
      "index": 737,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_core_plugin",
      "library": "micromega_core_plugin",
      "description": "This module implements core components for symbolic arithmetic and polynomial reasoning in formal verification systems. It provides operations for constructing and manipulating polynomials, logical formulas, and proof terms over integers, rationals, and natural numbers, with support for algebraic transformations, normalization, and decision procedures. Key use cases include automated theorem proving, constraint solving, and proof generation in real and integer arithmetic using Sums-Of-Squares and Positivstellensatz-based methods.",
      "description_length": 535,
      "index": 738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CoqworkmgrApi",
      "library": "rocq-runtime.coqworkmgrapi",
      "description": "This module defines priority levels and communication primitives for managing asynchronous proof workers. It provides functions to serialize and deserialize requests and responses, manage worker connections, and exchange messages like token allocation or heartbeat pings. Concrete use cases include coordinating distributed proof processing and handling worker initialization with specific priority settings.",
      "description_length": 408,
      "index": 739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqloadpath",
      "library": "rocq-runtime.sysinit",
      "description": "Initializes the load path for a Coq environment by combining standard library paths, user-contrib directories, and environment-specified paths into a structured list of physical and virtual object paths. It operates on environment configurations and file system paths to support module resolution during compilation or interactive sessions. This function is used when setting up a Coq process to ensure correct loading of libraries and user-defined modules.",
      "description_length": 457,
      "index": 740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqinit",
      "library": "rocq-runtime.sysinit",
      "description": "This module initializes the OCaml runtime and global data for the sysinit component, handling command-line argument parsing and runtime configuration. It operates on data types such as `Coqargs.t` for argument management and `Names.DirPath.t` for directory path handling. Concrete use cases include setting up the compilation environment for Coq, parsing command-line inputs, and initializing libraries with specific configurations.",
      "description_length": 432,
      "index": 741,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto0_plugin.Tuto0_main",
      "library": "tuto0_plugin",
      "description": "Contains a single value `message` holding a string, used to store a predefined text output. Works directly with string data types. Typically used to provide a static message for demonstration or initialization purposes in applications.",
      "description_length": 235,
      "index": 742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto0_plugin.G_tuto0",
      "library": "tuto0_plugin",
      "description": "This module defines a warning category and a function to issue a specific warning with an optional location. It works with the `CWarnings` module's category type and the `Loc.t` location type. It is used to trigger tutorial-specific warnings during compilation or analysis tasks.",
      "description_length": 279,
      "index": 743,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto0_plugin",
      "library": "tuto0_plugin",
      "description": "This module includes two submodules: `G_tuto0` defines a warning category and a function to issue tutorial-specific warnings with optional source locations, working with `CWarnings` and `Loc.t` types. `Tuto0_main` holds a static `message` string for demonstration or initialization use cases.",
      "description_length": 292,
      "index": 744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Debugger_support",
      "library": "rocq-runtime.debugger_support",
      "description": "Controls low-level debugging output with a mutable boolean flag. Useful for enabling or disabling verbose diagnostic logs during development.",
      "description_length": 141,
      "index": 745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Dep_info.Dep.Set.List",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module provides functions to compute the union of a list of dependency sets, where each set contains elements of type `Coqdeplib.Dep_info.Dep.t`. It operates directly on lists of these sets, enabling aggregation of multiple dependency collections into a single set. A concrete use case is consolidating dependencies from multiple source files into a unified set for analysis or processing.",
      "description_length": 394,
      "index": 746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Dep_info.Dep.Set",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module implements a functional set interface for dependency analysis, offering operations like union, intersection, difference, and membership checks alongside element aggregation and conditional extraction. It operates on sets of dependency elements (`Dep.t`) and supports conversions between sequences/lists and sets, with specialized functions for merging collections of dependency sets. Typical use cases include dependency resolution, set-based analysis of dependency graphs, and consolidating multiple dependency sources into unified representations.",
      "description_length": 561,
      "index": 747,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Common.StrSet",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module implements an immutable string set abstraction with operations for functional manipulation, including union, intersection, difference, filtering, mapping, and ordered traversal. It works with sets of strings (`t` type) and supports conversions to/from lists and sequences, along with safe element access via optional-returning variants. Typical applications include managing unique string collections with deterministic ordering, such as processing configuration keys, tracking identifiers, or handling sorted string data in a purely functional way.",
      "description_length": 561,
      "index": 748,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coqdeplib.Dep_info.Dep",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module defines a type `t` representing dependency kinds in a build system, including module basenames for resolution, plugin basenames with extensions, and other dependency categories. It includes a `Set` submodule implementing functional set operations tailored for dependency analysis tasks. These sets are used to perform union, intersection, and difference operations, supporting concrete use cases such as dependency resolution and consolidation of multiple dependency sources.",
      "description_length": 487,
      "index": 749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Loadpath.State",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module manages load path state for Coq projects, providing a `make` function to initialize the state with a worker and boot flag. It works with string options and boolean values to configure the environment. Concrete use cases include setting up Coq's load path during project initialization or worker spawning.",
      "description_length": 316,
      "index": 750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Common.State",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module provides access to the loadpath component of a global state structure, allowing retrieval of the current loadpath state. It works with the abstract state type `t` and a loadpath state type from the `Loadpath.State` module. A concrete use case is querying the current set of loaded paths during the execution of Coq commands or plugins.",
      "description_length": 347,
      "index": 751,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coqdeplib.Fl.Internal",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module provides a function `get_worker_path` that retrieves the path to the worker executable used by the system. It operates with string data types to handle and return file paths. A concrete use case includes determining the location of auxiliary binaries during runtime for proper execution setup.",
      "description_length": 305,
      "index": 752,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Args",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module defines a configuration structure for command-line arguments with boolean flags and path lists. It provides functions to initialize default settings, display usage information, and parse command-line inputs into the structured format. Concrete use cases include configuring build processes, managing file dependencies, and setting up dynamic loading paths in a compiler or interpreter toolchain.",
      "description_length": 407,
      "index": 753,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Dep_info",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module represents dependency information for build systems, with operations to construct and manage dependency records that include names and associated dependency kinds. It works with string identifiers and lists of dependency types, enabling precise tracking and manipulation of build dependencies. Concrete use cases include resolving module and plugin dependencies during compilation and consolidating dependency graphs from multiple sources.",
      "description_length": 451,
      "index": 754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Rocqdep_main",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module defines the entry point for a command-line tool that processes a list of string arguments. The `main` function takes these arguments and executes the core logic of the application, typically involving parsing, analysis, or transformation of input data. It is used to launch the tool with specific configurations or input files provided as command-line parameters.",
      "description_length": 375,
      "index": 755,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coqdeplib.Fl",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module resolves file paths for `.cmxs` plugins and their dependencies using `findlib_deep_resolve`, which takes a file and package name as inputs. It works with string lists to represent file paths and package dependencies. The `Internal` submodule retrieves worker executable paths, used to locate auxiliary binaries needed at runtime for system execution setup.",
      "description_length": 368,
      "index": 756,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Lexer",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module defines lexing rules and token types for parsing Coq source code. It processes input using a lexbuf and produces structured tokens representing Coq constructs such as Require, Declare, Load, and External. These tokens capture elements like qualified identifiers and file paths, enabling analysis or transformation of Coq code.",
      "description_length": 338,
      "index": 757,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coqdeplib.Static_toplevel_libs",
      "library": "rocq-runtime.coqdeplib",
      "description": "Contains a list of standard library modules automatically loaded in the Coq static toplevel. Used to track dependencies and available definitions during interactive proof sessions. Directly influences the initial environment setup in Coq's REPL.",
      "description_length": 245,
      "index": 758,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Error",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module defines functions for raising errors during file parsing and project loading operations. It works with strings and position data to report specific failure causes. Concrete use cases include handling invalid file formats, unreadable project files, and incorrect file paths during project initialization.",
      "description_length": 315,
      "index": 759,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.File_util",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module provides functions for manipulating file paths, specifically converting absolute paths to relative ones and normalizing paths by removing redundant components like `.` and `..`. It operates on string representations of file paths and preserves trailing slashes. Use cases include cleaning up paths for user display, ensuring consistent path formatting, and resolving relative paths during file loading or navigation tasks.",
      "description_length": 434,
      "index": 760,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Loadpath",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module handles load path configurations for Coq projects, providing operations to register directories with varying inclusion rules, resolve logical paths against physical directories, and normalize path representations. It works with strings, optional strings, and structured types like `dirpath` and `root`, organizing state transitions through a dedicated `State` module. These capabilities are essential during project initialization to establish valid library hierarchies and when spawning worker processes to maintain consistent path resolution contexts.",
      "description_length": 565,
      "index": 761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Common",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module handles initialization and state management for Coqdep, providing functions to set up the global state from command-line arguments, add input files, sort dependencies, and compute dependency information. It works with global state (`State.t`), string sets (`StrSet.t`), and dependency records (`Dep_info.t`). Concrete use cases include processing Coq source files, managing load paths, and generating dependency graphs for Coq projects.",
      "description_length": 448,
      "index": 762,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Makefile",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module handles dependency tracking and build configuration for Coq projects. It provides functions to print dependency information, control dynamic dependencies, disable globbing, and configure VOS file writing. Key operations include formatting and outputting dependency data, and toggling build system behaviors during compilation.",
      "description_length": 338,
      "index": 763,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module processes Coq source code to analyze and resolve dependencies between files and modules. It parses command-line arguments, tracks load paths, and constructs dependency graphs using structured representations of files and modules. Concrete use cases include compiling Coq projects with correct module inclusions, generating Makefile rules for dependency tracking, and ensuring consistent path resolution during interactive proof sessions.",
      "description_length": 449,
      "index": 764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tacinterp.TacStore",
      "library": "ltac_plugin",
      "description": "This module implements a typed key-value store for managing dynamic fields with operations to create, set, retrieve, remove, and merge fields. It works with a polymorphic store type `t` and typed fields identified by strings. Concrete use cases include tracking tactic interpreter state, storing transient values during proof script execution, and managing per-invocation data in Coq's Ltac system.",
      "description_length": 398,
      "index": 765,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.Tacinterp.Value",
      "library": "ltac_plugin",
      "description": "This module provides functions to convert and manipulate values within a tactic interpreter, supporting operations like converting Coq terms to values and vice versa, handling integers, lists, and closures. It works with data types such as `Geninterp.Val.t`, `EConstr.constr`, `int`, and tactic expressions. Concrete use cases include embedding Coq terms into tactic values, extracting integer or list data from interpreted values, and applying tactic closures with argument lists during proof scripting.",
      "description_length": 504,
      "index": 766,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Taccoerce.Value",
      "library": "ltac_plugin",
      "description": "This module defines conversions between abstract values and specific data types used in tactic interpretation, including integers, identifiers, constructions, and contexts. It provides bidirectional transformations for embedding and extracting these types into a generic value representation. These operations enable dynamic type inspection and coercion during tactic execution, particularly when interpreting user-provided arguments.",
      "description_length": 434,
      "index": 767,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tacsubst",
      "library": "ltac_plugin",
      "description": "This module handles the substitution of tactics and related expressions during module closing by applying substitutions to tactic expressions, generic arguments, and reduction expressions. It operates on data types such as `glob_tactic_expr`, `glob_generic_argument`, `glob_constr_and_expr`, and `glob_red_expr`, typically used in tactic manipulation and module system operations. Concrete use cases include adjusting tactic definitions when modules are instantiated or linked, ensuring correct references across module boundaries.",
      "description_length": 531,
      "index": 768,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Internals",
      "library": "ltac_plugin",
      "description": "This module offers low-level tactics for manipulating Coq proofs, including assertion, refinement, decomposition, hypothesis analysis, and term transformation, alongside utilities for heap optimization and proof metadata generation. It operates on proof terms (`EConstr.t`, `constr`, `clause`) and interacts with Coq's tactic framework (`Proofview.tactic`, `Tacinterp`), enabling term classification, controlled instantiation, and tactic execution optimizations. These tools are used internally for tasks like goal decomposition, handling optional values with holes, and improving tactic performance through efficient term processing.",
      "description_length": 634,
      "index": 769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.G_class",
      "library": "ltac_plugin",
      "description": "This module defines generalized argument types and entry points for debugging flags and eauto search strategies in Coq's tactic system. It works with boolean values and `search_strategy` options to configure tactic behavior during proof search. Concrete use cases include enabling debug output and specifying custom search strategies for the `eauto` tactic in proof scripts.",
      "description_length": 374,
      "index": 770,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.ComRewrite",
      "library": "ltac_plugin",
      "description": "This module provides functions to declare and manage rewrite relations and morphisms in Coq's Ltac system. It works with Coq's internal syntax and proof structures, such as `constr_expr`, `local_binder_expr`, and tactics. Concrete use cases include defining custom rewriting rules, adding setoids, and registering morphisms for interactive proof automation.",
      "description_length": 357,
      "index": 771,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.G_ltac",
      "library": "ltac_plugin",
      "description": "This module converts Coq/Ltac data types (e.g., `unit`, `int`, `constr_expr`, tactic expressions) into `Genarg`-typed arguments for tactic registration and parsing workflows. It processes grammar and argument handling for tactic definitions, including support for modes, selectors, and hint infrastructure. These utilities enable parsing tactic syntax, managing extra arguments during execution, and forming the backbone of Ltac's tactic definition and evaluation mechanisms.",
      "description_length": 475,
      "index": 772,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.G_rewrite",
      "library": "ltac_plugin",
      "description": "This module handles parsing, binding, and rewriting operations for Coq's tactic language, specifically supporting the `rewrite` tactic. It defines types and witnesses for interpreting and processing rewrite strategies, bound variables, and globally resolved constructions with bindings. It is used internally to implement tactic expressions involving rewriting, such as parsing rewrite rules and managing binder contexts during tactic execution.",
      "description_length": 445,
      "index": 773,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.G_auto",
      "library": "ltac_plugin",
      "description": "This module defines generalized argument types and entry points for automation tactics in Coq, specifically handling hint databases, paths to hints, and lists of constraints used during proof search. It supports parsing and processing of tactic arguments related to automated reasoning, such as hint bases, hint paths, and constraint expressions. Concrete use cases include configuring and invoking the `auto` tactic with custom hint databases and structured proof search parameters.",
      "description_length": 483,
      "index": 774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tactic_option",
      "library": "ltac_plugin",
      "description": "This module defines and manages tactic options with support for scoped configuration. It provides operations to declare tactic options with optional default values, associate them with attributes, and handle their evaluation and printing. The core data type is `tac_option_locality`, which represents the scope of a tactic option, and it works closely with tactic expressions and attributes. Use cases include configuring tactic behavior within specific scopes, such as setting local evaluation rules for proof automation.",
      "description_length": 522,
      "index": 775,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.Tacarg",
      "library": "ltac_plugin",
      "description": "This module defines generalized argument types used in tactic expressions, handling parsing, typing, and interpretation of constructs like intro patterns, bindings, and destruction arguments. It works with Coq's tactic expression structures, including constraint expressions, tactic values, and delayed opening mechanisms. These are used to implement tactic notations, pattern matching, and hypothesis manipulation in Ltac scripting.",
      "description_length": 433,
      "index": 776,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tacintern",
      "library": "ltac_plugin",
      "description": "This module converts raw tactic expressions into globally resolved tactic expressions, handling variable binding, environment context, and strict type checking. It operates on data types such as `raw_tactic_expr`, `glob_tactic_expr`, and `glob_sign`, which encapsulates the environment and variable state. Concrete use cases include parsing and resolving tactics during proof script execution, ensuring proper scoping and type correctness before tactic application.",
      "description_length": 465,
      "index": 777,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.Tacexpr",
      "library": "ltac_plugin",
      "description": "This module provides types for parsing, evaluating, and composing tactic expressions in Coq's Ltac language, handling operations like term manipulation, pattern matching, and resolution of constants and references. It works with structured data such as tactic dispatch types, introduction patterns, construction terms, and execution stacks, supporting phases like raw parsing, global resolution, and typed evaluation, with use cases in implementing plugin tactics, rewriting strategies, and execution tracing during proof development.",
      "description_length": 534,
      "index": 778,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.G_obligations",
      "library": "ltac_plugin",
      "description": "This module defines generalized arguments and entry points for handling tactic expressions in Coq's Ltac language. It provides `wit_withtac` and `withtac` to support optional tactic arguments in vernacular commands and tactic entry parsing. Concrete use cases include extending Coq commands to accept optional tactics for proof automation.",
      "description_length": 339,
      "index": 779,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.Tacentries",
      "library": "ltac_plugin",
      "description": "This module manages the definition and registration of Ltac tactics, notations, and quotations within Coq's proof engine. It provides operations to add tactic definitions, extend tactic syntax with custom grammar productions, register argument types for notations, and embed ML-defined tactics directly into Ltac. It works with data types such as `tacdef_body`, `tactic_grammar_obj`, `raw_argument`, `ml_ty_sig`, and `ty_ml`, supporting concrete use cases like defining new tactics, creating custom tactic syntax, and extending Ltac with plugin-based functionality.",
      "description_length": 565,
      "index": 780,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tacinterp",
      "library": "ltac_plugin",
      "description": "This module provides infrastructure for interpreting Ltac tactics in Coq, focusing on converting Coq terms to tactic values and vice versa, evaluating tactic expressions into executable actions, and managing interpreter state through a typed store. It operates on tactic expressions, bindings, constr expressions, and interpretation states, leveraging modules like `Environ`, `Evd`, and `Proofview` to handle type checking, globalization, and dynamic state tracking. Specific use cases include debugging tactic execution, tracing evaluation steps, and ensuring correct term manipulation during proof automation.",
      "description_length": 611,
      "index": 781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.G_tactic",
      "library": "ltac_plugin",
      "description": "This module defines a set of parser entry points for recognizing specific syntactic patterns in tactic expressions, such as identifiers followed by assignment operators or bracketed expressions. It works primarily with parsing states and lexical tokens to match concrete syntax forms. These entries are used to implement custom tactic notations and extend the Ltac language with new parsing rules.",
      "description_length": 397,
      "index": 782,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tactic_debug",
      "library": "ltac_plugin",
      "description": "This module implements a basic debugger for tactic expressions, providing operations to initialize debugging, print intermediate states, and handle exceptions during tactic execution. It works with tactic expressions, proof states, and trace information, supporting concrete use cases like inspecting tactic evaluation steps and catching errors in Ltac scripts. Key functions include setting breakpoints, printing constraints, and managing trace chunks to aid in step-by-step tactic debugging.",
      "description_length": 493,
      "index": 783,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tacenv",
      "library": "ltac_plugin",
      "description": "This module enables the registration, lookup, and lifecycle management of tactics within Coq's Ltac plugin system, supporting both user-defined and ML-implemented tactics. It operates on tactic entries, ML tactic definitions, and alias mappings in the tactic environment, facilitating use cases like extending proof automation, versioning tactic APIs, and maintaining backward compatibility through deprecation warnings or alternative names. Key operations include resolving tactic references by name, tracking redefinitions, and enforcing error handling for undefined tactics.",
      "description_length": 577,
      "index": 784,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Taccoerce",
      "library": "ltac_plugin",
      "description": "This module enables conversion of abstract tactic values into concrete Coq Ltac data types like identifiers, hypotheses, constructions, and patterns through dynamic type inspection. It operates on `Value.t` structures within an environment and evar_map context, supporting coercions to structured types such as hypothesis declarations and integer lists while raising exceptions for invalid inputs. These functions are critical for interpreting tactic arguments during Ltac execution, ensuring precise type-driven extraction and error detection in interactive proof scripting.",
      "description_length": 575,
      "index": 785,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tactic_matching",
      "library": "ltac_plugin",
      "description": "This module implements pattern matching logic for Coq's Ltac language, providing `match_term` and `match_goal` functions to apply tactic expressions based on term and goal structure. It operates on Coq terms (`EConstr.constr`), proof environments (`Environ.env`), and tactic expressions (`glob_tactic_expr`), using binding and instantiation data during pattern evaluation. It enables conditional tactic execution in proof scripts by matching goal contexts or arbitrary terms against user-defined patterns.",
      "description_length": 505,
      "index": 786,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Extratactics",
      "library": "ltac_plugin",
      "description": "This module defines comparison operators (`Eq`, `Lt`, `Le`, `Gt`, `Ge`) and provides typed witnesses for comparison and test operations. It supports constructing and manipulating logical tests involving integers or variables in tactic expressions. Concrete use cases include building conditional logic within Coq tactics based on numeric comparisons.",
      "description_length": 350,
      "index": 787,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Pltac",
      "library": "ltac_plugin",
      "description": "This module defines parsing entries for various components of tactics and proof terms in the context of interactive theorem proving. It provides entry points for parsing constructions with bindings, hypotheses, tactic expressions, introduction patterns, and clauses, among others. These are used directly by the proof engine to interpret tactic scripts and goal manipulations during proof development.",
      "description_length": 401,
      "index": 788,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Extraargs",
      "library": "ltac_plugin",
      "description": "This module provides functions to parse, manipulate, and print generalized argument types in Coq's tactic language, including support for term operations, variable renaming, occurrence specifications, orientation flags, and tactic execution contexts. It operates on Coq-specific data like identifiers, constraint expressions, and tactic expressions, enabling use cases such as defining tactic notations, handling optional arguments, and managing raw or globbed tactic forms with strategy levels.",
      "description_length": 495,
      "index": 789,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Leminv",
      "library": "ltac_plugin",
      "description": "This module provides tactics for inversion lemma manipulation and application in proof scripts. It supports operations like clause inversion and lemma registration, working with hypotheses, constraints, and identifiers. Concrete use cases include automating case analysis on inductive types and managing proof state transformations during inversion steps.",
      "description_length": 355,
      "index": 790,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin",
      "library": "ltac_plugin",
      "description": "This module provides functionalities for parsing, rewriting, proof automation, tactic execution, expression resolution, and debugging of Ltac tactics. It operates on Coq-specific data structures like `constr_expr`, `tactic_expr`, `Genarg`, `Value.t`, proof states, and environment contexts, enabling tasks such as defining tactic notations, managing rewrite rules, configuring automated proof search, and developing plugins with advanced pattern matching and scoped configurations.",
      "description_length": 481,
      "index": 791,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coq_config",
      "library": "rocq-runtime.config",
      "description": "This module provides configuration parameters and platform-specific settings for a proof assistant environment, working with basic types like strings, booleans, and integer lists to represent installation paths, version metadata, and compilation flags. It supports use cases such as enabling native dynamic linking, bytecode compilation, and web resource management through declarative flags and URL references. A dedicated type controls native compiler behavior, allowing explicit on/off states and demand-driven activation to optimize resource usage.",
      "description_length": 552,
      "index": 792,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernac.State",
      "library": "rocq-runtime.toplevel",
      "description": "This module manages the parsing and execution state of vernacular commands in a proof assistant. It tracks the document state, session ID, current proof context, and timing information during command processing. It is used to maintain and propagate the state across sequential commands, enabling features like proof mode, document re-parsing, and time-stamped output.",
      "description_length": 367,
      "index": 793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqc",
      "library": "rocq-runtime.toplevel",
      "description": "This module defines the entry point for executing a list of string arguments, typically used to process command-line inputs in a compiler or interpreter context. It operates directly on string lists, enabling argument parsing and initialization of execution workflows. Concrete use cases include launching compilation pipelines or handling script parameters in a REPL environment.",
      "description_length": 380,
      "index": 794,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Colors",
      "library": "rocq-runtime.toplevel",
      "description": "This module manages color output initialization and style tagging for terminal or Emacs environments. It defines operations to set color mode (`ON`, `AUTO`, `EMACS`, `OFF`), parse command-line arguments for color settings, and apply style tags based on the selected mode. Concrete use cases include enabling syntax highlighting in command-line tools or configuring output for compatibility with Emacs.",
      "description_length": 401,
      "index": 795,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common_compile",
      "library": "rocq-runtime.toplevel",
      "description": "This module handles file path manipulations, proof validation, and resource existence checks during compilation tasks. It works with strings representing file paths, extensions, and compilation states, and integrates with OCaml's standard libraries for file operations. Concrete use cases include ensuring target files exist based on source paths, safely removing file extensions, and validating that no pending proofs remain in a given file.",
      "description_length": 442,
      "index": 796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqrc",
      "library": "rocq-runtime.toplevel",
      "description": "Loads a configuration file into the given proof state, updating it with commands from the file. Works with the `Vernac.State.t` type, which represents the current state of the Coq proof environment. Useful for initializing or restoring proof sessions with predefined settings or tactics.",
      "description_length": 287,
      "index": 797,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ccompile",
      "library": "rocq-runtime.toplevel",
      "description": "This module compiles Coq source files into bytecode or native code. It handles parsing command-line arguments, initializing the compilation environment, and invoking the appropriate compiler backend. Concrete use cases include building Coq projects and generating standalone executables from Coq developments.",
      "description_length": 309,
      "index": 798,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Load",
      "library": "rocq-runtime.toplevel",
      "description": "Loads initialization vernaculars from the Coq configuration file using the provided command-line options and initial state, returning an updated vernacular state. It processes Coq's initialization script to set up the environment with user-specified settings and customizations. This function is used during Coq's startup to apply configurations before starting the main interaction loop.",
      "description_length": 388,
      "index": 799,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqtop",
      "library": "rocq-runtime.toplevel",
      "description": "This module defines custom toplevel behaviors for Coq, providing initialization and execution hooks for interactive and batch modes. It works with custom toplevel configurations, command-line arguments, and Coq's vernacular state, supporting operations like loading files, setting up the load path, and handling debug actions. Concrete use cases include launching a Coq session with custom initialization, executing Coq scripts in batch mode, and integrating debug hooks for tactics.",
      "description_length": 483,
      "index": 800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "G_toplevel",
      "library": "rocq-runtime.toplevel",
      "description": "This module defines a variant type representing top-level commands in a proof system, including navigation, quitting, and goal-display operations. It provides parsers and entry points for handling these commands, specifically working with proof modes and goal identifiers. Concrete use cases include implementing command-line interfaces for theorem provers and managing proof state transitions.",
      "description_length": 394,
      "index": 801,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WorkerLoop",
      "library": "rocq-runtime.toplevel",
      "description": "Starts a worker process that initializes with a setup function, runs a continuous loop, and accepts command-line arguments. It handles long-running tasks like background processing or event loops. Useful for implementing daemons or server workers that require initialization and persistent execution.",
      "description_length": 300,
      "index": 802,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coqcargs",
      "library": "rocq-runtime.toplevel",
      "description": "This module defines configuration options for controlling compilation behavior, including modes like building `.vo`, `.vos`, or `.vok` files, output naming, and whether to echo commands. It provides a `parse` function to extract these settings from a list of command-line arguments, and a `default` value for baseline configuration. It is used to set up compilation parameters in batch processing tools like `coqc`.",
      "description_length": 415,
      "index": 803,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Memtrace_init",
      "library": "rocq-runtime.toplevel",
      "description": "Initializes memory tracing for the application, setting up internal structures to track allocations and deallocations. Works directly with the runtime's memory management system to enable detailed tracing data. Useful for profiling memory usage patterns and identifying leaks during performance analysis.",
      "description_length": 304,
      "index": 804,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqloop",
      "library": "rocq-runtime.toplevel",
      "description": "This module implements the interactive toplevel loop for processing Coq commands. It manages input buffering, command execution, and feedback reporting during a Coq session. It works with parsing and evaluation states to handle incremental proof development and tactic execution.",
      "description_length": 279,
      "index": 805,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernac",
      "library": "rocq-runtime.toplevel",
      "description": "This module processes and executes vernacular commands in a proof assistant, managing document state, proof context, and timing information. It provides functions to load files and evaluate commands while maintaining session consistency. Concrete use cases include interpreting user input, replaying proof scripts, and generating time-stamped command output.",
      "description_length": 358,
      "index": 806,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Globnames.ExtRefMap.Monad",
      "library": "rocq-runtime.library",
      "description": "This module provides monadic variants of map and fold operations over `Globnames.ExtRefMap.t` structures. It allows folding over key-value pairs with monadic effects and mapping over the structure while producing new values within a monad. These operations are useful for traversing and transforming maps in a monadic context, such as accumulating results with error handling or state.",
      "description_length": 385,
      "index": 807,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Globnames.ExtRefMap.Smart",
      "library": "rocq-runtime.library",
      "description": "This module provides optimized versions of `map` and `mapi` that attempt to preserve structural sharing in maps keyed by `Globnames.ExtRef`. It works directly with `Globnames.ExtRefMap.t`, a map structure over extended references. These functions are useful when transforming values in large maps while minimizing memory allocation and maintaining performance.",
      "description_length": 360,
      "index": 808,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Summary.Dyn.HMap",
      "library": "rocq-runtime.library",
      "description": "Transforms and filters typed entries in a dynamic summary map using type-specific functions. It applies a map operation to convert values from one type to another or filters entries based on a predicate, both operating on maps parameterized by type representations. Useful for processing heterogeneous data stored in a structured summary, such as selectively extracting or modifying typed fields during analysis or serialization.",
      "description_length": 429,
      "index": 809,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Summary.Dyn.Easy",
      "library": "rocq-runtime.library",
      "description": "This module simplifies working with dynamically typed summaries by providing functions to create injectors and projectors for arbitrary types. It operates on `Summary.Dyn.t` values and uses type-safe tags to ensure correct serialization and deserialization. Use cases include embedding and extracting typed values like integers, strings, or custom structures from a summary without runtime type errors.",
      "description_length": 402,
      "index": 810,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libobject.Dyn.Easy",
      "library": "rocq-runtime.library",
      "description": "This module provides functions to create and manipulate dynamically typed values with runtime type information, enabling type-safe injection and projection operations. It works with abstract data types represented as `Libobject.Dyn.t` and associated type tags. Use cases include handling heterogeneous collections of values, implementing generic operations over different object types, and supporting dynamic dispatch based on type tags.",
      "description_length": 437,
      "index": 811,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libobject.Dyn.Map",
      "library": "rocq-runtime.library",
      "description": "This module implements a type-safe map from type tags to values parameterized by the tag type, supporting operations like insertion, lookup, modification, and traversal. It works with polymorphic keys (`'a key`) and values (`'a value`), ensuring type consistency across operations. Concrete use cases include managing heterogeneous collections of typed data, such as configuration settings or dynamic object properties, where type preservation is critical.",
      "description_length": 456,
      "index": 812,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Summary.Dyn.Map",
      "library": "rocq-runtime.library",
      "description": "This module implements a type-safe map from type tags to values parameterized by those tags, supporting operations like insertion, lookup, modification, and filtering. It works with existential types to store and retrieve values of varying types indexed by their corresponding type keys. Concrete use cases include managing heterogeneous collections of values keyed by their types, such as configuration settings or dynamic summaries.",
      "description_length": 434,
      "index": 813,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libobject.Dyn.HMap",
      "library": "rocq-runtime.library",
      "description": "This module provides transformations and filtering of dynamic maps using functions that operate on tagged values. It works with polymorphic maps where each entry is associated with a type tag, allowing type-safe retrieval and manipulation. Concrete use cases include adapting or restricting the contents of dynamic maps during module loading or substitution, such as mapping values from one representation to another or selecting a subset based on type-specific criteria.",
      "description_length": 471,
      "index": 814,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goptions.MakeStringTable",
      "library": "rocq-runtime.library",
      "description": "This module tracks a set of strings, providing operations to add, remove, and test membership. It supports boolean and value-based options for dynamic configuration. Use cases include managing command-line flags, feature toggles, or dynamic settings in a document-aware context.",
      "description_length": 278,
      "index": 815,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Summary.Stage",
      "library": "rocq-runtime.library",
      "description": "This module defines stages of processing, specifically `Synterp` and `Interp`, and provides an `equal` function to compare them. It works with the enumerated type `t` representing different execution phases. Use this module to track or compare processing stages in a system that requires synchronization across backtracking steps.",
      "description_length": 330,
      "index": 816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lib.Interp",
      "library": "rocq-runtime.library",
      "description": "This module manages the trace and undo of operations, including support for sections, modules, and modtypes. It provides functions to open/close sections, add entries, and manipulate summaries, working with identifiers, module paths, and libobjects. Use cases include tracking state changes during proof development and managing modular structures in the library.",
      "description_length": 363,
      "index": 817,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Globnames.ExtRefOrdered",
      "library": "rocq-runtime.library",
      "description": "This module defines operations for comparing, checking equality, and computing hash values for extended global references. It works directly with the type `Globnames.extended_global_reference`, enabling ordered handling of Coq's global identifiers. It is used in contexts requiring canonical ordering or hashing of global symbols, such as managing environments or persistent state.",
      "description_length": 381,
      "index": 818,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libobject.Dyn",
      "library": "rocq-runtime.library",
      "description": "This module implements a type-safe dynamic value system with runtime type identification and casting. It works with heterogeneous values wrapped in a universal type `t` and associated type tags, supporting concrete use cases like storing and retrieving typed metadata, implementing plugin systems with dynamic object registration, and managing extensible, type-preserving configuration data. Key operations include creating and comparing type tags, dynamically casting values, and inspecting registered types.",
      "description_length": 509,
      "index": 819,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goptions.MakeRefTable",
      "library": "rocq-runtime.library",
      "description": "This module implements operations for managing a table of elements with activation states, supporting queries, updates, and synchronization with document state. It works with a set of elements of type `A.t` and tracks whether each element is active. Concrete use cases include enabling or disabling specific configuration items through commands like `Add`, `Remove`, `Set`, and `Test`, with changes reflected in the document.",
      "description_length": 425,
      "index": 820,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libobject.ExportObj",
      "library": "rocq-runtime.library",
      "description": "This module handles the export of persistent objects during module loading and opening, managing their visibility in the `Nametab` based on suffix rules and module scope changes. It works with persistent objects defined in `Libobject`, particularly those requiring visibility registration and substitution behavior tied to module inclusion or import. Concrete use cases include controlling the visibility of definitions when modules are imported or included, ensuring correct name resolution and scoping for objects like monomorphic universes and constraints.",
      "description_length": 559,
      "index": 821,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libnames.Spmap",
      "library": "rocq-runtime.library",
      "description": "This module implements polymorphic map structures keyed by hierarchical full paths, supporting standard associative operations like insertion, deletion, and lookup, alongside higher-order transformations for merging, filtering, and folding over key-value pairs. It operates on the `Spmap.t` type, using `Spmap.key` (equivalent to `Libnames.full_path`) as the key type, with polymorphic values, enabling efficient querying, splitting, and extremal key-value selection. It is particularly suited for managing hierarchical data or symbol tables where path-based keys require structured traversal, aggregation, or conditional updates.",
      "description_length": 630,
      "index": 822,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Summary.Interp",
      "library": "rocq-runtime.library",
      "description": "This module manages summaries by allowing their freezing, unfreezing, and modification. It works with a `frozen` type representing immutable summaries, and supports operations like extracting or updating values of specific types using typed tags. It is used to capture, store, and manipulate structured summaries of data, enabling selective projection and safe modification of summary contents.",
      "description_length": 394,
      "index": 823,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lib.Synterp",
      "library": "rocq-runtime.library",
      "description": "This module tracks and manages operations for backtracking, including opening and closing sections, adding entries, and freezing state. It works with summaries, nodes, identifiers, and low-level module constructs like module paths and prefixes. It supports concrete actions like finding section opening points, closing sections with discharge handling, and initializing or restoring frozen states.",
      "description_length": 397,
      "index": 824,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nametab.GlobDirRef",
      "library": "rocq-runtime.library",
      "description": "This module defines a type `t` representing globally opened directories in Coq's name resolution system, specifically for modules, module types, and sections. It includes a comparison function `equal` to check equality between these directory references. Concrete use cases include tracking open scopes during proof development and managing qualified name resolution in the Coq interpreter.",
      "description_length": 390,
      "index": 825,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Summary.Dyn",
      "library": "rocq-runtime.library",
      "description": "This module implements type-safe dynamic values with unique tags, supporting creation, comparison, and lookup of typed data. It works with existential types to store and retrieve values of arbitrary types, indexed by registered type keys. Concrete use cases include safely embedding and extracting typed values like integers, strings, or custom structures from a summary, and managing heterogeneous collections of values keyed by type.",
      "description_length": 435,
      "index": 826,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nametab.Make",
      "library": "rocq-runtime.library",
      "description": "This module implements a scoping mechanism for mapping user-defined names to globally qualified identifiers, supporting operations like adding, removing, and resolving names within a visibility context. It works with qualified identifiers (`Libnames.qualid`), user names (`U.t`), and elements (`E.t`), providing precise name resolution and shortest qualification inference. Concrete use cases include managing local and global name bindings during proof development and ensuring unambiguous reference resolution in interactive theorem proving sessions.",
      "description_length": 552,
      "index": 827,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Globnames.ExtRefSet",
      "library": "rocq-runtime.library",
      "description": "This module supports membership testing, union operations, and functional transformations over collections of globally named references, specifically handling `Globnames.extended_global_reference` values. It provides utilities to inspect set properties like cardinality, extract ordered lists of elements, or select representative items from reference sets. Such capabilities are useful for tasks like dependency tracking, reference filtering, or static analysis of codebases with complex naming hierarchies.",
      "description_length": 508,
      "index": 828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goptions.OptionMap",
      "library": "rocq-runtime.library",
      "description": "This module implements a polymorphic map structure with string list keys representing hierarchical option names, supporting standard dictionary operations (insertion, deletion, lookup) and ordered key-value manipulation (e.g., min/max bindings, splitting). Advanced functions enable map transformations through mapping, merging, filtering, and key-based decomposition. It is used to manage document-synchronized configuration parameters, enabling vernacular commands like `Set`, `Add`, `Remove`, and `Print` for hierarchical tables and options.",
      "description_length": 544,
      "index": 829,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nametab.Modules",
      "library": "rocq-runtime.library",
      "description": "This module manages snapshots of globalization tables that map internal object references to qualified names. It provides operations to freeze the current state into a snapshot and restore it later, ensuring consistent name resolution across different compilation units. Use cases include saving and restoring name environments during module serialization or cross-compilation tasks.",
      "description_length": 383,
      "index": 830,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Summary.Synterp",
      "library": "rocq-runtime.library",
      "description": "This module manages snapshots of registered table states, providing functions to freeze, unfreeze, and manipulate these snapshots. It works with the `frozen` type, which captures the state of summaries at a point in time, and supports operations like partial unfreezing and making snapshots marshallable. Concrete use cases include checkpointing system state, restoring summaries, and extracting specific data from frozen summaries using dynamic tags.",
      "description_length": 451,
      "index": 831,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Summary",
      "library": "rocq-runtime.library",
      "description": "This module manages processing stages and structured summaries of data, enabling freezing, unfreezing, and type-safe dynamic value manipulation. It works with enumerated stages (`Synterp` and `Interp`), `frozen` summaries, and existential types via the `Dyn` module. Concrete use cases include checkpointing execution state, synchronizing data across backtracking steps, and embedding or extracting typed values (e.g., integers, custom structures) from summaries using type-safe tags.",
      "description_length": 484,
      "index": 832,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libnames",
      "library": "rocq-runtime.library",
      "description": "This module offers hierarchical path manipulation operations for `DirPath.t` and `full_path` types, including splitting, appending, and qualified name parsing, alongside utilities for handling qualified identifiers (`qualid`) with string conversions and path-component queries. It integrates the `Spmap` submodule for hierarchical, path-keyed polymorphic maps, enabling structured associative operations and traversal over nested data. These capabilities are primarily used for managing Coq's module system, resolving namespace hierarchies, and configuring development path conventions through predefined root prefixes and context initialization strings.",
      "description_length": 654,
      "index": 833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goptions",
      "library": "rocq-runtime.library",
      "description": "This module provides operations to declare and manage hierarchical configuration options and tables synchronized with a document, supporting typed values (boolean, integer, string) and structured collections (string/ref-based tables) through vernacular commands. It enables customization via actions like setting, unsetting, adding/removing entries, and testing/printing states, with use cases including document-scoped parameter configuration and extensible option management for features or plugins.",
      "description_length": 501,
      "index": 834,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Globnames",
      "library": "rocq-runtime.library",
      "description": "This module defines predicates and destructors for inspecting global references, including checks for variables, constants, inductives, and constructors, along with substitution operations over these references. It works directly with `Names.GlobRef.t` and related substitution mechanisms, supporting manipulation and canonicalization of global identifiers in Coq. Concrete use cases include symbol resolution, environment management, and reference substitution during term transformation or module instantiation.",
      "description_length": 513,
      "index": 835,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Global",
      "library": "rocq-runtime.library",
      "description": "This module orchestrates the global environment's evolution through operations that register and modify definitions (constants, inductives, modules), enforce universe polymorphism constraints, and manage hierarchical contexts via section scoping. It manipulates structured data like named declarations, kernel-level references, and module paths while supporting critical workflows such as type-safe name resolution, proof opacity handling, and cross-compilation backend configuration. Key applications include maintaining consistency during interactive theorem proving, managing library imports/exports, and configuring evaluation strategies for computational tasks.",
      "description_length": 666,
      "index": 836,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lib",
      "library": "rocq-runtime.library",
      "description": "This module provides mechanisms for backtracking operations, managing modular structures, and tracking library objects within a hierarchical naming system. It operates on data structures such as module paths, identifiers, libobjects, and section segments, supporting low-level state management for name resolution, compilation tracking, and discharge operations. Specific use cases include handling section hierarchies, classifying modular entities, and maintaining context during library compilation or projection discharge.",
      "description_length": 525,
      "index": 837,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Library_info",
      "library": "rocq-runtime.library",
      "description": "This module handles warnings related to library information during compilation. It provides a function to emit warnings when library paths or metadata are inconsistent or deprecated. The module works with directory paths and warning configurations to ensure correct handling of library dependencies.",
      "description_length": 299,
      "index": 838,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nametab",
      "library": "rocq-runtime.library",
      "description": "This module manages name resolution and globalization for programming language entities, handling qualified identifiers and paths across modules, types, and universes. It operates on structured references like module paths, directory paths, and visibility scopes, enabling operations to push, locate, and disambiguate global objects while supporting error-tolerant resolution and context-aware pretty-printing. Key use cases include cross-module name consistency during compilation, handling ambiguous name completions, and serializing global reference states for development tools or interactive environments.",
      "description_length": 610,
      "index": 839,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libobject",
      "library": "rocq-runtime.library",
      "description": "This module manages persistent, marshallable objects tied to Coq's module system, enabling precise control over their lifecycle and visibility through operations like caching, substitution, and discharge. It works with named, localized, or global objects that interact with module events (e.g., `Require`, `Import`, section closure) and maintain state via `Nametab` suffixes for scoping. Specific use cases include scoped name resolution, deferred substitution during module cloning, and safe persistence of data like monomorphic universes across module operations.",
      "description_length": 565,
      "index": 840,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coqlib",
      "library": "rocq-runtime.library",
      "description": "This module provides utilities for managing global references to Coq entities like constants and inductives by name, along with delayed construction of foundational type structures (e.g., sigma types, product types, equality primitives). It operates on data structures including module paths, loaded library metadata, and equality-related global references encapsulated in types like `coq_eq_data`, which are initialized lazily via `Util.delayed`. Specific use cases include bootstrapping Coq's standard library type hierarchies, resolving equality constructs during proof checking, and ensuring correct module path resolution in compiled environments.",
      "description_length": 652,
      "index": 841,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rocqlib",
      "library": "rocq-runtime.library",
      "description": "This module binds logical names to global references and provides operations to register, retrieve, and check these associations. It works with global references, inductive types, and structured data like sigma types and equality constants. Concrete use cases include resolving named constants like `\"core.eq.type\"` to their internal representations for use in tactics and plugins.",
      "description_length": 381,
      "index": 842,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Locality",
      "library": "rocq-runtime.library",
      "description": "This module manages locality settings for definitions in sections and modules, controlling whether they are discharged or exported. It provides functions to create and enforce locality policies, such as `make_locality`, `enforce_locality`, and `check_locality_nodischarge`, which determine visibility and scope behavior. Use cases include configuring definition scope during interactive proof development and ensuring correct export behavior in modular code.",
      "description_length": 458,
      "index": 843,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto3_plugin.Tuto_tactic",
      "library": "tuto3_plugin",
      "description": "This module defines tactics for manipulating lambda expressions and packing terms in a proof context. It provides `two_lambda_pattern` to deconstruct lambda expressions into their components and `pack_tactic` to apply a named identifier as a tactic. These are used in implementing custom proof automation and term transformations.",
      "description_length": 330,
      "index": 844,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto3_plugin.Construction_game",
      "library": "tuto3_plugin",
      "description": "This module implements functions for constructing and manipulating proof terms in a goal-directed manner. It provides operations for generating identity terms with unmet constraints, demonstrating sort application with lambda expressions, and working with type classes and canonical structures. These functions are used to illustrate and test various aspects of Coq's type inference and unification mechanisms during proof construction.",
      "description_length": 436,
      "index": 845,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto3_plugin",
      "library": "tuto3_plugin",
      "description": "This module includes submodules for constructing proof terms with unmet constraints, manipulating lambda expressions, and applying custom tactics. It works with Coq's proof terms, type classes, and tactic contexts to demonstrate type inference, deconstruct lambdas, and automate term transformations. Concrete uses include testing unification behaviors, extracting lambda components, and applying identifiers as tactics during proof development.",
      "description_length": 445,
      "index": 846,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Analyze.LargeArray",
      "library": "rocq-runtime.checklib",
      "description": "This module implements an array-like data structure that supports lengths exceeding 2^22 elements, particularly useful on 32-bit systems where standard arrays are limited. It provides operations to create, access, and modify elements at specific indices, as well as retrieve the length of the structure. Concrete use cases include handling large datasets that exceed the capacity of native arrays, such as processing extensive log files or managing large-scale simulations.",
      "description_length": 473,
      "index": 847,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Analyze.Make",
      "library": "rocq-runtime.checklib",
      "description": "This module parses a marshalled structure into an entry point and a reified memory representation using the `parse` function. It operates on an input type defined by the parameter module M and produces a tuple containing analysis data and a large array of objects. A concrete use case is extracting structured information from serialized Coq proof data for further analysis.",
      "description_length": 374,
      "index": 848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Validate",
      "library": "rocq-runtime.checklib",
      "description": "Performs validation of a given value against analysis data and an object array, ensuring correctness constraints. Works with `value` types and analysis structures including large arrays of objects. Used during proof checking to verify computed results match expected outcomes.",
      "description_length": 276,
      "index": 849,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.CheckInductive",
      "library": "rocq-runtime.checklib",
      "description": "Performs validation of inductive type definitions against the environment, ensuring consistency between declared and inferred fields. Works with environments, mutual inductive type identifiers, and mutual inductive bodies. Used during type checking to detect mismatches in inductive structure definitions.",
      "description_length": 305,
      "index": 850,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Values",
      "library": "rocq-runtime.checklib",
      "description": "This module defines a `value` type representing structured data used for validation and symbolic computation, along with operations to construct and compare values. Functions like `v_tuple`, `v_sum`, and `v_array` build composite values, while `equal` and `kind` inspect them. Concrete use cases include modeling Coq terms, validating expression structures, and defining recursive values through `fix`, avoiding direct self-reference.",
      "description_length": 434,
      "index": 851,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coq_checklib.Coqchk_main",
      "library": "rocq-runtime.checklib",
      "description": "This module defines the entry point for executing the Coq proof checker. It initializes the checking process and handles command-line arguments to validate Coq files. A typical use case involves running automated verification of formal proofs during development or CI pipelines.",
      "description_length": 278,
      "index": 852,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Analyze",
      "library": "rocq-runtime.checklib",
      "description": "This module parses marshalled data structures into an entry point and a reified memory representation, supporting large arrays beyond 2^22 elements. It works with custom data types including structured objects, integers, floats, and strings, and provides functions to parse from channels or strings, and to instantiate OCaml objects. Concrete use cases include deserializing and analyzing large Coq proof datasets that exceed standard array limits, particularly in memory-constrained environments.",
      "description_length": 497,
      "index": 853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.CheckFlags",
      "library": "rocq-runtime.checklib",
      "description": "Sets typing flags in the environment, excluding ignored flags, using a provided typing flags value. Operates on `Declarations.typing_flags` and `Environ.env` types. Used to configure type-checking behavior in the Coq checker by adjusting relevant flags in the environment.",
      "description_length": 272,
      "index": 854,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coq_checklib.Check_stat",
      "library": "rocq-runtime.checklib",
      "description": "Tracks and outputs statistical information about proof environments and variable dependencies. It provides functions to enable memory statistics and context output, and to generate dependency graphs from environments and variable sets. Useful for analyzing proof complexity and variable usage in Coq developments.",
      "description_length": 313,
      "index": 855,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Safe_checking",
      "library": "rocq-runtime.checklib",
      "description": "Performs safe and unsafe imports of compiled libraries into a type-checked environment, updating the environment and module dependencies. It operates on type-safe environments, module maps, and disk-based libraries with digest tracking. Used during Coq's proof checking to integrate precompiled modules while preserving consistency or bypassing checks for efficiency.",
      "description_length": 367,
      "index": 856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.CheckLibrary",
      "library": "rocq-runtime.checklib",
      "description": "This module manages the loading and checking of Coq libraries, handling both physical and logical file paths. It provides functions to add load paths and recheck libraries within a safe typing environment, supporting selective rechecking with options to skip, admit, or fully check specific files. The module works directly with Coq's `safe_environment`, `DirPath.t`, and custom path types to ensure correct module resolution and type safety during library processing.",
      "description_length": 468,
      "index": 857,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Mod_checking",
      "library": "rocq-runtime.checklib",
      "description": "This module sets an accessor for opaque proofs and validates modules within a given environment, producing a mapping of constants to their dependencies. It operates on environments, module paths, and module bodies, specifically handling opaque proof terms. It is used to ensure module correctness and dependency tracking during Coq's proof checking process.",
      "description_length": 357,
      "index": 858,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib",
      "library": "rocq-runtime.checklib",
      "description": "This module provides functionality for type checking, library management, and proof validation in Coq. It includes operations for parsing large datasets, configuring typing flags, validating inductive types, and managing module dependencies. Concrete use cases include automated proof verification, selective library rechecking, and analysis of Coq developments with memory-intensive data.",
      "description_length": 389,
      "index": 859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto1_plugin.Inspector",
      "library": "tuto1_plugin",
      "description": "Prints values in a formatted way using a provided pretty-printing function and a label. It takes a value of any type, a function to convert that value to a document, and a string label, then outputs the labeled document. Useful for debugging or logging structured data during program execution.",
      "description_length": 294,
      "index": 860,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto1_plugin.Simple_print",
      "library": "tuto1_plugin",
      "description": "This module provides a function `simple_body_access` that retrieves the body of a global reference using an indirect accessor. It operates on global references (`Names.GlobRef.t`) and constrained terms (`EConstr.constr`), enabling direct access to the underlying term representation. A concrete use case is inspecting or manipulating the definitions of constants or inductive types during proof automation or tactic development.",
      "description_length": 428,
      "index": 861,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto1_plugin.Simple_declare",
      "library": "tuto1_plugin",
      "description": "This module provides a function to declare definitions in the Coq environment, handling both polymorphic and monomorphic cases. It operates on Coq's internal representation of terms and identifiers, producing global references to declared definitions. A concrete use case is registering new constants during tactic or plugin execution.",
      "description_length": 335,
      "index": 862,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto1_plugin.Simple_check",
      "library": "tuto1_plugin",
      "description": "Performs type checking and constraint resolution on Coq expressions. It takes an environment, evar map, and a constr, and returns either a resolved evar map and constr or just the resolved constr. Useful for verifying and normalizing terms during tactic execution or proof term generation.",
      "description_length": 289,
      "index": 863,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto1_plugin",
      "library": "tuto1_plugin",
      "description": "This module includes submodules for debugging, type checking, declaring definitions, and accessing term bodies in Coq. It provides operations to print structured values with labels, resolve Coq term constraints, declare new constants, and retrieve term definitions by reference. These functions are used to build and manipulate Coq terms during tactic execution, proof automation, and plugin development.",
      "description_length": 404,
      "index": 864,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Unsafe",
      "library": "rocq-runtime.gramlib",
      "description": "This module provides low-level operations for manipulating extensible grammars, including functions like `clear_entry` to reset parser states associated with specific grammar entries. It works directly with grammar entries and parser state objects to control parsing behavior during stream pattern matching. Concrete use cases include implementing custom parsing rules and error recovery strategies in domain-specific language parsers.",
      "description_length": 435,
      "index": 865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Rules",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines and manipulates grammar rules for extensible parsers, focusing on stream pattern matching and entry extension. It works with grammar entries, streams, and rule constructors to build and compose parsing rules. Concrete use cases include defining custom syntax extensions, implementing recursive grammar productions, and handling rejection of stream patterns during parsing.",
      "description_length": 392,
      "index": 866,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.GState",
      "library": "rocq-runtime.gramlib",
      "description": "This module manages the state of a grammar entry during parsing, tracking progress through streams and keyword recognition. It provides operations to advance the state, test for acceptance, and handle rejection of stream patterns. Used internally when implementing extensible grammars with support for keyword-based parsing and error recovery.",
      "description_length": 343,
      "index": 867,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.EState",
      "library": "rocq-runtime.gramlib",
      "description": "This module manages the state of extensible grammars during parsing, tracking active entries and their extensions. It provides operations to manipulate and query the current parsing context, such as checking valid transitions between grammar rules. Concrete use cases include implementing custom parsing rules in Camlp5-based parsers and handling grammar extensions dynamically at runtime.",
      "description_length": 389,
      "index": 868,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Parsable",
      "library": "rocq-runtime.gramlib",
      "description": "This module provides functions to create and manipulate parsable grammar entries, handling stream patterns and lexical analysis. It works with streams of characters and tracks location and comment information during parsing. Concrete use cases include building custom parsers that require precise control over token streams and error handling in grammar extensions.",
      "description_length": 365,
      "index": 869,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Entry",
      "library": "rocq-runtime.gramlib",
      "description": "This module manages grammar entries for extensible parsers, providing operations to create, parse, and inspect entries. It works with streams of tokens and parser states, supporting concrete tasks like parsing specific grammar rules, handling keyword states, and accumulating entry data. Use cases include defining custom grammar extensions, implementing domain-specific parsers, and managing parsing contexts during stream processing.",
      "description_length": 435,
      "index": 870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Rule",
      "library": "rocq-runtime.gramlib",
      "description": "This module constructs and manipulates grammar rules for extensible parsers, primarily through operations like `stop`, which finalizes a rule, and `next`, which appends symbols to an existing rule. It works with abstract grammar entries, symbols, and rule types that represent parsing sequences and their continuations. Concrete use cases include defining custom parsing rules for domain-specific languages, extending existing grammars with new syntactic constructs, and composing complex parsers from simpler components.",
      "description_length": 521,
      "index": 871,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Production",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines and manipulates grammar productions for extensible grammars, primarily working with `Production.t` and `Rule.t` types. It provides operations to construct and extend grammar rules that are used in parsing streams of tokens. Concrete use cases include defining custom syntax extensions in OCaml using Camlp5, such as embedding domain-specific languages or preprocessing input streams with user-defined parsers.",
      "description_length": 429,
      "index": 872,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Symbol",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines symbolic representations of grammar components used in extensible grammars, enabling the construction of parsing rules through combinators. It operates on parameterized symbol types that represent terminals, non-terminals, and structured patterns like lists, options, and sequences. Concrete use cases include defining recursive grammar rules with `self` and `next`, specifying token parsers with `token`, and building list constructs with separators using `list0sep` and `list1sep`.",
      "description_length": 503,
      "index": 873,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake",
      "library": "rocq-runtime.gramlib",
      "description": "This module implements Camlp5's extensible grammars system, enabling dynamic grammar extensions and custom parsing rules through components like entries, symbols, and rules. It works with token streams, parser states, and grammar productions to support concrete tasks such as embedding domain-specific languages, defining recursive grammar constructs with combinators, and handling stream pattern rejection during parsing. Key operations include creating and extending grammar entries, composing parsing rules with `token`, `list0sep`, and `self`, and managing parsing contexts for keyword recognition and error recovery.",
      "description_length": 621,
      "index": 874,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.LStream",
      "library": "rocq-runtime.gramlib",
      "description": "This module extends streams with location tracking capabilities, allowing precise management of source positions during parsing. It provides operations to retrieve locations of elements, compute intervals between positions, and track the stream's current and peeked elements. Use cases include implementing parsers that require accurate error reporting with source locations or managing input streams where positional information is critical.",
      "description_length": 442,
      "index": 875,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Plexing",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines the lexer type used in Camlp5 extensible grammars and provides functions to create and manipulate lexers. It works with token streams and lexer functions that parse character input into tokens. Concrete use cases include building custom lexers for domain-specific languages and extending existing grammars with new lexical rules.",
      "description_length": 349,
      "index": 876,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Gramext",
      "library": "rocq-runtime.gramlib",
      "description": "Handles grammatical associations and positional relationships between elements. Works with `g_assoc` and `position` types to define and print associativity and placement in grammatical structures. Used for specifying operator precedence and associativity in parsers.",
      "description_length": 266,
      "index": 877,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Stream",
      "library": "rocq-runtime.gramlib",
      "description": "This module implements stream-based data processing with support for creating, inspecting, and manipulating streams. It provides functions to build streams from custom generators, strings, or input channels, and includes operations to consume, peek, or skip elements, along with tracking the number of consumed elements. Concrete use cases include incremental parsing of character input, resuming parsing from a specific position, and handling token streams in lexers or parsers.",
      "description_length": 479,
      "index": 878,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar",
      "library": "rocq-runtime.gramlib",
      "description": "This module implements Camlp5's extensible grammars system, enabling dynamic grammar extensions and custom parsing rules through components like entries, symbols, and rules. It works with token streams, parser states, and grammar productions to support concrete tasks such as embedding domain-specific languages, defining recursive grammar constructs with combinators, and handling stream pattern rejection during parsing. Key operations include creating and extending grammar entries, composing parsing rules with `token`, `list0sep`, and `self`, and managing parsing contexts for keyword recognition and error recovery.",
      "description_length": 621,
      "index": 879,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib",
      "library": "rocq-runtime.gramlib",
      "description": "This module provides components for building and manipulating extensible grammars with support for custom parsing rules, token streams, and location tracking. It includes tools for defining operator precedence, creating lexers, managing grammar extensions, and handling streams with positional information. Concrete use cases include embedding domain-specific languages, implementing parsers with precise error reporting, and constructing token-based parsers with dynamic rule extensions.",
      "description_length": 488,
      "index": 880,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rocqshim",
      "library": "rocq-runtime.rocqshim",
      "description": "This module manages worker executables by locating their paths and initializing runtime options. It handles command-line arguments to configure execution settings and ensures proper process spawning across platforms. Concrete use cases include launching worker processes after setup and resolving executable paths based on package and base names.",
      "description_length": 346,
      "index": 881,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Label.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations for maps with label keys. It supports `fold`, `mapi`, `fold_left`, and `fold_right`, enabling effectful computations over label-indexed map structures. It is useful for propagating state or handling side effects while processing labeled data, such as tracking renaming substitutions or accumulating errors during map transformations.",
      "description_length": 402,
      "index": 882,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Label.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized `map` and `mapi` functions for transforming values in a label-indexed map while preserving structural sharing. It works specifically with `Names.Label.Map.t`, a map structure keyed by label values. These operations are useful when updating associated data across a map where maintaining identity of unchanged elements is important for efficiency.",
      "description_length": 377,
      "index": 883,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Projection.Repr.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for the `Names.Projection.Repr.t` type. These functions are specifically used within the kernel to order and identify canonical names. Concrete use cases include implementing maps and sets over canonical names and ensuring consistent key handling in hash-based data structures.",
      "description_length": 343,
      "index": 884,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.Quality.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve structural sharing when transforming values in a `Sorts.Quality.Map.t`. It operates specifically on maps with keys of type `Sorts.Quality.Map.key` and values of a generic type `'a`. These functions are useful when updating map values while minimizing memory allocation, such as in performance-sensitive code paths or incremental data transformations.",
      "description_length": 424,
      "index": 885,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sorts.Quality.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module implements monadic traversal and transformation operations over maps with quality-sorted keys. It provides `fold`, `mapi`, `fold_left`, and `fold_right` to process map bindings in a monadic context, producing aggregated results or new maps. These functions are used to sequence effectful computations keyed by ordered, quality-ranked identifiers.",
      "description_length": 358,
      "index": 886,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Id.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized versions of `map` and `mapi` functions for identifier maps, which attempt to preserve structural sharing during transformation. It operates specifically on finite maps with identifiers as keys, improving efficiency when updating mapped values. These functions are useful when traversing or transforming syntax trees where identifier mappings are frequent and large, and maintaining sharing helps reduce memory usage.",
      "description_length": 447,
      "index": 887,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Id.Set.List",
      "library": "rocq-runtime.kernel",
      "description": "This module operates on lists of identifier sets, providing functions to combine and manipulate collections of identifiers. It supports operations like taking the union of multiple sets, enabling efficient aggregation of name collections. Use cases include merging sets of identifiers from different scopes or contexts into a single set for analysis or comparison.",
      "description_length": 364,
      "index": 888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Id.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over finite maps of identifiers. It supports operations like `fold`, `mapi`, `fold_left`, and `fold_right`, which allow accumulating results or transforming map values within a monadic context. It is used for processing identifier-keyed maps where each operation may involve effects, such as error handling or state manipulation, encapsulated by the monad `M`.",
      "description_length": 429,
      "index": 889,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.GlobRef.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic variants of map traversal operations, specifically `fold` and `mapi`, which process key-value pairs in a `Names.GlobRef.Map`. These functions sequence effects through a provided monad `M`, enabling sideful computations during iteration. It is useful for accumulating results in a monadic context or transforming map values with effectful logic.",
      "description_length": 373,
      "index": 890,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Projection.Repr.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides `compare`, `equal`, and `hash` functions for the `Names.Projection.Repr.t` type, enabling efficient ordering, equality checks, and hashing. It supports low-level operations that rely on syntactic identity of projections, such as managing projection keys in maps or sets. Concrete use cases include optimizing term comparison and ensuring consistent ordering in internal data structures.",
      "description_length": 407,
      "index": 891,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Projection.Repr.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module implements comparison, equality, and hashing operations for user names in the `Names.Projection.Repr.t` type. It enables ordered traversal, identity checks, and efficient storage in hash-based data structures. Concrete use cases include managing sets or maps of user names and ensuring consistent ordering in evaluation or serialization routines.",
      "description_length": 358,
      "index": 892,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve sharing when possible, operating specifically on maps with keys of type `Names.GlobRef.Map.key`. It is designed for efficient transformation of map values while minimizing unnecessary allocations. Use cases include traversing and modifying large maps in performance-sensitive parts of the code, such as during term substitution or environment updates in a type checker.",
      "description_length": 443,
      "index": 893,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Label.Set.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations to compute the union of a list of label sets, where each set contains names of type `Names.Label.t`. It is used to aggregate multiple label sets into a single set, combining all unique elements across the list. A concrete use case includes merging sets of variable names from different scopes or branches in a compiler or static analysis tool.",
      "description_length": 375,
      "index": 894,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.GlobRef.Map_env.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic fold and map operations over a map structure where keys are of type `Names.GlobRef.Map_env.key` and values are parameterized. It allows traversing and transforming maps within an arbitrary monad `M`, enabling effectful computations during iteration. Concrete use cases include accumulating results with error handling or state manipulation while processing map entries.",
      "description_length": 398,
      "index": 895,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Universe.Set.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides functions to compute the union of a list of sets and manipulate list-based set collections. It works with lists of `Univ.Universe.Set.t` values, enabling operations like combining multiple sets into a single set. Concrete use cases include aggregating results from multiple set queries or merging disjoint sets into a unified set.",
      "description_length": 351,
      "index": 896,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.Map_env.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized `map` and `mapi` functions that transform values in a `Names.GlobRef.Map_env.t` map while attempting to preserve structural sharing to improve performance. It works directly with maps keyed by `Names.GlobRef.Map_env.key`, which represent globally referenced identifiers in the system. These functions are particularly useful when applying consistent transformations to large maps without unnecessary duplication, such as during environment updates or batch renaming operations.",
      "description_length": 508,
      "index": 897,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.QVar.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations for maps with keys of type `Sorts.QVar.Map.key`. It supports `fold`, `mapi`, `fold_left`, and `fold_right`, which allow accumulating values or building new maps while sequencing effects through the monad `M`. These functions are useful for processing map entries in a specific order while handling effects like state updates or error handling within the monadic context.",
      "description_length": 439,
      "index": 898,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.QVar.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve sharing when possible, operating on maps keyed by `Sorts.QVar.Map.key` with arbitrary values. These functions are useful when transforming map values while avoiding unnecessary allocations, particularly in performance-sensitive contexts like compiler passes or symbolic manipulation. The sharing preservation makes them suitable for large maps where memory efficiency is critical.",
      "description_length": 454,
      "index": 899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Level.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic variants of map operations, enabling folding and mapping over universe level maps with effects. It works with `Univ.Level.Map.t` structures, applying monadic functions to keys and values. Concrete use cases include accumulating results in a monadic context during traversal or transforming map entries while handling side effects like state or error propagation.",
      "description_length": 391,
      "index": 900,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Universe.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module implements monadic traversal and transformation operations over maps with typed keys. It provides `fold`, `mapi`, `fold_left`, and `fold_right` to process map entries in a monadic context, producing aggregated results or new maps. These functions are used to safely build keyed data structures and perform effectful computations tied to specific key-value pairs.",
      "description_length": 374,
      "index": 901,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Univ.Universe.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve sharing when possible, operating on `Univ.Universe.Map.t` structures. These functions apply transformations to values while maintaining reference equality for unchanged parts of the map. They are useful when efficiently updating large maps where only a subset of values change, such as in incremental computation or persistent data structure manipulation.",
      "description_length": 429,
      "index": 902,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Level.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "Implements optimized mapping operations over universe level maps, preserving structural sharing during transformations. Works directly with `Univ.Level.Map.t` structures, applying functions to values while maintaining key associations. Useful for efficiently updating universe constraints in type-checking contexts where sharing optimization reduces memory overhead.",
      "description_length": 366,
      "index": 903,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module implements comparison, equality, and hashing operations for values of type `Names.GlobRef.t`. It enables using `GlobRef` values as keys in ordered and hash-based data structures like maps and sets. Concrete use cases include managing collections of globally referenced identifiers where structural ordering and identity checks are required.",
      "description_length": 352,
      "index": 904,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Mindmap_env.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a set structure for the key type used in a mindmap environment, supporting standard operations like membership checks, union, intersection, and difference, along with iteration and folding. It provides functions to query set properties, such as cardinality and element extraction, enabling efficient management of unique keys in domain-specific contexts. These sets are utilized for handling collections of identifiers where strict uniqueness and set algebra are required, such as tracking key dependencies or validating key presence in hierarchical structures.",
      "description_length": 584,
      "index": 905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Context.Named.Declaration",
      "library": "rocq-runtime.kernel",
      "description": "This module supports querying and transforming named variable declarations within parameterized typing contexts, handling properties like identifiers, types, and term annotations. It operates on declarations structured as typed and annotated terms, enabling use cases such as compiler symbol table management or proof assistant context manipulation where named bindings must be introspected or converted between representations. Key capabilities include mapping identifiers via custom name-resolution logic, extracting declaration metadata, and iterating over context elements with relevance tracking.",
      "description_length": 601,
      "index": 906,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Constraints.List",
      "library": "rocq-runtime.kernel",
      "description": "Handles operations on lists of constraint sets, primarily providing functions to compute unions and manage combinations of constraints. Works with lists of `Univ.Constraints.t` values, enabling aggregation and transformation of constraint collections. Useful for merging multiple constraint sets into a single set or processing groups of constraints in batch operations.",
      "description_length": 370,
      "index": 907,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MBImap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over `MBImap.t` structures, which are maps keyed by a specific type. It includes functions like `fold`, `mapi`, `fold_left`, and `fold_right`, allowing stateful computations that carry effects through the monad `M`. These operations are used to process and manipulate name maps in a way that integrates with effectful logic, such as error handling or state management.",
      "description_length": 437,
      "index": 908,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Universe.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module supports membership checks, insertion, deletion, and set algebra operations (union, intersection, difference) for sets containing `Univ.Universe.t` values, along with comparison and ordered traversal capabilities. It enables conversions between sets and lists/sequences, computes cardinality and extremal elements, and aggregates multiple sets through union operations. These features are useful for tasks like dynamic set composition, data filtering, and analysis of hierarchical or relational structures represented by `Univ.Universe.t` elements.",
      "description_length": 560,
      "index": 909,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Ind.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module implements comparison, equality, and hashing operations for the `Names.Ind.t` type, specifically using syntactic equality. It enables efficient ordering and set/map operations on identifiers based on their syntactic structure. Useful for maintaining ordered collections or hash tables where identifier identity must be determined by syntax.",
      "description_length": 352,
      "index": 910,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MBImap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations that preserve structural sharing in immutable data structures. It works with polymorphic map types indexed by keys, applying transformations to values while maintaining efficient memory usage. Useful for scenarios like updating nested configurations or transforming large datasets without unnecessary duplication.",
      "description_length": 363,
      "index": 911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constrset.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for working with lists of constraint sets, primarily supporting the union of multiple sets into a single set. It operates on `Names.Constrset.t list` and produces `Names.Constrset.t` values. A typical use case involves combining constraint sets from a list of branches in a match expression to compute a unified set of constraints.",
      "description_length": 363,
      "index": 912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Label.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module offers functions for standard set-theoretic operations\u2014union, intersection, difference, membership checks, and aggregation\u2014on collections of `Names.Label.t` elements. It works with sets represented as `Names.Label.Set.t`, supporting transformations to and from lists or sequences, cardinality queries, and element selection. These capabilities are particularly useful for managing identifiers in compiler intermediate representations, analyzing dependencies between labeled entities, or implementing algorithms requiring efficient set operations over symbolic identifiers.",
      "description_length": 584,
      "index": 913,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Projection.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines comparison, equality, and hashing operations for user names represented as `Names.Projection.t`. It enables ordering and identity checks between user name values, ensuring consistent behavior across data structures that rely on these operations. Concrete use cases include using user names as keys in hash tables or as elements in ordered collections.",
      "description_length": 371,
      "index": 914,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MPset.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for working with sets of names represented as lists, including union and membership checks. It handles list-based set manipulations efficiently, supporting concrete use cases such as tracking defined variables, managing name scopes, and performing set operations during type checking or program analysis.",
      "description_length": 336,
      "index": 915,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Univ.Level.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module implements finite maps with keys of type `Univ.Level.t` and polymorphic values, supporting operations for key-based queries, value updates, structural transformations, and algebraic combinations like merging or filtering. It provides utilities for analyzing or modifying universe level hierarchies, such as extracting domains, applying range filters, or computing symmetric differences, while submodules optimize traversals and effectful computations. Specific applications include managing type-theoretic universe constraints, substituting levels in mappings, and generating human-readable representations of level-value associations for debugging.",
      "description_length": 661,
      "index": 916,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Id.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module provides functional set operations\u2014union, intersection, difference, membership checks, and iteration\u2014for managing finite collections of identifiers. It centers on immutable sets of `Names.Id.t` values, leveraging OCaml's Set library for efficient manipulation and offering utilities to convert sequences into sets or aggregate lists of sets. The included `List` submodule facilitates bulk operations like combined unions, supporting tasks such as scope-wide identifier analysis or hierarchical name resolution.",
      "description_length": 522,
      "index": 917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for canonical names represented as `Names.GlobRef.t`. It enables ordered comparisons and efficient hashing for use in data structures like maps and sets. Concrete use cases include managing unique identifiers in the kernel where strict ordering and equivalence are required.",
      "description_length": 340,
      "index": 918,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.DPset.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for working with lists of sets of names, including taking the union of multiple sets. It manipulates values of type `Names.DPset.t list` and produces `Names.DPset.t` as output. A concrete use case is combining multiple name sets from different sources into a single set for analysis or processing.",
      "description_length": 329,
      "index": 919,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Constrset_env.List",
      "library": "rocq-runtime.kernel",
      "description": "This module operates on lists of constraint sets, providing a union function to combine multiple sets into one. It works with lists of `Names.Constrset_env.t` sets, merging them into a single set. A concrete use case is aggregating constraint environments from different branches of a proof or term into a unified set for further processing.",
      "description_length": 341,
      "index": 920,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Projection.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for values of type `Names.Projection.t`. It enables ordering and identity checks on syntactic projections, which are used to represent structural components in the kernel. These operations support use cases like set and map construction, caching, and deterministic sorting of projection-based data.",
      "description_length": 364,
      "index": 921,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MutInd.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for canonical names represented as `Names.MutInd.t`. These functions enable efficient ordering and identity checks on mutual inductive type names within the kernel. Concrete use cases include managing name uniqueness, sorting declarations, and implementing hash-based data structures like sets and maps over canonical names.",
      "description_length": 390,
      "index": 922,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Context.Rel.Declaration",
      "library": "rocq-runtime.kernel",
      "description": "This module manipulates components of variable declarations in de Bruijn-indexed contexts, supporting operations like name/type/value access, classification of assumptions versus definitions, and structural transformations via mapping or equality checks. It works directly with `pt` structures representing term declarations, enabling traversal, folding over embedded terms, and extraction of declaration properties through destructuring or body removal. Typical use cases include analyzing or modifying context-bound terms during type checking, normalizing definitions by stripping redundant bodies, or classifying variable roles in formal verification workflows.",
      "description_length": 664,
      "index": 923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Label.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a functional map structure for label-indexed data, supporting key-based association, transformation, and querying with structural sharing optimizations. It provides operations for atomic updates, set-theoretic combinations, filtered traversals, and monadic state propagation over label-value pairs, prioritizing immutability-preserving efficiency. Typical applications include managing named entities in symbolic computation systems, optimizing compiler intermediate representations with persistent data patterns, and implementing pure functional state machines over dynamic label sets.",
      "description_length": 609,
      "index": 924,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Universe.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module implements ordered maps with typed keys and polymorphic values, supporting standard operations like insertion, deletion, and traversal alongside advanced merging, filtering, and structural comparison. It includes optimized utilities for preserving sharing during transformations and monadic traversal for effectful computations over key-value pairs while maintaining key order. Use cases include managing hierarchical type-level data, efficient incremental updates to large maps, and monadic workflows requiring side-effect tracking or validation across bindings.",
      "description_length": 575,
      "index": 925,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.KNmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations that preserve sharing in key-value structures, specifically working with `Names.KNmap.t` maps. It includes functions like `map` and `mapi` which apply transformations to values while maintaining structural sharing for efficiency. Concrete use cases include efficiently updating large name maps during kernel processing without unnecessary duplication.",
      "description_length": 401,
      "index": 926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Ind.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for canonical names, which are used to uniquely identify inductive types in the kernel. It ensures efficient and consistent ordering and equivalence checks between these identifiers. These functions are critical for managing inductive definitions and supporting internal kernel mechanisms that rely on precise name identity.",
      "description_length": 390,
      "index": 927,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Projection.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for canonical names. It works directly with the `Names.Projection.t` type to support precise identity checks and ordering. These functions are used internally in the kernel to manage and distinguish projections uniquely during evaluation and compilation.",
      "description_length": 320,
      "index": 928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MBIset.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for working with lists of sets of names, specifically supporting the union of multiple sets. It handles data structures of type `Names.MBIset.t list` and combines them into a single `Names.MBIset.t`. A concrete use case is aggregating multiple name sets from different sources into one unified set for analysis or processing.",
      "description_length": 357,
      "index": 929,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Names.KNmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic fold and map operations over key-value maps with typed keys. It works with maps from keys to values of arbitrary types, supporting transformations and aggregations within a monadic context. Concrete use cases include accumulating results with effects like error handling or state updates, and building new maps by applying monadic functions to existing entries.",
      "description_length": 390,
      "index": 930,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evar.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve sharing when possible, operating on `Evar.Map.t` structures which associate `Evar.t` keys with values. These functions are useful when transforming or inspecting mappings from existential variables to other data, such as during substitution or analysis passes in a compiler or proof assistant. The sharing preservation improves performance and memory usage in transformations where many entries remain unchanged.",
      "description_length": 486,
      "index": 931,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evar.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation functions for maps with existential variables as keys. It supports operations like `fold`, `mapi`, and left/right folds that apply functions across key-value pairs within a monadic context. These functions are used to safely manipulate maps where keys are existential variables, ensuring proper tracking of unsafe casts from integers.",
      "description_length": 392,
      "index": 932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.Set_env",
      "library": "rocq-runtime.kernel",
      "description": "This module supports functional manipulation of sets containing environment-qualified global references, offering standard operations like membership checks, union, intersection, and difference while preserving immutability. It provides utilities to query set properties (size, elements) and extract values, working with collections of `Names.GlobRef.t` in scenarios requiring safe, side-effect-free transformations of reference environments. Such functionality is particularly useful in kernel modules handling name resolution or environment management tasks.",
      "description_length": 560,
      "index": 933,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Construct.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module implements comparison, equality, and hashing operations for user names. It works directly with the `Names.Construct.t` type, providing concrete functions `compare`, `equal`, and `hash`. These operations are used when user names need to be ordered, checked for identity, or stored in hash-based data structures.",
      "description_length": 322,
      "index": 934,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.DPmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over a map structure with keys of type `Names.DPmap.key`. It supports functions like `fold`, `mapi`, `fold_left`, and `fold_right`, which process map elements in a monadic context `M`, enabling effectful computations during iteration. It is used for scenarios requiring stateful or effectful processing of key-value pairs in a map, such as accumulating results or handling side effects during transformation.",
      "description_length": 477,
      "index": 935,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Id.Map",
      "library": "rocq-runtime.kernel",
      "description": "This component provides ordered associative map operations for managing polymorphic values indexed by identifier keys, supporting binding manipulation (addition, removal, updates), structural transformations (folding, filtering, partitioning), and set-like operations (union, symmetric difference). It works with finite maps where keys are canonical identifiers (`Names.Id.t`) and values can be arbitrary types, emphasizing ordered key traversal and structural comparison. The design targets performance-sensitive scenarios like kernel-level identifier tracking, leveraging optimized structural sharing for memory efficiency and monadic folds to handle effectful computations across large-scale mappings.",
      "description_length": 704,
      "index": 936,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.DPmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over directed persistent maps, where keys are bound to values in a structured, immutable way. It includes `map` and `mapi`, which apply functions across key-value pairs while preserving structural sharing to improve efficiency. These operations are particularly useful when transforming large, nested maps without duplicating unchanged branches, such as in incremental data processing or state management.",
      "description_length": 455,
      "index": 937,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Mindmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations that preserve structural sharing in a persistent map data structure. It works with key-value maps where keys are from the `Names.Mindmap.key` type and values support equality and sharing. Concrete use cases include efficiently transforming values in large, immutable name maps while minimizing memory usage and maintaining identity consistency.",
      "description_length": 394,
      "index": 938,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Id.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for manipulating lists of identifiers, including equality checks, membership tests, and association list queries. It works with lists of `Names.Id.t` elements and supports key-based lookups and modifications in association lists. Concrete use cases include managing variable bindings, symbol tables, and identifier mappings in compilers or formal verification systems.",
      "description_length": 400,
      "index": 939,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Construct.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for canonical names represented by the type `Names.Construct.t`. It enables efficient ordering and identity checks on canonical name values, primarily used within the kernel for consistent and deterministic name handling. Concrete use cases include managing name-based identifiers in data structures like maps and sets, and ensuring referential consistency during name comparisons.",
      "description_length": 447,
      "index": 940,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.ModIdmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over `ModIdmap` structures, which are maps keyed by module identifiers. It includes functions for folding, mapping, and iterating with monadic effects, enabling composition with other monadic computations. These operations are used to process module-specific data during compilation phases like type checking and code generation.",
      "description_length": 398,
      "index": 941,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.ModIdmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over a persistent map structure where keys are module identifiers (`ModId`) and values can be of any type. It includes `map` and `mapi` functions that apply transformations to values while preserving structural sharing to improve performance. It is particularly useful in environments where large, nested module maps are frequently updated or transformed, such as in compilers or module systems.",
      "description_length": 445,
      "index": 942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Mindmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic fold and map operations over a map structure where keys are of type `Names.Mindmap.key` and values can be of arbitrary types. The `fold` function accumulates results using a monadic function, while `mapi` applies a monadic transformation to each key-value pair, producing a new map. These operations are useful for traversing and transforming name-based maps in a monadic context, such as handling side effects or error propagation during mapping operations.",
      "description_length": 487,
      "index": 943,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constant.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for canonical names. It works directly with the `Names.Constant.t` type, ensuring consistent ordering and identity checks. It is used in the kernel to manage name comparisons and hash-based data structures like sets and maps.",
      "description_length": 291,
      "index": 944,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MutInd.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for values of type `Names.MutInd.t`. It enables ordering and identity checks on syntactic names used in mutual inductive definitions. These functions support use cases like sorting collections of mutual inductive identifiers or using them as keys in hash tables.",
      "description_length": 328,
      "index": 945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.Quality.Constants",
      "library": "rocq-runtime.kernel",
      "description": "This module defines equality, comparison, and pretty-printing operations for quality constants. It works directly with the `Sorts.Quality.constant` type. These functions are used to compare and display quality constants in a consistent manner, particularly during debugging or when generating user-facing output.",
      "description_length": 312,
      "index": 946,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cmap_env.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over environments indexed by constants, preserving sharing during transformations. It supports efficient key-based manipulation of constant-indexed maps, where keys are ordered by their user-form representation. It is used in scenarios requiring minimal structural changes to large constant maps, such as incremental updates in proof environments or symbol table optimizations.",
      "description_length": 427,
      "index": 947,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Indmap_env.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over `Indmap_env.t` structures, which associate keys of type `Indmap_env.key` with values. It supports mapping with `mapi`, and left/right folding with key-value access, all within a monadic context `M`. These operations are useful for processing environments that track inductive definitions, such as during type checking or proof construction in a theorem prover.",
      "description_length": 434,
      "index": 948,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.QVar.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for managing sets of qualified variables, including membership checks, insertion, deletion, and set algebra (union, intersection, difference). It supports ordered traversal, extremal element access (min/max), and conversion from sequences, working with sets of `Sorts.QVar.t` elements. These capabilities are useful for tasks requiring efficient variable set manipulation, such as static analysis or symbolic computation, where ordered iteration and functional composition with sequences are needed.",
      "description_length": 531,
      "index": 949,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cmap_env.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic variants of fold and map operations over constant maps. It works with maps keyed by constants ordered by their user form. Use it to accumulate values or transform map bindings in contexts requiring monadic effects like error handling or state threading.",
      "description_length": 282,
      "index": 950,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Indset.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations to compute the union of a list of index sets and iterate over elements in an index set. It works with `Names.Indset.t` values, which represent sets of indices. A concrete use case is combining multiple index sets into a single set for batch processing or analysis.",
      "description_length": 296,
      "index": 951,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Indmap_env.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over environment structures that associate keys with values, specifically preserving sharing during transformations. It works with the `Names.Indmap_env.t` data type, which represents environments mapping `Indmap_env.key` identifiers to arbitrary values. These functions are used when efficiently transforming environments while maintaining structural equality where possible, such as during substitution or renaming in type-checking or compilation passes.",
      "description_length": 506,
      "index": 952,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Indset_env.List",
      "library": "rocq-runtime.kernel",
      "description": "This module implements operations for combining and manipulating sets of names using the `Indset_env` structure. It provides functions like `union` to merge multiple sets from a list into a single set. Useful for aggregating name collections from nested or distributed data structures.",
      "description_length": 285,
      "index": 953,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.ModIdset.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for working with lists of sets of identifiers, including taking the union of multiple sets. It manipulates values of type `Names.ModIdset.t list` and produces a combined `Names.ModIdset.t`. It is useful for aggregating collections of identifier sets into a single set, such as merging multiple scopes or contexts in a compiler or interpreter.",
      "description_length": 374,
      "index": 954,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Projection.Repr",
      "library": "rocq-runtime.kernel",
      "description": "This module represents projections in the kernel, constructed from inductive types, parameter counts, argument indices, and labels. It provides operations to access components like the inductive, mutual inductive, parameter count, and argument index, as well as transformations via mapping functions. Key use cases include internal term manipulation, canonical name handling, and projection key management in maps or sets.",
      "description_length": 422,
      "index": 955,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic variants of fold and mapi operations over constant-keyed maps. It works with `Names.Cmap.t` structures, where keys are canonicalized constants and values are processed within a monadic context. Concrete use cases include accumulating results with effects (like error handling or state) during traversal or transforming map values while preserving key order and structure.",
      "description_length": 400,
      "index": 956,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Id.Pred",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a set-like structure for testing membership of identifiers, supporting operations such as union, intersection, difference, and complement. It works with `Names.Id.t` as the element type and represents sets using predicates, allowing both finite and potentially infinite sets. Concrete use cases include tracking sets of variables in type checking, managing name scopes in term manipulation, and efficiently testing inclusion in large or dynamically changing identifier sets.",
      "description_length": 497,
      "index": 957,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module provides associative map operations for keys of type `Names.GlobRef.t`, supporting insertion, deletion, lookup, merging, filtering, and iterative transformations while preserving structural sharing. It works with maps parameterized over arbitrary value types `'a`, offering specialized tools like `Smart` for efficient key-based updates and `Monad` for effectful traversals. Typical use cases include managing dynamic environments, symbol tables, or configuration data where precise key-level manipulation and efficient structural comparisons are critical.",
      "description_length": 568,
      "index": 958,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Constant.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines comparison, equality, and hashing operations for user names. It works with the `Names.Constant.t` type, treating it as an abstract type for user identity. These functions support use cases like storing user names in ordered collections, checking name equivalence, and using names as keys in hash tables.",
      "description_length": 323,
      "index": 959,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MutInd.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for user names represented as `Names.MutInd.t` values. It enables ordering and identity checks on user-defined inductive type names, which are used in contexts like type checking and proof management. Concrete use cases include sorting or deduplicating lists of user names and using them as keys in hash tables.",
      "description_length": 377,
      "index": 960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized map operations for constant keys, specifically `map` and `mapi` functions that attempt to preserve sharing during transformation. It works with the `Names.Cmap.t` data structure, which is a map keyed by `Constant.t` values ordered by their canonical form. It is useful in scenarios requiring efficient, structural sharing-preserving updates of constant-indexed maps, such as managing constant environments or optimizing term substitutions in a compiler or proof assistant.",
      "description_length": 503,
      "index": 961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constrmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over `Constrmap.t` structures, which are maps keyed by `Constrmap.key`. It supports operations like `fold`, `mapi`, `fold_left`, and `fold_right`, allowing accumulation and value transformation within a monadic context `M`. It is useful for scenarios requiring effectful iteration or building new maps based on existing ones while handling side effects like error handling or state manipulation.",
      "description_length": 464,
      "index": 962,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.GlobRef.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for values of type `Names.GlobRef.t`. It enables ordered traversal, identity checks, and efficient storage in hash-based collections. Concrete use cases include managing sets and maps keyed by global references, ensuring consistent ordering and fast lookups in environments like the Coq proof assistant's kernel.",
      "description_length": 378,
      "index": 963,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Mindmap_env.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over a specialized map structure that preserves sharing during transformations. It works with key-value pairs stored in a map where keys are of type `Names.Mindmap_env.key` and values are polymorphic. Concrete use cases include efficiently updating environment mappings in the kernel while maintaining structural identity where possible.",
      "description_length": 387,
      "index": 964,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Ind.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines comparison, equality, and hashing operations for user names represented as `Names.Ind.t` values. It enables ordered comparisons and efficient hashing for data structures requiring key-based sorting or storage. Concrete use cases include managing user identifiers in maps, sets, and hash tables where consistent ordering and equality checks are required.",
      "description_length": 373,
      "index": 965,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.MPmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over a map structure with keys of type `Names.MPmap.key`. It supports functions like `fold`, `mapi`, `fold_left`, and `fold_right`, which allow accumulating values or transforming bindings within a monadic context `M`. It is used for processing maps where each operation may involve effects encapsulated by the monad `M`, such as error handling or state manipulation.",
      "description_length": 436,
      "index": 966,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Construct.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for values of type `Names.Construct.t`. It enables ordering and identity checks on syntactic name constructs, which are used to represent identifiers and terms in the system's core logic. These functions are essential for implementing sets, maps, and hash tables that rely on structural identity of names in low-level operations.",
      "description_length": 395,
      "index": 967,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Mindmap_env.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic fold and map operations over a map structure where keys are of type `Names.Mindmap_env.key` and values can be of arbitrary types. It allows applying functions that return monadic values across key-value pairs in the map, accumulating results or transforming the map within the monad `M`. Concrete use cases include traversing and transforming maps while handling effects like state, error, or IO in a controlled way.",
      "description_length": 445,
      "index": 968,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MPmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations that preserve structural sharing when transforming values in a map. It works with the `Names.MPmap.t` data structure, which associates keys of type `Names.MPmap.key` with values of a generic type `'a`. Concrete use cases include efficiently updating or transforming entries in large maps without unnecessary duplication, such as during symbol table manipulation or environment updates in a compiler or interpreter.",
      "description_length": 464,
      "index": 969,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Constrmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over a specific type of key-value structure where keys are based on constructor names. It includes functions `map` and `mapi` that apply transformations to values while attempting to preserve structural sharing to improve performance and memory usage. These operations are particularly useful when modifying large data structures that contain repeated or nested constructor-based keys, such as abstract syntax trees or term representations.",
      "description_length": 490,
      "index": 970,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Indmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over `Indmap` structures, which are maps keyed by identifiers from the `Names` module. It includes functions for folding, mapping with monadic actions, and left/right folds that accumulate results in a monadic context. Concrete use cases include transforming and analyzing name-indexed data during type checking or proof processing, where effects like error handling or state management are required.",
      "description_length": 469,
      "index": 971,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Indmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over Indmap structures, preserving sharing during transformations. It works with `Names.Indmap.t`, a map indexed by keys of type `Names.Indmap.key`, where values are of a generic type `'a`. Concrete use cases include efficiently updating term or identifier mappings in the Coq kernel while minimizing memory allocation by reusing unchanged substructures.",
      "description_length": 404,
      "index": 972,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Environ.QProjection.Repr",
      "library": "rocq-runtime.kernel",
      "description": "This module implements operations for comparing, hashing, and normalizing projection representations within unsafe environments. It provides `equal`, `compare`, `hash`, and `canonize` functions that work directly on values of type `Environ.QProjection.Repr.t`. These functions are used to ensure consistent handling of projections during environment manipulations where type safety is not enforced.",
      "description_length": 398,
      "index": 973,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constrmap_env.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over a constrained map environment. It supports keyed folding and mapping with effects, handling data structures that associate keys with values within a monadic context. Concrete use cases include propagating state or handling side effects while transforming or querying key-value associations in a strict, ordered manner.",
      "description_length": 392,
      "index": 974,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Constrmap_env.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over a typed environment structure, specifically preserving sharing during transformations. It works with environments (`Names.Constrmap_env.t`) that bind keys to values, typically used to represent mappings from constructor names to terms or types. Concrete use cases include efficiently transforming and traversing environments in type-checking or compilation pipelines where maintaining structural identity is critical.",
      "description_length": 472,
      "index": 975,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for managing collections of global references through standard set-theoretic functionality, including membership checks, unions, intersections, and element selection. It works with sets of `Names.GlobRef.t` elements, supporting transformations via predicates and iteration over contents. Typical applications include tracking dependencies between global definitions, analyzing reference relationships in code, or implementing scoping rules where precise set-based reasoning about global identifiers is required.",
      "description_length": 543,
      "index": 976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.PRmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic variants of map traversal and transformation operations. It works with `Names.PRmap.t`, a map structure keyed by `PRmap.key`, where values are processed within a monadic context `M`. Use it to perform effectful iterations or build transformed maps while handling side effects like state or error handling.",
      "description_length": 334,
      "index": 977,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constant.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for values of type `Names.Constant.t`. It enables ordering and identity checks based on syntactic structure, ensuring consistent handling of constants in contexts like term comparison or hash-based data structures. Concrete use cases include normalizing constant identifiers during term processing and supporting efficient lookups in maps or sets.",
      "description_length": 413,
      "index": 978,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.Map_env",
      "library": "rocq-runtime.kernel",
      "description": "This module implements key-value associations and structural transformations for maps with globally unique identifiers as keys, supporting operations like conditional updates, filtered iterations, and symmetric difference calculations. It provides specialized tools for managing environments where keys represent persistent, globally-scoped references, enabling efficient merging, domain-specific traversal patterns, and effectful computations through its Monad submodule. Use cases include symbol table management, persistent state synchronization, and incremental computation over dynamically evolving key spaces.",
      "description_length": 615,
      "index": 979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Context.Compacted.Declaration",
      "library": "rocq-runtime.kernel",
      "description": "This module represents a compacted context of variable declarations, where each entry maps a name to its associated value or type. It supports conversion to and from a named context representation and applies transformations to the stored values. Concrete use cases include managing variable bindings in type checking or evaluation, where efficient lookup and traversal are required.",
      "description_length": 383,
      "index": 980,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.QVar.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a key-value map with ordered keys of type `Sorts.QVar.t`, supporting efficient insertion, lookup, and traversal operations alongside set-like transformations. It provides optimized structural sharing for performance-sensitive manipulations, monadic folds for stateful traversals, and advanced operations like symmetric difference computation. Designed for scenarios requiring precise key ordering, domain analysis, or high-performance map fusion with minimal memory overhead.",
      "description_length": 498,
      "index": 981,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.PRmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized versions of `map` and `mapi` operations for a persistent map structure, specifically preserving sharing during transformations to improve performance. It works with the `Names.PRmap.t` persistent map type, where keys are of type `Names.PRmap.key`. These functions are useful when efficiently transforming large maps without unnecessary node duplication, such as in symbol table or environment manipulations during compilation or analysis passes.",
      "description_length": 476,
      "index": 982,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Environ.QInd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for comparing, hashing, and normalizing qualified inductive type identifiers within an environment. It works directly with the `Names.Ind.t` type and uses the environment to contextualize comparisons and normalization. These functions are used to ensure consistent representation and efficient lookup of inductive types during type checking and compilation.",
      "description_length": 389,
      "index": 983,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Name",
      "library": "rocq-runtime.kernel",
      "description": "This module represents identifiers that can be either anonymous or named, providing operations to construct, compare, and print them. It works with a variant type `t` that combines an anonymous marker with a named identifier from `Names.Id`. Concrete use cases include handling placeholder variables in formal proofs and managing symbol tables where some entries lack explicit names.",
      "description_length": 383,
      "index": 984,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Context.Named",
      "library": "rocq-runtime.kernel",
      "description": "This module manages named typing contexts by supporting operations like adding declarations, looking up variables by identifier, mapping over terms, and extracting bound identifiers. It works with parameterized contexts containing declarations that track identifiers, types, and term annotations. Concrete use cases include building and manipulating symbol tables in compilers or managing local bindings in proof assistants.",
      "description_length": 424,
      "index": 985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Universe",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for constructing, comparing, and transforming universe types represented as levels or algebraic combinations, enabling universe polymorphism and type checking. It includes set algebra and ordered maps for structured management of these types, supporting efficient traversal, merging, and filtering. These capabilities are critical for modeling hierarchical type systems in proof assistants.",
      "description_length": 422,
      "index": 986,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Cset_env",
      "library": "rocq-runtime.kernel",
      "description": "This module provides set-theoretic operations like membership testing, insertion, deletion, and union over a persistent collection of constants, modeled as a mathematical set. It works with elements of type `Names.Constant.t` and offers derived capabilities such as cardinality measurement, element enumeration, and arbitrary element selection. These operations are used in the Coq kernel to manage and query immutable sets of constants efficiently, particularly in contexts requiring structural sharing and immutability.",
      "description_length": 521,
      "index": 987,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Mindmap",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a persistent map structure using keys of a specific identifier type to associate with arbitrary values, supporting insertion, deletion, lookup, structural comparison, and domain manipulation. It incorporates optimized structural sharing for efficient transformations and monadic traversal to enable effectful operations, making it suitable for managing immutable hierarchical data with frequent updates, such as symbolic representations or configuration states. The design facilitates precise key-aware mappings, safe/unsafe access patterns, and domain-specific filtering in performance-sensitive contexts.",
      "description_length": 629,
      "index": 988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Environ.QGlobRef",
      "library": "rocq-runtime.kernel",
      "description": "This module defines operations for comparing, hashing, and normalizing qualified global references within an environment. It works directly with `Environ.env` and `Environ.QGlobRef.t`, supporting precise identity checks and ordering. It is used to ensure consistent handling of global references during environment manipulations and lookups.",
      "description_length": 341,
      "index": 989,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MPmap",
      "library": "rocq-runtime.kernel",
      "description": "This module provides an associative map abstraction optimized for keys representing module paths, supporting efficient insertion, deletion, lookup, and functional transformations over immutable map structures. It operates on maps with `ModPath` keys and generic values, leveraging structural sharing for performance in large-scale updates while offering advanced operations like monadic traversal, filtering, and symmetric difference computation. Designed for scenarios requiring precise module path tracking\u2014such as kernel-level namespace management or stateful, effectful map transformations with preserved sharing\u2014the Smart module ensures minimal memory overhead during incremental modifications.",
      "description_length": 699,
      "index": 990,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.ModIdmap",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for inserting, querying, and transforming associative collections of module-identified data, supporting standard map manipulations like union, fold, and symmetric difference alongside monadic traversal for effectful computations. It works with persistent maps keyed by module identifiers, leveraging structural sharing to optimize transformations and minimize redundant allocations. These structures are particularly useful in compiler phases such as type checking and code generation, where module-specific state must be tracked, combined, or incrementally updated.",
      "description_length": 598,
      "index": 991,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Projection",
      "library": "rocq-runtime.kernel",
      "description": "This module supports operations for constructing, comparing, and transforming projections, including hash-consing for efficient identity management and transformations like canonization or unfolding. It operates on the abstract type `Projection.t`, exposing accessors to components such as inductive identifiers, parameter counts, and argument indices, while leveraging ordering submodules for contextual comparisons. These capabilities are critical for term processing tasks like debugging (via detailed string representations), mutual inductive type manipulation, and maintaining canonical forms during compilation or proof automation.",
      "description_length": 637,
      "index": 992,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Ind",
      "library": "rocq-runtime.kernel",
      "description": "This module handles inductive type names represented as pairs of `Names.MutInd.t` and an integer index. It provides operations to retrieve the module path associated with a name, compare and hash names using canonical, user, and syntactic orderings, and produce canonical forms of names. These capabilities are used to manage and identify inductive definitions uniquely and efficiently within the kernel.",
      "description_length": 404,
      "index": 993,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.KNmap",
      "library": "rocq-runtime.kernel",
      "description": "This module provides persistent map operations for managing associations between kernel names and arbitrary data, supporting creation, modification, traversal, and filtering with optimized sharing. It works with immutable maps (`'a KNmap.t`) keyed by `KerName.t`, offering domain-specific transformations like `filter_range`, `symmetric_diff_fold`, and monadic binding for composing updates. Typical use cases include maintaining versioned name bindings in a compiler or kernel, where efficient structural comparison and non-destructive updates are critical for correctness and performance.",
      "description_length": 590,
      "index": 994,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constrset_env",
      "library": "rocq-runtime.kernel",
      "description": "This module implements an immutable set abstraction for managing collections of constructor names, supporting standard operations like union, intersection, and difference, along with conversions to and from lists and sequences. It provides utilities to merge multiple constraint environments\u2014particularly useful for combining results from different proof branches\u2014and includes functions for element inspection (e.g., membership checks, min/max retrieval), filtering, and iterative transformations via folding. The underlying data structure (`t`) is optimized for functional manipulation of sets with elements of type `Names.constructor`.",
      "description_length": 637,
      "index": 995,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.PRpred",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a set-like structure for testing membership and manipulating predicates over projection representations. It supports standard set operations such as union, intersection, difference, and complement, along with membership checks and finiteness tests. It is used to represent and reason about sets of projection values in a way that can efficiently handle both finite and complemented infinite sets.",
      "description_length": 419,
      "index": 996,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MPset",
      "library": "rocq-runtime.kernel",
      "description": "This module provides set algebra operations for managing collections of module paths, including membership tests, union, intersection, and difference, along with iteration and folding capabilities. It works with immutable sets of `ModPath.t` elements, offering functions to query cardinality, extract extremal elements, and convert between sequences and sets. These tools are particularly used in type checking and program analysis to track variables and scopes efficiently through list-based utilities.",
      "description_length": 503,
      "index": 997,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Univ.Level",
      "library": "rocq-runtime.kernel",
      "description": "This module represents universe levels used in type theory, providing operations to create, compare, and manipulate them, including checking if a level is the base `Set` universe, extracting names or indices, and hashing. It supports concrete use cases like managing universe constraints in type checking, substituting levels in mappings, and debugging through pretty-printing. The associated `Set` and `Map` submodules enable efficient set operations and keyed value management over universe levels.",
      "description_length": 500,
      "index": 998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Context.Rel",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations to manipulate de Bruijn-indexed relational contexts, including adding declarations, mapping over terms while accounting for binders, and comparing or extracting variable information from contexts. It works with structured representations of contexts (`pt`) that track anonymous and non-anonymous variables, using declarations to model hypotheses and definitions. These capabilities are critical for tasks like typechecking, term transformation, and formal reasoning where precise variable scoping and context equivalence are required.",
      "description_length": 566,
      "index": 999,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Mindset",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a set-like structure for storing and manipulating collections of `MutInd` values, supporting functional operations like union, intersection, filtering, and comparison. It includes utilities to query cardinality, traverse elements, or select arbitrary items, enabling efficient analysis of relationships between `MutInd` instances. Typical use cases involve managing unique identifiers or tracking dependencies in the kernel where set-theoretic operations over `MutInd` are required.",
      "description_length": 503,
      "index": 1000,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Environ.Globals",
      "library": "rocq-runtime.kernel",
      "description": "This module manages global definitions in an unsafe environment, providing direct access to constants, inductives, modules, and module types through a structured view. It operates on environment types that store mappings from names to their respective declarations, enabling precise lookups and updates. Concrete use cases include resolving named constants or inductive types during type-checking and retrieving module definitions during compilation.",
      "description_length": 450,
      "index": 1001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.QUConstraints",
      "library": "rocq-runtime.kernel",
      "description": "This module manages combined universe and quantifier constraints using a pair of constraint sets. It provides operations to merge constraint pairs through union and initialize empty constraints. It is used to track and combine constraints during type inference and checking in the presence of universe polymorphism and quantified variables.",
      "description_length": 340,
      "index": 1002,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rtree.Kind",
      "library": "rocq-runtime.kernel",
      "description": "This module defines and manipulates kinds of R-trees, providing functions to construct, inspect, and retrieve the underlying tree representation. It works with abstract types `'a Rtree.Kind.t` and concrete representations `'a Rtree.Kind.rtree`, along with associated kind information. Use this module when implementing or working with R-tree variants that require explicit kind tracking, such as when distinguishing between different balancing strategies or node storage mechanisms.",
      "description_length": 482,
      "index": 1003,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.ModPath",
      "library": "rocq-runtime.kernel",
      "description": "This module represents and manipulates module paths in a type-safe way, supporting operations like comparison, equality checks, and string conversion. It works with module paths composed of file paths, bound identifiers, and labeled components. Use cases include tracking module hierarchies, resolving module references, and debugging module path structures in the compiler's kernel.",
      "description_length": 383,
      "index": 1004,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HConstr.Tbl",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a hash table implementation for storing and retrieving values indexed by `HConstr.t` keys, with operations for adding entries, looking up values, and checking for existence. It works directly with `HConstr.t` as the key type and supports arbitrary value types. It is useful for maintaining mappings from higher-order logic terms to associated data, such as term metadata or computed attributes.",
      "description_length": 415,
      "index": 1005,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Environ.QConstant",
      "library": "rocq-runtime.kernel",
      "description": "This module defines operations for comparing, hashing, and normalizing qualified constant identifiers within an environment. It works directly with `Environ.env` and `Environ.QConstant.t`, supporting structural equivalence checks and canonical representation. Concrete use cases include ensuring consistent identity checks for constants during type-checking and managing constant references in a compiler or proof assistant context.",
      "description_length": 432,
      "index": 1006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Indset_env",
      "library": "rocq-runtime.kernel",
      "description": "This module provides set manipulation operations including union, intersection, difference, membership checks, and element retrieval (min, max, arbitrary) over a collection of inductive names. It operates on a structured set type that supports safe access patterns through optional return variants and enables conversions between sets, lists, and sequences. Typical applications include merging name collections, filtering subsets based on predicates, and aggregating sequential data into normalized set representations.",
      "description_length": 520,
      "index": 1007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.DirPath",
      "library": "rocq-runtime.kernel",
      "description": "This module represents directory paths as reversed lists of module identifiers, supporting operations like creation, equality checking, comparison, and string conversion. It works with `module_ident` lists and provides hashconsing, empty path checks, and structured printing. Used to manage hierarchical module paths in the Coq kernel, such as in environment construction and safe typing.",
      "description_length": 388,
      "index": 1008,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef",
      "library": "rocq-runtime.kernel",
      "description": "This module handles global references through a sum type encompassing variables, constants, inductive types, and constructors. It provides direct operations for comparison, canonicalization, and set/map manipulations tailored for environments requiring precise name resolution and reference tracking. Use cases include managing symbol tables, dependency graphs, and scoping rules in the Coq kernel.",
      "description_length": 398,
      "index": 1009,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Environ.QProjection",
      "library": "rocq-runtime.kernel",
      "description": "This module implements operations for comparing, hashing, and normalizing projection representations within unsafe environments. It provides `equal`, `compare`, `hash`, and `canonize` functions that work directly on values of type `Environ.QProjection.Repr.t`. These functions are used to ensure consistent handling of projections during environment manipulations where type safety is not enforced.",
      "description_length": 398,
      "index": 1010,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.KNset",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a functional set interface for kernel names with operations like membership testing, union, intersection, and difference, alongside utilities for size calculation and element traversal. It works with immutable sets of unique identifiers (`Names.KerName.t`), supporting set-theoretic manipulations and inspections. Typical applications include managing name hierarchies, enforcing uniqueness constraints, and efficiently tracking declared entities during system compilation or analysis phases.",
      "description_length": 515,
      "index": 1011,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.KerName",
      "library": "rocq-runtime.kernel",
      "description": "This module represents fully qualified names in the system, constructed from a module path and a label. It provides operations to create, deconstruct, and compare these names, along with string and pretty-printed representations for debugging. Concrete use cases include tracking identifiers in the kernel, such as theorem or definition names during type checking and compilation.",
      "description_length": 380,
      "index": 1012,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IndTyping.NotPrimRecordReason",
      "library": "rocq-runtime.kernel",
      "description": "This module defines a variant type `t` representing distinct reasons why a record type cannot be considered primitive. It includes four specific cases: `MustNotBeSquashed`, `MustHaveRelevantProj`, `MustHaveProj`, and `MustNotHaveAnonProj`. These variants are used to classify and handle non-primitive record constraints in type checking or analysis phases, particularly when dealing with projections and squashing in a dependently typed system.",
      "description_length": 444,
      "index": 1013,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.ModIdset",
      "library": "rocq-runtime.kernel",
      "description": "This module provides functional, persistent set operations for managing collections of module identifiers, including membership checks, element insertion/removal, and set algebra (union, intersection, difference). It supports conversions between sets and lists/sequences, along with aggregation functions to combine multiple identifier sets into unified structures. Typical applications include consolidating configuration data, querying identifier existence, and processing sequences of identifiers into normalized set representations.",
      "description_length": 536,
      "index": 1014,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.QConstraints",
      "library": "rocq-runtime.kernel",
      "description": "This module provides set-like operations for managing collections of quantifier constraints, including insertion, union, ordered traversal, and membership queries, while supporting transformations like filtering and splitting. It works with a sorted, persistent data structure for `Sorts.QConstraint.t` elements, enabling efficient retrieval of extrema, subset checks, and conversions to lists or sequences. Specific use cases include constructing constraint sets from sequences, verifying trivial satisfiability, and formatting constraints with custom variable printers for analysis or debugging.",
      "description_length": 597,
      "index": 1015,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Indmap",
      "library": "rocq-runtime.kernel",
      "description": "This module implements ordered key-based associative maps with inductive identifiers as keys, supporting operations like insertion, deletion, and structural diffing through efficient traversal combinators. It provides functional transformations with sharing preservation via the Smart submodule and monadic state accumulation for effectful name-indexed data processing. Particularly suited for type checking systems and proof assistants requiring precise identifier tracking and minimal memory overhead during complex value transformations.",
      "description_length": 540,
      "index": 1016,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmbytecodes.Label",
      "library": "rocq-runtime.kernel",
      "description": "This module manages label identifiers for bytecode generation, providing functions to create unique labels and reset the label counter. It works with integer-based label values to track positions in generated code. Concrete use cases include assigning branch targets and loop anchors during bytecode compilation.",
      "description_length": 312,
      "index": 1017,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.Quality",
      "library": "rocq-runtime.kernel",
      "description": "This module defines quality values used in type and sort systems, including variables and constants like `QProp`, `QSProp`, and `QType`. It provides operations for comparison, substitution, hashing, and pretty-printing of quality values, along with pattern matching support for partial substitutions. Concrete use cases include managing quality variables during type inference and displaying error messages with consistent quality representations.",
      "description_length": 447,
      "index": 1018,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Environ.QMutInd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines operations for comparing, hashing, and normalizing mutually recursive type identifiers within an environment. It works directly with `Environ.env` and `Names.MutInd.t` types, enabling precise identity and ordering checks. Concrete use cases include ensuring consistent representation of recursive type definitions during compilation and supporting efficient lookups in type-checking contexts.",
      "description_length": 412,
      "index": 1019,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cmap_env",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a polymorphic map structure indexed by constants, supporting ordered key comparisons based on their normalized \"user form\". It offers standard operations like insertion, lookup, filtering, and merging, alongside advanced transformations such as structural diffing and domain manipulation. The design facilitates efficient management of constant-indexed data in contexts requiring ordered key traversal or frequent map updates, such as compiler symbol tables or configuration systems where constants dictate structure. Optimized transformations and monadic workflows are supported through specialized submodules.",
      "description_length": 632,
      "index": 1020,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MutInd",
      "library": "rocq-runtime.kernel",
      "description": "This module implements operations for constructing and manipulating mutual inductive names using user and canonical representations. It provides functions to build names from kernel names or modpath/label pairs, extract components, and canonicalize names. It supports concrete use cases such as managing name uniqueness, sorting declarations, and using names as keys in hash tables through dedicated comparison and hashing modules.",
      "description_length": 431,
      "index": 1021,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UGraph.Bound",
      "library": "rocq-runtime.kernel",
      "description": "This module defines a bound type used to track whether a graph node is a proposition or a set. It supports operations for comparing and converting between bound types, ensuring correct handling of polymorphic inductive structures. Concrete use cases include managing type bounds during graph construction and validation in formal verification tasks.",
      "description_length": 349,
      "index": 1022,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Label",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a typed representation for symbolic labels with precise equality, ordering, and hashing operations. It supports conversions to and from strings and identifiers, and provides a dedicated set module for efficient set-theoretic operations over label collections. It is used for managing unique identifiers in compiler representations and tracking dependencies between labeled entities.",
      "description_length": 405,
      "index": 1023,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genlambda.Make",
      "library": "rocq-runtime.kernel",
      "description": "Converts Coq terms into an intermediate representation suitable for execution in a virtual machine or native compilation. It processes lambda expressions using environment and evar information, producing values compatible with the target runtime. Useful for compiling proof terms into executable code or interpreting them directly.",
      "description_length": 331,
      "index": 1024,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Univ.ContextSet",
      "library": "rocq-runtime.kernel",
      "description": "This module manages sets of universe levels combined with constraints, providing operations for union, difference, and efficient appending of context sets. It supports creation from individual levels or existing level sets, and allows adding or extracting constraints and levels. Concrete use cases include tracking and combining universe contexts during type checking and managing constraints in proof terms.",
      "description_length": 409,
      "index": 1025,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.PRset",
      "library": "rocq-runtime.kernel",
      "description": "This module provides set-theoretic operations like union, intersection, difference, and filtering, alongside inspection capabilities such as membership checks, element traversal, and size queries, all tailored for sets of projection representations. It operates on immutable collections of `Names.Projection.Repr.t` values, offering persistent data structures that support functional programming patterns where modifications produce new sets rather than in-place updates. These capabilities are particularly useful in formal verification or compiler components where maintaining immutable state and efficiently composing set-based analyses are critical.",
      "description_length": 653,
      "index": 1026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Context.Compacted",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations to fold over a compacted context of variable declarations, transforming and processing entries efficiently. It works with structured contexts containing names mapped to values or types, supporting conversion and traversal. Use cases include type checking and evaluation phases where compact representation and performance are critical.",
      "description_length": 367,
      "index": 1027,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evar.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module implements ordered collections of integer-like variables with safety guarantees, supporting efficient membership tests, union/intersection/difference operations, and ordered traversal via min/max element access. It leverages a total ordering to enable directional searches, sorted enumeration, and sequence conversions for applications requiring deterministic variable set management. Typical use cases involve symbolic computation or program analysis tasks where unique variable identifiers must be tracked with both safety and ordering constraints.",
      "description_length": 562,
      "index": 1028,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Mindmap_env",
      "library": "rocq-runtime.kernel",
      "description": "This module provides associative map operations for key-value associations with keys of type `Names.MutInd.t`, supporting efficient lookup, transformation, filtering, and structural comparison. It works with a polymorphic map structure that binds these keys to arbitrary values, enabling set-based operations and conversions to and from domains. Typical use cases include managing named entities in kernel subsystems, optimizing shared representations via smart constructors, and handling monadic effects during symbolic computation or environment tracking.",
      "description_length": 557,
      "index": 1029,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constrmap_env",
      "library": "rocq-runtime.kernel",
      "description": "The module implements a constructor-keyed map with dictionary operations, set-like manipulations (union, merge), and transformation capabilities (filtering, folding, mapping) over environments of arbitrary values. It leverages an ordered map structure for efficient lookups and structural sharing, particularly useful in type-checking and compilation contexts requiring precise symbol table management, incremental updates, or effectful traversals during symbolic analysis.",
      "description_length": 473,
      "index": 1030,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Environ.QConstruct",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for comparing, hashing, and normalizing qualified constructors within an environment. It works with `Environ.env` and `Environ.QConstruct.t`, which represent environments and qualified constructors, respectively. Concrete use cases include ensuring structural equivalence of constructors during type checking and optimizing constructor comparisons through canonical forms.",
      "description_length": 404,
      "index": 1031,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cset",
      "library": "rocq-runtime.kernel",
      "description": "This set data structure provides standard algebraic operations like union, intersection, and difference, along with traversal and transformation functions (`iter`, `fold`, `filter`) over elements of type `Names.Constant.t`. It supports inspection through cardinality checks, element listing, and arbitrary element selection, enabling use cases such as managing unique constant collections, validating membership constraints, or analyzing character set compositions in symbolic computation systems.",
      "description_length": 497,
      "index": 1032,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.KNpred",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a set-like structure for elements of type `Names.KerName.t`, supporting standard operations such as membership testing, union, intersection, difference, and complement. It handles both finite and potentially infinite sets, with functions to check emptiness, fullness, and finiteness, and to extract a finite representation when possible. Concrete use cases include managing sets of kernel names in proof assistants or compilers where precise set manipulation and predicate representation are required.",
      "description_length": 524,
      "index": 1033,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Constrset",
      "library": "rocq-runtime.kernel",
      "description": "This API offers a functional set interface for managing immutable collections of constructor constraints, supporting operations like union, intersection, difference, membership testing, and element filtering. It works with sets of `Names.constructor` values, along with conversions to and from lists and sequences, enabling aggregation of multiple constraint sets through merging and union operations. Typical use cases include tracking constraint relationships, combining constraints from disparate sources, and processing sequences of constraints into unified sets.",
      "description_length": 567,
      "index": 1034,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.MBId",
      "library": "rocq-runtime.kernel",
      "description": "This module implements unique identifiers for bound names, combining a directory path, an integer tag, and an inner identifier. It supports equality, comparison, hashing, and serialization operations, primarily used to ensure name uniqueness across different files in the kernel. Typical use cases include managing bound variables in terms, avoiding capture during substitution, and tracking definitions across modules.",
      "description_length": 419,
      "index": 1035,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.DPset",
      "library": "rocq-runtime.kernel",
      "description": "This module provides set-theoretic operations and transformations for collections of directory paths, supporting efficient membership tests, unions, intersections, and element-wise filtering or partitioning. It works with ordered sets, sequences, and lists of directory path elements, enabling safe access to extremal values, cardinality queries, and bidirectional conversions between set and list representations. Typical applications include aggregating multiple name sets into a unified collection or analyzing hierarchical directory structures through iterative set manipulations.",
      "description_length": 584,
      "index": 1036,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UVars.Variance",
      "library": "rocq-runtime.kernel",
      "description": "This module defines a type `t` representing variance kinds\u2014`Irrelevant`, `Covariant`, and `Invariant`\u2014and provides operations to check subtyping relationships, compute suprema, and compare variances. It supports use cases like enforcing correct type parameter variance in a type checker or managing subtyping constraints in a constraint-solving system. Functions include `check_subtype` for verifying variance compatibility, `sup` for combining variances, and `equal` for structural comparison.",
      "description_length": 494,
      "index": 1037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Esubst.Internal",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a single operation, `repr`, which converts a substitution into a high-level representation consisting of a list of value-index associations and a relocation shift. It works directly with substitution data structures, specifically `Esubst.subs` and the internal `or_rel` type. A concrete use case is inspecting the structure of substitutions during debugging to understand variable bindings and shifts in explicit substitution manipulations.",
      "description_length": 461,
      "index": 1038,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UVars.AbstractContext",
      "library": "rocq-runtime.kernel",
      "description": "This module manages abstract contexts of universe variables with associated constraints, supporting operations to build, combine, and query contexts. It works with universe variables and constraints, tracking bound names and sizes. Concrete use cases include merging universe contexts under consistent constraints and instantiating constraints for specific universe instances.",
      "description_length": 376,
      "index": 1039,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MBIset",
      "library": "rocq-runtime.kernel",
      "description": "This module supports membership checks, insertion, deletion, and set algebra operations (union, intersection, difference) for sets of unique identifiers (`MBId.t`). It provides utilities to query set properties (cardinality, element selection), transform elements via predicates, and convert between sets, lists, and sequences. Common use cases include managing disjoint identifier collections, merging sets from multiple sources, and processing identifier groups through iterative folds or value-based searches.",
      "description_length": 512,
      "index": 1040,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Construct",
      "library": "rocq-runtime.kernel",
      "description": "This module operates on the `Names.Construct.t` type, representing structured names used throughout the system. It provides direct access to components of names, such as their module path via the `modpath` function, and supports name transformation through the `canonize` function, which returns the canonical form of a name. These operations are essential for managing name resolution, scoping, and identity checks in the kernel and related components.",
      "description_length": 453,
      "index": 1041,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.QConstraint",
      "library": "rocq-runtime.kernel",
      "description": "This module represents and manipulates quality constraints between variables, supporting equality and less-than-or-equal comparisons. It provides operations for comparing, printing, and checking trivial constraints, working directly with quality variables and constraint kinds. Concrete use cases include constraint solving and ordering checks in type inference systems.",
      "description_length": 370,
      "index": 1042,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UVars.Instance",
      "library": "rocq-runtime.kernel",
      "description": "This module represents and manipulates universe variable instances, handling operations like creation, concatenation, equality checks, and hash-consing. It works with arrays of `Sorts.Quality.t` and `Univ.Level.t`, supporting concrete tasks such as pretty-printing, substitution, and pattern matching in type-level computations. Use cases include managing universe levels during type inference and supporting rewrite rules via pattern matching on instances.",
      "description_length": 457,
      "index": 1043,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.UGlobal",
      "library": "rocq-runtime.kernel",
      "description": "This module represents universe levels qualified by a directory path, a string, and an integer. It provides operations to construct, compare, and convert these universe identifiers, supporting precise management of universe constraints in type theory implementations. Concrete use cases include tracking and resolving universe levels in dependent type systems during proof checking or compilation.",
      "description_length": 397,
      "index": 1044,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Id",
      "library": "rocq-runtime.kernel",
      "description": "This module provides identifiers with equality, comparison, and hashing operations, along with validation and conversion functions for strings and bytes. It supports efficient set, map, predicate, and list operations for managing collections of identifiers. Concrete use cases include managing variable names in compilers, tracking symbols in formal systems, and implementing efficient lookups in kernel-level code.",
      "description_length": 415,
      "index": 1045,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cpred",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a set-like structure over elements of type `Names.Constant.t`, supporting standard operations such as membership testing, union, intersection, difference, and complement. It handles both finite and potentially infinite sets, with functions to check emptiness, fullness, and finiteness. Concrete use cases include representing and manipulating sets of constants in environments or during type checking where precise inclusion and exclusion conditions matter.",
      "description_length": 480,
      "index": 1046,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.QVar",
      "library": "rocq-runtime.kernel",
      "description": "This module implements qualified variables with support for variable indexing, unification keys, and runtime name representation. It provides atomic comparison, hashing, and conversion to/from integer and string-based representations, enabling use cases like symbolic variable tracking in type inference or constraint solving. The Set and Map submodules enable efficient collection manipulation for tasks such as dependency resolution and variable set analysis.",
      "description_length": 461,
      "index": 1047,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rtree.Smart",
      "library": "rocq-runtime.kernel",
      "description": "Performs a conditional map over an R-tree, applying a function to each node only if it would change the node's value. Preserves the original tree structure when the function has no effect. Useful for optimizing transformations where most nodes may remain unchanged.",
      "description_length": 265,
      "index": 1048,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MBImap",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a rich set of associative map operations for immutable, ordered key-value structures indexed by a specific key type, supporting both pure and monadic transformations. It offers efficient functional manipulation of finite maps through structural sharing, including ordered key-based queries, higher-order transformations, and stateful traversals that combine reduction with effectful computations. Use cases include managing hierarchical or ordered data, performing precise key-value updates with minimal copying, and integrating effectful logic into map traversals while preserving immutability.",
      "description_length": 616,
      "index": 1049,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constr.UnsafeMonomorphic",
      "library": "rocq-runtime.kernel",
      "description": "This module provides low-level, unsafe operations for constructing and manipulating monomorphic kernel terms. It works directly with inductive types, constants, and constructors, exposing functions to build and deconstruct terms without safety checks. Concrete use cases include optimizing term generation in proof scripts and implementing custom reduction strategies where performance outweighs safety.",
      "description_length": 403,
      "index": 1050,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Univ.Constraints",
      "library": "rocq-runtime.kernel",
      "description": "This module suite provides operations for managing constraint sets, including union, intersection, difference, membership checks, and element retrieval, while supporting conversions between sequences and lists. It works with sets of universe constraints (`Univ.Constraints.t`) and their individual elements (`Univ.Constraints.elt`), enabling aggregation, transformation, and property queries. Specific use cases include constraint set manipulation for type inference, combining constraints via list operations, and structured printing with custom formatting.",
      "description_length": 558,
      "index": 1051,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UVars.UContext",
      "library": "rocq-runtime.kernel",
      "description": "This module manages universe contexts, which consist of named universe levels and constraints. It supports operations like creating, merging, and refining contexts, as well as extracting instance data and constraint sets. Use cases include handling universe polymorphism in type theory implementations and managing universe dependencies during proof checking.",
      "description_length": 359,
      "index": 1052,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constant",
      "library": "rocq-runtime.kernel",
      "description": "This module manages constant names using user and canonical representations, providing construction, decomposition, and transformation operations. It supports comparisons and hashing through its submodules, enabling efficient use in sets, maps, and term processing. Concrete use cases include normalizing identifiers, checking name equivalence, and storing constants in hash tables or ordered collections.",
      "description_length": 405,
      "index": 1053,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constrmap",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a heterogeneous map structure keyed by constructor names, supporting standard associative operations like insertion, lookup, and filtering, as well as advanced transformations such as merging, splitting, and symmetric difference analysis. It works with maps containing arbitrary value types under `Names.constructor` keys, offering efficient traversal, structural optimization via the `Smart` submodule, and monadic operations for effectful iteration. Use cases include managing constructor-indexed metadata, optimizing shared substructures in large nested terms, and accumulating state during ordered map transformations.",
      "description_length": 643,
      "index": 1054,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cmap",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a canonicalized key-value mapping using `Constant.t` as keys, ordered by their normalized form, with polymorphic values. It supports standard map operations like insertion, filtering, and folding, alongside optimized transformations and monadic traversals for handling effectful computations. The structure is particularly useful in scenarios requiring precise key equivalence and ordering guarantees, such as managing compiler kernel metadata or symbolic representations where canonicalization ensures consistent lookups.",
      "description_length": 545,
      "index": 1055,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Constr.GenHCons",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a higher-order cons function that takes a value of type `C.t` and returns a `Constr.constr`. It works directly with the `constr` type defined in the `Constr` module, which represents kernel terms in Rocq. A concrete use case is constructing normalized terms in a proof assistant context, where each term is built incrementally using previously defined components.",
      "description_length": 386,
      "index": 1056,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evar.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module provides map operations for key-value stores with existential variables (`Evar.t`) as keys, supporting functional updates, filtering, and folding over arbitrary value types. It emphasizes efficient key-based queries and structural sharing preservation, with specialized tools for tracking unsafe integer-to-variable casts during stateful transformations. Use cases include symbolic computation and theorem proving where typed variable mappings require precise manipulation and audit of unsafe conversions.",
      "description_length": 517,
      "index": 1057,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.PRmap",
      "library": "rocq-runtime.kernel",
      "description": "This module provides associative map operations for keys based on projection representations, supporting creation, transformation, and structural comparison of mappings. It works with persistent maps that bind `Names.Projection.Repr.t` keys to arbitrary values, offering domain manipulation, filtered traversal, and monadic composition via optimized submodules. Typical use cases involve managing hierarchical or scoped name mappings in kernel subsystems where precise key ordering and efficient value transformations are required.",
      "description_length": 531,
      "index": 1058,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Modops",
      "library": "rocq-runtime.kernel",
      "description": "This module provides structural transformations and validation mechanisms for OCaml's module system, focusing on functor manipulation, type conversion, and environment management. It operates on module paths, signatures, and types, with specialized support for handling inductive structures, constants, and delta resolvers during operations like module inclusion or functor instantiation. Key use cases include resolving signature mismatches, enforcing subtyping constraints, and maintaining consistency during module type strengthening and substitution.",
      "description_length": 554,
      "index": 1059,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Typeops",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for type inference, judgment validation, and primitive type computation in Coq's core type system. It manipulates environments, constructions, and universe instances to determine types for variables, constants, and match expressions, while enforcing sort constraints and context well-formedness. These capabilities are critical for verifying correctness of Coq's kernel-level term manipulations, such as cast validation and inductive definition typing.",
      "description_length": 484,
      "index": 1060,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Opaqueproof",
      "library": "rocq-runtime.kernel",
      "description": "This module manages opaque proof terms and their associated metadata, providing operations to create, substitute, and discharge opaque values. It works with data types like `opaquetab`, `opaque`, `opaque_proofterm`, and `opaque_handle`, along with substitutions and cooking info. Concrete use cases include handling proof terms that are shielded from reduction, tracking their origin via directory paths, and managing their delayed universes during substitution or compilation.",
      "description_length": 477,
      "index": 1061,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmbytegen",
      "library": "rocq-runtime.kernel",
      "description": "This module compiles Coq terms and constants into bytecode, handling monomorphic terms and constant definitions with universe constraints. It operates on data types like `Constr.constr`, `Environ.env`, and `Declarations.constant_def`, producing bytecode structures along with patching information. Concrete use cases include compiling function bodies during module strengthening and generating executable bytecode for Coq definitions.",
      "description_length": 434,
      "index": 1062,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vconv",
      "library": "rocq-runtime.kernel",
      "description": "This module implements conversion functions for comparing and normalizing terms in the Coq kernel, specifically handling universe polymorphism and existential variables. It provides `vm_conv` for kernel-level term conversion and `vm_conv_gen` for generalized conversion with customizable normalization strategies. These functions are used during type checking and proof reconstruction to ensure logical consistency and proper term equivalence.",
      "description_length": 443,
      "index": 1063,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Primred",
      "library": "rocq-runtime.kernel",
      "description": "This module defines core reduction operations for primitive values, handling evaluation of constants in a native environment. It works with environments, primitive types, inductive types, and constructors, providing direct access to predefined constants and their associated data constructors. Used during term reduction involving primitives like integers, booleans, pairs, and comparison results, enabling low-level evaluation of arithmetic and data manipulation operations.",
      "description_length": 475,
      "index": 1064,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Inductive",
      "library": "rocq-runtime.kernel",
      "description": "This module enables the analysis and transformation of inductive and coinductive types by validating positivity and guard conditions, expanding case expressions, and managing universe polymorphism. It operates on inductive specifications, constructors, cofixpoints, and environments with universe constraints to support type checking, recursive function validation, and correctness of inductive definitions in Coq's kernel. Key operations include instantiating contexts with substitutions, determining elimination rules, and ensuring proper handling of template polymorphism and squashing during type processing.",
      "description_length": 612,
      "index": 1065,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IndTyping",
      "library": "rocq-runtime.kernel",
      "description": "Handles type checking of inductive definitions, producing updated environments, universe constraints, and arity information. Works with inductive entries, environments, and universe instances, returning structured results including potential reasons for records not being primitive. Useful in compiler phases for validating inductive types and their projections in dependently typed programs.",
      "description_length": 392,
      "index": 1066,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmvalues",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for constructing, inspecting, and converting virtual machine values, including handling closures, fixpoints, cofixpoints, and switch constructs. It works with environments, stacks, atomic values, and structured constants, supporting runtime execution and code manipulation tasks. Specific use cases include managing function closures, executing control flow structures, and implementing primitive array and string operations during VM execution.",
      "description_length": 477,
      "index": 1067,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pstring",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a primitive string type with bounded length, supporting operations like creation, concatenation, substring extraction, and character access. It works with strings limited to a maximum length of `max_length_int` and uses `Uint63.t` for indices and lengths. Concrete use cases include handling fixed-size string data in low-level parsing or serialization tasks where length constraints are critical.",
      "description_length": 420,
      "index": 1068,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmsymtable",
      "library": "rocq-runtime.kernel",
      "description": "This module provides functions for evaluating and interpreting terms in a virtual machine environment. It operates on symbolic values, environments, and compiled code structures. It is used to execute terms represented as `Constr.constr` values and to run compiled virtual machine code against a given environment.",
      "description_length": 314,
      "index": 1069,
      "embedding_norm": 1.0
    },
    {
      "module_path": "InferCumulativity",
      "library": "rocq-runtime.kernel",
      "description": "This module determines the cumulativity of inductive types by analyzing their arities and constructors. It computes universe levels and variances for each inductive parameter based on the given environments and constraints. Used during type inference to ensure correct universe management in inductive definitions.",
      "description_length": 314,
      "index": 1070,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Safe_typing",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for managing typing environments, adding type-safe constructs like constants and inductive types, configuring typing flags, and handling module systems with support for nested structures and library imports. It operates on data structures such as safe environments, transformers, private constants, section contexts, and module paths, ensuring consistency during proof construction and module manipulation. Specific use cases include enforcing universe constraints, controlling VM compilation, resolving delta-reductions, and maintaining evaluation strategies for conversion oracles.",
      "description_length": 615,
      "index": 1071,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmbytecodes",
      "library": "rocq-runtime.kernel",
      "description": "This module defines data types and operations for constructing and manipulating bytecode instructions used in a virtual machine. It supports label management, stack operations, closures, and primitive operations, working with structured constants, global references, and arrays of labels. Concrete use cases include generating executable bytecode from higher-level constructs and implementing control flow for functional programs.",
      "description_length": 430,
      "index": 1072,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Subtyping",
      "library": "rocq-runtime.kernel",
      "description": "Performs subtyping checks between module types in a given environment and universe state, producing a result that may involve universe inconsistencies. Works with module type bodies and universe constraints. Used during module type inference and checking to ensure compatibility between different module type definitions.",
      "description_length": 321,
      "index": 1073,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UGraph",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for enforcing universe constraints, including subtyping checks, merging, and consistency validation within a graph-based structure. It works with universe levels, sorts, and constraints to manage declarations, extract relationships, and debug inconsistencies. It is particularly useful in type systems requiring precise universe management, such as in proof assistants or dependently typed languages.",
      "description_length": 432,
      "index": 1074,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CClosure",
      "library": "rocq-runtime.kernel",
      "description": "This module provides lazy evaluation and reduction mechanisms for manipulating Coq's internal terms through closures, substitutions, and reduction stacks. It operates on frozen terms (`fconstr`), substitution environments (`usubs`), and reduction contexts (`clos_infos`), supporting operations like normalization, weak head reduction, stack manipulation, and reference unfolding with customizable reduction strategies. Key use cases include efficient term normalization, partial evaluation of fixpoints and primitives, and controlled unfolding of definitions during proof reduction.",
      "description_length": 582,
      "index": 1075,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for managing identifiers, paths, and labels through persistent, ordered collections and hash-consed structures like sets (e.g., ModIdset, DPset) and maps (e.g., ModIdmap, DPmap) keyed by specialized name types (KerName.t, Constant.t, Ind.t). These tools support efficient set-theoretic manipulations, name binding, equivalence checks, and path-based transformations, critical for type checking, proof automation, and name resolution in formal systems. They underpin symbolic computation and canonicalization in environments requiring precise name handling, such as compiler kernels and proof assistants.",
      "description_length": 635,
      "index": 1076,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Context",
      "library": "rocq-runtime.kernel",
      "description": "This module implements operations for managing and manipulating structured contexts with annotated binders, including equality checks, hashing, mapping, and construction of binder annotations. It works with parameterized binder structures that track names and relevance information, supporting both homogeneous and heterogeneous transformations. Concrete use cases include formalizing variable binding in type theory, managing scoped declarations in compilers, and implementing proof assistants with precise scoping rules.",
      "description_length": 522,
      "index": 1077,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nativecode",
      "library": "rocq-runtime.kernel",
      "description": "This component manages symbol tables for tracking named entities like constants, inductives, and projections using integer identifiers, alongside utilities for debugging and source location tracking. It transforms high-level ML constructs\u2014such as constants, inductive types, and rewrite rules\u2014into executable native code representations, handling tasks like compiling definitions, constructing conversion logic, and linking loaded native files during the compiler's code generation phase.",
      "description_length": 488,
      "index": 1078,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declareops",
      "library": "rocq-runtime.kernel",
      "description": "This module provides substitution, transformation, and structural analysis operations for type declarations in Coq's kernel, focusing on polymorphism, universe management, and opacity. It operates on declaration types like `constant_body`, `mutual_inductive_body`, and `module_body`, offering utilities to inspect recursion arguments, validate well-formed paths, and optimize memory via hash-consing. Specific applications include enforcing cumulativity constraints, generating inductive projections, and maintaining type-checking invariants during module implementation.",
      "description_length": 571,
      "index": 1079,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Genlambda",
      "library": "rocq-runtime.kernel",
      "description": "This module defines an intermediate language for representing lambda terms with support for closures, case annotations, and environment-based evaluation. It provides functions for constructing and decomposing lambda expressions, managing free variables, and optimizing term structure. Used internally during compilation to translate Coq terms into executable code or interpret them within a runtime environment.",
      "description_length": 411,
      "index": 1080,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Retroknowledge",
      "library": "rocq-runtime.kernel",
      "description": "This module tracks and maps low-level primitive types and operations to their corresponding names in a structured format. It supports operations for registering primitive types and inductive constructs, associating them with constants or constructors from the `Names` module. It is used to maintain metadata about how primitive values like integers, floats, booleans, and arrays are represented in the system, enabling accurate name resolution during compilation or debugging.",
      "description_length": 476,
      "index": 1081,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Entries",
      "library": "rocq-runtime.kernel",
      "description": "This module defines data structures and types for representing global declarations such as constants, inductive types, and modules within a Coq-like environment. It includes specific types like `inductive_universes_entry`, `definition_entry`, and `module_struct_entry` used to encode declaration metadata, universes, and module structures. Concrete use cases include parsing and storing inductive type definitions, managing polymorphic constants, and structuring module expressions with optional inline parameters.",
      "description_length": 514,
      "index": 1082,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Relevanceops",
      "library": "rocq-runtime.kernel",
      "description": "This module determines the relevance of terms, variables, constants, and constructors in a given environment by checking whether they inhabit a proof-irrelevant type. It operates on core Coq data types such as `Constr.constr`, `Environ.env`, and various universe-annotated projections and constants. Concrete use cases include optimizing type checking by avoiding full term retyping when relevance information suffices.",
      "description_length": 419,
      "index": 1083,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Environ",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for managing contexts and global definitions in a type-unsafe setting, including pushing declarations, variable lookups, and context transformations over environments (`env`), `rel_context`, `named_context`, and identifiers like constants (`Constant.t`) and inductives (`Ind.t`). It supports querying and modifying type-unchecked data such as constant properties, inductive definitions, and universe constraints, while handling dependencies and VM-related structures like `Vmlibrary.t`. Key use cases include Coq's type-checking pipeline, compilation of global references, and manipulation of polymorphic or impredicative contexts where formal type guarantees are deferred.",
      "description_length": 705,
      "index": 1084,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Esubst",
      "library": "rocq-runtime.kernel",
      "description": "This module implements operations for explicit substitutions in type theory, handling variable bindings, shifts, and lifts in a de Bruijn index setting. It provides functions to construct and manipulate substitutions (`subs_cons`, `subs_shft`, `subs_liftn`) and lifts (`el_shft`, `el_liftn`), along with utilities to expand or relocate variables under substitutions. Concrete use cases include managing substitution propagation in type checkers and normalizers, where precise control over variable capture and binder traversal is required.",
      "description_length": 539,
      "index": 1085,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Partial_subst",
      "library": "rocq-runtime.kernel",
      "description": "This module manages partial substitutions for terms, qualities, and universes using a tuple-based structure. It supports adding or conditionally inserting values by index, and converting the substitution into arrays. It is used to build and manipulate incomplete mappings during type checking or term transformation tasks.",
      "description_length": 322,
      "index": 1086,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declarations",
      "library": "rocq-runtime.kernel",
      "description": "This component provides operations for constructing and manipulating global declarations in a dependently typed language, focusing on advanced type theory features. It works with data structures for constants, inductive types, modules, and universe-polymorphic constructs, while supporting operations on elimination patterns, rewrite rules, and module expressions. These capabilities enable managing logical axioms, recursive definitions, and modular structures in proof assistants like Coq.",
      "description_length": 491,
      "index": 1087,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nativelibrary",
      "library": "rocq-runtime.kernel",
      "description": "Implements separate compilation for libraries in the native compiler, handling module paths, environments, and signatures. Exposes a function to dump a library into a list of global identifiers and symbols for native compilation. Useful for compiling and linking OCaml modules separately while maintaining correct symbol resolution.",
      "description_length": 332,
      "index": 1088,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for manipulating sort systems in type theory, focusing on concrete sorts like `SProp`, `Prop`, `Set`, and `Type`, along with quality values and constraints. It supports variable handling (indexing, substitution), constraint creation (equality, ordering), and transformation of Coq sort representations with universe level tracking and erasure modeling via `relevance`. Key use cases include type inference, universe polymorphism, and substitution-based sort comparisons using pattern matching on sort families.",
      "description_length": 542,
      "index": 1089,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parray",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a persistent array structure with efficient indexing, supporting operations like creation, mapping, folding, and conversion to and from standard arrays. It works with polymorphic array values parameterized by a default element, using unsigned 63-bit integers for indexing. Concrete use cases include maintaining immutable arrays with structural sharing for efficient updates, such as in functional data processing pipelines or stateful computations requiring versioned arrays.",
      "description_length": 499,
      "index": 1090,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UVars",
      "library": "rocq-runtime.kernel",
      "description": "This module facilitates the manipulation of universe variables and their constraints through operations like substitution, instantiation, and variance enforcement in a type-theoretic setting. It interacts with data structures including universe levels, sort hierarchies, and context representations, serving critical roles in type inference, proof validation, and maintaining consistency within Coq's universe system. Key patterns involve abstraction, constraint propagation, and pretty-printing for debugging and user interaction.",
      "description_length": 531,
      "index": 1091,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmlambda",
      "library": "rocq-runtime.kernel",
      "description": "This module defines representations for lambda terms and low-level values used in the virtual machine. It provides functions to convert between structured values and lambda terms, extract values from lambda expressions, and compile Coq terms into VM-compatible lambda code. It is used during the compilation of Coq terms into executable VM code, particularly for handling constants, evars, and debugging compiled lambda output.",
      "description_length": 427,
      "index": 1092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mod_typing",
      "library": "rocq-runtime.kernel",
      "description": "This module translates module and module type entries into their compiled forms, handling universe constraints and environment dependencies. It operates on module paths, inline directives, and module entries to produce module bodies and signatures with associated state. It supports concrete tasks like compiling module definitions, finalizing module declarations with optional signatures, and translating include statements with delta resolvers.",
      "description_length": 446,
      "index": 1093,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Conv_oracle",
      "library": "rocq-runtime.kernel",
      "description": "This module manages conversion strategies for constants and variables during type checking, determining when and how to unfold or expand references based on transparency levels. It works with evaluable references like variables, constants, and projections, and tracks their evaluation state using an oracle structure. Use cases include controlling the unfolding of opaque constants during conversion checking and customizing reduction behavior in proof automation.",
      "description_length": 464,
      "index": 1094,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Discharge",
      "library": "rocq-runtime.kernel",
      "description": "This module transforms proof terms, constants, inductive definitions, and contexts according to specified cooking policies. It operates on core proof and type data structures such as `opaque_proofterm`, `constant_body`, `mutual_inductive_body`, and `rel_context`. It is used during proof compilation to apply erasure or optimization rules to internal proof objects.",
      "description_length": 365,
      "index": 1095,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmemitcodes",
      "library": "rocq-runtime.kernel",
      "description": "This module handles low-level code generation and patching for a virtual machine, managing relocations for constants, primitives, and global references. It works with bytecode structures, substitution environments, and patch descriptors to enable dynamic code modification and memory layout adjustments. Concrete use cases include compiling and linking VM instructions, applying fixups after code loading, and supporting module substitution in bytecode.",
      "description_length": 453,
      "index": 1096,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "RedFlags",
      "library": "rocq-runtime.kernel",
      "description": "This component provides operations to manage reduction flags that control term evaluation strategies in a proof assistant's type checker. It defines data structures like `reds` and `red_kind` to represent reduction modes, enabling precise configuration of beta, delta, zeta, and other reductions through functions for adding, removing, or querying individual flags and combinations. These mechanisms are used during type checking and term normalization to selectively apply computational rules when reducing expressions or resolving constraints.",
      "description_length": 545,
      "index": 1097,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Indtypes",
      "library": "rocq-runtime.kernel",
      "description": "This module checks inductive type definitions, validating their structure and universe constraints. It processes mutual inductive entries to produce well-formed inductive bodies, handling universe polymorphism and ensuring correctness of recursive and nested inductive types. A typical use case involves verifying the validity of inductive data types during compilation in a proof assistant or type checker.",
      "description_length": 407,
      "index": 1098,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Reduction",
      "library": "rocq-runtime.kernel",
      "description": "This module handles reduction operations on terms in an environment, focusing on beta-reduction, head normal form computation, and decomposition of products and lambdas. It works with data types such as `Constr.constr`, `Constr.types`, `Constr.rel_context`, and `Environ.env`, often involving application lists or arrays. Concrete use cases include normalizing terms during type checking, applying arguments to functions while reducing redexes, and extracting binding contexts from lambda expressions or fixpoints.",
      "description_length": 514,
      "index": 1099,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vars",
      "library": "rocq-runtime.kernel",
      "description": "This module implements substitution calculi for managing bound variables in lambda terms, featuring operations like parallel substitution (substnl, substl), index lifting (liftn, lift), and occurrence analysis (noccurn, closed0). It works with Coq's internal representations including terms (Constr.constr), typing contexts (Constr.rel_context), and substitution values (substituend, instance), while supporting universe level manipulation and polymorphic instantiation. These mechanisms are essential for type checking, term transformation, and context management in proof assistant kernels where precise binder handling is critical.",
      "description_length": 634,
      "index": 1100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nativelambda",
      "library": "rocq-runtime.kernel",
      "description": "This module translates Coq terms into lambda expressions for native compilation. It provides the `lambda_of_constr` function, which converts a Coq term (`Constr.constr`) into a lambda expression using a given environment and evar map. It operates on data types such as environments, evar maps, and Coq terms, producing lambda expressions used in the native code generation pipeline. A concrete use case is compiling Coq definitions into an intermediate lambda representation before generating C code.",
      "description_length": 500,
      "index": 1101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evar",
      "library": "rocq-runtime.kernel",
      "description": "This module implements integer-like existential variables with safe and unsafe conversion operations, equality, comparison, and hashing. It supports structured set and map collections that enforce ordering and safety guarantees for variable management. Use cases include symbolic computation and program analysis where unique, ordered variable identifiers require controlled casting and deterministic collection manipulation.",
      "description_length": 425,
      "index": 1102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rtree",
      "library": "rocq-runtime.kernel",
      "description": "This module implements recursive trees with labeled nodes and variable bindings, supporting operations to construct and compare infinite or cyclic tree structures. It provides functions for building recursive nodes, detecting infinite branches, mapping over tree elements, and managing variable capture in recursive contexts. Concrete use cases include representing and analyzing recursive data structures with shared or infinite substructures, such as abstract syntax trees with let-bindings or cyclic graphs.",
      "description_length": 510,
      "index": 1103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Uint63",
      "library": "rocq-runtime.kernel",
      "description": "The module provides numeric manipulation and bit-level operations for 63-bit unsigned integers, supporting arithmetic (addition, subtraction, multiplication, division), bitwise logic (AND, OR, XOR, shifts), and bit counting (leading/trailing zeros). It works with fixed-size 63-bit integers, offering conversions to and from native types like `int`, `int64`, and strings, while enabling precise control over overflow and underflow via carry-aware operations. These capabilities suit low-level systems programming, cryptographic implementations, and performance-sensitive applications requiring exact bit-width guarantees or bitwise algorithm optimization.",
      "description_length": 655,
      "index": 1104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nativevalues",
      "library": "rocq-runtime.kernel",
      "description": "This module manipulates low-level values and symbolic constructs for the native compiler, offering operations like function application, closure creation, arithmetic and bitwise operations, and structured data handling. It works with internal types such as tagged values, accumulators, blocks, and symbol tables, supporting compiler tasks like code generation and runtime optimizations. Specific use cases include direct manipulation of inductive types, fixpoints, arrays, and strings in performance-critical contexts where safety checks are bypassed.",
      "description_length": 551,
      "index": 1105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HConstr",
      "library": "rocq-runtime.kernel",
      "description": "This module implements hash-consed higher-order logic terms with operations to inspect their structure, track reference counts, and build terms without hash-consing. It works directly with `Constr.constr` and related types, supporting efficient term manipulation and sharing. Concrete use cases include optimizing term storage in proof engines and managing term identity in symbolic computation tasks.",
      "description_length": 401,
      "index": 1106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmlibrary",
      "library": "rocq-runtime.kernel",
      "description": "This module manages the compilation and linking of virtual machine code, handling operations like adding code segments, resolving references, and exporting compiled libraries. It works with abstract types representing libraries, indexes, and disk-loaded code, along with structured data for patching and emitting VM instructions. Concrete use cases include loading object files, linking code into a complete library, and injecting compiled code for execution.",
      "description_length": 459,
      "index": 1107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vmopcodes",
      "library": "rocq-runtime.kernel",
      "description": "This module provides low-level operations for a bytecode interpreter, encompassing stack manipulation (pushing, popping, loading), arithmetic on 63-bit integers and floats (checked operations, comparisons), function application (closure creation, argument handling), and control flow (branching, termination). It operates on stack-based execution contexts, heap-allocated blocks, closures, and environment variables, serving use cases like compiling and executing functional code in a virtual machine, managing numeric operations with safety checks, and implementing structured control flow via switch blocks or loops. Specific applications include OCaml compiler backends for translating high-level constructs into efficient, type-safe virtual machine instructions.",
      "description_length": 766,
      "index": 1108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nativelib",
      "library": "rocq-runtime.kernel",
      "description": "This module provides direct access to the OCaml native compiler and dynamic linking facilities, enabling compilation of OCaml code to native objects, loading of compiled libraries, and execution of dynamically linked code. It operates on native code representations (`Nativecode.global list`), object files, and runtime values (`Nativevalues.t`), with support for managing load paths, library symbols, and runtime state (`rt1`, `rt2`). Concrete use cases include compiling and dynamically loading Coq native plugins, executing generated native code with updated symbol locations, and enabling libraries for deferred linking during runtime initialization.",
      "description_length": 654,
      "index": 1109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Section",
      "library": "rocq-runtime.kernel",
      "description": "This module manages nested sections with support for opening and closing scoped environments that track global and local definitions, universe contexts, and constraints. It works with section entries like constants and inductive types, and carries custom data across section boundaries. Concrete use cases include managing universe polymorphism scoping, collecting definitions within a section, and handling local context extensions during type checking.",
      "description_length": 454,
      "index": 1110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Float64",
      "library": "rocq-runtime.kernel",
      "description": "This module offers precise manipulation of 64-bit floating-point values through classification (e.g., detecting NaNs/infinities), arithmetic (addition, square roots), conversion (string/hex representations, integer interoperation), and comparison (total ordering, equality checks). It enables low-level control via bit-level operations, exponent/mantissa decomposition, and directed rounding, catering to numerical algorithms, scientific computing, and systems requiring strict IEEE 754 compliance or edge-case handling.",
      "description_length": 520,
      "index": 1111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Type_errors",
      "library": "rocq-runtime.kernel",
      "description": "This module provides functionality for reporting and handling type-checking errors in dependently typed systems, including issues with inductive definitions, variable binding, incorrect term applications, and malformed branches or arities. It operates on terms (`Constr.constr`, `Environ.unsafe_judgment`), environments (`Environ.env`), universe constraints, and binder/case constructs, with utilities to map and transform error contexts during type inference. Specific use cases include diagnosing unsatisfied universe constraints, invalid recursive definitions, undeclared variables, and variance mismatches in proof assistants.",
      "description_length": 630,
      "index": 1112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constr",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for constructing and manipulating kernel terms, including primitives for term creation (e.g., de Bruijn indices, variables, constants) and structural inspection (e.g., case analysis, fixpoint detection). It operates on data structures like inductive types, coinductive terms, and associated metadata such as universe polymorphism and binder annotations, enabling use cases in formal verification, type checking, and proof transformation workflows. Key functionalities include term decomposition, equivalence checking, and transformations that preserve syntactic and semantic properties during kernel-level computations.",
      "description_length": 651,
      "index": 1113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "TransparentState",
      "library": "rocq-runtime.kernel",
      "description": "This module manages transparency states for identifiers, constants, and projections using sets stored in the `t` record. It provides checks to determine if a given identifier, constant, or projection is marked as transparent, with predefined states for fully transparent or opaque configurations. Concrete use cases include controlling inlining behavior during type checking or managing definitional equality in the presence of opaque definitions.",
      "description_length": 447,
      "index": 1114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Term",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for constructing and analyzing lambda abstractions, product types, and let-in expressions using Coq's internal representations. It manipulates `Constr.constr` and `Constr.types` values to handle binder management (named and de Bruijn), term composition, and structural decomposition, such as extracting binding contexts or stripping nested lambdas. These utilities are essential for tasks like type-directed term transformation, arity analysis, and implementing custom reduction strategies in proof assistants or compilers.",
      "description_length": 555,
      "index": 1115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vm",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for reducing and analyzing functions and fixpoints in a virtual machine context. It works with data types representing functions (`vfun`), fixpoints (`vfix`), cofixpoints (`vcofix`), and switches (`vswitch`), performing tasks such as decomposing function bodies, extracting branch information, and applying weak head reduction. Concrete use cases include evaluating lambda expressions, inspecting switch constructs during pattern matching, and normalizing recursive definitions during compilation or interpretation.",
      "description_length": 547,
      "index": 1116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nativeconv",
      "library": "rocq-runtime.kernel",
      "description": "This module provides functions for performing conversion tests by compiling to OCaml code, specifically `native_conv` and `native_conv_gen`, which handle kernel and generic conversion operations. It works with conversion problems (`conv_pb`), environments (`env`), and universe comparators. A concrete use case is validating type conversions during compilation in a way that leverages OCaml's execution for correctness checks.",
      "description_length": 426,
      "index": 1117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmerrors",
      "library": "rocq-runtime.kernel",
      "description": "This module defines an `error` type and handles compilation-related error reporting. It includes functions to print errors, raise a specific error for oversized code, and validate compilable inductive types based on argument and constant counts. It is used to enforce constraints during compilation and provide meaningful error messages.",
      "description_length": 337,
      "index": 1118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constant_typing",
      "library": "rocq-runtime.kernel",
      "description": "This module handles type inference and validation for definitions, parameters, primitives, and opaque terms in a typing context. It processes entries like section definitions, assumptions, and proof outputs, producing typed constants and constraints. Used during Coq's kernel type-checking phase to ensure correctness of global and local declarations.",
      "description_length": 351,
      "index": 1119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cooking",
      "library": "rocq-runtime.kernel",
      "description": "This module handles abstraction and instantiation of generalized declarations during type checking, working with contexts, universes, and constraints. It provides operations to create and manipulate cooking info and caches, enabling the lifting of universes and the abstraction of types, terms, and sorts. Concrete use cases include managing polymorphic and monomorphic universe contexts when discharging or applying declarations in a type-safe manner.",
      "description_length": 452,
      "index": 1120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Conversion",
      "library": "rocq-runtime.kernel",
      "description": "This module implements core conversion checking operations for type theory, including universe constraint generation, cumulativity checks for inductive types and constructors, and comparison of sorts and terms under a given conversion problem. It operates on data types such as `conv_pb`, `Sorts.t`, `UVars.Instance.t`, and `Constr.constr`, interfacing with environments, evar handlers, and universe graphs. Concrete use cases include checking type equivalence in the kernel, enforcing cumulativity during inductive type comparisons, and resolving universe constraints during term conversion.",
      "description_length": 592,
      "index": 1121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CPrimitives",
      "library": "rocq-runtime.kernel",
      "description": "This module supports arithmetic, bitwise, and comparison operations on 63-bit integers and 64-bit floats, alongside array and string manipulation primitives. It operates on Coq's internal representations of primitive operations, constants, and universe contexts, enabling introspection tasks like extracting type information, parsing operands, and converting values to string or hashable forms. These capabilities are particularly useful in formal verification workflows and compiler internals where precise control over low-level data representations and type-level computations is required.",
      "description_length": 592,
      "index": 1122,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 1165,
    "meaningful_modules": 1123,
    "filtered_empty_modules": 42,
    "retention_rate": 0.9639484978540772
  },
  "statistics": {
    "max_description_length": 766,
    "min_description_length": 141,
    "avg_description_length": 443.6918967052538,
    "embedding_file_size_mb": 16.261801719665527
  }
}