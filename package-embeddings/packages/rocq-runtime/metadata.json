{
  "package": "rocq-runtime",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 1282,
  "creation_timestamp": "2025-07-16T01:37:01.344978",
  "modules": [
    {
      "module_path": "Coq_config",
      "library": "rocq-runtime.config",
      "description": "This module manages configuration parameters, paths, and flags for the Coq system, handling build-time and runtime settings such as installation directories, architecture details, and platform-specific options. It operates on primitive types like strings, booleans, and integers, as well as derived types such as lists, to represent dynamic linking support, compilation modes, and URLs for web resources. Its functionality is essential for initializing the system, adapting behavior across environments, and configuring compilation workflows.",
      "description_length": 542,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn.Val.HMap",
      "library": "ltac2_plugin",
      "description": "This module provides operations to transform and filter typed maps of dynamic values using user-defined functions. It works with maps that associate type-indexed keys with values from modules V1 and V2, supporting type-preserving mapping and type-safe filtering. Concrete use cases include processing heterogeneous collections of Ltac2 values, such as rewriting or selecting specific entries based on their types or contents.",
      "description_length": 425,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn.Val.Easy",
      "library": "ltac2_plugin",
      "description": "This module provides functions to inject and project typed values into a dynamic representation, using tags to maintain type safety. It works with the `t` type representing dynamic values and `tag` for type identification. Useful for handling heterogeneous data in Ltac2, such as passing typed values between tactics and reconstructing them later.",
      "description_length": 347,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn.Val.Map",
      "library": "ltac2_plugin",
      "description": "This module implements a type-safe map from type tags to values parameterized by those tags, supporting operations like insertion, lookup, modification, and filtering. It works with dynamically typed values indexed by keys representing Coq's Ltac2 type tags, enabling heterogeneous storage and transformation of tactic arguments. Concrete use cases include managing dynamic tactic environments and handling polymorphic tactic evaluations.",
      "description_length": 438,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2typing_env.TVar.Map",
      "library": "ltac2_plugin",
      "description": "This module implements associative maps with keys of type `TVar.t` (from the tactic typing environment) and polymorphic values, supporting insertion, deletion, lookup, and traversal operations. It provides functional transformations like `map`, `mapi`, and `filter`, alongside structural queries such as `split`, `min_binding`, and `max_binding` for ordered key analysis. These maps are particularly useful for managing variable bindings or context-sensitive transformations in tactic scripts, where precise key ordering and efficient value manipulation are required.",
      "description_length": 567,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn.Arg",
      "library": "ltac2_plugin",
      "description": "This module defines and manipulates dynamic argument tags used in the Ltac2 abstract syntax tree. It provides operations to create unique argument tags, compare them for equality, and retrieve their string representation. A concrete use case is enabling type-safe manipulation of dynamically typed arguments within Ltac2 tactics, particularly during tactic composition and execution.",
      "description_length": 383,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn.ArgMap",
      "library": "ltac2_plugin",
      "description": "This module implements a type-safe map for dynamic arguments in Ltac2, using a higher-order representation to associate values with typed tags. It supports operations to add, remove, find, and check membership of entries, where each entry binds a tag to a packed pair of raw and global values. It is used to manage heterogeneous collections of arguments in tactic definitions and invocations.",
      "description_length": 392,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2core.MapType-M-Monad",
      "library": "ltac2_plugin",
      "description": "This module implements fold and mapi operations over a monadic structure, where keys and values are processed within a monadic context. It works with keyed data structures like maps or dictionaries, allowing transformations and accumulations that sequence monadic effects. Use it to traverse and transform map entries while handling side effects like state updates or error handling through the monad.",
      "description_length": 401,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2core.MapType",
      "library": "ltac2_plugin",
      "description": "This module implements a mapping structure for tactic expressions, providing operations to associate values with elements of a type. It supports equality checks on value maps and representation conversion for tactic expressions. Concrete use cases include managing bindings of tactic variables during proof script execution and converting between internal and external representations of mapped values.",
      "description_length": 402,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2core.Core",
      "library": "ltac2_plugin",
      "description": "This module defines core type constants and constructors for the Ltac2 tactic language, including basic types like unit, int, string, list, array, and option. It provides direct representations for values such as `v_unit` and constructors like `c_nil`, `c_cons`, `c_true`, and `c_false`. These are used to build and manipulate Ltac2 expressions and tactics directly, particularly during tactic definition and evaluation in Coq's proof engine.",
      "description_length": 442,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn.Val",
      "library": "ltac2_plugin",
      "description": "This module manages dynamic type tags and values for tactic programming, enabling creation, comparison, and lookup of typed tags. It supports key operations like `create` for registering new types, `eq` for type equality checks, and `name` for retrieving tags by name, facilitating type-safe dynamic data structures and Ltac2 tactic argument handling. Submodules extend this functionality by providing type-preserving transformations and filtering on dynamic maps, injection and projection of typed values into dynamic representations, and type-safe maps from tags to values. Examples include processing heterogeneous tactic environments, rewriting Ltac2 value collections, and passing typed values between tactics while preserving type integrity.",
      "description_length": 747,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2val.Valexpr",
      "library": "ltac2_plugin",
      "description": "This module directly manipulates values used in Coq's Ltac2 tactic language, providing low-level access to their internal structure. It supports operations such as checking if a value is an integer, extracting and modifying fields of compound values, and constructing new values from blocks or integers. These functions are used when implementing custom tactic logic that needs to inspect or build Ltac2 values at runtime, such as during proof automation or tactic composition.",
      "description_length": 477,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2entries.Pltac",
      "library": "ltac2_plugin",
      "description": "This module provides parsing and construction facilities for Ltac2 expressions and syntactic constructs used in tactic definitions, such as intro patterns, rewriting rules, and conversion flags. It operates on Ltac2's abstract syntax tree types like `raw_tacexpr`, `intro_pattern`, and `Tac2qexpr`, enabling advanced features like quotation and anti-quotation in tactic scripts. Specific applications include handling proof term manipulations for variable introduction (`pose`), assertion statements, and location-based transformations within Coq's tactic language.",
      "description_length": 565,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2core.MapType-S",
      "library": "ltac2_plugin",
      "description": "This module provides set-like operations including union, intersection, difference, and membership testing for collections of elements with type `S.elt`. It supports querying the size of a collection (`cardinal`), extracting elements as a list (`elements`), and selecting an arbitrary element (`choose`), which are useful for tasks like dependency tracking, filtering, or iterative processing over unordered element groups. The operations are designed for efficiency in scenarios requiring dynamic set manipulation and traversal.",
      "description_length": 529,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2core.MapType-M-Smart",
      "library": "ltac2_plugin",
      "description": "This module provides `map` and `mapi` functions that apply transformations to values within a map structure while attempting to preserve physical sharing. It operates on map types where keys and values are managed with smart constructors to optimize structure sharing. These functions are useful when efficiently updating map contents without duplicating unchanged parts of the structure.",
      "description_length": 388,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2core.MapType-M",
      "library": "ltac2_plugin",
      "description": "This module implements a polymorphic associative map library with keys of type `S.elt` and values of arbitrary type `'a`, supporting core operations like insertion, deletion, membership checks, and cardinality queries. It provides advanced functionality for map combination (union, merge), traversal (iter, fold), filtering (filter, partition), and structural comparison (compare, equal), alongside optimized utilities for key lookup (find_opt, get), domain manipulation (bind, domain), and bulk construction (of_list, set). The Smart and Monad submodules enhance usability with efficient smart constructors and monadic composition, making it suitable for symbolic computation, environment management, or data transformation pipelines requiring precise key-value manipulations.",
      "description_length": 777,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2expr.PartialPat",
      "library": "ltac2_plugin",
      "description": "This module defines a type `r` for representing partial patterns in Ltac2, used during tactic elaboration. It supports operations like variable binding, constructor application, disjunction, and pattern annotations. The structure is used to match and deconstruct terms in Ltac2 scripts, enabling precise control over tactic execution based on term shape.",
      "description_length": 354,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2typing_env.TVar",
      "library": "ltac2_plugin",
      "description": "This module represents type variables in the Ltac2 tactic language and provides equality checks and a map module for associating data with them. It supports operations such as comparison, insertion, deletion, and lookup, along with functional transformations like `map`, `mapi`, and `filter`. The module enables managing type variable bindings during type inference and checking, offering structural queries like `split`, `min_binding`, and `max_binding` for ordered key analysis. It is particularly useful for context-sensitive transformations and maintaining variable bindings in tactic scripts.",
      "description_length": 597,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2dyn",
      "library": "ltac2_plugin",
      "description": "This module enables dynamic argument handling and type-safe manipulation of tactic parameters in Ltac2. It provides core data types such as typed tags and dynamic maps, supporting operations like argument mapping, value extraction, and type-preserving transformations. With it, users can create and manage heterogeneous argument collections, inject and project typed values into dynamic contexts, and perform type-safe lookups during tactic execution. Example uses include building polymorphic tactics that adapt behavior based on argument types and managing complex tactic environments with mixed value types.",
      "description_length": 610,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2quote",
      "library": "ltac2_plugin",
      "description": "This module enables syntactic manipulation of Ltac2 expressions through abstract syntax tree construction and transformation, focusing on quotation mechanisms for tactic notations. It operates on Ltac2's syntax trees, Coq's concrete term representations (`constr_expr`, `glob_constr`), and semantic tags to handle identifiers, structured data, and Ltac2-specific constructs like intro patterns. Key use cases include embedding Ltac2 notations into Coq's term language while preserving hygiene, converting syntactic elements (orientations, occurrences) into tactic expressions, and building composable syntax nodes for domain-specific notations.",
      "description_length": 644,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2extffi",
      "library": "ltac2_plugin",
      "description": "This module defines representations for handling quantified hypotheses, variable bindings, and constructions with associated bindings in the context of tactic programming. It directly supports operations involving Coq's Ltac2 tactic language by exposing FFI-compatible structures for tactic execution and term manipulation. Concrete use cases include implementing custom tactics that inspect or construct proof terms with bound variables and hypotheses.",
      "description_length": 453,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2bt",
      "library": "ltac2_plugin",
      "description": "This module manages backtraces for Ltac2 tactics, providing operations to capture, manipulate, and print execution frames. It works with Ltac2 expressions and tactics, specifically handling backtrace and frame data structures. Concrete use cases include debugging tactic execution by inspecting the call stack and customizing frame output for error reporting.",
      "description_length": 359,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2print",
      "library": "ltac2_plugin",
      "description": "This module provides utilities for pretty-printing and formatting Ltac2 expressions, types, and values, handling identifiers, abstract syntax trees, and type constants. It includes operations for parsing format specifiers from strings and generating structured output representations, particularly for rendering tactic results and managing syntax across global and raw Ltac2 levels. Key use cases involve converting internal data structures into human-readable forms while preserving syntactic nuances and supporting name generation or pattern manipulation during output formatting.",
      "description_length": 582,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2entries",
      "library": "ltac2_plugin",
      "description": "This module orchestrates the registration and evaluation of Ltac2 tactics, types, and notations within Coq's plugin system, integrating parsing, typechecking, and execution of tactic expressions with Coq terms. Its core functionality enables defining custom proof automation strategies and domain-specific notations, while its child module enhances this by providing utilities to construct and manipulate Ltac2 syntax trees, such as `raw_tacexpr` and `intro_pattern`, supporting features like quotation and variable introduction. Together, they facilitate advanced tactic scripting, including rewriting, assertion handling, and location-based transformations. Specific use cases include building extensible tactic languages, embedding domain-specific logic into proofs, and automating repetitive proof patterns through Ltac2 extensions.",
      "description_length": 836,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2expr",
      "library": "ltac2_plugin",
      "description": "This module parses, type-checks, and manipulates Ltac2 expressions and type definitions using algebraic datatypes that capture atomic values, pattern matching constructs, and structured type information. It handles global and raw tactic expressions, type constants, constructors, and backtraces, supporting tactic execution, compilation, and error handling\u2014especially for recursive or mutable types and complex type schemes. A key type, `r`, represents partial patterns used in tactic elaboration, enabling operations like variable binding, constructor application, disjunction, and annotations to control tactic behavior based on term structure. Examples include building and deconstructing tactic expressions, defining type schemes for Ltac2 functions, and using pattern matching to guide tactic execution in Coq proofs.",
      "description_length": 822,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.G_ltac2",
      "library": "ltac2_plugin",
      "description": "This component defines parsing infrastructure for tactic language expressions and types, focusing on syntactic constructs like identifiers, parenthetical groupings, bracketed sections, and prefix operators (dollar/ampersand). It processes raw tactic expressions, optional integers, and s-expression lists to support type conversions and tactic definition parsing in a proof assistant's tactic language. The utilities enable integration of Ltac2 syntax with generalized argument handling and vernacular command manipulations.",
      "description_length": 524,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2stdlib",
      "library": "ltac2_plugin",
      "description": "This module defines standard tactics shared with Ltac1, focusing on pattern-based introduction of hypotheses. It works with Ltac2's tactic types and representation structures, particularly for handling intro patterns. Concrete use cases include implementing tactics that manipulate and decompose logical connectives in proof goals.",
      "description_length": 331,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2env",
      "library": "ltac2_plugin",
      "description": "This module supports defining and managing Ltac2 constructs such as tactics, types, constructors, and notations, along with their associated metadata and visibility rules. It operates on data structures like qualified names, tactic expressions, projections, and ML-defined objects, emphasizing symbol registration, name resolution, and compilation state tracking. Key use cases include extending Coq's tactic language with custom primitives, resolving cross-references in Gallina terms, and embedding Ltac2 expressions via quotations for interactive proof automation.",
      "description_length": 567,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2typing_env",
      "library": "ltac2_plugin",
      "description": "This module manages typing environments and generalized type expressions through operations like unification, substitution, and type scheme handling, supporting type inference and proof state manipulation in tactic systems. It tracks variable freshness, normalizes types, and resolves aliases, while its child module provides a structured way to manage type variables with ordered maps, enabling efficient lookups, transformations, and context-sensitive operations. Users can perform tasks such as inserting and filtering variable bindings, applying function mappings, and analyzing key order during type checking. Together, they facilitate precise and efficient handling of polymorphic types and variable contexts in tactic-based theorem proving.",
      "description_length": 747,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2qexpr",
      "library": "ltac2_plugin",
      "description": "This module provides operations for constructing and manipulating quoted Ltac2 expressions with anti-quotation support, enabling the representation of tactic syntax in a structured, annotated form. It works with Coq's tactic and term syntax structures (e.g., `constr_expr`, identifiers, hypotheses) to encode constructs like bindings, introduction patterns, rewriting directives, and assertion statements. These capabilities are specifically used to define notation scopes that allow dynamic embedding of terms or hypotheses into tactic expressions, facilitating flexible proof script customization and metaprogramming tasks.",
      "description_length": 625,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2core",
      "library": "ltac2_plugin",
      "description": "The module defines core tactics and data structures for Ltac2, centered on type-safe manipulation of extensible maps and sets via the `map_tag` type. It supports registration of map and set implementations for various key types\u2014such as identifiers, integers, and Coq constants\u2014and provides operations like `register_map` for associating types with their implementations. This enables efficient lookups, transformations, and stateful traversals over structured proof data, particularly when combined with submodules that implement monadic folds, tactic expression mappings, and set operations. Specific capabilities include managing tactic variable bindings, transforming map entries with preserved sharing, and performing set operations like union and membership testing over dynamic collections.",
      "description_length": 796,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2interp",
      "library": "ltac2_plugin",
      "description": "This module evaluates Ltac2 expressions within a given environment, mapping identifiers to values and supporting operations like tactic application and global constant evaluation. It works with environments, syntactic tactic expressions, and values, providing functions to interpret or evaluate them into Coq tactics. Concrete use cases include executing Ltac2 scripts during proof construction and resolving global tactic references at runtime.",
      "description_length": 445,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2match",
      "library": "ltac2_plugin",
      "description": "This module implements pattern matching logic for Ltac2 goal matching, handling both hypothesis and conclusion patterns. It processes match rules against a goal's context and conclusion using pattern variables and environment data. Use cases include implementing Ltac2 tactics that inspect or transform proof goals based on structured patterns.",
      "description_length": 344,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2intern",
      "library": "ltac2_plugin",
      "description": "This module provides utilities for processing Ltac2 expressions during tactic elaboration, focusing on type-checking, substitution, and globalizing operations. It manipulates Ltac2 syntax trees (`raw_tacexpr`, `glb_tacexpr`) and type environments, enforcing purity checks, subtyping, and argument validation while handling identifiers and type schemes. Its functionality supports tactic development workflows where environment state (e.g., `Genintern.Store.t`) must be filtered or LTAC2-specific context removed during execution.",
      "description_length": 529,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2types",
      "library": "ltac2_plugin",
      "description": "This module defines data structures and types used to represent proof manipulation operations in a tactic system, such as bindings, destruction arguments, introduction patterns, and rewriting directives. It works with Coq's tactic primitives like `EConstr.t`, `Proofview.tactic`, and identifiers, enabling precise control over hypothesis manipulation, induction, and rewriting. Concrete use cases include building and deconstructing logical assertions, specifying induction clauses, and controlling tactic application through explicit or implicit bindings.",
      "description_length": 556,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2ffi",
      "library": "ltac2_plugin",
      "description": "This module enables bidirectional conversion between OCaml values and Ltac2's `valexpr` type, supporting both primitive types (integers, strings, booleans) and structured data like Coq expressions, exceptions, tuples, and dynamic values with semantic tags. It facilitates foreign function interface (FFI) interactions by marshaling complex Coq types (e.g., `EConstr.t`, `Pattern.constr_pattern`, `Names.Constant.t`) and Ltac2 constructs into a shared representation, while providing combinators for custom transformations and typed embeddings. Key use cases include interoperating with Ltac2's dynamic typing system, embedding Coq-specific structures into Ltac2 values, and safely converting between OCaml and Ltac2 representations for functions, blocks, and tagged data.",
      "description_length": 771,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_plugin.Tac2val",
      "library": "ltac2_plugin",
      "description": "This module represents and manipulates Ltac2 values with explicit handling of closures, structured blocks, and dynamic data, enabling operations like closure creation, application, and arity management. It directly supports working with expressions modeling integers, strings, tuples, and effectful functions, allowing for the implementation of Ltac2 function abstractions and evaluation of tactic expressions. The child module provides low-level access to Ltac2 values, enabling inspection and construction of their internal structure, such as checking types or modifying compound fields. Together, they support managing delayed computations and building custom tactic logic for proof automation and script composition.",
      "description_length": 720,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin.Tac2externals",
      "library": "ltac2_plugin",
      "description": "This module defines external tactics in the tactic monad by specifying their behavior and return types through representations. It works with tactic expressions, environments, and goals, enabling precise control over tactic execution context. Concrete use cases include defining custom tactics that integrate directly with proof scripts, such as goal-dependent computations or environment-aware operations.",
      "description_length": 406,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_plugin",
      "library": "ltac2_plugin",
      "description": "This module provides a comprehensive framework for building, manipulating, and executing Ltac2 tactics within Coq's proof environment. It centers around Ltac2's core data types\u2014tactic expressions, type schemes, dynamic values, and syntactic constructs\u2014supporting operations like type-safe argument handling, pattern matching, quotation, and evaluation. Users can define and compose tactics that inspect and transform proof goals, manage typed bindings and environments, and embed Ltac2 expressions into Coq terms with hygiene. Specific applications include implementing domain-specific notations, automating proof patterns through rewriting and induction, and extending Coq's tactic language with custom, type-preserving primitives.",
      "description_length": 732,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_ltac1_plugin.Tac2quote_ltac1",
      "library": "ltac2_ltac1_plugin",
      "description": "This module provides quotation tags for embedding Ltac1 abstract syntax trees as tactics or value-returning expressions in Ltac2. It operates on parsed and globally resolved Ltac1 tactic expressions paired with identifier lists. Concrete use cases include metaprogramming tasks that generate or manipulate Ltac1 code within Ltac2, such as writing Ltac2 functions that construct Ltac1 tactics dynamically.",
      "description_length": 404,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac2_ltac1_plugin.Tac2core_ltac1",
      "library": "ltac2_ltac1_plugin",
      "description": "This module handles the embedding and evaluation of Ltac2 expressions within Ltac1, supporting the interning of quoted Ltac2 code into Ltac1 values and managing variable bindings during the transition. It defines specialized argument types for parsing and interpreting Ltac2 quotations in Ltac1 contexts, enabling the use of Ltac2 closures that interface with Ltac1's tactic system. Concrete use cases include writing Ltac1 tactics that invoke or manipulate Ltac2-defined logic, such as composing hybrid tactics or extending Ltac1 with Ltac2-based extensions.",
      "description_length": 559,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac2_ltac1_plugin",
      "library": "ltac2_ltac1_plugin",
      "description": "This module bridges Ltac1 and Ltac2 by enabling bidirectional embedding of tactics and expressions, allowing Ltac2 to construct and manipulate Ltac1 code and vice versa. It introduces quotation mechanisms and binding management to handle cross-language evaluation, supporting dynamic tactic generation and hybrid tactic composition. Key operations include parsing and resolving Ltac1 expressions within Ltac2, interning Ltac2 code into Ltac1 values, and managing variable scopes during transitions. Examples include writing Ltac2 functions that generate Ltac1 tactics at runtime or embedding Ltac2 logic into Ltac1 tactics for extended functionality.",
      "description_length": 650,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.IMap.Smart",
      "library": "micromega_core_plugin",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve sharing when possible, operating on immutable maps from the `IMap` module. It is useful when transforming map values while avoiding unnecessary allocations, particularly in performance-sensitive contexts where structural sharing can reduce memory usage. Concrete use cases include efficiently updating large maps in symbolic computation or constraint solving tasks.",
      "description_length": 439,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.IMap.Monad",
      "library": "micromega_core_plugin",
      "description": "This module provides monadic traversal and transformation operations for immutable maps. It supports folding over key-value pairs with monadic actions, applying functions to entries, and building new maps through monadic computations. Concrete use cases include stateful transformations of map entries, accumulating results during traversal, and integrating map operations with effectful computations.",
      "description_length": 401,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.NumCompat.Q.Notations",
      "library": "micromega_core_plugin",
      "description": "This module defines arithmetic and comparison operations for rational numbers represented by the `Q.t` type. It includes functions for addition, subtraction, multiplication, division, and all standard comparison operators. These operations enable precise numerical computations and are used in contexts requiring exact fractional arithmetic, such as formal verification or symbolic mathematics.",
      "description_length": 394,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.ISet",
      "library": "micromega_core_plugin",
      "description": "This module implements integer set operations with functions for union, intersection, difference, and element manipulation, alongside utilities for iteration, filtering, and transformation. It works with sets of integers (`t`) and sequences (`Seq.t`), supporting conversions between these structures and enabling imperative-style updates or functional transformations. Use cases include symbolic computation, constraint solving, and scenarios requiring efficient set-based data manipulation, such as formal verification workflows where integer sets model logical states or constraints.",
      "description_length": 585,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.Hash",
      "library": "micromega_core_plugin",
      "description": "This module implements equality checks and hash functions for various algebraic and arithmetic types, including operations (`op1`, `op2`), numeric types (`z`, `q`, `positive`), and structured types like polynomials and pairs. It supports precise structural comparisons and efficient hashing for use in data structures like hash tables. Concrete use cases include comparing and hashing expressions in formal verification tasks involving arithmetic reasoning.",
      "description_length": 457,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.NumCompat.QArith-Notations",
      "library": "micromega_core_plugin",
      "description": "This module provides arithmetic and comparison operations for rational numbers, including addition, subtraction, multiplication, division, and equality and ordering checks. It works directly with the `t` type representing rational numbers. Concrete use cases include precise numerical computations where exact fractions are required, such as symbolic mathematics or financial calculations.",
      "description_length": 389,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.CamlToCoq",
      "library": "micromega_core_plugin",
      "description": "This module converts OCaml numeric types to their Coq equivalents, handling integers, natural numbers, and rational numbers. It supports conversions from `int` and arbitrary-precision integers (`Z.t`) to Coq's `positive`, `nat`, `z`, and `q` types. Use this when translating arithmetic expressions from OCaml to Coq for proof generation or formal verification tasks.",
      "description_length": 366,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_core_plugin.NumCompat.Q",
      "library": "micromega_core_plugin",
      "description": "This module provides exact arithmetic and comparisons for rational numbers using the `Q.t` type, supporting addition, subtraction, multiplication, division, and all standard comparisons. Its operations are ideal for applications requiring precise fractional calculations, such as symbolic math or formal verification. The module integrates submodules that extend its core functionality, offering additional utilities and structured operations on rational numbers. Together, they form a comprehensive interface for both basic and advanced rational number manipulations.",
      "description_length": 568,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.IMap",
      "library": "micromega_core_plugin",
      "description": "This module implements an immutable ordered map structure for integer keys, supporting standard operations like insertion, deletion, and lookup, along with advanced transformations such as merging, splitting, and range filtering. It provides efficient traversal, stateful transformations through fold-map hybrids, and conversion to lists and sets, making it suitable for symbolic computation and interval-based processing. The module includes submodules that optimize `map` and `mapi` for sharing preservation, reducing memory usage during large-scale transformations, and enabling monadic traversal for effectful computations, such as stateful updates and result accumulation. Examples include efficiently updating constraint sets and traversing maps while logging or accumulating intermediate values.",
      "description_length": 802,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Micromega.Pos",
      "library": "micromega_core_plugin",
      "description": "This module defines a type `mask` that represents the sign of a value, with constructors indicating whether the value is zero, positive, or negative. It provides operations to compare and manipulate these sign values, primarily used in arithmetic reasoning within proof assistants. The module is useful in formal verification tasks where precise sign analysis of expressions is required.",
      "description_length": 387,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Micromega.N",
      "library": "micromega_core_plugin",
      "description": "This module provides a function `of_nat` that converts values from the `nat` type (natural numbers) into the `n` type, which represents integers. It is used to bridge arithmetic operations between natural numbers and integers within the Micromega framework. A concrete use case is translating numeric constraints from Coq's natural number representation into a form suitable for integer arithmetic solving.",
      "description_length": 406,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.NumCompat.ZArith",
      "library": "micromega_core_plugin",
      "description": "This module implements arithmetic operations on an arbitrary-precision integer type `t`, including basic operations like addition, subtraction, multiplication, division, and more advanced functions such as greatest common divisor (gcd), least common multiple (lcm), and modular exponentiation. It supports numeric computations requiring exact integer handling, such as cryptographic algorithms, symbolic mathematics, or precise financial calculations. Functions like `quomod`, `gcd`, and `power_int` enable efficient implementation of number-theoretic routines and exact arithmetic manipulations.",
      "description_length": 596,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.McPrinter",
      "library": "micromega_core_plugin",
      "description": "This module provides functions to print arithmetic values and proofs to an output channel. It supports natural numbers, positive numbers, integers, polynomials, and proof terms from the `Mc` namespace. These functions are used to serialize arithmetic expressions and their proofs for debugging or external consumption.",
      "description_length": 318,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.CoqToCaml",
      "library": "micromega_core_plugin",
      "description": "This module converts Coq numeric and index types to OCaml equivalents, handling big integers, rationals, and various integer-like types. It provides direct mappings from Coq's `z`, `q`, `positive`, `n`, and `nat` to OCaml's `Big_int`, `Q`, and `int`. Useful for translating Coq expressions into OCaml values during proof processing or code extraction tasks.",
      "description_length": 357,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.NumCompat.QArith-Z",
      "library": "micromega_core_plugin",
      "description": "This module implements arithmetic operations and number-theoretic functions over arbitrary-precision integers (`Z.t`), including basic operations like addition, subtraction, multiplication, division, and modulus, as well as advanced functions for greatest common divisor (gcd), least common multiple (lcm), and integer exponentiation. It supports concrete computations involving large integers with exact precision, making it suitable for cryptographic calculations, symbolic mathematics, and formal verification tasks requiring exact integer arithmetic. The module also provides comparison, sign detection, and string conversion for debugging and output purposes.",
      "description_length": 664,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_core_plugin.NumCompat.QArith",
      "library": "micromega_core_plugin",
      "description": "This module enables arithmetic with rational numbers, modular calculations, and rounding through a numeric type based on `Z.t` integers, supporting exponentiation and conversions to strings and floats. It serves symbolic computation, precise algorithm implementation, and scenarios requiring exact numerical representation or cross-type data conversion.",
      "description_length": 353,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.Tag",
      "library": "micromega_core_plugin",
      "description": "This module implements a simple integer-based tag system with operations to create, compare, and manipulate tags. It provides functions to convert tags to and from integers, generate the next tag in sequence, and determine the maximum of two tags. These tags are used to manage unique identifiers in contexts requiring ordered, incremental labeling.",
      "description_length": 349,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.NumCompat.Z",
      "library": "micromega_core_plugin",
      "description": "This module implements arbitrary-precision integer arithmetic with operations including addition, subtraction, multiplication, division, modulus, greatest common divisor (gcd), least common multiple (lcm), and exponentiation. It works with the abstract type `t` representing integers and provides constants like zero, one, and two. Use cases include precise numerical computations in formal verification, symbolic mathematics, and constraint solving where floating-point precision is insufficient.",
      "description_length": 497,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils.Cmp",
      "library": "micromega_core_plugin",
      "description": "This module defines functions for comparing lists in different ways. `compare_list` compares two lists element-wise using a provided comparison function, while `compare_lexical` performs lexicographical comparison of a list of thunks returning integers. It is used to implement ordered comparisons for structured data like tuples or sequences in formal verification tasks.",
      "description_length": 372,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Micromega.Z",
      "library": "micromega_core_plugin",
      "description": "This module supports arithmetic operations, comparisons, and division algorithms on a custom integer type (`z`), including Euclidean division, greatest common divisors, and conversions to natural numbers. It provides precise handling of both general integers and positive-only values through specialized functions like `pos_sub` and `pos_div_eucl`. These capabilities are tailored for formal verification tasks requiring rigorous integer manipulation, such as proving arithmetic properties or implementing verified mathematical algorithms.",
      "description_length": 539,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_core_plugin.Sos",
      "library": "micromega_core_plugin",
      "description": "This module implements polynomial manipulation and sum-of-squares (SOS) decomposition for use in formal verification tasks. It provides operations such as polynomial multiplication, exponentiation, negation, and conversion between polynomials and terms, along with functions to generate and verify SOS proofs. It is used in automated reasoning about real-valued constraints by constructing and checking Positivstellensatz certificates.",
      "description_length": 435,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_core_plugin.Micromega",
      "library": "micromega_core_plugin",
      "description": "This module combines polynomial manipulation with logical transformations to support automated theorem proving over arithmetic constraints. It provides core data types like `pol` for polynomials, `tFormula` and `nFormula` for logical expressions, and `z` and `q` for integer and rational arithmetic, enabling operations such as addition, exponentiation, CNF conversion, and sign analysis. Submodules enhance these capabilities with sign tracking via `mask`, natural-to-integer conversion through `of_nat`, and precise integer arithmetic on `z`, allowing tasks like translating Coq numeric constraints into integer expressions and performing verified arithmetic reasoning.",
      "description_length": 671,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.NumCompat",
      "library": "micromega_core_plugin",
      "description": "This module supports precise numerical computations with integers and rational numbers through its submodules Z and Q. It enables exact arithmetic operations like addition, multiplication, and division, along with advanced functions such as gcd, lcm, and modular exponentiation on arbitrary-precision integers, and comparisons and conversions on rational numbers. Users can perform symbolic calculations, implement cryptographic algorithms, or handle financial computations requiring exact fractional or integer representations. Specific operations include `Z.gcd` for integer greatest common divisors, `Q.add` for rational addition, and `Z.power_int` for exponentiation with integer exponents.",
      "description_length": 694,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Sos_lib",
      "library": "micromega_core_plugin",
      "description": "This module provides operations for function manipulation using a custom mapping type that supports domain",
      "description_length": 106,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Sos_types",
      "library": "micromega_core_plugin",
      "description": "This module defines algebraic expressions and proof terms used in Satisfiability Modulo Theories (SMT) solvers, specifically for handling arithmetic constraints. It includes data types for terms (constants, variables, arithmetic operations) and positivstellensatz proof structures (axioms, rational comparisons, monoids, and combinations). These are used to construct and manipulate logical proofs in automated theorem proving tasks involving polynomial arithmetic.",
      "description_length": 465,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin.Mutils",
      "library": "micromega_core_plugin",
      "description": "This module provides core utilities for symbolic computation and data transformation, centered around integer sets, maps, and tag-based identifiers, with support for comparison, hashing, and serialization. It offers data structures like immutable integer maps and sets with operations for efficient traversal, merging, and transformation, alongside utilities for comparing and hashing complex arithmetic types, generating tags, and converting between OCaml and Coq numeric representations. You can use it to manipulate constraint sets, rewrite terms, serialize proofs, or manage unique identifiers in formal verification workflows. Submodules optimize map operations for memory efficiency, enable effectful traversals, and provide precise conversions and comparisons for arithmetic expressions.",
      "description_length": 794,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_core_plugin",
      "library": "micromega_core_plugin",
      "description": "This module provides foundational components for formal verification and automated reasoning involving arithmetic constraints. It centers on data types like `pol` for polynomials, `z` and `q` for exact integer and rational arithmetic, and `tFormula` for logical expressions, supporting operations such as polynomial multiplication, sign analysis, CNF conversion, and SOS decomposition. Users can construct and verify Positivstellensatz proofs, translate Coq constraints into arithmetic expressions, or perform exact symbolic computations using verified arithmetic. Specific capabilities include `Z.gcd` for integer GCD, `Q.add` for rational addition, and `Z.power_int` for exponentiation, alongside structures for term rewriting, proof serialization, and constraint set manipulation.",
      "description_length": 783,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dyn.Make.Map",
      "library": "rocq-runtime.clib",
      "description": "This module implements a type-safe map from type tags to values parameterized by the tag type, enabling heterogeneous storage and retrieval. It supports operations like insertion, lookup, modification, and filtering of values associated with type tags, with strong typing guarantees. Concrete use cases include managing configuration settings, dynamic dispatch tables, and heterogeneous caches where values are tied to specific type keys.",
      "description_length": 438,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.Map.Monad",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic traversal and transformation operations over finite maps with string keys. It supports functions like `fold`, `mapi`, `fold_left`, and `fold_right`, which allow accumulating values or mapping with effects captured by the monad `M`. These operations are useful for processing map entries sequentially while threading monadic state, such as handling I/O or error propagation during transformations.",
      "description_length": 425,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CString.Map.Smart",
      "library": "rocq-runtime.clib",
      "description": "Implements efficient transformations on finite maps with string keys while preserving structural sharing. It provides `map` and `mapi` functions that apply a given function to each value or key-value pair, returning a new map with updated values. Useful when updating specific entries in a map without reallocating the entire structure, such as modifying configuration values or caching intermediate results.",
      "description_length": 408,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dyn.Make.HMap",
      "library": "rocq-runtime.clib",
      "description": "This module transforms and filters maps with dynamically typed values using two distinct value representations. It supports remapping values from one typed representation to another and selecting subsets of entries based on typed value predicates. Concrete use cases include converting between different serialization formats and pruning maps based on typed value properties.",
      "description_length": 375,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dyn.Make.Easy",
      "library": "rocq-runtime.clib",
      "description": "This module simplifies creating and working with dynamically typed values using runtime tags. It provides functions to inject values into a universal type and project them back using type tags, enabling type-safe dynamic typing. Use cases include handling heterogeneous collections and implementing plugins or configuration systems where types are determined at runtime.",
      "description_length": 370,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CMap.Make.Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized `map` and `mapi` functions that transform values in a map while attempting to preserve structural sharing to improve performance. It operates on map data structures where keys and values are immutable. These functions are useful when applying transformations to large maps without unnecessary duplication of unchanged subtrees.",
      "description_length": 358,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HMap.Make.Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides hash map operations optimized for key types with efficient hash and equality functions. It supports standard map manipulations like insertion, lookup, and traversal, while preserving structural sharing during transformations. Concrete use cases include managing dynamic sets of uniquely identified entities, such as tracking active user sessions or caching computation results by hashed keys.",
      "description_length": 413,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HMap.Make.Set",
      "library": "rocq-runtime.clib",
      "description": "This module implements purely functional set operations for key-based elements, including membership checks, insertion, deletion, and set algebra (union, intersection, difference). It works with an abstract set",
      "description_length": 210,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PolyMap.Make.OneTag",
      "library": "rocq-runtime.clib",
      "description": "This module defines a polymorphic map specialized for a single tag type `a`, supporting operations to bind, lookup, and traverse key-value pairs associated with the tag `T`. It works with tagged data structures where each key is tied to the unique tag `T`, ensuring type-safe access and manipulation. Concrete use cases include managing heterogeneous maps with strict tag-based key scoping, such as configuration stores or typed environment contexts.",
      "description_length": 450,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PolyMap.Make.Map",
      "library": "rocq-runtime.clib",
      "description": "This module implements a polymorphic map with operations to add, find, check membership, and modify values associated with typed tags. It works with arbitrary value types through the `V` module and supports tag-based keys with type-safe access. Concrete use cases include managing heterogeneous configurations or state where different types are stored and retrieved by unique tag identifiers.",
      "description_length": 392,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Monad.Make.List",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic list operations including mapping, filtering, and left/right folds with explicit control over evaluation order and tail recursion. It works with lists and monadic values, enabling effectful traversal and transformation of list elements. Concrete use cases include processing sequences of effectful computations, accumulating results from list elements with side effects, and validating or transforming structured data like trees or records in a monadic context.",
      "description_length": 490,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CArray.Fun1.Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized versions of array operations that avoid closure allocation by taking an additional environment argument directly. It works with arrays and functions that require an environment parameter alongside elements. Use this to improve performance in tight loops or critical sections where closure creation overhead matters.",
      "description_length": 346,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Int.Map.Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized `map` and `mapi` functions that operate on integer-keyed maps, preserving structural sharing during transformations. It works specifically with `Int.Map.t`, a map structure where keys are native integers. These functions are useful when efficiently updating mapped integer-keyed data structures, such as sparse arrays or integer-indexed symbol tables, without unnecessary memory allocation.",
      "description_length": 421,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HMap.Make.Monad",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic variants of common hash map operations, specifically `fold` and `mapi`, which allow for effectful computations during iteration. It works with purely functional hash maps where keys have a hash implementation. Concrete use cases include accumulating results with effects like IO or error handling, or transforming values while preserving the hash map structure.",
      "description_length": 390,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSet.Make.List",
      "library": "rocq-runtime.clib",
      "description": "Performs union operations on a list of sets, combining all elements into a single set. Works with lists of elements that form sets, ensuring uniqueness in the result. Useful for aggregating multiple disjoint sets into one, such as merging results from parallel computations.",
      "description_length": 274,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CMap.Make.Monad",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic traversal and transformation operations over maps, including `fold`, `mapi`, `fold_left`, and `fold_right`. It works with map structures where keys and values are processed within a monadic context `M`. Concrete use cases include accumulating results across map entries with effects like state, error handling, or asynchronous computation, and transforming map values while propagating monadic side-effects.",
      "description_length": 436,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Int.Map.Monad",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic traversal and transformation functions for integer-keyed maps, including `fold`, `mapi`, `fold_left`, and `fold_right`. It operates on `Int.Map.t` structures, applying monadic actions over key-value pairs. Concrete use cases include accumulating results across a map with monadic effects or transforming map values while sequencing monadic operations.",
      "description_length": 380,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.Set.List",
      "library": "rocq-runtime.clib",
      "description": "Performs set union operations on a list of string sets. It combines multiple string sets into a single set containing all unique elements. Useful for aggregating results from multiple set-based queries or filters.",
      "description_length": 213,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PolyMap.Make.MapS",
      "library": "rocq-runtime.clib",
      "description": "This module implements a polymorphic map with first-class support for typed keys and values. It provides operations to add, find, check membership, and modify entries using strongly typed tags as keys. Concrete use cases include managing heterogeneous configurations, storing tagged runtime values, and handling extensible records with type-safe access.",
      "description_length": 353,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CMap.ExtS-Monad",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic traversal and transformation functions for associative containers, including `fold`, `mapi`, `fold_left`, and `fold_right`, which operate on key-value pairs. It works with map-like data structures parameterized over a key type and value type, supporting monadic effects through the `M` module. Concrete use cases include accumulating results across a map with effectful operations, transforming values while preserving keys, and performing effectful left or right folds over the structure.",
      "description_length": 518,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.ExtS-Map-Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve structural sharing when transforming values in a map. It works with immutable map data structures where keys are of type `Map.key` and values are of a generic type `'a`. These functions are useful when performing value transformations on large maps while minimizing memory allocation and maintaining performance.",
      "description_length": 386,
      "index": 89,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Trie.Make",
      "library": "rocq-runtime.clib",
      "description": "This module implements a trie structure where keys are lists of labels and values are stored at the end nodes. It supports operations to add or remove values at label paths, retrieve subtries, and iterate over all stored values with their paths. It is useful for applications like prefix-based routing tables or hierarchical data indexing.",
      "description_length": 339,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.S",
      "library": "rocq-runtime.clib",
      "description": "This module provides a comprehensive set of operations for creating, transforming, and analyzing immutable byte sequences, with a focus on index-based manipulation, character-level processing, and binary data interpretation. It supports operations ranging from basic string construction and decomposition (e.g., concatenation, substring extraction) to advanced transformations (e.g., case conversion, folding, escaping) and low-level parsing (e.g., UTF-8 decoding, integer extraction from byte layouts). Key use cases include text normalization, protocol message parsing, binary file format handling, and sequence-based data manipulation where precise control over byte-level representation and character encoding is required.",
      "description_length": 726,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HMap.Make",
      "library": "rocq-runtime.clib",
      "description": "This module enables efficient, purely functional hash map operations using key-based hashing for fast lookups and transformations. It provides core functions for insertion, deletion, folding, and merging, optimized for scenarios like tracking unique entities or caching results by hashed keys. The design supports structural sharing and immutability, with submodules adding set-like operations and monadic variants for effectful computations during iteration. Specific use cases include managing active sessions, combining maps with set algebra, or accumulating results with IO effects.",
      "description_length": 586,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CList.MonoS",
      "library": "rocq-runtime.clib",
      "description": "This module implements operations for working with lists of a single element type, including equality checks, membership tests, association list lookups, and removal. It supports data structures like lists of elements and association lists where elements act as keys or values. Use this module for managing key-value pairs in list form, checking list equality, or efficiently querying and modifying association lists.",
      "description_length": 417,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Heap.Ordered",
      "library": "rocq-runtime.clib",
      "description": "Implements comparison-based ordering for heap elements using a total ordering function. Works with any data type that supports comparison operations, typically integers, floats, or custom types with defined comparison logic. Enables efficient insertion, extraction, and ordering of elements in priority queues and heap-based algorithms.",
      "description_length": 336,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unionfind.MapS",
      "library": "rocq-runtime.clib",
      "description": "Implements a map structure with efficient key-value storage and retrieval, supporting operations like insertion, lookup, membership checks, and folding over key-value pairs. It works with arbitrary key types and associated values, using the module's defined key type for comparisons. Useful for managing dynamic associations between identifiers and data in applications like symbol tables or configuration settings.",
      "description_length": 415,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SList.Smart",
      "library": "rocq-runtime.clib",
      "description": "Performs transformations and accumulations over sparse lists, applying functions only to non-default elements. Works directly with `'a SList.t`, preserving sparsity during operations like `map` and `fold_left_map`. Useful for efficiently processing large sparse data structures where most values are default, such as sparse vectors or matrices.",
      "description_length": 344,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSet.ExtS-List",
      "library": "rocq-runtime.clib",
      "description": "Performs union operations on a list of sets, combining all elements into a single set. Works with lists of elements that can be used to construct or modify sets. Useful for aggregating multiple sets into one when processing collections of unique items.",
      "description_length": 252,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSig.SetS",
      "library": "rocq-runtime.clib",
      "description": "This module implements efficient set operations for ordered elements, supporting creation, membership checks, union, intersection, and difference alongside queries like cardinality, extremal element retrieval, and subset relationships. It works with sets of ordered values, sequences, and lists, leveraging total ordering to optimize performance. Typical applications include managing sorted collections, combining or comparing sets of unique elements, and converting sequential data into structured sets.",
      "description_length": 505,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Int.List",
      "library": "rocq-runtime.clib",
      "description": "This module extends native integer operations to work with lists, providing membership checks, association lookups, and association removals. It handles standard list types like `int list` and tuples of the form `(int * 'a) list`. Use this module for tasks like checking if an integer exists in a list, retrieving associated values from key-value pairs, or filtering out specific associations.",
      "description_length": 393,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CString.ExtS-Map-Monad",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic traversal operations over map structures, including `fold`, `mapi`, `fold_left`, and `fold_right`, which apply functions across key-value pairs and accumulate results within a monadic context. It works with `Map.t` data structures, where keys conform to the `Map.key` type and values are monad-wrapped. Concrete use cases include transforming and aggregating map values while handling effects like state, error handling, or asynchronous operations through the monad `M`.",
      "description_length": 499,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSet.ExtS",
      "library": "rocq-runtime.clib",
      "description": "This module provides operations for creating and manipulating functional, immutable sets with elements of type `elt`, supporting standard set algebra (union, intersection, difference), membership testing, and higher-order transformations (filtering, folding, partitioning). It includes utilities for querying set properties (cardinality, disjointness), converting sets to sequences or lists, and constructing sets from sequential data, making it suitable for applications like data analysis, algorithmic set manipulations, and handling dynamic collections with immutable functional semantics.",
      "description_length": 592,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CArray.Fun1",
      "library": "rocq-runtime.clib",
      "description": "This module offers higher-order array operations like `map`, `iter`, and `iter2` that take an additional parameter to avoid closure allocation, improving performance in critical code sections. It directly supports functions that accept an environment argument alongside array elements, enabling efficient iteration and transformation without repeated closure creation. Submodules extend this functionality with optimized variants for specific use cases involving environments and element pairs. For example, you can use `iter` to traverse an array with a function that takes both an environment and an element, reducing overhead in performance-sensitive loops.",
      "description_length": 660,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Predicate.OrderedType",
      "library": "rocq-runtime.clib",
      "description": "This module defines a type `t` and a comparison function `compare` that establishes a total order on values of type `t`. It is used to determine the ordering of elements in sets created by the `Make` functor. The comparison function must return a negative, zero, or positive integer depending on whether the first argument is less than, equal to, or greater than the second.",
      "description_length": 374,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CMap.ExtS-Set",
      "library": "rocq-runtime.clib",
      "description": "This module provides operations for constructing and manipulating sets, including membership checks, algebraic operations (union, intersection, difference), and transformations via iteration or folding. It works with a set type (`t`) containing elements of a specified type (`elt`), supporting conversions to and from lists and sequences. Typical applications include deduplicating elements, performing set algebra, and efficiently querying set properties like cardinality or",
      "description_length": 475,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "PolyMap.Make",
      "library": "rocq-runtime.clib",
      "description": "This module creates polymorphic maps indexed by tags from a specified tag module, enabling type-safe access to heterogeneous data through operations like binding, lookup, and traversal. It supports constructing tagged values, comparing them across types, and converting them to their underlying tags, making it ideal for configuration systems and extensible records. Submodules refine this functionality by specializing for single tag types, supporting arbitrary value types via a `V` module, and offering first-class typed key-value management. Specific use cases include typed environment contexts, heterogeneous state storage, and runtime-tagged value handling.",
      "description_length": 664,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CMap.MonadS",
      "library": "rocq-runtime.clib",
      "description": "This module implements monadic operations for a map structure, supporting value injection and chaining computations with `return` and bind (`>>=`). It works with map types where values are wrapped in a monadic context, enabling sequential composition of functions that produce map values. Use it to build complex map transformations from smaller, composable monadic steps, such as conditional insertions or value-dependent lookups.",
      "description_length": 431,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Memprof_coq.Resource_bind",
      "library": "rocq-runtime.clib",
      "description": "This module enables RAII-style resource management using the `let&` binding, ensuring resources are automatically cleaned up at the end of their scope. It works with functions and values that represent scoped resource usage, such as file handles or memory allocations. A concrete use case is managing a file resource, where opening a file with `let&` ensures it is closed automatically after processing, even if an exception occurs.",
      "description_length": 432,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CArray.ExtS",
      "library": "rocq-runtime.clib",
      "description": "This module offers comprehensive array manipulation capabilities, encompassing creation (e.g., `make`, `init`, `make_matrix`), transformation (e.g., `map`, `fold_left`, `mapi`), and index-aware operations (e.g., `iteri`, `blit`). It supports arrays of arbitrary type `'a`, including multi-dimensional and jagged arrays, with functions for slicing, transposition, and element-wise processing across multiple arrays. Key use cases include numerical computations requiring matrix operations, data pipeline implementations needing filtering or uniqueness checks, and algorithms demanding precise traversal control or in-place modifications with index tracking.",
      "description_length": 656,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CString.ExtS-Map",
      "library": "rocq-runtime.clib",
      "description": "This module provides functional map manipulation operations for string-keyed polymorphic maps (`'a Map.t`), supporting creation, insertion, modification, and ordered traversal with state accumulation. It offers advanced transformations like symmetric difference folding, range-based filtering, and structural property computation, optimized for performance through structural sharing. Use cases include dynamic configuration management, hierarchical data processing, and algorithms requiring efficient key-based aggregation or ordered traversal with stateful transformations.",
      "description_length": 575,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSet.Make",
      "library": "rocq-runtime.clib",
      "description": "This module creates and manipulates immutable sets with elements ordered by a provided comparison function, supporting core operations like membership checks, union, intersection, and difference, along with transformations via folds and filters. It works with comparable types, offers conversions to and from lists and sequences, and includes utilities for min/max queries and disjointness checks. The union operation on a list of sets merges multiple sets into one, ensuring uniqueness and enabling efficient aggregation of results from parallel computations. Example uses include managing unique collections, implementing set algebra, and processing sequential data with ordered traversal requirements.",
      "description_length": 704,
      "index": 110,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CString.ExtS-List",
      "library": "rocq-runtime.clib",
      "description": "This module implements association lists using strings as keys, providing operations to check equality, membership, and association presence. It supports retrieving values by key, removing key-value pairs, and checking for symmetric associations in lists of pairs. Use cases include managing configuration settings, mapping identifiers to values in interpreters, and handling key-based lookups in data processing pipelines.",
      "description_length": 423,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Int.PMap",
      "library": "rocq-runtime.clib",
      "description": "This module implements a map structure for integer keys using persistent arrays and a binary tree, enabling O(1) access for existing keys and logarithmic time insertion/deletion. It is optimized for contiguous, zero-starting key ranges where most operations are lookups rather than modifications. Use cases include efficiently managing sparse integer-indexed data with frequent read operations, such as tracking dynamic state in algorithms or caching results by integer identifiers.",
      "description_length": 482,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Diff2.S",
      "library": "rocq-runtime.clib",
      "description": "Implements Eugene Myers' O(ND) difference algorithm for computing diffs and longest common subsequences between two sequences. Provides functions to compute the LCS, generate edit scripts, and fold or iterate over edits without intermediate list allocation. Works directly on sequences of arbitrary elements with customizable equality comparison. Useful for version control systems, text comparison tools, and data synchronization logic.",
      "description_length": 437,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSet.Hashcons",
      "library": "rocq-runtime.clib",
      "description": "This module implements hash-consing for sets using a custom hash function and equality. It provides operations to generate a hash-consing table, apply hash-consing to a set, and retrieve statistics on the table's usage. The module works with sets built from a given element type and a comparison function, ensuring efficient memory usage and equality checks for immutable sets.",
      "description_length": 377,
      "index": 114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CMap.UExtS-Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized `map` and `mapi` functions that transform values in a map while attempting to preserve structural sharing to improve performance. It operates specifically on map data structures where keys and values are immutable. These functions are useful when applying transformations to large maps where maintaining efficiency through shared structure is critical.",
      "description_length": 383,
      "index": 115,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SList.Skip",
      "library": "rocq-runtime.clib",
      "description": "This module provides operations to process sparse lists by skipping default values. It includes functions for iteration, mapping, folding, and checking conditions across non-default elements. Use it to efficiently traverse or transform sparse lists without processing unused default entries.",
      "description_length": 291,
      "index": 116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Monad.ListS",
      "library": "rocq-runtime.clib",
      "description": "This module implements list traversal and transformation functions with left-to-right and right-to-left evaluation orders, returning results in a monadic context. It supports operations like mapping, filtering, folding, and iteration over single and paired lists, handling effects such as error propagation or state changes. Concrete use cases include processing sequences of monadic computations, accumulating results from effectful list transformations, and validating and combining paired lists under monadic constraints.",
      "description_length": 524,
      "index": 117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dyn.MapS",
      "library": "rocq-runtime.clib",
      "description": "This module implements a dynamic map structure that supports key-value operations with heterogeneous types. It provides functions to add, remove, modify, and query values associated with typed keys, along with filtering and transformation capabilities over the map's contents. Use cases include managing configuration settings with mixed types, dynamically scoped variables, or attribute-based data processing where type safety is maintained per key.",
      "description_length": 450,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Memprof_coq.Masking",
      "library": "rocq-runtime.clib",
      "description": "Handles resource management by acquiring a resource, applying a scoped operation, and releasing the resource, ensuring proper cleanup. Works with any resource type `'a` and associated transformation functions. Useful for managing external resources like file handles or network connections where setup and teardown are required.",
      "description_length": 328,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Memprof_coq.Thread_map",
      "library": "rocq-runtime.clib",
      "description": "This module provides thread-local storage with scoped value binding, allowing values to be associated with individual threads during specific execution scopes. It supports creating empty maps, temporarily binding values to threads, and retrieving the current thread's bound value. Use cases include managing per-thread state in asynchronous applications, such as tracking request-specific data across function calls.",
      "description_length": 416,
      "index": 120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CString.Set",
      "library": "rocq-runtime.clib",
      "description": "This module provides immutable sets of unique strings with standard set-theoretic operations such as union, intersection, and difference, along with membership testing, insertion, and removal. It supports transformations between sets, lists, and sequences, and includes utilities for querying size and extracting ordered elements. The child module extends this functionality by performing union operations across a list of string sets, enabling efficient aggregation of multiple set results. Together, they enable tasks like deduplication, range-based filtering, and complex set comparisons in data processing workflows.",
      "description_length": 620,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Diff2.SeqType",
      "library": "rocq-runtime.clib",
      "description": "This module defines the interface for accessing elements in a sequence, providing `get` to retrieve the element at a specific index and `length` to obtain the total number of elements. It operates on two data types: `t` representing the sequence itself and `elem` representing the type of elements within the sequence. Concrete use cases include comparing sequences of lines in text files or elements in arrays to compute differences using the O(ND) algorithm.",
      "description_length": 460,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hashset.Combine",
      "library": "rocq-runtime.clib",
      "description": "This module provides functions for combining hash values into a single hash, such as `combine`, `combinesmall`, and variants for combining 3 to 5 integers. It works directly with integer hash values, typically used when hashing composite data structures. Concrete use cases include hashing tuples, variant types, or custom data structures where multiple hash components need to be merged into a single hash.",
      "description_length": 407,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSig.MapS",
      "library": "rocq-runtime.clib",
      "description": "This module provides a polymorphic map structure supporting key-based manipulation, transformation, and analysis of associative data. It operates on a key type paired with arbitrary values (`'a t`), offering operations for safe value retrieval (via optional returns), set-like transformations (union, intersection), and key-range partitioning. Typical use cases include managing dynamic configurations, aggregating heterogeneous data, and implementing algorithms requiring efficient key-space decomposition or value mapping.",
      "description_length": 524,
      "index": 124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hashset.Make",
      "library": "rocq-runtime.clib",
      "description": "This module implements a hash-consing set where elements are stored once and retrieved by their computed hash key. It supports creating sets with a specified initial size, clearing existing sets, and retrieving or storing elements based on their hash representation. The module is useful for scenarios requiring canonical representation of values, such as symbol interning or memoization with controlled hashing.",
      "description_length": 412,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CArray.ExtS-Fun1",
      "library": "rocq-runtime.clib",
      "description": "This module provides higher-order versions of standard array operations like `map`, `iter`, and `iter2`, where each function takes an additional parameter passed to the function argument at each call. It works with arrays of arbitrary types and is useful in performance-sensitive contexts where avoiding closure allocation is critical. Concrete use cases include in-place array transformations and iterations where the extra parameter serves as a shared state or configuration.",
      "description_length": 477,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dyn.S-HMap",
      "library": "rocq-runtime.clib",
      "description": "This module maps and filters over polymorphic maps with dynamic key-value types, transforming values from one type representation to another. It operates on `Map(V1).t` and `Map(V2).t` structures, where each value is tied to a type tag. Use it to convert or filter heterogeneous map contents, such as processing configuration values across different serialization formats.",
      "description_length": 372,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HMap.HashedType",
      "library": "rocq-runtime.clib",
      "description": "This module defines a hashed type with a total ordering and a compatible hash function. It works with a type `t` and provides `compare` and `hash` operations. Used to create hash tables where keys must support both equality and hashing, such as in custom key types for `Hashtbl` or `Map` modules.",
      "description_length": 296,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CMap.UExtS",
      "library": "rocq-runtime.clib",
      "description": "This module offers operations for creating, modifying, and querying polymorphic maps with key-based associations, supporting transformations via predicates, safe/unsafe key access, and domain manipulation. It works with association lists, sets, and monadic workflows to enable efficient traversal, difference folding, and higher-order filtering. Use cases include data processing pipelines, configuration management, and scenarios requiring associative structures with complex key-value interactions.",
      "description_length": 500,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CString.ExtS-Set",
      "library": "rocq-runtime.clib",
      "description": "This module provides operations for constructing, comparing, and transforming finite string collections through union, intersection, difference, membership checks, and extremal value extraction. It operates on sets of strings represented by type `t` and individual string elements (`elt`), with utilities to convert sequences into sets and traverse elements. Use cases include deduplicating string lists, validating presence in a set, and performing set algebra for configuration or filtering tasks.",
      "description_length": 499,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Trie.Grp",
      "library": "rocq-runtime.clib",
      "description": "Implements algebraic operations for combining and manipulating trie structures with group semantics. Provides functions to compute the inverse of a trie and to combine tries using associative addition and subtraction. Useful for applications like version control systems or document deltas where trie-based changes need to be merged or rolled back.",
      "description_length": 348,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.ExtS-Pred",
      "library": "rocq-runtime.clib",
      "description": "This module implements a set-like structure for representing predicates over a base type `elt`, supporting operations such as membership testing, union, intersection, complement, and subset checks. It handles both finite and potentially infinite sets, with special representations for the empty and full sets. Concrete use cases include symbolic set manipulation, finite state representation, and predicate logic operations where explicit enumeration is impractical or impossible.",
      "description_length": 480,
      "index": 132,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Monad.Def",
      "library": "rocq-runtime.clib",
      "description": "This module defines core monadic operations including value injection, chaining, sequencing, and transformation. It works with monadic types `'a t` that represent computations. Concrete use cases include handling effectful computations like IO, state transitions, or error propagation in a composable way.",
      "description_length": 305,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Store.S",
      "library": "rocq-runtime.clib",
      "description": "This module manages a dynamic key-value store with typed fields. It supports creating fields, setting and retrieving typed values, removing fields, and merging stores. Use it to build extensible records or configuration objects with runtime-defined fields.",
      "description_length": 256,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSet.OrderedType",
      "library": "rocq-runtime.clib",
      "description": "This module defines a totally ordered type used to create and manipulate sets of comparable elements. It specifies a type `t` and a `compare` function that determines the ordering between elements. It enables concrete operations like set union, intersection, and ordered traversal, typically used for types like integers, strings, or custom types requiring strict ordering.",
      "description_length": 373,
      "index": 135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CMap.UExtS-Set",
      "library": "rocq-runtime.clib",
      "description": "This module offers a functional set interface with operations for membership testing, modification (insertion, deletion), and set algebra (union, intersection, difference), alongside utilities for inspecting structure through cardinality, element listing, and arbitrary selection. It manipulates a set type `t` containing elements of type `elt` (equivalent to `key`), designed for immutable data workflows. Such capabilities are particularly useful in domain-specific data processing where hierarchical set relationships or unique element collections must be rigorously maintained and queried.",
      "description_length": 593,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Monad.Make",
      "library": "rocq-runtime.clib",
      "description": "This module implements core monadic operations like bind (`>>=`), sequence (`>>`), and map for working with monadic values of type `'a t`, enabling chaining and transformation of effectful computations. Its List submodule extends these capabilities with list-specific combinators for mapping, filtering, and folding, supporting controlled traversal and accumulation over lists of monadic values. You can use it to process sequences of effectful actions, validate structured data, or accumulate results from side-effecting list elements. The combined interface supports both general monadic composition and precise, tail-recursive list manipulation in a unified monadic context.",
      "description_length": 677,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CArray.ExtS-Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized versions of common array transformations like `map`, `map2`, and combined fold-map operations. It works with OCaml arrays and improves performance by avoiding unnecessary copies when the result would be identical to an existing input array. These functions are useful in performance-sensitive code paths where in-place updates are possible and array immutability would otherwise lead to redundant allocations.",
      "description_length": 440,
      "index": 138,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CMap.OrderedType",
      "library": "rocq-runtime.clib",
      "description": "This module defines a totally ordered type with a comparison function. It works with any data type that can be linearly ordered, such as integers, strings, or custom types with a defined sort key. Concrete use cases include enabling ordered maps and sets where keys must be compared, like maintaining a sorted list of timestamps or organizing a dictionary by lexicographic order.",
      "description_length": 379,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CMap.UExtS-Monad",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic fold and map operations over key-value collections. It works with associative data structures like maps, where each element is a key-value pair. Use it to sequence monadic actions across map entries, accumulating results or transforming values in a monadic context.",
      "description_length": 294,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Trie.S",
      "library": "rocq-runtime.clib",
      "description": "This module implements a trie structure where keys are lists of labels, supporting operations to traverse, insert, delete, and iterate over data associated with paths of labels. It works with abstract types for labels, data, and trie nodes, allowing precise manipulation of hierarchical key-value associations. Concrete use cases include efficient prefix-based lookups, dictionary implementations with word path decompositions, and routing tables with hierarchical keys.",
      "description_length": 470,
      "index": 141,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Monad.S-List",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic operations over lists, including mapping, folding, and filtering with effects sequenced left-to-right or right-to-left. It supports list transformations where each element computation is monadic, handling effectful operations like IO or error handling. Use cases include processing effectful streams of data, accumulating results with side effects, or validating and transforming lists where each step depends on prior results.",
      "description_length": 456,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Diff2.Make",
      "library": "rocq-runtime.clib",
      "description": "This module computes differences and common sequences between two sequences using a generic element comparison function. It provides operations to calculate the longest common subsequence (LCS), the edit list representing insertions and deletions, and utilities to fold or iterate over the edits without creating intermediate lists. It works with any sequence type that supports element comparison, making it suitable for tasks like text line comparison, version diffing, or synchronization of structured data.",
      "description_length": 510,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Heap.Functional",
      "library": "rocq-runtime.clib",
      "description": "This module implements a functional priority queue with max-heap semantics, supporting efficient insertion and removal of the maximum element. It works with a comparable element type `X.t`, maintaining elements in a heap-ordered structure that allows for $O(1)$ access to the maximum value and $O(\\log n)$ insertion and removal. It is suitable for applications like scheduling tasks by priority, maintaining a dynamic collection of elements with frequent access to the largest item, or implementing greedy algorithms requiring ordered element processing.",
      "description_length": 554,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Option.List",
      "library": "rocq-runtime.clib",
      "description": "This module extends list operations to work with optional values, providing functions like `cons` to prepend a value from an option to a list, `flatten` to extract values from a list of options, and `map` to apply a function returning an option across a list, yielding `None` if any application fails. It operates on `'a option` and `'a list` types, combining them to handle optional elements within list structures. Use cases include processing lists where elements may be missing, such as parsing optional fields from a sequence or filtering out absent values.",
      "description_length": 562,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Predicate.S",
      "library": "rocq-runtime.clib",
      "description": "This module represents infinite sets over a specific ordered type, supporting standard set operations such as union, intersection, difference, and complement. It works with two primary types: `elt` for individual elements and `t` for sets, enabling precise membership tests, subset checks, and set construction via addition or removal of elements. Concrete use cases include symbolic reasoning over infinite domains, such as representing intervals or constraints in program analysis or formal verification tasks.",
      "description_length": 512,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.ExtS-Set-List",
      "library": "rocq-runtime.clib",
      "description": "Performs the union of multiple sets contained in a list, combining all elements into a single set. Works with lists of sets, where each set contains elements of a comparable type. Useful for aggregating results from multiple set-based computations into one unified set.",
      "description_length": 269,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CArray.Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized versions of common array transformations like `map`, `map2`, and combined fold-map operations, which avoid unnecessary array copies when the result would be identical to the input. It works specifically with OCaml arrays and functions that transform elements in place. Use this when performing array manipulations where identity preservation can reduce memory allocation, such as in iterative updates or conditional transformations.",
      "description_length": 463,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.Pred",
      "library": "rocq-runtime.clib",
      "description": "This module implements a set-like structure for character strings, supporting standard operations such as membership testing, union, intersection, and complement. It works with the type `CString.t` and represents sets either extensionally or via their complements, allowing for both finite and potentially infinite sets. Concrete use cases include managing inclusion or exclusion of specific strings in configurations, filtering string-based identifiers, and symbolic manipulation of string sets where explicit enumeration is impractical.",
      "description_length": 538,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PolyMap.Tag",
      "library": "rocq-runtime.clib",
      "description": "This module defines a polymorphic tagged map structure where each value is associated with a type-specific key. It supports operations to insert, lookup, and remove values using type-safe tags, ensuring that each key uniquely identifies a value of the corresponding type. Concrete use cases include managing heterogeneous configurations, storing type-safe metadata, and implementing extensible records with static type guarantees.",
      "description_length": 430,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CMap.ExtS-Smart",
      "library": "rocq-runtime.clib",
      "description": "This module provides optimized `map` and `mapi` functions that transform values in a map while attempting to preserve structural sharing to improve efficiency. It operates specifically on map data structures where keys and values are immutable. These functions are useful when applying transformations to large maps without unnecessary duplication of unchanged subtrees.",
      "description_length": 370,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CArray.S",
      "library": "rocq-runtime.clib",
      "description": "This module provides array manipulation operations spanning creation, transformation, and iteration with in-place and functional variants. It works with `'a array` types, supporting list and sequence conversions, matrix operations via 2D arrays, and indexed processing. Key use cases include data pipeline transformations, imperative array updates, matrix algorithm implementations, and sequence-array interoperation for streaming workflows.",
      "description_length": 441,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unionfind.Make",
      "library": "rocq-runtime.clib",
      "description": "Implements an imperative Union-Find data structure with path compression and in-place partition updates. It supports element addition, equivalence class lookup via `find`, and merging of classes through `union` and `union_set`. Designed for managing dynamic partitions of elements from a set, such as tracking connected components in graphs or grouping items under equivalence relations.",
      "description_length": 387,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hashcons.Hlist",
      "library": "rocq-runtime.clib",
      "description": "This module implements hash-consing for lists of a given type, ensuring that structurally identical lists are represented by the same physical object. It provides operations to create a hash-consing table, perform hash-consing on lists, and retrieve statistics about the table's usage. Use cases include optimizing memory usage when working with large numbers of lists that may have repeated structure, such as in symbolic computation or AST manipulation.",
      "description_length": 455,
      "index": 154,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hashcons.HashedType",
      "library": "rocq-runtime.clib",
      "description": "This module defines a hash-consed type with a total ordering and a hash function. It works with immutable data structures that require canonical representation through hashing and equality. Concrete use cases include efficient comparison and storage of abstract syntax trees or symbolic expressions where structural identity matters.",
      "description_length": 333,
      "index": 155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unionfind.PartitionSig",
      "library": "rocq-runtime.clib",
      "description": "Implements imperative union-find with path compression for efficient equivalence class management. Operates on elements of type `elt`, grouped into disjoint sets of type `set`, and stored in a mutable partition structure of type `t`. Useful for dynamic connectivity problems, such as tracking connected components in graphs or merging clusters in algorithms like Kruskal's minimum spanning tree.",
      "description_length": 395,
      "index": 156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CMap.ExtS",
      "library": "rocq-runtime.clib",
      "description": "This module provides associative map operations for polymorphic map structures with typed keys, supporting insertion, deletion, traversal, and comparison. It includes set-like functionality, advanced combinators for merging and splitting maps, key-aware transformations (`map`, `filter`, `modify`), and domain management (`bind`, `domain`), alongside left/right folds for ordered traversal and combined fold-map operations that accumulate state during value transformations. These features are suited for structured data manipulation tasks like merging hierarchical datasets, filtering key-based subsets, or analyzing structural differences between maps through ordered traversal and stateful processing.",
      "description_length": 704,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Int.Map",
      "library": "rocq-runtime.clib",
      "description": "This module manages ordered key-value collections with integer keys, offering operations like insertion, deletion, traversal, and structural comparison. It supports transformations that preserve ordering and sharing, such as `map`, `mapi`, and monadic folds, working directly on `Int.Map.t` structures. You can efficiently update sparse arrays indexed by integers, accumulate results with effects over map entries, or convert maps into lists and sets. Submodules enhance this with optimized transformations and monadic traversal, enabling precise control over iteration direction and effect sequencing.",
      "description_length": 602,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CList.Smart",
      "library": "rocq-runtime.clib",
      "description": "Performs list transformations with maximal physical sharing between input and output when possible. It provides `map`, `fold_left_map`, and `fold_right_map` that return results sharing suffixes with the input list if the transformation leaves elements unchanged. Useful for efficient list updates in performance-sensitive code where preserving identity of unmodified elements is beneficial.",
      "description_length": 390,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Monad.S",
      "library": "rocq-runtime.clib",
      "description": "This module defines core monadic operations including bind (`>>=`), sequence (`>>`), and map, working with monadic values of type `'a t`. It provides structured composition for effectful computations, enabling chaining and transformation of values within a monadic context. Concrete use cases include handling optional values, error propagation, and asynchronous operations where sequential composition and side-effect management are critical.",
      "description_length": 443,
      "index": 160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Store.Make",
      "library": "rocq-runtime.clib",
      "description": "This module creates a store type with operations to manage named fields. It supports setting, getting, and removing values associated with string keys, along with merging two stores. It is useful for handling dynamic configurations or attribute collections where fields can be added or modified at runtime.",
      "description_length": 306,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dyn.S-Map",
      "library": "rocq-runtime.clib",
      "description": "This module implements a heterogeneous map where keys are type-safe dynamic type tags and values are parameterized by their corresponding type. It supports operations like adding, removing, and modifying entries based on type, as well as iterating and folding over all entries regardless of type. Concrete use cases include storing and managing values of different types indexed by their type representations, such as configuration settings or dynamic attributes.",
      "description_length": 463,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "OrderedType.UnorderedPair",
      "library": "rocq-runtime.clib",
      "description": "This module represents pairs of values where order does not matter, using a tuple of two elements from the parameter module M. It provides a comparison function that treats pairs as equal regardless of element order, enabling use in ordered data structures like sets or maps. It is useful for representing undirected edges in graphs or combinations where the sequence of elements has no semantic meaning.",
      "description_length": 404,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hashcons.Hstring",
      "library": "rocq-runtime.clib",
      "description": "This module implements hash-consing for strings, ensuring that equivalent strings share the same memory representation. It provides functions to create a hash-consing table, to intern strings into the table, and to retrieve statistics about the table's usage. Concrete use cases include optimizing memory usage when dealing with large numbers of duplicate strings, such as in compilers or data processing pipelines.",
      "description_length": 415,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Memprof_coq.Mutex_aux",
      "library": "rocq-runtime.clib",
      "description": "This module provides a function `with_lock` that acquires a mutex before executing a given scope function and releases it afterward, ensuring thread-safe execution. It works with `Stdlib.Mutex.t` locks and arbitrary functions that encapsulate critical sections. A concrete use case is protecting access to shared resources in concurrent programs, such as coordinating updates to a shared counter or buffer.",
      "description_length": 406,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSet.HashedType",
      "library": "rocq-runtime.clib",
      "description": "This module defines a hashed type interface with a hash function for a specific type `t`. It works with any data type that can be mapped to an integer hash value. Concrete use cases include enabling efficient storage and retrieval in hash tables or sets where fast equality checks and distribution are required.",
      "description_length": 311,
      "index": 166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hashcons.Make",
      "library": "rocq-runtime.clib",
      "description": "This module implements hash-consing for a given data type, using user-provided canonicalization functions. It provides operations to create a hash-consing table, perform hash-consing on values, and retrieve statistics about the table's usage. Concrete use cases include optimizing memory usage for large sets of duplicated values, such as abstract syntax trees or symbolic expressions.",
      "description_length": 385,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Heap.S",
      "library": "rocq-runtime.clib",
      "description": "This module implements a priority queue with efficient insertion and extraction of the maximum element. It maintains a collection of elements ordered such that the maximum can be retrieved and removed in logarithmic time. Useful for scheduling tasks by priority, maintaining a top-k collection of results, or processing elements in descending order.",
      "description_length": 349,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dyn.S",
      "library": "rocq-runtime.clib",
      "description": "Handles creation and manipulation of dynamically typed values with type-safe tags. Supports runtime type registration, equality checks, and type name resolution. Useful for implementing plugins or configuration systems where types are determined at runtime.",
      "description_length": 257,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CArray.ExtS-Fun1-Smart",
      "library": "rocq-runtime.clib",
      "description": "Performs in-place transformations on arrays using a function that takes an external argument and an array element, applying the function to each element of the array. Works with arrays of any type and a provided transformation function. Useful for efficiently updating array elements based on external state without creating new arrays.",
      "description_length": 336,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.List",
      "library": "rocq-runtime.clib",
      "description": "This module implements association lists where keys are strings, supporting operations like checking membership of keys or values, retrieving associated values, and removing key-value pairs. It works with lists of string elements and pairs of strings with arbitrary values. Use it to manage mappings from string keys to values, such as configuration settings or named data entries.",
      "description_length": 381,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unionfind.SetS",
      "library": "rocq-runtime.clib",
      "description": "Implements a minimal set interface with imperative union operations and path compression for efficient partition management. Operates on elements of type `elt` and maintains a canonical representative for each set. Useful for grouping elements into disjoint sets and merging groups efficiently, such as in dynamic connectivity problems or Kruskal's algorithm.",
      "description_length": 359,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.ExtS",
      "library": "rocq-runtime.clib",
      "description": "This module provides functional string processing with character-level transformations, slicing, and search operations, alongside utilities for encoding/decoding binary data, text normalization, and linguistic pattern generation. It operates on strings and string lists, incorporating UTF-8 validation, hashconsing, and index-aware algorithms for tasks like HTML escaping, pluralization, and memory-efficient string set/map manipulations. Use cases include parsing binary formats with endianness control, generating human-readable text from numeric data, and building efficient string analysis pipelines with safe optional-result variants.",
      "description_length": 639,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CSig.UMapS",
      "library": "rocq-runtime.clib",
      "description": "This module provides functions for manipulating polymorphic maps through insertion, deletion, lookup, and transformation operations, alongside set-like merging and filtering. It operates on immutable key-value structures where keys index arbitrary-typed values, supporting functional workflows such as environment tracking or data aggregation pipelines. Specific use cases include managing hierarchical configurations, symbolic computation contexts, and versioned state transitions requiring persistent associative collections.",
      "description_length": 527,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSig.USetS",
      "library": "rocq-runtime.clib",
      "description": "This module provides a polymorphic set interface with operations for membership testing, set construction, algebraic operations (union, intersection, difference), and higher-order traversal (fold, filter, partition). It works with ordered elements of type `elt` and sets of type `t`, relying on total ordering for efficient implementation. Typical use cases include managing collections of comparable values, performing set-theoretic computations, and iterating over elements in sorted order.",
      "description_length": 492,
      "index": 175,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "OrderedType.S",
      "library": "rocq-runtime.clib",
      "description": "Implements a total ordering for a type `t` using a comparison function `compare` that returns a negative, zero, or positive integer based on the ordering of its two arguments. Works with any data type that requires a strict ordering, such as integers, strings, or custom data structures. Used to define ordered keys in data structures like sets and maps, ensuring correct insertion, lookup, and traversal behavior.",
      "description_length": 414,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Option.Smart",
      "library": "rocq-runtime.clib",
      "description": "Smart implements optimized variants of common option operations with a focus on memory efficiency. It provides functions like `map` that preserve structure while minimizing allocations, working directly with `'a option` types. This module is useful when frequently transforming optional values in performance-sensitive code paths where reducing garbage collection pressure is critical.",
      "description_length": 385,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Predicate.Make",
      "library": "rocq-runtime.clib",
      "description": "Constructs infinite sets over a given ordered type with operations for membership testing, set union, intersection, difference, and complement. It supports concrete uses like representing mathematical sets, filtering elements based on inclusion criteria, and symbolic manipulation of set expressions. The implementation handles both finite and infinite sets, providing explicit element lists when possible.",
      "description_length": 406,
      "index": 178,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Int.PArray",
      "library": "rocq-runtime.clib",
      "description": "This module implements a persistent array structure indexed by integers, supporting efficient lookup and modification. It provides operations to create an empty array with a specified initial size, retrieve values by index (returning `None` if unset), and update or remove values at specific indices. Use it when you need an array-like structure that retains previous versions after modifications, enabling safe, immutable updates.",
      "description_length": 431,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dyn.S-Easy",
      "library": "rocq-runtime.clib",
      "description": "This module provides dynamic type tagging and injection/projection operations for values. It works with dynamically typed values (`t`) and type tags (`'a tag`) to enable runtime type manipulation. Concrete use cases include building heterogeneous collections and implementing type-safe dynamic dispatch without static type information.",
      "description_length": 335,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hashset.EqType",
      "library": "rocq-runtime.clib",
      "description": "This module defines a hash-consing mechanism where equality and hash computation are decoupled. It works with a type `t` and a custom equality function `eq`, enabling efficient sharing of values based on user-defined identity. Concrete use cases include interning strings, managing unique identifiers, or optimizing memory usage in symbolic computation systems.",
      "description_length": 361,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString.Map",
      "library": "rocq-runtime.clib",
      "description": "This module organizes finite maps over string keys, offering both direct operations and submodules for transformation and traversal. It supports core operations like `fold`, `map`, and `mapi`, enabling tasks such as aggregating values, applying functions to entries, and threading monadic effects like error handling or I/O. The first submodule enhances traversal by integrating monadic actions, allowing stateful processing of map elements, while the second optimizes transformations with structural sharing, reducing memory use when updating values. Examples include processing configuration maps with effectful operations or efficiently updating cached data without full reallocation.",
      "description_length": 687,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "OrderedType.Pair",
      "library": "rocq-runtime.clib",
      "description": "Defines a lexicographical ordering for pairs of values from two ordered types. Provides a `compare` function that orders pairs first by their first component, then by their second component. Useful for sorting or comparing tuples where each element has a defined order, such as coordinates or version numbers.",
      "description_length": 309,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hashcons.S",
      "library": "rocq-runtime.clib",
      "description": "Implements hash-consing operations for efficient memory sharing of immutable values. It provides `hcons` to intern values in a hash table, ensuring structural equality implies physical equality, and `generate` to create fresh tables. Useful for optimizing memory in symbolic computation or AST manipulation where many duplicate values occur.",
      "description_length": 341,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dyn.Make",
      "library": "rocq-runtime.clib",
      "description": "This module enables the creation and management of dynamic type tags with operations to register named types, compare tags, retrieve type names, and list all registered types. It supports existential types and boxed tags for type-erased manipulation, facilitating type-safe dynamic dispatch, serialization of unknown types, and runtime introspection. The associated modules provide a type-safe map for heterogeneous storage and retrieval, transformation and filtering of dynamically typed maps, and utilities to inject and extract values using runtime type tags. Together, they support use cases like dynamic configuration systems, heterogeneous caches, format conversion, and plugin architectures with strong typing guarantees.",
      "description_length": 728,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CMap.Make",
      "library": "rocq-runtime.clib",
      "description": "This module implements a polymorphic map with balanced binary trees for functional manipulation of immutable key-value associations, supporting ordered traversal, transformation, and custom merging. It provides core operations like insertion, deletion, filtering, and folding, while its submodules enhance transformation efficiency and enable monadic processing across entries. The first submodule optimizes value transformations (`map`, `mapi`) by preserving structural sharing, reducing memory overhead when updating large maps. The second extends traversal (`fold`, `fold_left`, `mapi`) to support monadic effects, enabling stateful computations, error propagation, or asynchronous transformations over key-value pairs.",
      "description_length": 722,
      "index": 186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hashset.S",
      "library": "rocq-runtime.clib",
      "description": "This module implements a hash-consing set where elements are stored based on a user-provided hash key. It supports creating a set with a given initial size, clearing its contents, retrieving a canonical representation of an element using its hash key, and gathering statistics on the set's internal structure. It is particularly useful for interning values where hash computation and equality checking are decoupled from the set's internal logic.",
      "description_length": 446,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hashcons.HashconsedType",
      "library": "rocq-runtime.clib",
      "description": "Implements hash-consing for a data type with structural equivalence, using a customizable equality and hash function. It ensures that equivalent values share the same physical representation, reducing memory usage and speeding up equality checks. Useful for optimizing memory in symbolic computation or AST manipulation where many structurally equivalent values are created.",
      "description_length": 374,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CEphemeron",
      "library": "rocq-runtime.clib",
      "description": "This module implements ephemeral keys for managing weak references to values of any type. It provides operations to create a key, retrieve or default its value, and clean up invalidated keys. Useful for caching systems where referenced values should not prevent garbage collection.",
      "description_length": 281,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Memprof_coq",
      "library": "rocq-runtime.clib",
      "description": "This module coordinates interruption states with `is_interrupted` and manages concurrency through submodules that handle resource binding, thread-local storage, and mutex locking. It supports scoped resource management via `let&`, automatic thread-local value binding, and safe critical section execution with `with_lock`, enabling robust handling of shared and external resources. You can use it to manage file handles that close automatically, track per-thread state in async workflows, or protect shared data structures with mutexes. Each submodule integrates with the core interruption model to ensure safe, deterministic behavior in multi-threaded programs.",
      "description_length": 662,
      "index": 190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SList",
      "library": "rocq-runtime.clib",
      "description": "This module implements sparse lists, where elements can be present or absent, supporting construction with `cons`, `default`, and `cons_opt`, and inspection with `view`, `is_empty`, and `is_default`. It enables efficient manipulation of sequences with optional values, such as partial data streams or sparse arrays, while preserving sparsity during operations. The first child module allows transformations and accumulations over sparse lists, applying functions only to non-default elements, which is ideal for processing large sparse data structures like vectors or matrices. The second child module focuses on traversal and processing while skipping default values, offering iteration, mapping, folding, and condition-checking functions tailored for efficient sparse list manipulation.",
      "description_length": 788,
      "index": 191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Diff2",
      "library": "rocq-runtime.clib",
      "description": "This module implements the O(ND) difference algorithm for comparing sequences of arbitrary elements, identifying matches, insertions, and deletions with customizable equality checks. It provides core operations to compute the longest common subsequence (LCS), generate edit scripts, and process differences through folds or iterations without intermediate allocations. The sequence interface submodule abstracts element access via `get` and `length`, supporting comparison of lines in text files, array elements, or other structured data. Together with the diff computation submodule, it enables efficient difference calculation and traversal across diverse sequence types.",
      "description_length": 673,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unionfind",
      "library": "rocq-runtime.clib",
      "description": "This module provides an imperative union-find data structure with path compression and in-place updates for efficient dynamic partition management. It supports operations to add elements, find canonical representatives, and merge sets, working with elements that have an equality comparison. The structure is well-suited for applications like tracking connected components in graphs or implementing algorithms such as Kruskal's minimum spanning tree. Submodules extend this functionality with map-like storage, set interfaces, and specialized union operations, enabling efficient key-value associations, dynamic grouping, and minimal set manipulation over arbitrary element types.",
      "description_length": 680,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Monad",
      "library": "rocq-runtime.clib",
      "description": "This module provides monadic operations for sequencing and composing effectful computations, supporting types like `option`, `result`, and custom monads through core functions like `bind`, `map`, and `return`. It enables chaining operations with effects such as error propagation, state transitions, and IO, while its submodules extend these capabilities to list processing with controlled evaluation order and accumulation. You can use it to validate and transform lists of monadic values, sequence effectful actions, or fold over structured data with left-to-right or right-to-left evaluation. Specific examples include processing error-prone computations in a clean pipeline, accumulating results from effectful list elements, and composing asynchronous or optional values with concise, composable syntax.",
      "description_length": 808,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSig",
      "library": "rocq-runtime.clib",
      "description": "This module introduces type classes for sets and maps with unique and non-unique keys, enabling membership testing, insertion, and key-based lookup across abstract and concrete data structures. It supports polymorphic maps and sets with total ordering, allowing operations like union, intersection, difference, and key-range partitioning, while enabling custom comparison logic and efficient key-value manipulation. Use it to implement persistent associative collections, manage dynamic or hierarchical configurations, or perform set-theoretic computations on ordered elements. Submodules refine these capabilities with specialized operations for ordered sets, polymorphic maps, and functional transformations over immutable structures.",
      "description_length": 736,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NeList",
      "library": "rocq-runtime.clib",
      "description": "This module implements a non-empty list structure, providing operations to access the head and tail, apply functions across elements, and convert to and from standard lists. It supports data types like `'a NeList.t` and pairs of head and list. Use cases include safely handling lists guaranteed to have at least one element, such as processing command-line arguments with a required command or managing sequences where emptiness is invalid.",
      "description_length": 440,
      "index": 196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Exninfo",
      "library": "rocq-runtime.clib",
      "description": "This module attaches metadata like backtraces and user-defined annotations to exceptions. It provides operations to create, enrich, and query exception metadata, working with structured data like `info` and `backtrace`. Use cases include debugging failed computations by capturing context at the point of failure or adding diagnostic tags to exceptions.",
      "description_length": 353,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CArray",
      "library": "rocq-runtime.clib",
      "description": "This module provides efficient array manipulation with a focus on performance-critical operations, combining direct functions and submodules that optimize common transformations, iterations, and in-place updates. It supports arrays of arbitrary type `'a`, including multi-dimensional and jagged arrays, with operations like `map`, `iter`, `fold_left`, and indexed variants that avoid closure allocation or unnecessary array copies. Submodules extend these capabilities with environment-aware functions, stateful transformations, and optimized variants for matrix operations, element-wise processing, and identity-preserving updates. Examples include using `iter` with an environment argument for low-overhead traversal, `map` that reuses input buffers, and `make_matrix` for creating structured arrays with subsequent in-place modifications.",
      "description_length": 841,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Option",
      "library": "rocq-runtime.clib",
      "description": "This module enhances the `'a option` type with a unified set of combinators that support monadic transformations, filtering, and case analysis, treating options as singleton lists for consistent functional processing. It includes core operations like `map`, `bind`, `filter`, and `cata`, enabling idioms such as chaining optional computations, extracting values with defaults, or branching explicitly on presence. The first submodule extends list interactions, offering utilities like `cons`, `flatten`, and `map` to integrate optional values into list workflows, ideal for handling sequences with potential missing elements. The Smart submodule optimizes common transformations for performance-critical contexts, ensuring minimal memory allocation when mapping or folding over optional values.",
      "description_length": 794,
      "index": 199,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Int",
      "library": "rocq-runtime.clib",
      "description": "This module provides core operations for working with native integers, including equality, comparison, and hashing, forming the basis for integer-based data manipulation. Its submodules extend this functionality to specialized structures: sets for unique integer membership checks, lists for association and filtering operations on integer-keyed pairs, and a persistent array-backed map for efficient lookups and sparse integer indexing with immutable updates. The persistent array submodule enables versioned, array-like storage with safe modifications, while the map submodule supports ordered traversal, structural comparison, and monadic transformations over integer-keyed data. Examples include tracking integer identifiers in sets, caching computation results by integer keys, and transforming integer-indexed collections with guaranteed ordering and immutability.",
      "description_length": 870,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CMap",
      "library": "rocq-runtime.clib",
      "description": "This module implements an ordered key-value map with rich transformation and traversal capabilities, including standard operations like `find`, `add`, and `map`, as well as monadic bindings and custom merging. Its submodules enhance functionality with monadic traversal, set-like operations, optimized structural sharing for transformations, and ordered folding strategies, enabling efficient processing of large maps, effectful computations, and precise key-based manipulations. You can use it to build symbol tables with ordered keys, perform set algebra alongside map operations, or apply effectful transformations across key-value pairs while preserving performance and immutability. Specific examples include safely modifying values conditionally through monadic pipelines, folding over a map's entries with custom accumulators, or maintaining structural sharing when mapping over large datasets.",
      "description_length": 901,
      "index": 201,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hashcons",
      "library": "rocq-runtime.clib",
      "description": "This module enables hash-consing for user-defined types, ensuring structurally equivalent values share the same physical representation through persistent hash tables. It provides functors to create hash-consed types with canonical forms, supporting operations like `hcons` for interning values and `generate` for creating new tables, while submodules extend this functionality to specific data types such as lists, strings, and ordered values. Use cases include deduplicating abstract syntax trees, optimizing memory in symbolic computation, and ensuring unique representation of structured data. Modules like `Hlist` and `Hstring` apply these techniques to common data structures, offering specialized functions for interning and comparison.",
      "description_length": 743,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CList",
      "library": "rocq-runtime.clib",
      "description": "This module provides powerful list manipulation capabilities for both generic and homogeneous lists, combining structural operations, set-like functionality, and performance-optimized transformations. It supports key operations such as indexed mapping, stable sorting, custom equality-based set operations, and efficient handling of association lists with key-based lookups and updates. The included submodules enhance element-level operations with equality checks, membership tests, and optimized physical sharing during transformations to minimize memory use. For example, you can perform key-based queries on association lists, apply transformations that preserve unmodified elements through sharing, or fold over multiple lists in parallel with custom combining logic.",
      "description_length": 772,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CObj",
      "library": "rocq-runtime.clib",
      "description": "This module calculates physical and logical sizes of OCaml values, including support for shared structure analysis. It operates on arbitrary OCaml values, tracking size in words, bytes, or kilobytes, and handles cyclic structures. Concrete use cases include memory profiling, analyzing data structure overhead, and optimizing resource usage in performance-sensitive code.",
      "description_length": 371,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Predicate",
      "library": "rocq-runtime.clib",
      "description": "This module represents infinite sets using predicates over any ordered type, enabling purely applicative set operations such as union, intersection, and complement through higher-order functions. It defines core types `elt` for elements and `t` for sets, with operations that support membership testing, subset checks, and symbolic manipulation of sets like intervals or constraints. Submodules provide ordered type definitions, concrete set implementations, and functors for building sets over custom types with explicit element enumeration or logical inclusion rules. Examples include defining sets of integers with range conditions, filtering characters by properties, or performing symbolic set algebra in program analysis.",
      "description_length": 727,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CString",
      "library": "rocq-runtime.clib",
      "description": "This module combines low-level string and byte manipulation with advanced data structure operations, enabling efficient text processing, binary parsing, and set/map manipulations. It directly supports string indexing, UTF handling, and hashconsing, while its submodules provide optimized map transformations, monadic traversals, association lists, and set operations over strings, including union aggregation and predicate-based sets. You can parse binary protocols, sanitize text, manage configurations with string keys, and perform high-performance set algebra or map reductions. Specific capabilities include byte-level integer extraction, case conversion, HTML escaping, stateful map traversal, and symbolic set manipulation.",
      "description_length": 729,
      "index": 206,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HMap",
      "library": "rocq-runtime.clib",
      "description": "This module implements a hash table-based map with support for arbitrary key and value types, using a hashable key type that ensures consistent hashing and comparison. It provides core operations for binding, looking up, and removing key-value pairs, enabling efficient storage and retrieval in use cases like symbol tables and caches. The module supports purely functional transformations with structural sharing, and includes submodules for set-like operations, monadic iterations, and custom key type definitions. For example, it can manage active sessions, combine maps with set algebra, or define hash tables over custom keys with total ordering.",
      "description_length": 651,
      "index": 207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IStream",
      "library": "rocq-runtime.clib",
      "description": "This module implements purely functional streams where accessing elements does not consume them. It supports operations like `cons`, `map`, `fold`, and `concat_map`, working with stream values that can be built from or converted to lists. Use cases include lazy processing of sequences, infinite data structures, and non-destructive traversal of elements.",
      "description_length": 355,
      "index": 208,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "PolyMap",
      "library": "rocq-runtime.clib",
      "description": "This module manages polymorphic key-value mappings where keys implement a Tag interface and values follow the ValueS signature, enabling type-safe dictionaries with custom comparison logic for keys\u2014such as case-insensitive strings or numerics with specific precision. It supports creating, querying, and transforming maps, with operations for binding, lookup, and traversal, while child modules specialize for single tag types, arbitrary value types via a `V` module, and first-class typed key-value management. Use cases include typed environment contexts, heterogeneous state storage, and configuration systems where type-safe access to tagged data is critical. The module also allows converting tagged values to their underlying representations, enabling flexible yet safe manipulation of heterogeneous data.",
      "description_length": 811,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Segmenttree",
      "library": "rocq-runtime.clib",
      "description": "This module implements a segment tree for mapping ranges of integers to values. It supports constructing a tree from a list of non-overlapping, sorted intervals, each associated with a value, and efficiently looking up the value corresponding to a specific integer. It is useful for applications like range-based configuration settings or sparse array representations where intervals map to specific values.",
      "description_length": 407,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CUnix",
      "library": "rocq-runtime.clib",
      "description": "This module handles file paths with operations like canonicalization, stripping, and correction, working with strings and physical paths. It supports command execution with `run_command` and `sys_command`, capturing output and managing processes without shell dependencies. Use cases include script execution, path manipulation for file access, and temporary directory creation.",
      "description_length": 378,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CSet",
      "library": "rocq-runtime.clib",
      "description": "This module implements a flexible set data structure supporting element manipulation, membership queries, and set algebra, accommodating both ordered and hashed element types. It provides core operations like union, intersection, and difference, along with transformations such as fold, filter, and partition, enabling tasks like data aggregation, analysis, and dynamic collection management. Submodules enhance functionality with hash-consing for memory efficiency, ordered set manipulation, and utilities for constructing and working with comparable or hashed types. Specific uses include merging multiple sets, maintaining unique collections with custom equality, and performing efficient set operations in functional or ordered contexts.",
      "description_length": 741,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CThread",
      "library": "rocq-runtime.clib",
      "description": "This module provides functions for managing threads and performing thread-safe input operations. It works with custom thread input channels (`thread_ic`) and standard threading primitives like `Thread.t` and `Mutex.t`. Concrete use cases include safely reading values or lines from input channels in a multi-threaded context and synchronizing access to shared resources using mutex locks.",
      "description_length": 388,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Range",
      "library": "rocq-runtime.clib",
      "description": "This module implements skewed binary lists, enabling efficient O(1) prepend operations and O(log n) indexed access. It supports standard list transformations like map and fold, along with direct index retrieval and traversal via head/tail operations. It is ideal for use cases requiring persistent sequences with fast cons and logarithmic-time indexing, such as incremental computation or immutable finger trees.",
      "description_length": 412,
      "index": 214,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "OrderedType",
      "library": "rocq-runtime.clib",
      "description": "This module defines a total ordering interface for data types, providing core operations like `compare`, `equal`, and `hash` that enable consistent element comparison. It supports building and manipulating ordered collections such as sets and maps, ensuring correct ordering behavior for both built-in and custom types. Child modules extend this functionality by handling unordered pairs, customizable orderings via comparison functions, and lexicographical orderings for tuples\u2014useful for tasks like representing undirected graph edges or sorting version numbers. Specific applications include defining keys for ordered data structures and comparing multi-component values like coordinates or composite identifiers.",
      "description_length": 716,
      "index": 215,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unicodetable",
      "library": "rocq-runtime.clib",
      "description": "This module provides operations for classifying Unicode characters into categories such as uppercase, lowercase, numeric, and punctuation, as well as converting case using predefined codepoint ranges and transformation rules. It works with lists of integer pairs representing Unicode codepoint intervals and mappings between uppercase and lowercase ranges. These capabilities are useful for text processing tasks requiring Unicode compliance, such as case conversion, character validation, or categorization in internationalized applications.",
      "description_length": 542,
      "index": 216,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dyn",
      "library": "rocq-runtime.clib",
      "description": "This module enables dynamic typing through type-safe value manipulation, supporting creation, conversion, and runtime type handling. It includes a heterogeneous map for storing values indexed by type tags, transformation functions to convert between type representations, and utilities for type registration and comparison. You can build generic pipelines, manage mixed-type configurations, or implement dynamic dispatch by leveraging maps, type tags, and injection/projection operations. Specific capabilities include converting configuration values across formats, storing type-safe dynamic attributes, and handling runtime-determined types in plugins or serialization systems.",
      "description_length": 679,
      "index": 217,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hashset",
      "library": "rocq-runtime.clib",
      "description": "This module manages hash tables with custom hash and equality functions, enabling efficient insertion, lookup, and traversal while supporting statistical analysis of bucket distribution. It includes submodules for combining hash values, hash-consing sets with computed keys, and decoupling equality and hash computation for user-defined types. Operations like `combine` merge hash components for composite data, while hash-consing functions store and retrieve canonical values based on user-defined logic. Examples include interning strings, hashing tuples, and optimizing memory in symbolic computation through controlled hash key management.",
      "description_length": 643,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Trie",
      "library": "rocq-runtime.clib",
      "description": "This module provides a generic trie structure parameterized over key types and group operations, enabling insertion, lookup, deletion, and folding over hierarchical data. It supports list-based keys with values stored at end nodes, allowing prefix-based searches, auto-completion, and routing table implementations. Submodules extend functionality with algebraic operations for combining and inverting tries, as well as abstract traversal and manipulation of label-path associations. Example uses include hierarchical indexing, version-controlled data deltas, and efficient dictionary storage with path-based decomposition.",
      "description_length": 623,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Terminal",
      "library": "rocq-runtime.clib",
      "description": "This module defines operations for constructing, combining, and rendering terminal text styles using ANSI escape sequences. It works with structured style values that include foreground and background colors, text attributes like bold or underline, and optional prefix/suffix strings. Concrete use cases include coloring terminal output based on file types, applying visual emphasis to log messages, and generating styled command-line interface elements.",
      "description_length": 454,
      "index": 220,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unicode",
      "library": "rocq-runtime.clib",
      "description": "This module handles Unicode character classification, identifier validation, and string transformations for UTF-8 compatibility. It operates on integers representing Unicode code points and strings, providing functions to check identifier validity, convert characters, and manage non-ASCII content. Use cases include sanitizing identifiers, validating UTF-8 strings, and converting Unicode strings to ASCII-safe representations.",
      "description_length": 428,
      "index": 221,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mutex_aux",
      "library": "rocq-runtime.clib",
      "description": "Handles synchronized execution of functions using mutual exclusion locks. It provides a function that takes a mutex and a scoped function, running the function while holding the lock. Useful for ensuring thread-safe access to shared resources like counters or stateful data structures.",
      "description_length": 285,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Heap",
      "library": "rocq-runtime.clib",
      "description": "This module implements priority queues using binary heaps, supporting insertion, extraction of the minimum or maximum element, and heap construction. It works with ordered data types like integers and floats, as well as custom types with defined comparison functions, enabling efficient management of dynamic collections where elements are processed by priority. The core functionality supports both min-heap and max-heap semantics through its submodules, allowing for $O(1)$ access to extreme elements and $O(\\log n)$ insertion and removal. Examples include scheduling tasks, maintaining top-k results, and implementing graph or greedy algorithms requiring ordered element processing.",
      "description_length": 685,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Store",
      "library": "rocq-runtime.clib",
      "description": "This module provides a polymorphic key-value store with operations to add, retrieve, and remove values using hashable keys, enabling efficient state management and caching. It supports typed and untyped value storage through its submodules, allowing creation of extensible records or dynamic configuration objects with runtime-modifiable fields. You can use it to manage application state, cache computed results, or build flexible data structures with named, mutable fields. The API includes direct store manipulation alongside typed field management, merging capabilities, and runtime field definition.",
      "description_length": 604,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Number_string_notation_plugin.Number_string",
      "library": "number_string_notation_plugin",
      "description": "This module defines and registers number and string notations with custom parsing and printing behavior. It supports associating notations with qualified identifiers and specifying transformation rules through options like `Via` or `After`. Concrete use cases include extending the concrete syntax for numbers and strings in a proof assistant, enabling user-defined notations for specific scopes.",
      "description_length": 396,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Number_string_notation_plugin.G_number_string",
      "library": "number_string_notation_plugin",
      "description": "This module defines Coq's vernacular argument types and entries for parsing number and string notations with customizable modifiers and mappings. It supports data types like boolean flags, qualified identifiers, and custom options for controlling number-string conversions. Concrete use cases include defining custom number representations, string encodings, and parsing directives in Coq's notation system.",
      "description_length": 407,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Number_string_notation_plugin",
      "library": "number_string_notation_plugin",
      "description": "This module enables the extension of concrete syntax for numbers and strings through customizable parsing and printing rules, supporting user-defined notations within specific scopes. It provides data types such as qualified identifiers, boolean flags, and transformation options like `Via` and `After`, allowing precise control over notation behavior. Operations include registering notations, defining conversion mappings, and specifying parsing modifiers. Example uses include introducing custom number formats, alternative string encodings, and scoped syntax extensions in a proof assistant's vernacular language.",
      "description_length": 617,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CLexer.Lexer.State",
      "library": "rocq-runtime.parsing",
      "description": "This module manages the state of a lexer, including initialization, retrieval, and storage of the current state. It works with a state type `t` and maintains a list of comments with their positions and content. Use it to track and manipulate the lexer's state during parsing, or to extract comments collected during lexing for further processing.",
      "description_length": 346,
      "index": 228,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CLexer.LexerDiff.State",
      "library": "rocq-runtime.parsing",
      "description": "This module manages a stateful context for tracking and retrieving comments during lexical analysis. It provides operations to initialize, set, and retrieve a global state object, as well as to drop the current state when no longer needed. The state includes a list of comments, each associated with a position range and content, used to support precise comment handling in parsing workflows.",
      "description_length": 392,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Symbol",
      "library": "rocq-runtime.parsing",
      "description": "This module constructs and manipulates grammar symbols for defining parsers, including non-terminal and terminal symbols, repetition patterns like lists and optional elements, and direct references to recursive and next-level grammar rules. It works with grammar entries, tokens, and rule sets to build structured syntactic elements. Concrete use cases include defining list productions with and without separators, referencing recursive grammar components, and embedding token recognizers directly into parsing rules.",
      "description_length": 518,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Lookahead",
      "library": "rocq-runtime.parsing",
      "description": "This module defines combinators and primitives for constructing lookahead parsers that operate on token streams. It provides operations like sequence (`>>`), choice (`<+>`), and utilities for matching specific tokens such as keywords, identifiers, and natural numbers. Concrete use cases include defining grammatical constructs in the Rocq parser by composing token-level recognizers into structured parsing rules.",
      "description_length": 414,
      "index": 231,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Procq.Entry",
      "library": "rocq-runtime.parsing",
      "description": "This module defines entry points for parsing named constructs, supporting operations to create entries, parse input using associated parsers, and retrieve entry names. It works with token streams and parser functions that produce typed results, along with a heterogeneous list of entry values. Concrete use cases include registering and invoking specific parsers for language constructs, tracking entry names during parsing, and accumulating entries into a structured map for later lookup.",
      "description_length": 489,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CLexer.LexerDiff",
      "library": "rocq-runtime.parsing",
      "description": "This module implements token pattern matching and lexing functionality for parsing streams, working with token streams and keyword states. It provides operations to compare token patterns, extract token text, and match tokens against patterns, returning typed results. The integrated comment handling submodule tracks and retrieves comments with position ranges and content, enabling precise lexical analysis alongside tokenization workflows. Together, they support parsing source code input, managing lexical state transitions, and preserving comment metadata during token stream processing.",
      "description_length": 592,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Prim",
      "library": "rocq-runtime.parsing",
      "description": "This module provides low-level lexical and syntactic parsers for constructing Coq's abstract syntax trees from string inputs, handling core elements like identifiers, numeric literals, qualified references, and universe declarations. It operates on primitive Coq syntax components and structured parsers for tactic language elements, supporting use cases in Coq's frontend parsing of proofs, strategies, and module paths.",
      "description_length": 421,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CLexer.Lexer",
      "library": "rocq-runtime.parsing",
      "description": "This module implements a lexer for parsing tokens from character streams, managing state transitions and keyword recognition through functions like `tok_func` and `tok_match`. It supports building custom parsers for programming languages or structured data formats by converting character streams into tagged tokens based on lexical rules. The state module handles initialization, retrieval, and storage of the lexer's state, allowing manipulation of context during parsing and extraction of collected comments with their positions and content. Together, they enable precise control over lexical analysis and comment tracking in complex parsing workflows.",
      "description_length": 655,
      "index": 235,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Procq.Rules",
      "library": "rocq-runtime.parsing",
      "description": "This module constructs and manages parsing rules for the Rocq parser, focusing on creating reusable rule combinators. It works with grammar definitions and parser functions that process token streams into structured values. Concrete use cases include defining custom syntax extensions and parsing domain-specific languages embedded within Rocq.",
      "description_length": 344,
      "index": 236,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Procq.Rule",
      "library": "rocq-runtime.parsing",
      "description": "This module defines combinators for building recursive and non-recursive grammar rules, primarily using `stop` to terminate rules and `next` / `next_norec` to sequence symbols within rules. It operates on grammar rule and symbol types parameterized by self, recursion status, result types, and final return types. Concrete use cases include constructing complex parser rules from simpler components in a type-safe manner, such as defining expressions, statements, or nested structures in a grammar.",
      "description_length": 498,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CLexer.Error",
      "library": "rocq-runtime.parsing",
      "description": "This module defines an error type for handling lexical analysis errors in C-like syntax. It includes a function to convert error values into human-readable strings. Use this module to report and display syntax errors during tokenization of C-based source code.",
      "description_length": 260,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Production",
      "library": "rocq-runtime.parsing",
      "description": "This module defines and constructs productions for parsing rules, primarily using the `make` function to create a production from a rule and a function. It works with abstract syntax tree nodes and location data to build structured parse results. Concrete use cases include defining grammar productions that map parsed tokens to typed values within the Rocq parser.",
      "description_length": 365,
      "index": 239,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Procq.Module",
      "library": "rocq-runtime.parsing",
      "description": "This module defines entry points for parsing module expressions and module types in the Rocq language. It works with abstract syntax trees represented by `Constrexpr.module_ast` and provides parsing rules for constructing modules and module types from source input. Concrete use cases include parsing module declarations and type signatures during compiler front-end processing.",
      "description_length": 378,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq.Constr",
      "library": "rocq-runtime.parsing",
      "description": "This module handles parsing and construction of Coq's surface syntax elements, including terms, patterns, binders, and type constraints, producing and manipulating values of the `Constrexpr` type hierarchy. It provides operations to build and transform syntax tree nodes like `constr_expr` for expressions, type annotations, record declarations, and function arguments, with support for binder scoping and global reference resolution. These capabilities are used to implement Coq's parser and quotation mechanisms, particularly for handling complex expressions involving dependent types, implicit arguments, and higher-order abstract syntax.",
      "description_length": 641,
      "index": 241,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Procq.Parsable",
      "library": "rocq-runtime.parsing",
      "description": "This module provides functions to create and manipulate parsable input streams, primarily handling character-based input with position tracking. It supports operations to consume characters, retrieve comments with their positions, and access the current source location. Concrete use cases include parsing source code files where precise location tracking and comment extraction are required.",
      "description_length": 392,
      "index": 242,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Procq.GramState",
      "library": "rocq-runtime.parsing",
      "description": "This module manages a dynamic, key-value store for grammar-related state during parsing, where keys are typed fields and values can be any marshallable data. It supports creating, setting, getting, and removing typed fields, as well as merging state from multiple sources. Useful for tracking contextual information like symbol tables, parser flags, or intermediate results across grammar rules.",
      "description_length": 395,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tok",
      "library": "rocq-runtime.parsing",
      "description": "This module defines the token type used by the Rocq lexer and parser, including variants for keywords, identifiers, numbers, strings, and special symbols. It provides functions to compare tokens, extract their string representation, and process quotation delimiters. Concrete use cases include pattern matching in grammar rules and generating error messages with token names during parsing.",
      "description_length": 390,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pcoq",
      "library": "rocq-runtime.parsing",
      "description": "This component offers functionalities for constructing and modifying grammars through rule and symbol manipulation, alongside managing parser state transitions via freezing, registration, and keyword context handling. It operates on data structures such as grammar entries, frozen parser snapshots (`frozen_t`), and lexical keyword states (`CLexer.keyword_state`). These capabilities support use cases like building extensible parsing frameworks, implementing synchronized grammar extensions with undo support, and maintaining dynamic keyword registration during parsing.",
      "description_length": 571,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "G_constr",
      "library": "rocq-runtime.parsing",
      "description": "This module defines a set of entry points for parsing and validating specific syntactic constructs in a formal proof or term construction system. It includes tests for identifiers, natural numbers, annotations, and structural symbols like parentheses and array delimiters. These entries are used to enforce correct syntax during term parsing or tactic application in a proof assistant or logical framework.",
      "description_length": 406,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Procq",
      "library": "rocq-runtime.parsing",
      "description": "This module orchestrates parsing workflows by combining grammar definitions, symbol manipulations, and state management to enable structured parsing of complex syntax. It provides core operations for defining and composing grammar rules, lookahead parsers, and entry points, while supporting dynamic grammar extensions and context-sensitive parsing through stateful tracking. Users can construct typed productions, parse Coq expressions and modules, manage token streams with precise location tracking, and define recursive or iterative grammar patterns with type-safe combinators. Concrete applications include building custom language parsers, extending existing grammars with new syntax, and implementing interpreters that require fine-grained control over parsing behavior and runtime state.",
      "description_length": 795,
      "index": 247,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Extend",
      "library": "rocq-runtime.parsing",
      "description": "This module defines data structures and equality checks for entry keys used in grammar productions, specifically handling positions and levels within parsing rules. It supports concrete use cases like specifying where and how non-terminals should be parsed in Coq's grammar, such as associating entry keys with specific syntactic constructs (e.g., \"x ident\" or \"x bigint\"). Key types include `production_position`, `production_level`, and `constr_entry_key`, which are used to control parsing behavior and resolve ambiguities in grammar rules.",
      "description_length": 543,
      "index": 248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "G_prim",
      "library": "rocq-runtime.parsing",
      "description": "This module defines test cases for specific operations in a system. It includes tests for handling of closed curly braces in a pipeline context and subtraction of natural numbers. These tests are used to verify correct behavior of parsing and arithmetic operations.",
      "description_length": 265,
      "index": 249,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CLexer",
      "library": "rocq-runtime.parsing",
      "description": "This module manages keyword and identifier validation for lexing, supporting operations to define and check keywords with optional quotation states, validate identifiers, and construct terminal parsers for keywords and numeric literals. It works with strings, token types, and lexing locations to enable precise lexing for custom languages, such as defining language-specific keywords, validating variable names, or resuming lexing from specific positions. The token pattern matching submodule enables typed token comparison, pattern extraction, and integrated comment handling with position tracking, supporting lexical analysis that preserves comment metadata. The character stream lexer submodule implements stateful token parsing with keyword recognition and error handling for C-like syntax, allowing construction of custom parsers with precise control over lexical state and error reporting.",
      "description_length": 897,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation_gram",
      "library": "rocq-runtime.parsing",
      "description": "This module defines data structures for representing grammatical productions of notations, including terminals, non-terminals, and list markers. It provides types for specifying notation levels, associativity, and corresponding Coq expressions. Used to encode how notations map to abstract syntax trees in the Coq proof assistant.",
      "description_length": 330,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notgram_ops",
      "library": "rocq-runtime.parsing",
      "description": "This module manages the declaration and retrieval of notation grammar rules and non-terminal symbols for parsing. It provides operations to associate grammars and non-terminals with notations, look up existing associations, and find the longest common prefix among declared notations. It is used to implement custom parsing rules for notations in a concrete syntax.",
      "description_length": 365,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Mlutil.Mlenv",
      "library": "extraction_plugin",
      "description": "This module manages a typed environment stack for ML type information, supporting operations to add types and retrieve them by index. It works with `ml_type` values from the `Miniml` module, maintaining an environment structure for type tracking. It is used during type processing to manage type variable scoping and resolution in a stack-based manner.",
      "description_length": 352,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Table.Refmap'",
      "library": "extraction_plugin",
      "description": "This module implements a polymorphic map structure with keys of type `Names.GlobRef.t`, supporting associative operations like insertion, deletion, lookup, merging, and predicate-driven filtering. It provides keyed transformations via `mapi`, arbitrary element selection, and ordered list conversion, enabling deterministic processing of heterogeneous data where reference-based keys dictate value organization or traversal order.",
      "description_length": 430,
      "index": 254,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Extraction_plugin.Table.Refset'",
      "library": "extraction_plugin",
      "description": "This module provides functional set operations for managing immutable collections of global references, supporting standard manipulations like union, intersection, difference, and membership testing. It operates on a set structure storing elements of type `Names.GlobRef.t`, with additional utilities to inspect size, list all elements, or select an arbitrary element. Such functionality is useful in contexts like program analysis or compiler passes, where persistent reference tracking and non-destructive set transformations are required.",
      "description_length": 541,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.G_extraction",
      "library": "extraction_plugin",
      "description": "This module defines generalized argument types for Coq's extraction commands, specifically handling integer-or-identifier, language, and ML name arguments. It provides the necessary wrappers to integrate these argument types into Coq's vernacular command system. These are used when processing extraction-related commands like `Extraction`, `Recursive Extraction`, and `Extraction Language`.",
      "description_length": 391,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Mlutil",
      "library": "extraction_plugin",
      "description": "This module provides utilities for manipulating ML abstract syntax trees, handling type operations like instantiation and simplification, and transforming terms by removing type data or anonymizing identifiers. It includes a typed environment stack for tracking `ml_type` values, enabling scoped type variable resolution and environment queries during AST processing tasks like substitution and normalization. With this module, developers can optimize extracted code, analyze signature structures, and manage lambda abstractions or pattern matches efficiently. Specific operations include expunging unused variables, simplifying type representations, and maintaining type environments during term transformations.",
      "description_length": 713,
      "index": 257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Extraction_plugin.Extraction",
      "library": "extraction_plugin",
      "description": "This module implements core routines for translating Coq terms and declarations into OCaml-like abstract syntax trees. It handles constants, inductive types, fixpoints, and type specifications, producing output used by the Coq extraction mechanism to generate OCaml code. Functions like `extract_constant`, `extract_inductive`, and `extract_fixpoint` process Coq's internal representations into equivalent ML structures, while helpers like `extract_with_type` and `extract_constr` support type-driven term extraction.",
      "description_length": 517,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Ocaml",
      "library": "extraction_plugin",
      "description": "Defines an OCaml description for the extraction plugin, specifying how to translate terms into OCaml syntax. It includes functions for generating variable names, handling type declarations, and emitting OCaml code from internal structures. This module is used when extracting Coq definitions to executable OCaml code, ensuring proper syntax and type representation.",
      "description_length": 365,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Json",
      "library": "extraction_plugin",
      "description": "Binds a language description for JSON processing, enabling parsing and serialization of JSON data. It operates on JSON abstract syntax trees, facilitating transformations and validations of JSON structures. Useful for implementing JSON-based APIs or configuration parsers.",
      "description_length": 272,
      "index": 260,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Miniml",
      "library": "extraction_plugin",
      "description": "This module defines core data structures and types for representing OCaml-like abstract syntax trees and signatures, including types for inductive definitions, terms, patterns, and modules. It supports operations for type manipulation, inductive packet construction, and declaration handling, tailored for code extraction tasks. Concrete use cases include generating OCaml code from Coq definitions, managing type equivalences, and handling module structures during extraction.",
      "description_length": 477,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Haskell",
      "library": "extraction_plugin",
      "description": "This module defines the language description for Haskell code generation, specifying how OCaml constructs are translated into equivalent Haskell syntax. It maps OCaml types and expressions to their Haskell counterparts, handling data structures like algebraic types, functions, and pattern matching. It is used during the extraction process to generate correct and idiomatic Haskell code from OCaml sources.",
      "description_length": 407,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Extract_env",
      "library": "extraction_plugin",
      "description": "This module handles the extraction of Coq terms into ML code, providing functions to extract specific identifiers, entire libraries, or compute ML structures from Coq environments. It operates on qualified identifiers, ML structures, and Coq terms, producing ML declarations and types for compilation or display. Concrete use cases include extracting Coq functions into executable ML code, generating ML modules from Coq developments, and printing extracted ML declarations for debugging or integration.",
      "description_length": 503,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Scheme",
      "library": "extraction_plugin",
      "description": "This module defines the language description for the Scheme extraction target, specifying how OCaml constructs are translated into Scheme. It includes mappings for types, expressions, and declarations, ensuring correct generation of Scheme code from OCaml sources. It is used during the extraction process to customize the output for Scheme-specific syntax and semantics.",
      "description_length": 371,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin.Modutil",
      "library": "extraction_plugin",
      "description": "This module provides functions for analyzing and transforming ML AST structures, including searching for specific AST nodes, iterating over references in types and expressions, and extracting signatures from structures. It operates on data types such as `ml_ast`, `ml_type`, `ml_structure`, and `ml_module_type`, and supports tasks like reference tracking, type inspection, and structure optimization. Concrete use cases include extracting module signatures, identifying specific declarations within a structure, and optimizing module structures based on reference usage.",
      "description_length": 571,
      "index": 265,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Extraction_plugin.Table",
      "library": "extraction_plugin",
      "description": "This module coordinates consistency checks and configuration controls for Coq's extraction mechanism, working with module paths, global references, kernel names, and inductive definitions to resolve naming conflicts and optimize code generation. It includes a polymorphic map structure for organizing heterogeneous data using global references as keys, supporting operations like insertion, lookup, and transformation, as well as a functional set module for immutable collections of references used in program analysis and compiler passes. You can use it to validate term visibility, manage inlining policies, maintain blacklists during extraction, or perform deterministic traversal and filtering of reference-keyed data. The combination of direct configuration tools with rich data structures enables precise control over extraction behavior and efficient manipulation of global reference-based data.",
      "description_length": 902,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Extraction_plugin",
      "library": "extraction_plugin",
      "description": "This module system provides comprehensive infrastructure for extracting Coq code into multiple target languages, including OCaml, Haskell, Scheme, and JSON. It defines generalized argument types for extraction commands, supports manipulation of ML abstract syntax trees with typed environments, and implements language-specific translations that preserve type structure and semantics. Core operations include extracting Coq terms into ML-like ASTs, transforming and optimizing those ASTs, and emitting executable code in the target language. Developers can perform tasks like extracting and optimizing OCaml code, generating module signatures, validating JSON structures, or translating Coq definitions into Haskell or Scheme.",
      "description_length": 726,
      "index": 267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Dep_info.Dep.Set.List",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module provides functions to compute the union of a list of dependency sets, where each set represents dependencies in a Coq project. It operates on lists of `Coqdeplib.Dep_info.Dep.Set.t` values and returns a single set containing all elements from the input sets. A typical use case involves aggregating dependencies from multiple files or modules into a single set for analysis or processing.",
      "description_length": 400,
      "index": 268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Dep_info.Dep.Set",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module implements a functional set library for managing immutable collections of dependency elements, supporting standard operations like union, intersection, difference, membership checks, and extremal element access. It provides the core type `Dep.Set.t` for sets of elements of type `Dep.Set.elt`, along with functions to convert between sets and lists or sequences. One child module specializes in aggregating dependencies from multiple Coq project files by computing the union of a list of dependency sets, returning a consolidated `Coqdeplib.Dep_info.Dep.Set.t` value for further analysis. This enables efficient, persistent set-based computations over hierarchical data, particularly in dependency tracking and multi-module dependency resolution.",
      "description_length": 758,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Fl.Internal",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module provides a function `get_worker_path` that retrieves the path to the worker executable used by the system. It operates on basic string data types and is specifically used to locate the worker binary during execution. A concrete use case is determining the correct path to spawn or reference the worker process in distributed or multi-process applications.",
      "description_length": 367,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Common.StrSet",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module provides ordered sets of strings with standard set operations like union, intersection, and difference, along with efficient membership testing and ordered traversal. It supports transformations through mapping, filtering, and folding, as well as conversions to and from lists and sequences, maintaining canonical sorted order. Use cases include managing sorted string collections, functional set manipulation with ordered elements, and scenarios requiring predicate-based selection or integration with sequential data processing.",
      "description_length": 542,
      "index": 271,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coqdeplib.Common.State",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module provides access to the loadpath component of a global state structure, allowing retrieval of the current loadpath state. It operates on a global state type `t` that encapsulates various components, including the loadpath. A concrete use case is querying the current loadpath configuration during the execution of Coq commands or plugins.",
      "description_length": 349,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Dep_info.Dep",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module represents dependency information for Coq projects, handling Coq modules, plugin modules, and auxiliary files through a structured set-based interface. It supports operations like union, intersection, and membership checks over dependency sets, with the core type `Dep.Set.t` enabling immutable, persistent manipulation of collections. A dedicated submodule aggregates dependencies across project files by computing the union of multiple sets, facilitating consolidated analysis of inter-module dependencies. These capabilities enable concrete use cases such as dependency resolution and build management in Coq tooling.",
      "description_length": 632,
      "index": 273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Loadpath.State",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module manages load path state for Coq projects, providing a `make` function to initialize the state with a worker and boot flag. It works with string options and boolean flags to configure the environment. Concrete use cases include setting up Coq's load path during initialization or in worker processes for parallel proof checking.",
      "description_length": 339,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Args",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module defines a configuration structure for command-line arguments with boolean flags and path lists. It provides functions to initialize default settings, display usage information, and parse command-line inputs into the configuration structure. Concrete use cases include setting up build options for Coq projects, managing file paths during compilation, and handling dynamic dependencies in proof scripts.",
      "description_length": 414,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Error",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module defines functions for raising errors during file parsing and project setup, including failures to open or parse files with specific error messages and location information. It works with strings to represent file names or error contexts and optional position data as integer pairs. These functions are used to handle and report critical failures in reading or interpreting project configuration and source files.",
      "description_length": 424,
      "index": 276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Lexer",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module defines token types for parsing Coq code, including qualified identifiers and load paths. It provides a function to lex Coq source code into structured tokens representing commands like `Require`, `Declare`, `Load`, and `External`. These tokens capture the hierarchical structure of Coq modules and references, enabling analysis or transformation of Coq code.",
      "description_length": 371,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Dep_info",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module manages dependency information for Coq projects, combining structured representations of Coq modules, plugin modules, and auxiliary files with operations to construct and analyze dependency graphs. It provides core data types like `Dep.Set.t` for immutable sets of dependencies, supporting union, intersection, and membership checks, while a dedicated submodule aggregates dependencies across files through set union. You can use it to resolve dependencies, manage builds, or analyze inter-module relationships in Coq projects by working directly with dependency sets or combining them across multiple sources.",
      "description_length": 622,
      "index": 278,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coqdeplib.Common",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module coordinates dependency resolution for Coq files by initializing configuration state, processing command-line inputs, and computing ordered dependency lists for build systems. It works with state structures and string sets, using operations like file addition, dependency sorting, and loadpath querying. The string set submodule enables functional manipulation of ordered string collections through union, intersection, and traversal, while the loadpath submodule gives access to global state components for runtime configuration checks. You can, for example, process a list of Coq files into a sorted dependency graph, filter loadpath entries based on project settings, or fold over a set of module names to generate build rules.",
      "description_length": 741,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Static_toplevel_libs",
      "library": "rocq-runtime.coqdeplib",
      "description": "Contains a list of standard library modules automatically opened in the toplevel environment. It provides direct access to commonly used libraries without requiring explicit open statements. This list is used during the initialization of the OCaml toplevel to pre-load essential modules like `Pervasives`, `List`, and `String`.",
      "description_length": 327,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.File_util",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module provides functions for manipulating file paths, specifically converting absolute paths to relative ones and normalizing paths by removing redundant components. It operates on string representations of file paths, handling edge cases like trailing slashes and current/parent directory references. Use cases include preparing file paths for display, ensuring consistent path formatting, and resolving paths relative to the current working directory.",
      "description_length": 459,
      "index": 281,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coqdeplib.Fl",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module resolves file paths for OCaml packages, locating `.cmxs` files and their dependencies using string-based operations. It includes a child module that provides `get_worker_path`, which retrieves the path to a worker executable, aiding in spawning or referencing worker processes. Together, they support runtime discovery of plugins and auxiliary binaries, such as determining a package's native plugin path or the executable for a distributed application's worker. Example uses include dynamically loading a `.cmxs` plugin and launching a worker process using its resolved path.",
      "description_length": 588,
      "index": 282,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coqdeplib.Rocqdep_main",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module defines the `main` function that processes a list of command-line arguments and performs operations related to Coq project dependency management. It works directly with string lists as input, typically representing file paths or module names. A concrete use case includes analyzing and printing dependencies for Coq projects based on provided source files.",
      "description_length": 368,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Loadpath",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module manages path resolution and directory registration for Coq's loadpath system, combining core operations like logical-to-physical path mapping with state management for Coq projects. It provides data types such as `dirpath` and `root` to support operations including module import resolution, file search, and absolute path construction, while its child module initializes load path state using worker configurations and boot flags. Use cases include organizing source dependencies, validating library paths, and setting up parallel proof checking environments. Direct API functions handle path manipulation and resolution, while submodules focus on environment initialization and state configuration.",
      "description_length": 712,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib.Makefile",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module generates and manages dependency files for Coq projects. It provides functions to print dependency information, control dynamic dependencies, disable globbing, and configure VOS file writing. It works with file paths and dependency structures to support build systems tracking Coq source dependencies.",
      "description_length": 313,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqdeplib",
      "library": "rocq-runtime.coqdeplib",
      "description": "This module suite provides tools for configuring, parsing, and resolving dependencies in Coq projects. It centers around data types like configuration structures, token streams, dependency sets, and path representations, with operations to parse command-line arguments, lex Coq source code, manage load paths, and construct dependency graphs. You can use it to analyze Coq code structure, resolve module imports, normalize file paths, and generate build rules. Specific tasks include processing command-line inputs into project settings, extracting dependencies from source files, and dynamically loading plugins or workers based on resolved paths.",
      "description_length": 648,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Debugger_support",
      "library": "rocq-runtime.debugger_support",
      "description": "Controls low-level debugging output with a mutable boolean flag. Works directly with OCaml's standard `bool` and `Stdlib.ref` types. Useful for conditionally enabling or suppressing debug logs in development without recompiling code.",
      "description_length": 233,
      "index": 287,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Rules",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines combinators for constructing and manipulating grammar rules, supporting the definition of extensible grammars with precise entry points and recursive structures. It operates on data types representing grammar entries, productions, and semantic actions, enabling the creation of complex parsers with location-aware error handling. Concrete use cases include implementing domain-specific languages, parsing structured text formats, and building custom syntax extensions.",
      "description_length": 488,
      "index": 288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Unsafe",
      "library": "rocq-runtime.gramlib",
      "description": "This module provides low-level operations for manipulating extensible grammars, including functions for adding and removing grammar rules dynamically. It works directly with grammar entries and their associated states, enabling modifications to parsing behavior at runtime. Concrete use cases include implementing domain-specific languages with customizable syntax and extending existing grammars without recompilation.",
      "description_length": 419,
      "index": 289,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Symbol",
      "library": "rocq-runtime.gramlib",
      "description": "This module provides combinators for constructing grammar symbols used in defining extensible grammars. It supports operations like `nterm` for non-terminal symbols, `token` for matching lexical tokens, and list combinators like `list0`, `list1`, and their separator variants for handling sequences. These symbols are used to build parsing rules that map directly to grammar entries, enabling precise control over syntax extensions in the grammar system.",
      "description_length": 454,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Parsable",
      "library": "rocq-runtime.gramlib",
      "description": "This module provides functions to create and manipulate parsable input streams for extensible grammars, including tracking comments and source locations. It works with character streams and grammar entries, supporting precise parsing control through stream position updates and keyword state management. Concrete use cases include parsing source code with embedded comments and handling grammar extensions in domain-specific language implementations.",
      "description_length": 450,
      "index": 291,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.GMake.EState",
      "library": "rocq-runtime.gramlib",
      "description": "This module manages extensible grammar entries and their associated states, providing operations to extend and manipulate grammars dynamically. It works with grammar entries, their levels, and associated data such as entry points and rules. Concrete use cases include defining and modifying parsing rules for domain-specific languages at runtime, and integrating user-defined extensions into the grammar without recompilation.",
      "description_length": 426,
      "index": 292,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.GMake.GState",
      "library": "rocq-runtime.gramlib",
      "description": "This module manages the state of grammar entries during parsing, tracking both the current parsing position and keyword recognition. It provides functions to update and query the state as the parser processes input. Concrete use cases include maintaining context while parsing extensible grammars and handling keyword transitions in the grammar.",
      "description_length": 345,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Entry",
      "library": "rocq-runtime.gramlib",
      "description": "This module manages grammar entries for extensible grammars, providing operations to create, parse, and inspect entries. It works with entries tied to specific grammars, handling token streams and parser functions. Concrete use cases include defining entry points for custom syntax extensions and parsing structured input according to defined grammars.",
      "description_length": 352,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Production",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines and manipulates grammar productions for extensible grammars, primarily working with `Production.t` and `Rule.t` types. It provides operations to construct and combine grammar rules, enabling the definition of complex syntactic structures. Concrete use cases include building custom parsers for domain-specific languages and extending existing grammars with new syntactic constructs.",
      "description_length": 402,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.GMake.Rule",
      "library": "rocq-runtime.gramlib",
      "description": "This module constructs and combines parsing rules for extensible grammars, enabling the definition of grammar entries through sequential composition of symbols. It operates on rule and symbol types parameterized by grammar entry states, supporting both recursive and non-recursive extensions. Concrete use cases include building custom parsers for domain-specific languages by chaining token recognizers and embedding semantic actions within grammar definitions.",
      "description_length": 462,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.ExtS-Production",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines operations for constructing and manipulating grammar productions, primarily through the `make` function, which creates a production from a rule and a function. It works with abstract syntax tree nodes and grammar entries parameterized by location information. Concrete use cases include defining custom parsing rules for extending OCaml syntax via Camlp5, such as adding new constructs or domain-specific languages directly within source code.",
      "description_length": 463,
      "index": 297,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.S-Parsable",
      "library": "rocq-runtime.gramlib",
      "description": "This module provides functions to create and manipulate parsable grammar entries from character streams, including tracking comments and source locations. It works with streams of characters and grammar entries extended via Camlp5's `EXTEND` syntax. Concrete use cases include parsing source code with embedded comments and handling grammars that evolve through extensions.",
      "description_length": 373,
      "index": 298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.ExtS",
      "library": "rocq-runtime.gramlib",
      "description": "This module supports manipulating extensible grammars through operations like safely extending or deleting grammar entries and rules. It works with grammar components such as entries, symbols, productions, and parser states. Concrete use cases include defining and modifying parsing rules for custom languages or domain-specific syntax extensions.",
      "description_length": 347,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Plexing.S",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines the lexer type and associated operations for building and manipulating lexers in Camlp5 grammars. It works with token streams, patterns, and keyword states, providing functions to match tokens, extract text, and handle lexical analysis with location tracking. Concrete use cases include implementing custom lexers for domain-specific languages and extending existing grammars with new lexical constructs.",
      "description_length": 424,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.ExtS-Symbol",
      "library": "rocq-runtime.gramlib",
      "description": "This module provides symbolic representations of grammar constructs for building and manipulating extensible grammars. It supports operations for defining non-terminal symbols, handling lists with and without separators, optional elements, and direct token matching. These capabilities enable precise grammar extensions and custom parsing rules for domain-specific languages.",
      "description_length": 375,
      "index": 301,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.GMake",
      "library": "rocq-runtime.gramlib",
      "description": "This module implements an extensible grammar parsing system that allows dynamic definition and modification of grammar entries, rules, and symbols. It provides core data types such as grammar entries, productions, rules, and symbols, along with operations to construct, combine, and manipulate them, supporting recursive structures and semantic actions. The system enables runtime modification of grammars through low-level rule management, symbol combinators for sequence handling, and state tracking for context-sensitive parsing. Specific applications include building and extending domain-specific language parsers, handling structured text formats with location-aware error reporting, and integrating user-defined syntax extensions without recompilation.",
      "description_length": 759,
      "index": 302,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.ExtS-EState",
      "library": "rocq-runtime.gramlib",
      "description": "This module manages extensible grammar states, supporting dynamic modification of grammar entries through operations like adding or removing rules. It works with grammar entries and parsing states to enable runtime grammar extensions. Concrete use cases include implementing domain-specific language extensions and modifying parser behavior in response to loaded modules or user input.",
      "description_length": 385,
      "index": 303,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.ExtS-Entry",
      "library": "rocq-runtime.gramlib",
      "description": "This module manages extensible grammar entries, providing operations to create, parse, and manipulate entries using custom parsers and token streams. It supports data types like `Entry.t`, `EState.t`, and `GState.t`, along with utilities for tracking and printing entry states. Concrete use cases include defining custom syntax extensions, parsing structured input with dynamic grammars, and inspecting grammar entry contents during parsing sessions.",
      "description_length": 450,
      "index": 304,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.S-Rules",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines operations for constructing and manipulating grammar rules, centered around the `make` function that creates a rule from a specification and a function. It works with abstract rule types that represent grammar entries, supporting the definition of extensible grammars with location-aware parsing. Concrete use cases include building custom parsing rules for domain-specific languages and extending existing grammars with new constructs.",
      "description_length": 456,
      "index": 305,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.S-Production",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines the structure and operations for building and manipulating grammar productions. It works with extensible grammar entries and supports the creation of parsing rules using the `make` function, which constructs a production from a rule and a function. Concrete use cases include defining custom syntax extensions in OCaml parsers, such as adding new constructs to the language grammar through the `EXTEND` statement.",
      "description_length": 433,
      "index": 306,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.ExtS-Unsafe",
      "library": "rocq-runtime.gramlib",
      "description": "This module provides low-level operations for manipulating extensible grammar entries, including functions to clear and update entry states. It works directly with grammar entries and their associated state structures. Concrete use cases include modifying parser behavior at runtime by resetting or altering specific grammar rules.",
      "description_length": 331,
      "index": 307,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.S-Symbol",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines symbolic representations of grammar constructs used to build extensible parsers. It supports operations like `nterm` for non-terminal symbols, `token` for terminal symbols, and combinators like `list0`, `list1`, and `opt` for handling repetitions and optional elements. These functions work directly with grammar entries and patterns to define parsing rules for concrete syntax structures, such as expressions, statements, or custom domain-specific languages.",
      "description_length": 479,
      "index": 308,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.ExtS-Parsable",
      "library": "rocq-runtime.gramlib",
      "description": "This module provides functions to create and manipulate parsable grammar entries, including extracting comments, retrieving source locations, and consuming input during parsing. It works with `Parsable.t` values, which represent parsed grammar entries, and interacts with streams and keyword states. Concrete use cases include building extensible parsers that track comment positions, manage source code locations, and handle keyword recognition during parsing.",
      "description_length": 461,
      "index": 309,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.ExtS-Rule",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines rule construction operations for extensible grammars, including `stop` to terminate rules, `next` to sequence symbols with recursive rules, and `next_norec` for non-recursive rule extensions. It works with grammar entries, symbols, and rule types parameterized over self, recursion flags, and result types. Concrete use cases include building parser rules for custom syntax extensions in Camlp5, such as defining arithmetic expressions or custom literals.",
      "description_length": 475,
      "index": 310,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.S-Rule",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines combinators for building and composing grammar rules, centered around constructing sequences of symbols and handling recursion in extensible grammars. It provides operations like `next` and `next_norec` to chain symbols into rules, and `stop` to terminate rule definitions, all operating on the `Rule.t` type with varying recursion flags. It is used to define parser extensions in Camlp5, enabling concrete syntax extensions by combining symbols into structured parsing rules.",
      "description_length": 496,
      "index": 311,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar.ExtS-Rules",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines combinators for building and transforming grammar rules, supporting the creation of extensible grammars with location-annotated entries. It operates on rule types that represent grammar productions, enabling the extension of existing entries through functions like `make`. Concrete use cases include defining custom parsing rules for domain-specific languages and extending existing grammars with new syntactic constructs.",
      "description_length": 442,
      "index": 312,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.S",
      "library": "rocq-runtime.gramlib",
      "description": "This module provides operations for defining and extending grammars using Camlp5's extensible grammar system. It supports parsing operations through entries, symbols, rules, and productions, enabling the construction of complex grammars via the EXTEND statement. Concrete use cases include implementing domain-specific languages and custom parsers directly within OCaml code.",
      "description_length": 375,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.S-Entry",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines operations for creating and manipulating grammar entries, such as `make`, `of_parser`, and `parse`, which allow defining and applying grammars to input streams. It works with types like `'a Entry.t`, `Parsable.t`, and token streams, supporting parsing and state management. Concrete use cases include building custom parsers for domain-specific languages and extending grammars dynamically using loaded modules.",
      "description_length": 431,
      "index": 314,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Plexing.S-State",
      "library": "rocq-runtime.gramlib",
      "description": "This module manages the state of a Camlp5 lexer, providing operations to initialize, retrieve, set, and drop the current lexer state. It supports working with comment data through a list of position-marked strings. Use this module to maintain and manipulate lexer context during parsing of extensible grammars.",
      "description_length": 310,
      "index": 315,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Grammar.ExtS-GState",
      "library": "rocq-runtime.gramlib",
      "description": "This module manages the state of extensible grammars during parsing, tracking both entry and keyword states. It provides operations to update and query the current parsing context, including handling keyword recognition and entry transitions. Use it when implementing or extending grammars that require dynamic state changes, such as custom syntax extensions or domain-specific language parsers.",
      "description_length": 395,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.Plexing",
      "library": "rocq-runtime.gramlib",
      "description": "This module defines the lexer type and core operations for building and manipulating lexers in extensible grammars, working with token streams, patterns, and stateful analysis. It includes functions to create lexer rules, match tokens, and track positions, supporting custom lexers for domain-specific languages. The state module allows initializing, modifying, and managing lexer context, including handling comments and position data during parsing. Together, they enable constructing and extending grammars with precise lexical control and contextual tracking.",
      "description_length": 563,
      "index": 317,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Grammar",
      "library": "rocq-runtime.gramlib",
      "description": "This module implements an extensible grammar system that allows dynamic definition and modification of parsing rules through Camlp5's `EXTEND` syntax. It enforces strict grammar boundaries using OCaml's type system, ensuring safe composition of entries, symbols, and productions parameterized by location and state. Core operations include defining grammar entries with custom parsers, constructing rules using combinators like `nterm`, `token`, `list0`, and `opt`, and manipulating grammar states to support context-sensitive parsing. It enables building domain-specific parsers that evolve at runtime, such as interpreters with user-defined syntax or configuration file readers with extensible formats.",
      "description_length": 704,
      "index": 318,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Stream",
      "library": "rocq-runtime.gramlib",
      "description": "This module implements lazy streams with position tracking and supports parsing operations like element extraction, lookahead, and position manipulation. It works with stream values parameterized by an environment type and an element type, such as character streams for parsing text. Concrete use cases include incremental parsing of strings or input channels, resuming parsing from a specific offset, and implementing custom parsers with controlled element consumption.",
      "description_length": 470,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gramlib.LStream",
      "library": "rocq-runtime.gramlib",
      "description": "This module extends stream functionality with precise location tracking for parsing applications. It provides operations to create streams with location-annotated elements, retrieve positions of elements, and consume or inspect elements without altering the stream. Functions like `peek`, `next`, and `junk` handle element access and traversal, while `current_loc`, `max_peek_loc`, and `get_loc` support accurate error reporting and source mapping in parsers.",
      "description_length": 459,
      "index": 320,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib.Gramext",
      "library": "rocq-runtime.gramlib",
      "description": "Handles grammar extension operations with support for specifying associativity and position in grammar rules. Works with grammar definitions using `g_assoc` for associativity and `position` for rule placement. Used to define and manipulate parsing rules in OCaml grammar extensions, particularly in custom syntax or DSL implementations.",
      "description_length": 336,
      "index": 321,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Gramlib",
      "library": "rocq-runtime.gramlib",
      "description": "This module provides a comprehensive framework for building and extending grammars with precise lexical and syntactic control. It supports creating custom lexers that process token streams with stateful analysis, defining extensible parsing rules with combinators, and managing grammar entries parameterized by location and context. Lazy streams with position tracking enable incremental parsing and custom parser implementations, while location-aware operations facilitate accurate error reporting and source mapping. Examples include developing domain-specific languages with user-defined syntax, parsing configuration files with evolving formats, and implementing interpreters that support runtime grammar modifications.",
      "description_length": 723,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.MonadR.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations for working with computations in the `Evd.MonadR` monad, including mapping, folding, and filtering over lists with left-to-right or right-to-left traversal. It supports standard list transformations like `map`, `fold_left`, `fold_right`, and `iter`, along with specialized functions like `map_filter` and `fold_left2` for handling optional results and simultaneous iteration over two lists. These functions are used to sequence monadic actions that manipulate unification state, such as updating evar definitions or processing conversion constraints, while traversing list-structured data.",
      "description_length": 634,
      "index": 323,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview.Monad.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations for tactics, including mapping, folding, and filtering over lists with left-to-right or right-to-left traversal. It supports list-based control flow in tactic programming, enabling accumulation of results, conditional processing via filtering, and synchronized traversal of two lists with explicit length-checking. Concrete use cases include applying a sequence of transformations to proof goals, accumulating tactic results across multiple goals, and processing paired lists of hypotheses or terms in lockstep.",
      "description_length": 556,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.Logical.Unsafe",
      "library": "rocq-runtime.engine",
      "description": "This module provides low-level operations for manipulating the internal state of the tactic monad, including direct access and modification of the `rstate`, `ustate`, `wstate`, and `sstate` fields. It works with the `state` type, which encapsulates proof-related data, and uses `Logic_monad.BackState.t` to represent computations that transform this state. Concrete use cases include implementing custom tactics that require fine-grained control over proof state transitions or handling exceptions within the tactic monad using `Exninfo.iexn`.",
      "description_length": 543,
      "index": 325,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview.NonLogical.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations for working with the `Proofview.NonLogical.t` effectful context, supporting left-to-right and right-to-left traversal with sequencing of non-logical effects. It handles standard list transformations and iterations\u2014such as `map`, `fold`, `iter`, and `map_filter`\u2014while preserving the order of effects, and includes a `fold_left2` variant for simultaneous processing of two lists of equal length. These functions are used to manipulate lists of goals or other proof-related data within the proof engine, ensuring that side effects like I/O or state modifications are properly sequenced.",
      "description_length": 629,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.MiniEConstr.ERelevance",
      "library": "rocq-runtime.engine",
      "description": "This module provides functions to create and inspect relevance values for use in unification and type-checking contexts. It operates on the `t` type, which represents relevance as an abstract value tied to the unification state. Use cases include determining the sort relevance of existential variables and constructing relevance annotations for type inference during tactic execution.",
      "description_length": 385,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logic_monad.Logical.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations such as mapping, folding, and filtering, where each element transformation may involve backtracking or logical effects. It works with lists of values wrapped in a monadic type that supports backtracking, allowing computations to fail and retry during traversal. These functions are used to implement tactics that process or transform proof states in a logical context, such as applying rules across multiple hypotheses or accumulating results from goal manipulations.",
      "description_length": 512,
      "index": 328,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Logic_monad.Logical.Unsafe",
      "library": "rocq-runtime.engine",
      "description": "This module provides low-level monadic operations for manipulating and composing backtracking computations that operate on a composite state type consisting of `rstate`, `ustate`, `wstate`, and `sstate`. It includes functions to construct and deconstruct monadic values, enabling direct control over state transitions and exception handling during logical operations. Concrete use cases include implementing custom backtracking strategies and integrating effectful computations that require fine-grained state management.",
      "description_length": 521,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logic_monad.NonLogical.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations such as mapping, folding, and iteration where each element transformation involves non-logical effects. It supports left-to-right and right-to-left traversal, filtering with optional results, and strict two-list folding with length validation. These functions are used for handling lists within a non-logical monadic context, ensuring effects are sequenced correctly without backtracking.",
      "description_length": 433,
      "index": 330,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evd.MiniEConstr.EInstance",
      "library": "rocq-runtime.engine",
      "description": "This module provides low-level operations for creating and manipulating evar_map entries tied to existential variables in the unification state. It works directly with UVars.Instance.t and EInstance.t to manage instantiation data during unification and proof construction. Concrete use cases include initializing and inspecting evar_map entries for existential variables in the Rocq tactic engine.",
      "description_length": 397,
      "index": 331,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.MiniEConstr.ESorts",
      "library": "rocq-runtime.engine",
      "description": "This module provides functions to create and manipulate sort values within the unification state, primarily working with the `t` type representing sorts. It includes operations to construct sort values, retrieve their underlying sort kind, and perform unchecked conversion to standard sort types. Concrete use cases involve handling sort constraints during unification and managing sort information for existential variables.",
      "description_length": 425,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.Monad.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations for working with values in the `Evd.Monad` context, including mapping, folding, iteration, and filtering over single and paired lists. It supports functions that thread effects through computations involving lists of arbitrary types, with strict left-to-right or right-to-left evaluation order. Concrete use cases include transforming or accumulating values while maintaining unification state during tactic execution, such as processing lists of existential variables or constraints.",
      "description_length": 529,
      "index": 333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview_monad.Logical.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides list traversal and transformation functions within the `Proofview_monad.Logical` context, including mapping, filtering, and left/right folds that sequence monadic actions over list elements. It supports operations on lists of arbitrary types, producing transformed lists or accumulated results in the logical monad. Concrete use cases include applying tactics to each element of a list of goals or hypotheses, accumulating state across a list of terms during proof manipulation.",
      "description_length": 499,
      "index": 334,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.Pv",
      "library": "rocq-runtime.engine",
      "description": "This module provides direct access to the internal proofview state within the tactic monad, allowing retrieval, modification, and replacement of the current proofview. It operates on the `Proofview_monad.proofview` type, using the `Logical.t` monadic context. Concrete use cases include inspecting the current proof state, updating goals, and manipulating proof context during tactic execution.",
      "description_length": 394,
      "index": 335,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Termops.Internal",
      "library": "rocq-runtime.engine",
      "description": "This module provides low-level term and environment printing utilities for debugging and specialized output scenarios. It operates on Coq's internal term representations, including `EConstr.constr`, `Evd.evar_map`, and `Environ.env`, with functions for printing raw terms, contexts, and declarations. Concrete use cases include inspecting terms during development, displaying internal state in debugging tools, and custom pretty-printing when the standard printer is unavailable.",
      "description_length": 479,
      "index": 336,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EConstr.EInstance",
      "library": "rocq-runtime.engine",
      "description": "This module represents and manipulates evar instances, which are used to track instantiations of existential variables during type inference. It provides operations to create an instance from a UVars instance, retrieve its underlying representation, and check if it is empty. Concrete use cases include managing substitutions in unification problems and handling delayed instantiations in tactics.",
      "description_length": 397,
      "index": 337,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview.Goal",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations to inspect and manipulate individual proof goals within a tactic context. It supports data types like `t` for representing goals, along with functions to access a goal's conclusion, hypotheses, environment, and existential variable map. Use cases include writing custom tactics that analyze or modify specific goals, checking whether a goal is solved, or applying transformations independently across all focused goals.",
      "description_length": 451,
      "index": 338,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UnivProblem.Set",
      "library": "rocq-runtime.engine",
      "description": "This module offers a suite of operations for managing sorted, immutable sets of universe constraints, including structural manipulations (union, intersection, difference), element-wise queries (membership checks, bounded searches), and ordered traversals. It works with sets containing elements that model Coq's type system constraints, maintaining internal ordering through a dedicated comparison function. The functionality supports use cases like dependency resolution in type inference, constraint normalization, and hierarchical set construction from sequential data sources.",
      "description_length": 580,
      "index": 339,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evd.Abstraction",
      "library": "rocq-runtime.engine",
      "description": "This module manages a list of abstraction markers used to track the structure of existential variables during unification. It supports operations to create an identity abstraction list and to modify it by abstracting the last element. These abstractions influence how existential variables are instantiated, particularly in handling dependent types and higher-order unification scenarios.",
      "description_length": 388,
      "index": 340,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview_monad.Env",
      "library": "rocq-runtime.engine",
      "description": "This module provides direct access to the global environment within the tactic monad, allowing retrieval, modification, and updating of the environment state. It works specifically with the `Environ.env` type and the `Proofview_monad.Logical.t` monadic context. Concrete use cases include inspecting the current environment during tactic execution, updating it with new definitions, or adjusting environment flags dynamically.",
      "description_length": 426,
      "index": 341,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EConstr.Unsafe",
      "library": "rocq-runtime.engine",
      "description": "This module directly converts between EConstr and Constr types with physical identity, handling structures like binders, declarations, contexts, and relevance. It supports precise casting of terms, arrays, and case analysis without evaluation or normalization. Use when working with low-level term manipulation where evar and sort normalization is irrelevant.",
      "description_length": 359,
      "index": 342,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview_monad.StateStore",
      "library": "rocq-runtime.engine",
      "description": "This module implements a typed key-value store for managing internal state within a tactic monad. It supports creating, setting, getting, and removing fields with arbitrary values, as well as merging two stores. It is used to track and manipulate per-invocation state during proof construction, such as caching intermediate results or tracking configuration options.",
      "description_length": 366,
      "index": 343,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview_monad.P",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic operations for managing proof states and environment interactions in a tactic system. It works with data types representing proofviews, environments, and state metadata, supporting operations like unit value creation and product combination for state tracking. Concrete use cases include structuring tactic computations that manipulate proof goals and environment data while maintaining traceability and naming context.",
      "description_length": 448,
      "index": 344,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ftactic.List",
      "library": "rocq-runtime.engine",
      "description": "This module provides monadic list operations for composing effectful computations, including mapping, folding, and filtering over lists with left-to-right or right-to-left evaluation order. It supports list transformations that thread effects through each element, enabling precise control over sequencing and error handling in tactic programming. Use cases include processing sequences of proof obligations where each step depends on prior effects, such as variable binding or hypothesis manipulation.",
      "description_length": 502,
      "index": 345,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview_monad.Info",
      "library": "rocq-runtime.engine",
      "description": "This module manages trace information for tactic execution, providing structured logging through tags like messages, tactic calls, and dispatch markers. It supports operations to collapse nested tactic traces and print formatted output using environment and evar map contexts. It is used to track and visualize the flow of tactics during proof development.",
      "description_length": 356,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.Store",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations to manage a key-value store for attaching arbitrary data to unification states. It supports creating, setting, retrieving, and removing typed fields, as well as merging stores. It is used to extend unification state with custom information such as tactic-specific metadata or solver data.",
      "description_length": 320,
      "index": 347,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview.Progress",
      "library": "rocq-runtime.engine",
      "description": "This module tracks and manages progress during proof construction by comparing goals and their associated existential variables. It provides the `goal_equal` function to check equality of goals under different states of existential variable instantiations and universe constraints. Concrete use cases include determining whether a tactic has made progress by comparing the state of goals before and after its application.",
      "description_length": 421,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.Monad",
      "library": "rocq-runtime.engine",
      "description": "This module implements monadic operations for composing stateful computations that manipulate unification data, particularly existential variables. It provides core functions like `return`, bind (`>>=`), and sequencing (`>>`) to chain operations, along with mapping and list utilities through its submodule for handling lists within the monadic context. You can use it to build complex constraint solvers or tactics that safely thread unification state, such as processing and transforming lists of evars while accumulating results or applying side effects in a controlled way.",
      "description_length": 577,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nameops.Subscript",
      "library": "rocq-runtime.engine",
      "description": "Handles subscript incrementing and ordering with string-based representations, supporting operations like `succ` for generating next subscripts and `compare` for ordering. Works with the abstract type `t` representing subscripts as strings. Useful for generating ordered identifiers in contexts like document sections or list indices where subscripts must follow lexicographic and numeric rules.",
      "description_length": 395,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.Status",
      "library": "rocq-runtime.engine",
      "description": "This module provides a single operation, `put`, which updates the tactic status (safe or unsafe) within the logical monad. It works with the internal state of the tactic monad, specifically manipulating a boolean flag that indicates whether the current tactic context is safe. Use this module to set the safety status of a tactic during proof construction, affecting how it interacts with the proof environment.",
      "description_length": 411,
      "index": 351,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview_monad.Writer",
      "library": "rocq-runtime.engine",
      "description": "Handles writing state updates within a monadic computation, specifically using the `t` type to track changes. Provides the `put` function to inject state modifications into the monadic context. Useful for logging or accumulating values during tactic execution without affecting the main computation flow.",
      "description_length": 304,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logic_monad.NonLogical",
      "library": "rocq-runtime.engine",
      "description": "This module handles imperative operations and side effects that are not backtracked, such as I/O, mutable references, and exceptions, using a non-logical monadic structure. It provides direct access to functions for printing, reading input, exception handling, and timeouts, while its child module extends these capabilities to list operations like mapping, folding, and filtering with strict sequencing and effect handling. You can use it to log debug output during proofs, read user input interactively, or run external computations with time limits, and process lists of values where each element involves non-backtrackable effects.",
      "description_length": 635,
      "index": 353,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Logic_monad.Param",
      "library": "rocq-runtime.engine",
      "description": "This module defines the parametric types and operations required to construct a logic monad with support for logical state, environment, and writer effects. It includes monoidal operations on the writer type `w` and a pointed type `u` for handling failure and backtracking. Concrete use cases include managing proof state changes, accumulating results during tactic execution, and handling non-backtrackable effects like persistent state or output.",
      "description_length": 448,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.MonadR",
      "library": "rocq-runtime.engine",
      "description": "This module provides a monadic interface for stateful computations over unification variables, enabling operations like binding, sequencing, and mapping over values wrapped in the `'a Evd.MonadR.t` type. It directly manipulates the unification state (`evar_map`) and supports chaining actions such as defining evar bodies or handling conversion constraints in the tactic engine. The module includes submodules for list-based monadic operations, allowing left-to-right or right-to-left traversal with functions like `map`, `fold_left`, and `map_filter` to process lists of evars or constraints. These capabilities enable precise, composable manipulation of unification state during type inference and proof construction.",
      "description_length": 719,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ftactic.Notations",
      "library": "rocq-runtime.engine",
      "description": "This module provides infix operators for sequencing and composing focussing tactics. It works with values of type `'a Ftactic.t`, enabling chaining of tactic computations in a monadic style. Concrete use cases include writing compact tactic expressions that depend on the success or failure of previous tactic steps, such as conditionally applying transformations based on the outcome of a matching operation.",
      "description_length": 409,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EConstr.ESorts",
      "library": "rocq-runtime.engine",
      "description": "This module represents and manipulates sort constraints in the context of unification variables. It provides operations to create, compare, and inspect sorts, including checking sort properties like `Prop`, `SProp`, and `Set`, and deriving relevance and quality information. Concrete use cases include managing sort hierarchies during type inference and ensuring correct sort propagation in unification problems.",
      "description_length": 412,
      "index": 357,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EConstr.Vars",
      "library": "rocq-runtime.engine",
      "description": "The module offers operations to manipulate variables in terms and contexts using de Bruijn indices, including substitution, lifting, and closure checks. It operates on `EConstr.t` terms, `rel_declaration` values, and `rel_context` structures, handling tasks like universe substitution, instance application, and nested context flattening. These capabilities are critical for Coq's type-checking and elaboration phases, where precise variable management ensures correctness during term transformation and context manipulation.",
      "description_length": 525,
      "index": 358,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logic_monad.Logical",
      "library": "rocq-runtime.engine",
      "description": "This module combines monadic combinators for stateful backtracking computations with submodules that extend its capabilities for list processing and low-level state manipulation. It centers around the `'a t` type representing logical transitions, supporting operations like `get`, `set`, `modify`, `zero`, `plus`, `once`, and `split` to manage state and control flow during proof search or constraint solving. The list submodule enables mapping, folding, and filtering with backtracking-aware transformations, useful for applying tactics across hypotheses or collecting results from goal manipulations. The low-level submodule exposes functions to construct and deconstruct monadic values over a composite state type, allowing precise control over backtracking strategies and integration of effectful computations.",
      "description_length": 814,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview.Monad",
      "library": "rocq-runtime.engine",
      "description": "This module structures tactic composition using monadic operations like bind (`>>=`), map, and sequence (`>>`), centered around the `'a tactic` type for managing proof state transitions. It enables chaining tactics, transforming results, and building complex proof strategies from simpler steps, such as applying a sequence of transformations to goals or accumulating tactic outputs across multiple goals. The module supports list-based control flow with left-to-right or right-to-left traversal, allowing synchronized processing of hypotheses or terms with explicit length checks. Specific capabilities include composing conditional tactic pipelines, folding over goal lists to collect results, and applying tactics pairwise across structured term lists.",
      "description_length": 755,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview.NonLogical",
      "library": "rocq-runtime.engine",
      "description": "This module provides a monadic interface for executing non-logical effects such as I/O, mutable state, and exceptions within tactics, using a simple unit -> 'a monad. It supports core operations like reading input, logging, and handling exceptions, while sequencing effects through list combinators in its submodules. You can use it to log debug information during proof search, read user input to guide tactic execution, or manage imperative state across proof steps. The module ensures that these effects persist across tactic failures, enabling interactive and stateful proof automation.",
      "description_length": 590,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.State",
      "library": "rocq-runtime.engine",
      "description": "This module manages state transitions within the tactic monad using `get`, `set`, and `modify` operations. It works directly with the internal state type `t` to manipulate proof-related data during tactic execution. Concrete use cases include tracking proof progress, managing goal contexts, and applying transformations to the proof state.",
      "description_length": 340,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.Logical",
      "library": "rocq-runtime.engine",
      "description": "This module combines stateful computation with list manipulation capabilities to support advanced proof automation. It provides core operations like `bind`, `map`, and state transformers that interact with the `state` type, managing proof environments, universes, and warnings through fields like `rstate`, `ustate`, `wstate`, and `sstate`. The module enables precise control over proof state transitions, exception handling via `Exninfo.iexn`, and monadic list processing for tasks like applying tactics across multiple goals or transforming collections of hypotheses. Examples include writing custom tactics that modify proof state directly or sequencing actions over lists of terms within the logical monad.",
      "description_length": 710,
      "index": 363,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UState.Internal",
      "library": "rocq-runtime.engine",
      "description": "Handles low-level universe unification state manipulations, including operations for merging and comparing universe constraints. Works directly with universe states and environment contexts. Used internally during type inference and unification to manage universe levels and ensure consistency in the presence of program definitions.",
      "description_length": 333,
      "index": 364,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EConstr.ERelevance",
      "library": "rocq-runtime.engine",
      "description": "This module represents and manipulates the relevance of terms in the context of existential variables. It provides operations to create, compare, and check relevance values, specifically working with `Sorts.relevance` and `EConstr.ERelevance.t`. It is used to determine whether a term should be considered during unification or type inference, such as marking a subterm as irrelevant to avoid unnecessary constraints.",
      "description_length": 417,
      "index": 365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.FutureGoals",
      "library": "rocq-runtime.engine",
      "description": "Maintains and transforms a collection of existential variables representing unresolved proof goals. Provides operations to filter and map over these variables, enabling precise manipulation of pending goals during proof construction. Useful for tactics that selectively process or update specific goals based on custom criteria.",
      "description_length": 328,
      "index": 366,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EConstr.UnsafeMonomorphic",
      "library": "rocq-runtime.engine",
      "description": "This module directly constructs specific kinds of terms in the extended constructor language, including constants, inductive types, and constructors. It operates on data types representing Coq's core terms and relies on names from the `Names` module to identify constants, inductives, and constructors. It is used when building low-level term representations, such as during tactic development or term transformation passes.",
      "description_length": 424,
      "index": 367,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview.UnsafeRepr",
      "library": "rocq-runtime.engine",
      "description": "This module exposes low-level operations to manipulate the internal state of the proof monad, allowing direct access to the underlying computation structure of tactics. It provides functions to convert between abstract tactics and their concrete monadic representations, working with the `state` type that encapsulates the proof environment's logical context. Use cases include advanced tactic manipulation where fine-grained control over the proof state is required, such as implementing custom backtracking mechanisms or inspecting tactic behavior at a lower level.",
      "description_length": 567,
      "index": 368,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd.Expand",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations for expanding existential variables and instances within a unification state. It works with `evar_map`, `econstr`, and `handle` types to manipulate and inspect terms during constraint solving. It is used internally in EConstr to handle term expansion during unification and instance resolution.",
      "description_length": 326,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Logic_monad.BackState",
      "library": "rocq-runtime.engine",
      "description": "This module implements a backtracking state monad with interleaving and exception handling, designed for managing logical computations with mutable state that can be rolled back on failure. It supports operations like `get` and `modify` for state manipulation, `zero` and `plus` for failure and choice, and `interleave` for adapting exceptions between different contexts. Concrete use cases include implementing tactics in a theorem prover where state changes must be undone upon failure, or search algorithms that require checkpointing and rollback.",
      "description_length": 550,
      "index": 370,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview_monad.Solution",
      "library": "rocq-runtime.engine",
      "description": "This module provides direct access to the existential variable map (`evar_map`) within the proofview state. It includes operations to retrieve, update, or modify the `evar_map` using the monadic context. These functions are used to inspect or manipulate unresolved existential variables during tactic execution.",
      "description_length": 311,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview.Unsafe",
      "library": "rocq-runtime.engine",
      "description": "This module directly manipulates the proof state's internal structures, including the evar_map, environment, and goal lists, with operations like replacing the evar map, setting goals, and shelving goals. It works with data types such as `Evd.evar_map`, `Environ.env`, `Proofview_monad.goal_with_state`, and `Evar.t`. Concrete use cases include integrating pretyping results into the proof engine, manually adjusting the list of active goals, and managing unresolved existential variables during tactic execution.",
      "description_length": 513,
      "index": 372,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EConstr.Expand",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations for inspecting and manipulating expanded representations of terms, including functions to create, project, and iterate over term structures with handles. It works with term kinds, handles, and lists of terms, supporting operations like lifting handles, expanding instances, and traversing terms with or without binder contexts. Concrete use cases include term analysis, transformation passes, and instance expansion during type checking or proof construction.",
      "description_length": 491,
      "index": 373,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evd.MiniEConstr",
      "library": "rocq-runtime.engine",
      "description": "This module combines core utilities for managing unification state with specialized submodules for handling relevance, evar_maps, and sorts. It centers around the unification state, providing operations to create and inspect relevance values, manipulate evar_map entries for existential variables, and construct and convert sort values. The `t` type appears throughout, representing abstract values for relevance and sorts, while UVars.Instance.t and EInstance.t handle instantiation data. Examples include determining the relevance of existential variables, initializing evar_map entries during tactic execution, and managing sort constraints in unification.",
      "description_length": 659,
      "index": 374,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evarutil.VarSet",
      "library": "rocq-runtime.engine",
      "description": "This module represents sets of variables and supports operations like union, intersection, and membership testing. It works with variable sets in the context of environments and evar management. Concrete use cases include tracking which variables are in scope, filtering expressions based on variable presence, and computing overlaps between different sets of variables.",
      "description_length": 370,
      "index": 375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview_monad.InfoL",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations to manipulate and record information traces during tactic execution. It works with the internal state of the `Proofview_monad.Info` module, using tags to structure trace entries. Functions like `record_trace`, `tag`, `opn`, and `close` allow opening, closing, and annotating trace nodes, while `update` modifies the trace state directly. Use cases include logging tactic behavior, tracking proof progress, and debugging proof scripts through structured trace data.",
      "description_length": 496,
      "index": 376,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Namegen.Generator",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations to generate fresh identifiers and manage name uniqueness within a context. It works with data types like `Names.Id.t`, `Names.Name.t`, and maps or sets of these identifiers. Concrete use cases include generating unique variable names during program transformation and tracking name collisions in a scoped environment.",
      "description_length": 349,
      "index": 377,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview_monad.Comb",
      "library": "rocq-runtime.engine",
      "description": "This module provides direct access to the list of focused goals within the tactic monad's state. It includes operations to retrieve, update, or modify the current list of goals with state information. These functions are used to manipulate the proof context during tactic execution, such as when reprioritizing or filtering active goals.",
      "description_length": 337,
      "index": 378,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evd.Filter",
      "library": "rocq-runtime.engine",
      "description": "This module implements boolean filters used to selectively process elements in lists, arrays, and sparse lists, where each filter is represented as a sequence of boolean flags. It supports operations like filtering collections, extending and composing filters, and mapping functions over filters and lists. Concrete use cases include selectively applying unification constraints or debugging actions in the tactic engine based on dynamic conditions.",
      "description_length": 449,
      "index": 379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nameops.Fresh",
      "library": "rocq-runtime.engine",
      "description": "This module manages the generation of fresh identifiers by tracking used names and providing operations to add, remove, and check name availability. It supports generating the next available name variant or a completely fresh name paired with an updated state. It works with identifier sets, lists, and context values to ensure unique name assignment in scenarios like variable binding or symbol resolution.",
      "description_length": 407,
      "index": 380,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview_monad.Trace",
      "library": "rocq-runtime.engine",
      "description": "This module builds and manipulates trace structures for tracking execution in the tactic monad. It provides operations to open and close hierarchical trace nodes, create leaf nodes, and convert incremental traces into forest representations. These operations are used to record and visualize the structure of proof search steps in Coq's tactic system.",
      "description_length": 351,
      "index": 381,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nameops.Name",
      "library": "rocq-runtime.engine",
      "description": "This module handles operations on named identifiers, supporting construction, inspection, comparison, and transformation of names. It works with the variant type `t` representing either an anonymous identifier or a named one, built from `Names.Id.t`. Use cases include managing variable bindings, pretty-printing identifiers, and manipulating name-based annotations in binders.",
      "description_length": 377,
      "index": 382,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnivMinim.UPairSet",
      "library": "rocq-runtime.engine",
      "description": "This module provides set operations for unordered pairs of universe levels, including standard manipulations like union, intersection, and difference, alongside iteration, transformation, and sequence-based construction. It operates on sets of unordered pairs, with elements compared via a fixed ordering to ensure consistent representation, and supports ordered traversal and bulk operations through sequence interfaces. Such functionality is useful in scenarios like type inference where relationships between universe levels must be tracked without regard to pair order.",
      "description_length": 573,
      "index": 383,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview_monad.Reader",
      "library": "rocq-runtime.engine",
      "description": "Handles computations that depend on a shared environment, allowing access to a global state through the `get` operation. Works with the `t` type, which represents the internal state of the tactic monad. Useful for retrieving contextual information during proof construction, such as goal or hypothesis data, without explicitly passing it through function arguments.",
      "description_length": 365,
      "index": 384,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview.Notations",
      "library": "rocq-runtime.engine",
      "description": "This module defines combinators for composing tactics in sequence or alternative, using operators like `>>=`, `<*>`, and `<+>`. It works with the `'a tactic` type, which represents state-modifying operations in a proof context. These combinators enable constructing complex proof strategies by chaining or branching tactic applications based on success or failure.",
      "description_length": 364,
      "index": 385,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proofview.Trace",
      "library": "rocq-runtime.engine",
      "description": "This module provides operations for logging and tracing tactic execution, including recording detailed information traces, naming tactics for identification, and printing trace information with environment and evar_map context. It works with tactics, lazy messages, and trace trees. Concrete use cases include debugging proof script execution and inspecting tactic behavior during interactive theorem proving.",
      "description_length": 409,
      "index": 386,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UnivNames",
      "library": "rocq-runtime.engine",
      "description": "This module manages mappings between universe names and levels, providing bidirectional lookups using identifier maps. It supports operations to convert universe levels to qualified identifiers and pretty-print levels with global universe names. Concrete use cases include resolving universe levels during type checking and generating human-readable representations of universes in Coq's kernel.",
      "description_length": 395,
      "index": 387,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Proofview_monad",
      "library": "rocq-runtime.engine",
      "description": "This module manages proof states and tactic execution context through a monadic framework, combining state manipulation, environment tracking, and structured logging. It centers on the `proofview` type and interacts with `evar_map`, `env`, and state metadata to support operations like goal manipulation, environment updates, trace logging, and safety status control. You can use it to write tactics that dynamically adjust proof contexts, track unresolved variables, log execution traces, or maintain per-invocation state in a type-safe way. Submodules provide fine-grained access to goals, environments, traces, and state transitions, enabling precise control over proof construction and debugging.",
      "description_length": 700,
      "index": 388,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Namegen",
      "library": "rocq-runtime.engine",
      "description": "This module generates fresh names and ensures uniqueness in Coq's type theory, particularly during term and proof construction. It directly handles identifiers, name sets, types, and constructions within environments and evar_maps, supporting operations like binder-aware renaming and scoped name tracking. Submodules focus on scoped name generation and collision tracking, using data types like `Names.Id.t` and `Names.Name.t`. Example uses include safely creating lambda expressions, managing let-bindings, and handling pattern-matching contexts without name clashes.",
      "description_length": 569,
      "index": 389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UState",
      "library": "rocq-runtime.engine",
      "description": "This module manages universe unification states by supporting constraint merging, level normalization, variable substitution, and declaration validation within a unification graph. It operates on universe levels, sort variables, and constraint sets, enabling type inference, polymorphic universe handling, and consistency checks. Submodules handle low-level state manipulations, such as merging and comparing constraints, working directly with universe states and environment contexts during type inference. Example use cases include demoting global universes, minimizing contexts, and converting universe hierarchies to identifiers for type-checking workflows.",
      "description_length": 661,
      "index": 390,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "EConstr",
      "library": "rocq-runtime.engine",
      "description": "This module provides core operations for constructing and manipulating Coq's extended terms with support for universe polymorphism, existential variables, and precise context management. It enables term inspection, binder handling, and conversion between constrained and unconstrained representations, working directly with `EConstr.t`, typing contexts, and case constructs. The module supports low-level term transformations, type-checking workflows, and tactic development through submodules that manage evar instantiations, sort constraints, relevance, de Bruijn indices, term construction, and term expansion. Specific capabilities include handling unification substitutions, managing sort hierarchies, lifting variables in contexts, and building inductive terms with proper naming and structure.",
      "description_length": 800,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evd",
      "library": "rocq-runtime.engine",
      "description": "The module revolves around the `evar_map`, a central data structure that maps existential variables to their associated metadata, including type, context, and definition. It provides low-level operations to manipulate unification state directly, such as updating evar bodies and managing conversion constraints, while submodules extend its functionality with structured abstractions, custom data attachment, and monadic composition for stateful computations. You can use it to build and transform complex unification problems, for example by filtering and mapping over unresolved goals, applying boolean filters to control constraint application, or threading state through monadic operations that safely compose evar manipulations. Additional capabilities include term expansion during instance resolution, attaching tactic-specific metadata, and managing relevance and sort constraints within unification problems.",
      "description_length": 916,
      "index": 392,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ftactic",
      "library": "rocq-runtime.engine",
      "description": "This module combines monadic operations with list processing and infix combinators to build and sequence focussing tactics that selectively target goals during proof construction. It centers around the `'a t` monadic type, supporting lifting, sequencing, binding, and goal-focused execution, with operations for mapping, folding, and filtering over lists of tactics in left-to-right or right-to-left order. The module enables precise control over tactic flow and effects, allowing automation that adapts to goal structure\u2014such as applying transformations conditionally based on prior results or processing multiple proof obligations in sequence. Examples include chaining tactics with infix operators for compact expressions, or using list operations to apply a sequence of transformations that each depend on the effects of previous steps.",
      "description_length": 840,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnivMinim",
      "library": "rocq-runtime.engine",
      "description": "This module simplifies and normalizes universe constraints during type checking by managing universe levels and their relationships through a combination of level sets and unordered pair sets. It directly provides operations to merge, simplify, and enforce consistency on universe contexts, using core data structures like `UPairSet` to track symmetric constraints between levels. The child module enhances this functionality by offering efficient set operations on unordered level pairs, enabling precise manipulation and traversal of constraint relationships. Together, they support tasks like constraint union, difference, and iteration, ensuring minimal and consistent universe representations during type inference.",
      "description_length": 720,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnivFlex",
      "library": "rocq-runtime.engine",
      "description": "This module handles substitution management and constraint manipulation for universe levels and algebraic universes, supporting operations like adding definitions, enforcing constraints, and minimizing universe expressions. It works with structured representations of universe flexibility to classify and optimize algebraic and non-algebraic levels during type checking or proof processing. Specific applications include normalizing complex universe hierarchies and generating human-readable visualizations of substitutions through pretty-printing.",
      "description_length": 548,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnivGen",
      "library": "rocq-runtime.engine",
      "description": "This module facilitates operations for generating and manipulating universe levels, sort contexts, and global identifiers, primarily working with environments (`Environ.env`), global references (`Names.GlobRef.t`), and universe instances. It supports constraint propagation, substitution, and polymorphism management in type theory systems like Coq, with specific functions for creating monomorphic constants while rejecting polymorphic references during constraint generation. Use cases include universe context manipulation and ensuring consistency in inductive type and constructor definitions.",
      "description_length": 597,
      "index": 396,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evar_kinds",
      "library": "rocq-runtime.engine",
      "description": "This module defines types and constructors for representing different kinds of existential variables and holes in terms, including obligations, pattern variables, and subexpression roles. It includes structured data types like `question_mark`, `record_field`, and `subevar_kind` to classify and manage these variables during type inference and proof construction. Concrete use cases include tracking implicit arguments, handling named and unnamed placeholders, and controlling expansion behavior in Coq's logic.",
      "description_length": 511,
      "index": 397,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Logic_monad",
      "library": "rocq-runtime.engine",
      "description": "This module provides a layered monadic framework for managing backtracking and state in logical computations, combining non-backtrackable effects like I/O with backtrackable state transitions. It defines core types like `'a t` for logical computations and operations such as `get`, `set`, `modify`, `zero`, and `plus` to manipulate state and control flow, while supporting monoidal accumulation through writer effects. You can use it to implement tactics that modify proof states with rollback on failure, log output during execution, or apply transformations across hypotheses with backtracking-aware list operations. Submodules extend these capabilities with list combinators, low-level state manipulation, and interleaving strategies for advanced control over logical search and exception handling.",
      "description_length": 801,
      "index": 398,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnivSubst",
      "library": "rocq-runtime.engine",
      "description": "This module handles substitutions and constraints for universes and quality variables in a type theory context. It provides functions to map and enforce relationships between universe levels and sorts, supporting operations like constraint generation and universe substitution in terms. It is used in type checking and elaboration processes where universe polymorphism and constraints must be resolved.",
      "description_length": 402,
      "index": 399,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nameops",
      "library": "rocq-runtime.engine",
      "description": "This module provides tools for constructing, analyzing, and transforming identifiers using prefixes, suffixes, and subscripts, with support for tasks like splitting names into base and subscript components, incrementing numeric suffixes, and extracting name roots. Submodules handle subscript ordering and incrementing, fresh name generation with state tracking, and manipulation of named identifiers with comparison and transformation operations. You can use it to generate unique variable names in a binder context, manage metavariables with indexed subscripts, or produce ordered identifiers for document sections and list elements. The main types include strings for subscripts, sets and contexts for name tracking, and variant types for named or anonymous identifiers.",
      "description_length": 773,
      "index": 400,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Profile_tactic",
      "library": "rocq-runtime.engine",
      "description": "This module provides profiling primitives for Ltac tactics, enabling detailed performance analysis by tracking execution time and call counts. It works with tactic expressions and a tree-based data structure to represent profiling results, with operations to start and stop timers, reset statistics, and print formatted output. Concrete use cases include identifying performance bottlenecks in proof scripts and optimizing tactic execution through detailed timing feedback.",
      "description_length": 473,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proofview",
      "library": "rocq-runtime.engine",
      "description": "This module manages proof states and tactics in a theorem prover, centering on types like `proofview`, `'a tactic`, and `evar_map`, with operations for goal manipulation, backtracking, and effect tracking. Submodules enable goal inspection, tactic composition via monadic combinators, and low-level state transformations, supporting use cases like custom tactic development, progress checking, and interactive proof automation. You can write tactics that analyze goal hypotheses, sequence transformations across multiple goals, or log execution traces with environment context, while handling exceptions and side effects across tactic failures. Advanced features include manual evar map updates, custom backtracking logic, and structured term processing with explicit traversal direction and length checks.",
      "description_length": 806,
      "index": 402,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Termops",
      "library": "rocq-runtime.engine",
      "description": "This module provides utilities for manipulating Coq terms and contexts, including substitution, binder-aware traversal, and construction of lambda abstractions and products. It operates on internal structures like `EConstr`, environments, and both named and relational contexts, supporting tasks such as assumption management, dependency tracking, and existential variable inspection. Its child module adds low-level printing functionality for debugging and custom output, allowing inspection of raw terms, contexts, and declarations in formats suitable for development tracing or specialized pretty-printing. Together, they enable both transformation and analysis of Coq's internal terms across normal processing and debugging workflows.",
      "description_length": 738,
      "index": 403,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evarutil",
      "library": "rocq-runtime.engine",
      "description": "This module offers high-level utilities for working with evars, including creation, instantiation, and querying within Coq's logic. It includes a submodule for managing sets of variables, enabling operations like union, intersection, and membership checks. Main data types include evars and variable sets, with operations to manipulate and analyze their relationships in proof terms. Examples include filtering expressions based on variable presence, tracking in-scope variables, and resolving overlaps between variable sets during tactic execution.",
      "description_length": 549,
      "index": 404,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UnivProblem",
      "library": "rocq-runtime.engine",
      "description": "This module manages universe constraints from type inference, handling equality, subtyping, and least upper bound requirements across sorts, levels, and cumulative instances. It provides core operations to check level equivalence, enforce constraints, and compare universe structures, while its child module organizes these constraints into sorted, immutable sets with efficient set operations and ordered traversal. You can use it to normalize constraint sets, resolve dependencies during type inference, or construct hierarchical universes from sequential data. The combined interface supports both direct constraint manipulation and set-level operations with Coq-specific type system modeling.",
      "description_length": 696,
      "index": 405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CoqworkmgrApi",
      "library": "rocq-runtime.coqworkmgrapi",
      "description": "This module defines priority levels and communication primitives for managing asynchronous proof workers. It provides functions to serialize and deserialize requests and responses, manage worker connections, and exchange messages like token allocation or heartbeat pings. Concrete use cases include coordinating distributed proof checking tasks and handling worker resource negotiation over sockets.",
      "description_length": 399,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqloadpath",
      "library": "rocq-runtime.sysinit",
      "description": "Initializes the default load path for Coq, combining standard library locations, user-contrib directories, and environment-specified paths. It returns a tuple containing physical file paths and compiled Coq library paths. This function is used to set up the search path for loading Coq files when starting a new session.",
      "description_length": 320,
      "index": 407,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqinit",
      "library": "rocq-runtime.sysinit",
      "description": "This module initializes the OCaml runtime and global data for compiling Coq units, handling command-line arguments and setting up the environment for library compilation. It operates on data types such as `Coqargs.t`, `Names.DirPath.t`, and `Library.Intern.t,` coordinating the compilation workflow from runtime setup to library initialization. Concrete use cases include launching Coq compilation processes, configuring runtime settings, and starting new Coq libraries with specified options and prelude objects.",
      "description_length": 513,
      "index": 408,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Reductionops.ReductionBehaviour.Db",
      "library": "rocq-runtime.pretyping",
      "description": "Stores and manages reduction behavior settings for constants, including policies for unfolding and inlining. It uses a database-like structure to associate constants with their reduction rules. Used to control evaluation strategies during proof normalization and tactic execution.",
      "description_length": 280,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unification.Metamap.Smart",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve sharing when possible, operating on `Unification.Metamap.t` structures with values of type `'a`. It is useful in scenarios where structural sharing reduces memory usage or improves performance, such as in persistent data structures or symbolic computation systems.",
      "description_length": 338,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coercionops.ClTypSet.List",
      "library": "rocq-runtime.pretyping",
      "description": "This module operates on lists of sets, providing functions to compute the union of multiple sets and manipulate collections of set elements. It works with `Coercionops.ClTypSet.t list` data structures, enabling aggregation and combination of set-based collections. A concrete use case includes merging multiple disjoint sets into a single set for further processing.",
      "description_length": 366,
      "index": 411,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Unification.Metamap.Monad",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides monadic traversal and transformation operations over metamaps, which are maps from keys to values in a monad. It supports operations like `fold`, `mapi`, `fold_left`, and `fold_right`, allowing accumulation and value transformation while threading a monadic context through each step. It is useful for scenarios requiring effectful iteration over key-value maps, such as propagating state or handling side effects during traversal.",
      "description_length": 452,
      "index": 412,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unification.Metamap",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages persistent maps from metavariables to values, supporting standard associative operations like insertion, deletion, and lookup, along with transformations and customizable merging strategies. It includes optimized functions for mapping and filtering that preserve structural sharing, improving efficiency in symbolic computation or unification contexts. The module also provides monadic traversal and transformation capabilities, enabling effectful operations over maps where values reside in a monadic context. Together, these features allow precise manipulation of metavariable substitutions, efficient value transformations, and stateful or effectful iterations over map structures.",
      "description_length": 704,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Geninterp.Val",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines typed values and tags for representing and manipulating generic interpreted values, including operations for creating, comparing, and printing value types. It works with data types like `t` for dynamically typed values, `tag` for type descriptors, and supports structured types such as lists, options, and pairs. Concrete use cases include handling Ltac values with precise typing, enabling type-safe injection and extraction of values, and supporting type comparisons for generic interpretation tasks.",
      "description_length": 522,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genarg.ArgT",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines a parameterized type `('a, 'b, 'c) tag` representing generic arguments at different processing stages\u2014raw, glob, and interpreted\u2014and provides operations to manipulate and identify these arguments. It supports concrete use cases such as registering and distinguishing argument types used in Coq's tactic language (Ltac), command extensions, and notation mechanisms, ensuring correct parsing, substitution, and evaluation. Functions like `eq`, `repr`, and `name` enable type-safe comparisons and lookups, while `dump` lists registered argument tags for debugging.",
      "description_length": 581,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Structures.CSTable",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides direct access to the Canonical Structure database, allowing retrieval of entries by projection or globally. It works with structured entries containing projections, values, and solutions, all represented as global references or value patterns. Concrete use cases include querying canonical structure associations for specific fields or inspecting the full list of stored canonical entries.",
      "description_length": 410,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genarg.Register",
      "library": "rocq-runtime.pretyping",
      "description": "This module registers and retrieves type-specific manipulation functions for generic arguments, working with `genarg_type` and `M.obj` values. It supports operations like registering a new ground type, checking if a type is registered, and folding over registered keys. Concrete use cases include enabling extensible syntax in tactics, notations, and vernacular commands by associating raw, glob, and top-level transformations with specific argument types.",
      "description_length": 456,
      "index": 417,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Geninterp.TacStore",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages a store of dynamically typed fields, supporting operations to create, set, get, and remove fields by name. It works with a polymorphic store type `t` and typed field descriptors. Useful for maintaining contextual state during tactic execution, such as tracking variable bindings or configuration settings across interpretation steps.",
      "description_length": 353,
      "index": 418,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Structures.ValuePattern",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines a data type for patterns that describe the structure of values in canonical instances, including constants, projections, products, sorts, and defaults. It provides operations to compare, print, and check equality of these patterns, as well as to construct them from Coq terms. It is used to analyze and query components of canonical structures during type class resolution or unification.",
      "description_length": 408,
      "index": 419,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Structures.CanonicalSolution",
      "library": "rocq-runtime.pretyping",
      "description": "This module represents and manipulates canonical solutions for problems involving abstractions and constructor applications. It provides operations to find a canonical solution that equates a projection to a value, check if a term is an open canonical projection, and print solution details. It works with environments, evar_maps, and terms in the form of EConstr.t, handling cases where values may correspond to abstractions or constructor applications with parameters and arguments.",
      "description_length": 484,
      "index": 420,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coercionops.ClTypSet",
      "library": "rocq-runtime.pretyping",
      "description": "This module implements standard functional set operations for `Coercionops.cl_typ` values, supporting union, intersection, difference, membership checks, and filtering. It works with sets represented as `t` structures, allowing conversion from sequences and to lists, and includes operations for cardinality and predicate-based searches. The child module extends this functionality to lists of sets, enabling aggregation and combination of multiple sets, such as computing the union of a list of disjoint sets. Together, they support complex set-theoretic workflows involving transformation, combination, and analysis of `cl_typ` element collections.",
      "description_length": 650,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unification.Metaset",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides ordered set operations for managing collections of metavariables, supporting efficient insertion, deletion, union, intersection, and difference calculations. It works with sets of `Constr.metavariable` elements, leveraging ordered traversal for deterministic iteration and transformations like mapping, filtering, and partitioning. Use cases include unification algorithms and symbolic computation tasks requiring precise tracking of variable relationships through ordered set semantics.",
      "description_length": 508,
      "index": 422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genarg.GenObj",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles the lifecycle of generic arguments in Rocq, supporting operations like parsing, globalization, substitution, and interpretation. It works with abstract syntax trees (ASTs) at various levels\u2014raw, glob, and top\u2014primarily for tactic expressions, vernacular commands, and extensible syntax constructs. Concrete use cases include registering printers for debugging, enabling custom tactic arguments in Ltac2, and integrating user-defined syntax in notations and vernacular extensions.",
      "description_length": 499,
      "index": 423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Reductionops.Stack",
      "library": "rocq-runtime.pretyping",
      "description": "This module implements stack-based operations for managing reduction contexts in term manipulation, handling data types like `app_node`, `case_stk`, and `member`. It supports concrete tasks such as appending arguments to stacks, decomposing and stripping applicative structures, comparing stack shapes, and extracting argument lists. Use cases include processing function applications, analyzing case expressions, and assisting in reduction steps during proof normalization.",
      "description_length": 474,
      "index": 424,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Reductionops.ReductionBehaviour",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines and manages customizable reduction behaviors for constants, controlling when and how they unfold during evaluation. It provides data types to represent reduction policies, such as inlining and unfolding rules, and operations to associate these policies with specific constants using a database-like structure. You can use it to specify fine-grained reduction strategies for proof normalization, tactic execution, or program extraction. For example, you might configure a constant to always unfold during reduction or to remain opaque unless certain conditions are met.",
      "description_length": 588,
      "index": 425,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Structures.Structure",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines and manipulates inductive structures, each represented as a named inductive type with a list of projections and a parameter count. It supports operations to create, register, substitute, and rebuild structures, along with lookups by inductive or projection identifiers. Concrete use cases include managing record-like data structures with named fields and handling projection functions in a type system.",
      "description_length": 423,
      "index": 426,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evarsolve.AllowedEvars",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages sets of existential variables (evars) that can be defined during type inference or proof search. It provides operations to check membership, create sets from predicates, exclude specific evars, and remove individual evars from allowed sets. Concrete use cases include controlling which evars are eligible for instantiation in unification algorithms or tactic execution.",
      "description_length": 389,
      "index": 427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Structures.Instance",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages the creation and registration of canonical instances for structures, handling conversions between record components and structure projections. It operates on the abstract type `t`, which represents a canonical instance, and works with environment (`Environ.env`), existential variable maps (`Evd.evar_map`), and global references (`Names.GlobRef.t`). It is used to declare and process record instances that can be registered as canonical, ensuring they conform to a previously declared structure type.",
      "description_length": 521,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Structures.PrimitiveProjections",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages mappings between constants and primitive projections, providing operations to register, check existence, and retrieve projections associated with constants. It works with data types such as `Names.Constant.t`, `Names.Projection.Repr.t`, and `EConstr.EInstance.t`. It is used to support projection-related operations in record manipulation and term processing.",
      "description_length": 379,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Reductionops.CredNative",
      "library": "rocq-runtime.pretyping",
      "description": "Implements native reduction operations for Coq's evaluation machinery. It provides functions like `red_prim` to reduce primitive operations in a given environment, working directly with `EConstr.t` elements, `Evd.evar_map`, and `CPrimitives.t`. Used during tactic execution and term normalization to evaluate primitives under a specific substitution and universe instance.",
      "description_length": 372,
      "index": 430,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unification.Meta",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages metavariables and their assignments during unification, tracking their typing status, names, and instance information. It provides operations to declare, assign, and retrieve metavariables, as well as merge and transform metavariable sets. Concrete use cases include handling incomplete terms during type inference and managing evar maps in proof automation.",
      "description_length": 378,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Detyping.PrintingInductiveMake",
      "library": "rocq-runtime.pretyping",
      "description": "This module encodes and manipulates inductive types using qualified identifiers, providing operations to substitute, discharge, and print them. It works with inductive type representations, environment data, and substitution contexts. Concrete use cases include pretty-printing inductive definitions and handling their substitution during module transformations.",
      "description_length": 362,
      "index": 432,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Geninterp.ValTMap",
      "library": "rocq-runtime.pretyping",
      "description": "This module implements a type-safe key-value map where keys are typed with `'a key` and values are typed with `'a value`, supporting operations like insertion, lookup, modification, and filtering. It provides concrete functionality for managing heterogeneous mappings with type-preserving transformations and typed iteration. Use cases include tracking and manipulating typed values associated with generic keys in a structured and type-safe manner.",
      "description_length": 449,
      "index": 433,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Locusops",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides operations for manipulating occurrence-based structures like `or_var` and `occurrences_gen`, enabling precise control over proof context elements (hypotheses, goals) through clause expressions. It supports analyzing occurrence patterns, validating selections, and detecting contextual targeting in Coq's Ltac system, particularly useful for proof automation tasks requiring hypothesis or goal filtering based on occurrence counts or generic context rules. Applications include selective rewriting, tactic application, and context inspection where explicit occurrence management is critical.",
      "description_length": 611,
      "index": 434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evarsolve",
      "library": "rocq-runtime.pretyping",
      "description": "This module coordinates the solving of existential variables by combining core operations for instantiation, constraint validation, and unification with structured management of evar sets. It supports key data types including evar maps tracking current instantiations, sets of allowable evars for controlled solving, and unification flags guiding constraint resolution. Operations allow users to instantiate evars while respecting type and occur constraints, filter eligible evars for solving based on predicates, and validate unification steps within type inference or tactic-driven proof search. Example usage includes restricting instantiation to specific evars during unification or dynamically adjusting allowed evar sets during tactic execution.",
      "description_length": 751,
      "index": 435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Structures",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides access to canonical structure data, enabling queries on structured entries with projections, values, and solutions. It supports pattern analysis of canonical components using structured patterns, and resolves canonical solutions for equating projections with values in unification problems. It also handles inductive structures with named projections, manages canonical instance registration, and maintains mappings between constants and their associated projections. Examples include retrieving canonical entries by field, analyzing structure patterns during type class resolution, and registering record instances as canonical structures.",
      "description_length": 661,
      "index": 436,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Reductionops",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides core normalization and reduction machinery for Coq terms, combining environment-aware evaluation with customizable reduction strategies and native operations. It supports head-normalization (whd), lambda/product decomposition, and conversion checking over `EConstr.constr`, `Environ.env`, `Evd.evar_map`, and `Stack.t`, enabling efficient proof validation and tactic execution. The stack submodule manipulates reduction contexts using structures like `app_node` and `case_stk`, allowing precise control over applicative decomposition and reduction tracing. The constant reduction policies and native reduction components enable fine-grained control over constant unfolding and evaluation of primitives, such as reducing `CPrimitives.t` operations under specific substitutions and universes.",
      "description_length": 811,
      "index": 437,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Indrec",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles the construction and validation of elimination schemes for inductive types, including dependent and mutual recursion cases. It works with inductive definitions, sorts, and term structures to build case analysis and induction principles tailored to specific type properties. Concrete use cases include generating Peano-style induction schemes, checking elimination validity based on type dependencies, and resolving eliminator names and suffixes for inductive constructs.",
      "description_length": 490,
      "index": 438,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cbv",
      "library": "rocq-runtime.pretyping",
      "description": "This module implements call-by-value normalization for Coq terms, using reduction flags, an environment, and an evar map to control and track the normalization process. It works with `cbv_infos` structures that encapsulate reduction parameters, and operates on `EConstr.constr` values to reduce them to normal form. It is used in proof checking and term manipulation tasks where precise reduction behavior is required.",
      "description_length": 418,
      "index": 439,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vnorm",
      "library": "rocq-runtime.pretyping",
      "description": "Performs call-by-value reduction using a virtual machine, operating on Coq's internal terms and types. It takes an environment, evar map, term, and type, returning the normalized term. Useful for efficient evaluation of terms during proof checking or tactic execution.",
      "description_length": 268,
      "index": 440,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Genarg",
      "library": "rocq-runtime.pretyping",
      "description": "This module enables the registration and transformation of extensible argument types used in Coq's tactic and vernacular command extensions. It operates on `Genarg` values annotated with phantom types to track processing stages\u2014raw parsing, global resolution, and top-level interpretation\u2014supporting embedded values like tactic expressions, notation terms, and Ltac arguments. Key operations include registering type-specific printers, substitution handlers, and interpreters to ensure correct parsing, globalization, and evaluation across AST layers. It facilitates concrete use cases such as defining custom notations with `ltac2:(...)`, extending vernacular commands with user-defined syntax, and embedding tactic scripts in Hint Extern and Ltac definitions.",
      "description_length": 761,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Combinators",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides functions for constructing and manipulating nested sigma-types and tuples in Coq's internal term language. It handles operations like telescoping contexts into sigma-types, building iterated tuples that inhabit these types, and generating case-split selectors for inductive types. These functions are used in tactic development and term elaboration where structured term manipulation is required.",
      "description_length": 417,
      "index": 442,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Find_subterm",
      "library": "rocq-runtime.pretyping",
      "description": "This module supports finding and replacing subterms within Coq's extended constructions, either exactly or under a customizable unification function. It operates on data types like `EConstr.constr` and `EConstr.named_declaration`, handling occurrences specified via `Locus.occurrences`. Concrete use cases include substituting specific closed terms in expressions or hypotheses, with support for managing universe constraints during replacement.",
      "description_length": 445,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Typeclasses",
      "library": "rocq-runtime.pretyping",
      "description": "This module supports operations for managing typeclass hierarchies and instance resolution in Coq's type system, including loading, querying, and removing typeclasses, extracting class metadata, and handling universe polymorphism. It works with data structures like typeclass definitions, instance hints, and existential variable maps (`Evd.evar_map`) to enable tasks such as unification, membership checking, and customizable resolution of typeclass constraints during inference. Specific use cases include resolving universe-level obligations, filtering resolvable evars, and enforcing instance uniqueness in proof contexts.",
      "description_length": 626,
      "index": 444,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "GlobEnv",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages environments extended with naming and Ltac interpretation data, primarily for type inference and term manipulation. It provides operations to register interpretation functions, push declarations, create evars, and handle variable renaming and hiding. Concrete use cases include managing bound variables during pattern matching, resolving Ltac variables, and supporting proper naming in pretyping and tactic execution.",
      "description_length": 437,
      "index": 445,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pattern",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines data types and structures for representing patterns in terms and case analysis. It includes types for pattern variables, case info patterns, and various kinds of construction patterns, supporting precise pattern matching and analysis. It is used in the implementation of match expressions and tactic pattern handling.",
      "description_length": 337,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_pretype",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages mappings of pattern variables during tactic preprocessing, handling terms under binders and untyped or closed constructions. It supports operations for matching and substituting variables in terms, preserving binder order and avoiding conflicts with existing variable names. Used in tactic execution to bind and propagate matched terms, identifiers, and arguments in proof scripts.",
      "description_length": 401,
      "index": 447,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Program",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides utilities to retrieve Coq constants for logical constructs (e.g., sigma types, equality) and compose propositions (`mk_coq_and`, `mk_coq_not`), alongside polymorphic application over delayed references. It operates on Coq's kernel structures\u2014environments, evar maps, and constr terms\u2014and queries implicit global state to determine compilation behaviors like proof transparency and coercion handling. These capabilities support proof term generation, program extraction, and logical consistency management in program definitions.",
      "description_length": 549,
      "index": 448,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pretyping",
      "library": "rocq-runtime.pretyping",
      "description": "This component provides type inference capabilities for converting untyped global terms (`glob_constr`) into fully typed terms (`constr`), specializing in resolving complex pattern-matching constructs, inserting coercions, and handling implicit arguments. It operates on environments (`env`) and existential variable maps (`evar_map`), leveraging typeclasses and unification constraints to solve existential variables through heuristics or external solvers. Key use cases include elaborating terms under bidirectional type hints, compiling high-level pattern-matching into elementary forms, and managing guards for fixpoint/cofixpoint definitions.",
      "description_length": 647,
      "index": 449,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Retyping",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides functions to recompute the type of terms without full type-checking, assuming the input is well-typed. It operates on Coq's internal term and type representations, such as `EConstr.constr`, `EConstr.types`, and environments like `Environ.env` and `Evd.evar_map`. It is used in contexts where performance is critical and full type-checking overhead must be avoided, such as in proof term transformations, extraction, and tactic development.",
      "description_length": 460,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Arguments_renaming",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles argument renaming and type manipulation for global references. It provides operations to set and retrieve argument names, rename types based on specified parameters, and perform type checking with environment support. These functions are used when defining or modifying the parameters of constants or inductive types, ensuring correct name binding and type consistency during compilation.",
      "description_length": 408,
      "index": 451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Gensubst",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles substitution operations for generic arguments in Coq's abstract syntax trees. It provides functions to apply substitutions to terms, perform generic term substitutions, and register custom substitution functions for specific argument types. Concrete use cases include manipulating Coq expressions during tactic execution and transforming terms with bound variables.",
      "description_length": 385,
      "index": 452,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coercion",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles type coercions and conversions during type checking, providing operations to insert coercions into terms to match expected types, including coercions to sorts, base types, and function types. It works with environments, evar maps, unsafe judgments, and coercion traces, supporting concrete tasks like pattern coercion in case expressions and handling subset types in program mode. Use cases include resolving type mismatches in function application, converting terms to expected types during unification, and transforming inductive patterns through registered coercions.",
      "description_length": 590,
      "index": 453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coercionops",
      "library": "rocq-runtime.pretyping",
      "description": "This module orchestrates coercion class management and inheritance path resolution in type systems, offering operations to query and manipulate coercion paths, check reversibility, and handle metadata across environments and inductive types. It centers around key data types like `cl_typ` and structured sets, supporting precise operations such as path discovery, coercion declaration, and set-based analysis of subtype relationships. The integrated child module enriches this with functional set operations\u2014union, intersection, filtering\u2014on `cl_typ` collections, enabling advanced manipulation of coercion-related data through both individual sets and aggregated list-of-set structures. Together, they facilitate tasks like resolving implicit coercions in Coq's type checker and analyzing complex subtype hierarchies through set transformations and path analysis.",
      "description_length": 864,
      "index": 454,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Glob_term",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides operations for manipulating untyped intermediate terms during Coq's elaboration pipeline, focusing on name resolution, implicit argument handling, and notation expansion while postponing coercion insertion and pattern-matching compilation. It works with generalized data structures like `predicate_pattern`, `extended_glob_local_binder`, and `any_glob_constr` to represent terms, patterns, and binders in a flexible, extensible format. These structures are specifically used for processing tactics and intermediate representations where heterogeneous term manipulation and modular term reconstruction are required.",
      "description_length": 635,
      "index": 455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evardefine",
      "library": "rocq-runtime.pretyping",
      "description": "This module manipulates existential variables and type/value constraints in a type-checking environment. It provides operations to instantiate evars with arguments, split type constraints, define evars as products, lambdas, or sorts, and transform constraints between different forms. These functions are used during type inference and elaboration to manage evar dependencies and enforce typing constraints.",
      "description_length": 407,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Locus",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles positions and occurrences of hypotheses and goals in proof contexts. It provides types and structures to specify which parts of a goal (such as specific hypotheses or the conclusion) and how many instances of a term should be targeted for operations like rewriting or inversion. Concrete use cases include selecting occurrences of a term in a hypothesis or conclusion for tactics such as `rewrite` or `inversion`, and specifying which hypotheses to include or exclude when applying a tactic.",
      "description_length": 511,
      "index": 457,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Heads",
      "library": "rocq-runtime.pretyping",
      "description": "Computes approximations of head symbols for constants and local definitions, determining whether terms reduce to rigid head symbols. Works with terms represented as `EConstr.constr`, using environment and evar map context. Used to analyze term structure for evaluation and reduction behavior in proof checking.",
      "description_length": 310,
      "index": 458,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nativenorm",
      "library": "rocq-runtime.pretyping",
      "description": "Performs normalization of Coq terms by evaluating them into OCaml code. It takes a term and its type, along with environment and evar_map, and returns the normalized term. Useful for implementing efficient reduction strategies in Coq's type checker.",
      "description_length": 249,
      "index": 459,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evaluable",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines a sum type representing references that can be evaluated, including variables, constants, and projections. It provides operations to transform these references using mapping functions and to compare them for equality. Additionally, it supports converting evaluable references into a form suitable for conversion oracles.",
      "description_length": 340,
      "index": 460,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "TemplateArity",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines a recursive type `template_arity` representing the structure of inductive type arities, including template arguments, constructor types, and inductive types with universe constraints. It includes operations to analyze and retrieve the template arity of inductive types from the environment, determining whether they can be instantiated in `Prop`. The module is used during type checking to handle template polymorphism and universe management in inductive definitions.",
      "description_length": 488,
      "index": 461,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pretype_errors",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides error types and handling mechanisms for unification and type-checking failures, including unification mismatches, unsolvable constraints, and abstraction anomalies during type inference and tactic execution. It operates on core data structures like environments, evar maps, existential variables, and constr terms, enabling precise error reporting with contextual details such as source locations and constraint inconsistencies.",
      "description_length": 449,
      "index": 462,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Geninterp",
      "library": "rocq-runtime.pretyping",
      "description": "This module interprets generic arguments and Ltac values in a proof context, using data types like `genarg_type`, `Val.t`, and `TacStore.t` to manage dynamic representations and typed values. It enables evaluation of Ltac expressions, type-safe value injection, and context-aware interpretation through operations like argument type registration and value comparison. Submodules handle structured data such as typed value tags, dynamic field stores, and type-preserving key-value maps, supporting use cases like managing tactic state, typed variable bindings, and heterogeneous mappings. Together, they provide a cohesive framework for interpreting and manipulating typed values across generic and concrete contexts.",
      "description_length": 716,
      "index": 463,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Typeclasses_errors",
      "library": "rocq-runtime.pretyping",
      "description": "This module defines error types for typeclass-related operations, including `NotAClass` and `unbound_method`, which capture invalid typeclass usages. It provides functions to raise these errors within the context of an environment and evar map, using global references and identifiers. These are used during typeclass resolution to signal missing or malformed typeclass instances and methods.",
      "description_length": 392,
      "index": 464,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evarconv",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles term-level unification and conversion checking within type-checking environments, focusing on resolving existential variables and constraints through heuristic-driven strategies. It operates on terms, evar maps, and typing contexts to support tasks like canonical structure resolution, second-order pattern matching, and customizable constraint solving. Its mechanisms are essential for managing complex type inference scenarios where delayed unification or strategic evar resolution is required.",
      "description_length": 516,
      "index": 465,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Unification",
      "library": "rocq-runtime.pretyping",
      "description": "This module orchestrates higher-order unification and constraint solving over terms and environments, integrating metavariable management, ordered set operations, and persistent map transformations. It supports key data types like `Meta.t` for metavariables, evar_maps for persistent assignments, and ordered sets for tracking metavariable collections, with operations for instantiation, coercion, and abstraction building. You can perform inversion, pattern unification, and type-directed term reconstruction while applying custom reduction strategies and effectful map traversals. The module enables efficient manipulation of metavariable dependencies, merging and transforming evar_maps with structural sharing, and managing metavariable sets with deterministic ordered operations.",
      "description_length": 784,
      "index": 466,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cases",
      "library": "rocq-runtime.pretyping",
      "description": "This module handles the compilation and validation of pattern-matching constructs in the context of inductive types and constructors. It provides operations for checking pattern exhaustiveness, argument counts, and irrefutability, as well as translating high-level pattern-matching syntax into low-level terms. It works directly with inductive types, constructors, and global constraints, supporting use cases like typechecking case expressions and generating return predicates for match statements.",
      "description_length": 499,
      "index": 467,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Detyping",
      "library": "rocq-runtime.pretyping",
      "description": "This module converts typed terms into untyped global syntax trees, handling name resolution, pattern factorization, and context substitution across constructions, environments, and substitution mappings. It supports operations like pretty-printing terms for proof assistants, optimizing pattern matching clauses, and substituting variables in complex expressions. A child module specializes in encoding and manipulating inductive types with qualified identifiers, enabling their substitution, discharge, and structured display. Together, they provide a pipeline for transforming and rendering rich type-level data into simplified, usable forms.",
      "description_length": 644,
      "index": 468,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Inductiveops",
      "library": "rocq-runtime.pretyping",
      "description": "The module facilitates manipulation of inductive types and constructors within Coq's type theory, supporting operations like substitution, lifting, arity extraction, and universe consistency checks. It works with environments, evar maps, inductive families, and constructor data to analyze recursive structures, build case expressions, and compute projections for dependent type definitions. Key applications include type-checking inductive definitions, instantiating parameterized constructors, and handling elimination rules with precise sort constraints.",
      "description_length": 557,
      "index": 469,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Keys",
      "library": "rocq-runtime.pretyping",
      "description": "This module manages key equivalence declarations and checks, using a `key` type to represent symbolic identifiers. It provides operations to declare two keys as equivalent, test key equivalence, and compute a key from a term's head structure in a given environment. A concrete use case includes managing identifier mappings during term normalization or ensuring consistent key representation in proof automation.",
      "description_length": 412,
      "index": 470,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Patternops",
      "library": "rocq-runtime.pretyping",
      "description": "This module implements operations for constructing, transforming, and comparing patterns used in proof automation and term manipulation. It supports pattern matching on terms with metavariables, substitution under patterns, and extracting head references from patterns. Concrete use cases include interpreting patterns during tactic execution, checking pattern equality in unification algorithms, and lifting patterns through binders in higher-order contexts.",
      "description_length": 459,
      "index": 471,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tacred",
      "library": "rocq-runtime.pretyping",
      "description": "This module focuses on reducing, normalizing, and evaluating Coq terms, with operations like simplification, head-normalization, unfolding definitions, and substitution. It works with environments, evar maps, inductive types, and evaluable references to manage tasks such as contextual reduction, privacy checks for inductives, and handling global references during tactic execution. Key applications include simplifying expressions, normalizing terms under specific reduction strategies, and resolving definitions while respecting scoping constraints.",
      "description_length": 552,
      "index": 472,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constr_matching",
      "library": "rocq-runtime.pretyping",
      "description": "This module provides functions for pattern-matching on Coq terms, supporting both full and subterm matching with context handling. It works with data types such as `constr_pattern`, `constr`, `patvar_map`, and `context`, enabling precise binding and substitution of metavariables and bound variables. Concrete use cases include implementing tactics that analyze or transform proof terms based on structural patterns, such as rewriting or inversion.",
      "description_length": 448,
      "index": 473,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Glob_ops",
      "library": "rocq-runtime.pretyping",
      "description": "This component provides operations for transforming and analyzing abstract syntax elements in a proof assistant's core language, focusing on global terms and pattern-matching structures. It works with data types representing constructions, case patterns, binding contexts, and sorting levels, offering capabilities like variable capture analysis, context-preserving transformations, and canonical form encoding. Specific utilities include argument application, pattern parameterization adjustments, and bidirectional conversion between pattern representations while maintaining semantic integrity during term manipulations.",
      "description_length": 623,
      "index": 474,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tacinterp.Value",
      "library": "ltac_plugin",
      "description": "This module provides functions to convert between Coq values and their tactic-level representations, supporting operations like embedding and extracting Coq terms, integers, and lists. It works with tactic values, Coq constructions, integers, and lists of tactic values, enabling dynamic evaluation and application of tactics. Concrete use cases include implementing custom tactic combinators, interpreting tactic expressions with arguments, and manipulating proof terms within Ltac2 plugins.",
      "description_length": 492,
      "index": 475,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.Taccoerce.Value",
      "library": "ltac_plugin",
      "description": "This module defines conversions between dynamic values and specific types like `EConstr.constr`, `int`, and `Names.Id.t`, enabling safe extraction and injection of typed data from untyped values. It supports operations such as `to_constr`, `of_int`, and `to_ident` for working with Coq's Ltac values in a type-safe manner. Use cases include interpreting Ltac expressions that require coercion of generic arguments into concrete types during tactic execution.",
      "description_length": 458,
      "index": 476,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.Tacinterp.TacStore",
      "library": "ltac_plugin",
      "description": "This module implements a type-safe key-value store for tactic interpretation states, supporting operations to create, set, get, and remove fields with arbitrary values. It uses a polymorphic field type to associate named entries with their values, enabling dynamic storage of tactic-specific data during proof execution. Concrete use cases include tracking local tactic state, caching intermediate results, or passing contextual information between tactic invocations.",
      "description_length": 468,
      "index": 477,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tacentries",
      "library": "ltac_plugin",
      "description": "This module defines and extends Ltac tactics, notations, and quotations through direct manipulation of tactic expressions, grammar productions, and argument types. It operates on tactic definitions, raw and typed arguments, and grammar entries to enable custom tactic syntax and behavior. Concrete uses include registering new Ltac commands, defining tactic notations with custom parsing rules, and embedding ML-defined tactics directly into Ltac scripts.",
      "description_length": 455,
      "index": 478,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.Tactic_debug",
      "library": "ltac_plugin",
      "description": "This module implements a basic debugger for tactic expressions, providing functionality to track and print tactic execution states, handle exceptions during debugging, and manage breakpoints. It operates on tactic expressions, proof states, and trace information, using data types like `debug_info` and `ltac_trace`. Concrete use cases include stepping through tactic evaluations, inspecting intermediate proof states, and diagnosing tactic-related exceptions without treating them as critical anomalies.",
      "description_length": 504,
      "index": 479,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Leminv",
      "library": "ltac_plugin",
      "description": "This module provides tactics for inversion lemmas, enabling the derivation of equalities from inductive types. It operates on quantified hypotheses, constructions, and identifier lists, supporting proof manipulation in Coq. Concrete use cases include automating case analysis and generating inversion principles for inductive predicates.",
      "description_length": 337,
      "index": 480,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Extratactics",
      "library": "ltac_plugin",
      "description": "This module defines comparison operators (`Eq`, `Lt`, `Le`, `Gt`, `Ge`) and provides typed witnesses for comparison and test operations, primarily used in tactic definitions. It supports working with integers and variables in the context of Coq's Ltac language, enabling conditional logic based on numeric values. Concrete use cases include writing custom tactics that perform comparisons or tests on integer expressions during proof automation.",
      "description_length": 445,
      "index": 481,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Pltac",
      "library": "ltac_plugin",
      "description": "This module defines parsing entries for various components used in writing and interpreting tactics, such as `constr`, `bindings`, `hypident`, and `tactic`. It provides direct support for parsing tactic expressions, introduction patterns, clause locations, and destruction arguments. These are used to implement custom tactics in Coq that manipulate terms, hypotheses, and proof states in specific, structured ways.",
      "description_length": 415,
      "index": 482,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.G_obligations",
      "library": "ltac_plugin",
      "description": "This module defines generalized argument types and entry points for handling optional tactic expressions in Coq's Ltac plugin system. It works with `raw_tactic_expr` and constructs like `vernac_genarg_type` and `Procq.Entry.t` to support tactic parsing and execution. Concrete use cases include extending Coq's vernacular commands with optional tactic arguments and processing tactic expressions in proof scripts.",
      "description_length": 413,
      "index": 483,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.G_class",
      "library": "ltac_plugin",
      "description": "This module defines generalized argument types and entries for configuring debugging flags and eauto search strategies in tactic definitions. It supports operations to specify and retrieve boolean debug settings and search strategy parameters, working directly with `Genarg.genarg_type` and `Procq.Entry.t` structures. Concrete use cases include customizing tactic behavior during proof automation, such as enabling debug output or selecting specific search algorithms for type class resolution.",
      "description_length": 495,
      "index": 484,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.G_ltac",
      "library": "ltac_plugin",
      "description": "This module provides utilities for converting Coq/Ltac data types (e.g., `int`, `constr_expr`, tactic expressions) into `Genarg`-typed arguments, enabling tactic registration and parsing. It defines grammar constructs, parsing entries, and argument-processing mechanisms for Ltac tactics, supporting customization of tactic behavior and extension of parsing rules. These components are used to implement tactic definitions, handle proof modes, and manage hint-based automation in Coq's Ltac system.",
      "description_length": 498,
      "index": 485,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tactic_option",
      "library": "ltac_plugin",
      "description": "This module defines and manages tactic options with support for declaring, setting, and retrieving tactic expressions. It works with tactic expressions, option locality attributes, and proof manipulation primitives. Concrete use cases include configuring tactic behavior dynamically, such as setting default tactics for options and querying those settings during proof construction.",
      "description_length": 382,
      "index": 486,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tacarg",
      "library": "ltac_plugin",
      "description": "This module defines a variety of generalized argument types used in tactic expressions, such as introduction patterns, quantified hypotheses, and binding structures, each supporting parsing, globbing, and interpretation phases. It handles data types like `intro_pattern`, `with_bindings`, `tactic_expr`, and `quantified_hypothesis`, enabling precise manipulation of Coq's tactic language constructs. These are used to implement tactics that require structured input, such as pattern matching on goals, hypothesis manipulation, and tactic composition with bound variables.",
      "description_length": 571,
      "index": 487,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Internals",
      "library": "ltac_plugin",
      "description": "This module provides low-level tactics and utilities for manipulating proof terms, hypotheses, and expressions in Coq's proof system. It operates on internal data structures like `EConstr.t` for terms, `Locus.clause` for goal targeting, and `Names.Id.t` for identifiers, enabling operations such as hypothesis discrimination, term refinement, existential variable handling, and clause replacement. These tools are used for implementing proof automation, term inspection, and integration with proof assistants like ProofGeneral.",
      "description_length": 527,
      "index": 488,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tacexpr",
      "library": "ltac_plugin",
      "description": "This module provides types for constructing and manipulating tactic expressions in Coq's Ltac language, focusing on directional operations, scoping, and evaluation strategies. It works with terms, patterns, constants, references, and occurrence variables across raw, glob, and typed processing stages, while supporting atomic tactics, rewriting strategies, and ML-defined tactic integration. Key use cases include defining custom proof automation tactics, structured term manipulation during proof development, and tracing tactic execution contexts with environment data.",
      "description_length": 571,
      "index": 489,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.G_tactic",
      "library": "ltac_plugin",
      "description": "This module defines parser entry points for recognizing specific syntactic constructs in tactic expressions, such as identifiers followed by assignment operators or enclosed in brackets. It works with parsing states and lexical tokens to match patterns like `x :=`, `(x)`, or `[=]` within tactic scripts. Concrete use cases include parsing custom tactic notations and handling structured goal manipulations in proof scripts.",
      "description_length": 424,
      "index": 490,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tacenv",
      "library": "ltac_plugin",
      "description": "The module enables registering, managing, and resolving both user-defined and ML-level tactics within Coq's Ltac system, using tactic entries and a global tactic environment. It supports operations like defining aliases, tracking redefinitions, and emitting deprecation warnings, while providing direct lookup for ML tactics by name during proof scripting or tactic composition. Use cases include integrating custom tactics into Coq's ecosystem, dynamically resolving tactic references, and maintaining backward compatibility for evolving tactic libraries.",
      "description_length": 556,
      "index": 491,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tactic_matching",
      "library": "ltac_plugin",
      "description": "This module implements pattern matching logic for Ltac's `match` and `match goal` constructs. It provides `match_term` and `match_goal` functions to match Coq terms and proof goals against sets of structured rules, producing tactic expressions based on matched patterns. It operates on Coq's term and goal representations, including environments, evar_maps, named contexts, and tactic expressions. Use cases include writing Ltac scripts that perform case analysis on terms or hypotheses, applying different tactics based on the structure of the goal.",
      "description_length": 550,
      "index": 492,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tacinterp",
      "library": "ltac_plugin",
      "description": "This module interprets and evaluates Coq tactics and Ltac expressions, handling constraint resolution, binding interpretation, and tactic execution using tactic expressions, environments, evar_maps, and constr values. It supports preprocessing, globalization, and debugging in proof automation, with direct use cases like resolving tactic script bindings and executing tactics interactively. The conversion submodule enables embedding and extracting Coq terms, integers, and lists for dynamic tactic application, while the state submodule provides a type-safe key-value store for managing tactic-specific data across invocations. Together, these components allow implementing custom tactic combinators, caching intermediate proof results, and passing contextual information during tactic execution.",
      "description_length": 798,
      "index": 493,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.G_rewrite",
      "library": "ltac_plugin",
      "description": "This module handles parsing, binding, and rewriting operations for Coq's tactic language. It provides support for working with global and parsed constructions, rewrite strategies, and binder expressions. Concrete use cases include defining and manipulating rewrite rules, tactic arguments, and expression bindings during proof scripting.",
      "description_length": 337,
      "index": 494,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Pptactic",
      "library": "ltac_plugin",
      "description": "This module enables pretty-printing and custom formatting of Ltac expressions, their syntactic components, and related environments through operations that convert structured data (e.g., tactics, match patterns, constants, and evar_maps) into human-readable `Pp.t` output. It supports context-sensitive rendering across stages like raw parsing, globbing, and interpretation, while handling specialized contexts such as redexes, clauses, and occurrence specifications. Key use cases include generating readable representations of tactic notations, debugging Ltac execution traces, and formatting error messages involving Ltac expressions.",
      "description_length": 637,
      "index": 495,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Taccoerce",
      "library": "ltac_plugin",
      "description": "This module bridges untyped Ltac values with Coq's typed data structures by converting dynamic `Value.t` objects into entities like `EConstr.constr` and `Names.Id.t` during tactic execution. It examines runtime types to resolve values within environments and evar_maps, handling type mismatches and errors. The child module provides direct coercions such as `to_constr`, `of_int`, and `to_ident`, enabling precise extraction and injection of typed data from untyped Ltac arguments. These functions support operations like converting Ltac integers to OCaml `int` or extracting identifiers for hypothesis manipulation in proof scripts.",
      "description_length": 633,
      "index": 496,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.ComRewrite",
      "library": "ltac_plugin",
      "description": "This module provides operations for defining and managing rewrite rules and relations in Coq's tactic system. It works with Coq's internal syntax and proof structures, including constr_expr, local_binder_expr, and tactic types. Concrete use cases include declaring custom rewrite relations, adding setoids, and registering morphisms interactively or as parameters.",
      "description_length": 364,
      "index": 497,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.Extraargs",
      "library": "ltac_plugin",
      "description": "This module provides parsing and pretty-printing functionality for Ltac tactic arguments, focusing on syntax representations like orientations, renaming, and occurrence selections. It works with data structures such as concrete syntax witnesses (`wit_orient`, `wit_occurrences`), parsing entries (`glob`, `hloc`), and utility types (`loc_place`, `place`) to manage tactic execution contexts. These tools enable use cases like processing tactic expressions with optional components, testing syntax patterns, and handling environment-dependent printing during proof scripting.",
      "description_length": 574,
      "index": 498,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.G_auto",
      "library": "ltac_plugin",
      "description": "This module defines generalized argument types and entry points for handling hint databases, paths, and optional hints in proof automation. It supports parsing and processing of hint-related constructs, including hint bases, paths, and expressions. Concrete use cases include configuring automated tactics with specific hint databases or paths during proof development.",
      "description_length": 369,
      "index": 499,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin.Tacintern",
      "library": "ltac_plugin",
      "description": "This module converts raw tactic expressions into globally resolved tactic expressions, handling variable and hypothesis globalization, constraint resolution, and reduction expression processing. It operates on data types like `raw_tactic_expr`, `glob_sign`, `constr_expr`, and `red_expr`, producing globally valid counterparts such as `glob_tactic_expr` and `glob_constr`. It is used during tactic parsing to prepare expressions for execution in a given environment, ensuring proper binding and scoping of variables and hypotheses.",
      "description_length": 531,
      "index": 500,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ltac_plugin.Tacsubst",
      "library": "ltac_plugin",
      "description": "This module handles the substitution of tactics and related expressions during module closing in the context of Coq's Ltac language. It provides functions to apply substitutions to tactic expressions, generic arguments, reduction expressions, and globally interned constructions with bindings. These operations are used when closing modules to adjust tactic and term references to their new environments.",
      "description_length": 404,
      "index": 501,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ltac_plugin",
      "library": "ltac_plugin",
      "description": "This module extends Coq's Ltac system to define, parse, debug, and execute custom tactics with rich syntactic and semantic control. It introduces core data types like `tactic_expr`, `raw_tactic_expr`, `debug_info`, and `ltac_trace`, and supports operations for tactic composition, inversion, comparison, rewriting, and environment manipulation. Users can create custom tactic notations, step through tactic execution, derive equalities from inductive types, and embed ML-defined tactics, enabling advanced proof automation and structured goal manipulation. Examples include writing conditional tactics based on integer comparisons, defining custom inversion lemmas, and registering ML-level tactics for interactive proof scripting.",
      "description_length": 731,
      "index": 502,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Formula.Env",
      "library": "firstorder_core_plugin",
      "description": "Maintains variable bindings and type information for logical formulas during parsing and evaluation. It supports operations to add, lookup, and manage variables within a formula context. Useful when processing first-order logic expressions where environment state must be tracked across nested scopes.",
      "description_length": 301,
      "index": 503,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Unify.Item",
      "library": "firstorder_core_plugin",
      "description": "This module represents and manipulates items used in unification processes, typically involving logical variables and constraints. It provides operations to compare items, check if they are ground (i.e., contain no variables), and retrieve their internal representation as a pair of an integer and a Coq constructor. These capabilities are essential for implementing unification algorithms in proof search or term rewriting systems.",
      "description_length": 432,
      "index": 504,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Rules",
      "library": "firstorder_core_plugin",
      "description": "This module implements tactics for applying first-order logic rules to sequents, handling operations like conjunction, disjunction, implication, quantifiers, and induction. It works with data types such as `tactic`, `seqtac`, `lseqtac`, `GlobRef`, `pinductive`, and Coq's `constr` and `types`. Concrete use cases include automating logical reasoning steps in proof scripts, such as decomposing implications, applying induction principles, or handling case analysis on inductive types.",
      "description_length": 484,
      "index": 505,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Firstorder_core_plugin.Instances",
      "library": "firstorder_core_plugin",
      "description": "Implements functions for collecting and handling quantified formulas in a sequent calculus context. Works with environments, evar_maps, sequents, and formulas to support tactic development. Used to extract and manipulate quantified formulas during proof search in automated theorem proving.",
      "description_length": 290,
      "index": 506,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Firstorder_core_plugin.Formula",
      "library": "firstorder_core_plugin",
      "description": "This module enables the construction and manipulation of first-order logic formulas with atoms, quantifiers, and logical connectives, using GADTs like `any_formula` to unify different formula representations. It integrates environment management through variable binding operations, allowing the tracking of type information and identifiers across nested scopes during parsing and evaluation. With support for proof context transformations via evar maps and flags, it facilitates normalization and abstraction of logical expressions in theorem proving workflows. Example uses include building and comparing quantified expressions, managing hypothesis contexts, and transforming logical formulas during interactive proof sessions.",
      "description_length": 729,
      "index": 507,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Ground",
      "library": "firstorder_core_plugin",
      "description": "Implements a ground tactic for processing sequents with customizable flags. It provides access to global flags and a higher-order tactic that applies a given function to sequents, enabling precise control over proof strategies. Useful for implementing custom proof automation that operates on ground terms without variables.",
      "description_length": 324,
      "index": 508,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Unify",
      "library": "firstorder_core_plugin",
      "description": "This module implements unification for atoms in a first-order logic context, enabling operations to match and generalize terms that involve both real and phantom instances. It works with core data types such as `instance`, atoms, and environments like `evar_map` and `metavariable`, supporting key operations to check generality between atoms and unify atomic formulas during theorem proving. The child module enhances this by representing and manipulating logical variables and constraints, offering comparisons, ground checks, and access to internal item representations as integer-constructor pairs. Together, they enable precise unification tasks in proof search and term rewriting, such as matching a term against a pattern or generalizing two atoms into a common supertype.",
      "description_length": 779,
      "index": 509,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin.Sequent",
      "library": "firstorder_core_plugin",
      "description": "This module manages sequents for first-order logic reasoning, providing operations to manipulate formulas, track redexes, and maintain proof state. It works with data types like `t` for sequents, `h_item` for hypothesis items, and interacts with environments, evar maps, and glob references. Concrete use cases include adding and removing formulas from the sequent, deepening the search space, recording and looking up hypotheses, and integrating auto hints during proof search.",
      "description_length": 478,
      "index": 510,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_core_plugin",
      "library": "firstorder_core_plugin",
      "description": "This module provides a comprehensive framework for first-order logic reasoning within a sequent calculus system. It centers around data types such as `tactic`, `seqtac`, `any_formula`, `t` (for sequents), and `evar_map`, supporting operations like unification, quantifier handling, formula construction, and hypothesis management. Users can automate logical reasoning steps such as decomposing implications, applying induction, performing case analysis, and transforming logical expressions across nested scopes. Specific applications include building custom proof automation tactics, normalizing quantified formulas, matching and generalizing terms, and maintaining dynamic proof states during interactive theorem proving sessions.",
      "description_length": 732,
      "index": 511,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial.ProofFormat.Env",
      "library": "micromega_plugin",
      "description": "This module manages environments for proof generation in polynomial reasoning, providing operations to construct and manipulate proof contexts. It works with integer, rational, and real number proofs, supporting specific constructions like `CutPrf` tailored for integer arithmetic. Concrete use cases include generating and validating proofs in algebraic decision procedures over numeric domains.",
      "description_length": 396,
      "index": 512,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial.LinPoly.MonT",
      "library": "micromega_plugin",
      "description": "This module manages a bijective mapping between monomials and integer variables. It provides operations to register and retrieve monomials, reserve specific integers, and obtain fresh variables. It is used to maintain a consistent integer-to-monomial correspondence during polynomial manipulation.",
      "description_length": 297,
      "index": 513,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_plugin.Polynomial.BoundWithProof",
      "library": "micromega_plugin",
      "description": "This module represents polynomial bounds with associated proofs. It supports constructing bounds from polynomial expressions, multiplying bounds while preserving proof validity, and extracting both the bound and proof components. It is used to formally verify arithmetic properties in Coq's micromega tactic, particularly for reasoning about inequalities involving polynomials.",
      "description_length": 377,
      "index": 514,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial.ProofFormat",
      "library": "micromega_plugin",
      "description": "This module defines data structures and operations for constructing and manipulating proofs in a Rocq-compatible format, tailored for arithmetic reasoning over integers, rationals, and reals. It includes core proof rules like `AddPrf`, `MulPrf`, and `CutPrf`, and supports transformations such as normalization and compilation to internal proof formats. The child module extends this by managing proof environments for polynomial reasoning, enabling context-aware proof construction and validation over numeric domains. Together, they support generating and processing formal proofs in automated theorem proving tools, particularly for arithmetic goals involving algebraic manipulations and cuts specific to integer arithmetic.",
      "description_length": 727,
      "index": 515,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Micromega_plugin.Polynomial.Monomial",
      "library": "micromega_plugin",
      "description": "This module represents monomials as multisets of variables with associated degrees. It supports operations to compute the total degree, check subset relations, fold over variable-degree pairs, and output a textual representation. It is used for manipulating algebraic expressions in formal verification tasks involving polynomials.",
      "description_length": 331,
      "index": 516,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Vect.Bound",
      "library": "micromega_plugin",
      "description": "This module represents and manipulates bounds on variables in a vector space using rational coefficients and constants. It provides conversions between bound representations and vectors, enabling precise arithmetic and constraint handling. Concrete use cases include solving linear constraints and interval analysis in formal verification tasks.",
      "description_length": 345,
      "index": 517,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial.LinPoly",
      "library": "micromega_plugin",
      "description": "This module represents linear polynomials as sorted association lists, supporting variable creation, polynomial construction, and arithmetic operations like product. It enables symbolic manipulation of linear expressions, constraint generation, and pretty-printing of polynomials as Coq goals. A child module maintains a bijection between monomials and integer variables, allowing registration, retrieval, and reservation of monomial-variable mappings. Together, they support concrete operations such as converting monomials to variables, building and evaluating linear constraints, and generating theorem proving goals with consistent variable tracking.",
      "description_length": 654,
      "index": 518,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial.Poly",
      "library": "micromega_plugin",
      "description": "This module represents polynomials with rational coefficients, supporting operations like addition, multiplication, negation, and evaluation. It works with monomials and rational numbers, allowing construction and manipulation of polynomial expressions. Concrete use cases include symbolic algebra, constraint solving, and arithmetic expression simplification.",
      "description_length": 360,
      "index": 519,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Persistent_cache.PHashtable",
      "library": "micromega_plugin",
      "description": "Implements a persistent hash table that stores key-value pairs in a file, supporting operations to add, find, and memoize values with type-safe file-backed storage. Works with any key type and arbitrary value types, ensuring bindings persist across sessions. Useful for caching expensive computations like proof results or file metadata, where durability and lookup efficiency are critical.",
      "description_length": 390,
      "index": 520,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial.MonMap",
      "library": "micromega_plugin",
      "description": "This module implements a polymorphic map structure with monomials as keys, supporting operations like insertion, lookup, ordered traversal, and merging with conflict-resolution strategies. It is designed for polynomial manipulation, enabling efficient representation of terms as key-value pairs and facilitating coefficient aggregation, term filtering, and sequence-based construction of maps. Utilities for folding, iteration, and sequence conversion further support complex polynomial computations and transformations.",
      "description_length": 520,
      "index": 521,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Persistent_cache",
      "library": "micromega_plugin",
      "description": "This module provides a persistent hash table that efficiently stores and retrieves key-value pairs across program executions, using file-backed storage to ensure durability. It supports arbitrary key and value types through serialization, enabling type-safe caching of results from expensive computations such as proof checking or file analysis. The module includes operations to add, find, and memoize values, with direct access to disk-persisted bindings for maintaining state or accelerating repeated lookups. Submodules extend this functionality with specialized storage strategies and type-specific optimizations for improved performance and safety.",
      "description_length": 654,
      "index": 522,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Vect",
      "library": "micromega_plugin",
      "description": "This module combines sparse vector manipulation with bound analysis to support symbolic computation over rational coefficients and integer variables. It provides core operations like vector addition, scalar multiplication, normalization, and variable substitution, while its bound-handling submodule enables constraint representation and interval analysis. Main data types include `Vect.t` for linear combinations and specialized bound types for constraint solving. Examples include solving linear equations, normalizing expressions with GCD reduction, and converting between vector forms and SMTLIB constraints.",
      "description_length": 612,
      "index": 523,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Polynomial",
      "library": "micromega_plugin",
      "description": "This module represents and manipulates polynomials and linear constraints over rational numbers, using variables as integers and structuring polynomials through submodules. It supports evaluation, comparison, and combination of polynomial expressions and constraints, enabling tasks like constraint solving and arithmetic proof generation. Submodules handle monomials as multisets of variables, linear polynomials as association lists, and rational-coefficient polynomials with arithmetic operations. Additional components manage proof environments, bound reasoning with Coq integration, and monomial-based maps for efficient term manipulation, supporting formal verification and automated theorem proving workflows.",
      "description_length": 716,
      "index": 524,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Certificate",
      "library": "micromega_plugin",
      "description": "This module converts proofs from the Sos module into rational or integer certificates for use in Coq. It provides functions to generate unsatisfiability proofs for linear and non-linear constraint systems over integers or rationals, using Micromega's solvers. These certificates can then be used to validate the results of automated reasoning in a formal proof context.",
      "description_length": 369,
      "index": 525,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Simplex",
      "library": "micromega_plugin",
      "description": "This module implements a simplex-based solver for linear arithmetic constraints over polynomials. It provides functions to search for feasible points, generate unsatisfiability certificates, and solve integer constraint systems with proof output. The module tracks solver performance through detailed profiling statistics returned in a `profile_info` record.",
      "description_length": 358,
      "index": 526,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Linsolve",
      "library": "micromega_plugin",
      "description": "This module solves systems of linear equations over positive integer variables with positive coefficients, generating all possible solutions. It represents equations using identifiers, variables as integers, and supports operations like setting constants, adding monomials, and merging systems. Use cases include constraint solving for small equation systems where enumerating all valid integer solutions is required.",
      "description_length": 417,
      "index": 527,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Coq_micromega",
      "library": "micromega_plugin",
      "description": "This module automates arithmetic reasoning and proof generation for rational and integer formulas in Coq. It operates on logical formulas structured as `BFormula (Formula Q)` or `BFormula (Formula Z",
      "description_length": 198,
      "index": 528,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin.Itv",
      "library": "micromega_plugin",
      "description": "This module represents intervals with optional rational bounds and provides operations for printing, intersecting, comparing, and checking containment of values within intervals. It includes functions to compute the range of an interval, normalize intervals, and determine if one interval is smaller than another. Concrete use cases include constraint solving and interval arithmetic in formal verification tasks.",
      "description_length": 413,
      "index": 529,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Micromega_plugin",
      "library": "micromega_plugin",
      "description": "This module suite provides a comprehensive framework for symbolic arithmetic, constraint solving, and formal proof generation over rational and integer domains. Core data types include polynomials, sparse vectors, linear constraints, and interval bounds, with operations for evaluation, normalization, solving, and proof construction. Functionality spans persistent result caching, linear and nonlinear constraint system solving, simplex-based optimization, and certificate generation for Coq verification. Specific applications include automated theorem proving, SMT constraint translation, integer solution enumeration, and bound analysis for program verification tasks.",
      "description_length": 672,
      "index": 530,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Notation.NotationSet.List",
      "library": "rocq-runtime.interp",
      "description": "Operates on lists of sets to compute unions, working with `Notation.NotationSet.t` elements. Combines multiple sets from a list into a single set through union operations. Useful for aggregating disjoint notation sets from a list into a unified set.",
      "description_length": 249,
      "index": 531,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.SpecificNotationMap.Monad",
      "library": "rocq-runtime.interp",
      "description": "This module provides monadic traversal and transformation operations over maps with keys of type `Notation.SpecificNotationMap.key`. It supports `fold`, `mapi`, `fold_left`, and `fold_right`, which allow accumulating values or building new maps through monadic actions. These operations are used to sequence effectful computations while iterating over or transforming map entries.",
      "description_length": 380,
      "index": 532,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.SpecificNotationSet.List",
      "library": "rocq-runtime.interp",
      "description": "This module operates on lists of sets, providing a `union` function to combine multiple sets into a single set. It works with `Notation.SpecificNotationSet.t` values stored in a list structure. A typical use case involves merging disjoint sets of notation elements into a unified set for further processing or analysis.",
      "description_length": 319,
      "index": 533,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.SpecificNotationMap.Smart",
      "library": "rocq-runtime.interp",
      "description": "This module provides optimized `map` and `mapi` functions that transform values in a specific notation map while preserving structural sharing. It operates on `Notation.SpecificNotationMap.t` data structures, which associate keys of type `Notation.SpecificNotationMap.key` with values of a generic type `'a`. These functions are particularly useful when updating large maps where maintaining efficiency through shared structure is critical, such as in symbolic computation or AST transformations.",
      "description_length": 496,
      "index": 534,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.NotationMap.Smart",
      "library": "rocq-runtime.interp",
      "description": "This module provides optimized `map` and `mapi` functions that transform values in a notation map while preserving structural sharing to improve performance. It works directly with `Notation.NotationMap.t` data structures, which associate keys with values in a persistent map. These functions are useful when applying transformations to large maps where maintaining efficiency through shared structure is critical.",
      "description_length": 414,
      "index": 535,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.NotationMap.Monad",
      "library": "rocq-runtime.interp",
      "description": "This module provides monadic traversal and transformation operations over maps with keys of type `Notation.NotationMap.key`. It supports `fold`, `mapi`, `fold_left`, and `fold_right`, which allow monadic actions during iteration, enabling effectful computations while processing map entries. These functions are particularly useful for tasks like validating, transforming, or accumulating values across map entries in a notation system.",
      "description_length": 436,
      "index": 536,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NumTok.SignedNat",
      "library": "rocq-runtime.interp",
      "description": "Handles conversion and classification of signed natural numbers represented as raw strings with a separate sign flag. Works with tuples of sign and unsigned natural number components, supporting operations like parsing from string, converting to normalized string, and translating to and from arbitrary-precision integers. Useful for preserving exact number syntax during parsing to support custom notations overriding standard numeric interpretation.",
      "description_length": 451,
      "index": 537,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NumTok.Unsigned",
      "library": "rocq-runtime.interp",
      "description": "This module handles unsigned number tokens with optional fractional parts and exponents, preserving their exact string representation. It provides parsing from character streams and strings, classification, and conversion to natural number strings when applicable. Use cases include parsing and printing numeric literals in a notation-sensitive context, such as formal verification systems or domain-specific languages where number syntax carries specific meaning.",
      "description_length": 464,
      "index": 538,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NumTok.UnsignedNat",
      "library": "rocq-runtime.interp",
      "description": "This module handles unsigned natural numbers represented as raw strings of decimal or hexadecimal digits, preserving their original formatting, including leading zeros and underscores. It provides conversion from and to string, comparison, and classification operations. Concrete use cases include parsing and printing numeric literals exactly as written, supporting custom notations that depend on specific string forms of numbers.",
      "description_length": 432,
      "index": 539,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.NotationMap",
      "library": "rocq-runtime.interp",
      "description": "This module manages ordered maps keyed by `Constrexpr.notation`, supporting insertion, removal, and query operations alongside advanced transformations such as fold, merge, and filter with customizable conflict resolution. It includes set-like operations through `NotationSet` and provides optimized `map` and `mapi` functions that preserve structural sharing for efficient manipulation of large maps. The module also supports monadic traversal with `fold`, `fold_left`, and `fold_right`, enabling effectful computations during iteration over notation-keyed entries. Example uses include transforming symbolic environments, merging disjoint maps with precedence rules, and validating structured contexts in computation pipelines.",
      "description_length": 729,
      "index": 540,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.SpecificNotationMap",
      "library": "rocq-runtime.interp",
      "description": "This module manages associations between `specific_notation` keys and polymorphic values, offering precise insertion, deletion, and transformation with support for symmetric difference folds and filtered unions. It includes operations for safe and unsafe access, domain manipulation, and stateful traversal, making it suitable for merging context-specific configurations or processing hierarchical data. The monadic traversal module enables effectful iterations and transformations using actions like `fold` and `mapi`, while the optimized mapping module ensures efficient value transformations with structural sharing, ideal for symbolic computation or AST manipulation. Together, they provide a comprehensive toolkit for handling notation-bound data with both flexibility and performance.",
      "description_length": 790,
      "index": 541,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genintern.Store",
      "library": "rocq-runtime.interp",
      "description": "This module manages a dynamic store of typed fields, allowing creation, setting, retrieval, and removal of fields with associated values. It supports operations to merge two stores and provides an empty store as a base. Concrete use cases include tracking configuration settings, dynamic state, or metadata where fields can be added or modified at runtime.",
      "description_length": 356,
      "index": 542,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation.SpecificNotationSet",
      "library": "rocq-runtime.interp",
      "description": "This module provides a functional interface for managing immutable sets of `Constrexpr.specific_notation` values, supporting standard set operations such as union, intersection, difference, and membership checks. It includes utilities for cardinality queries, element selection, and conversion from sequences, enabling efficient manipulation of symbolic notations in formal systems. A key use case involves resolving ambiguous parses by applying set algebra to ensure uniqueness and consistency. The child module extends this functionality by operating on lists of sets, offering a `union` function to merge multiple sets into one, useful for combining disjoint notation scopes into a unified structure.",
      "description_length": 703,
      "index": 543,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NumTok.Signed",
      "library": "rocq-runtime.interp",
      "description": "This module handles signed numeric literals with optional fractional and exponential components, offering precise parsing, decomposition, and type conversion while preserving original string representations. It operates on signed numbers structured as a sign flag paired with an unsigned magnitude, supporting comparisons between signed integers and unsigned natural numbers. Key applications include notation system integration where exact lexical forms dictate semantic meaning, and mixed-sign arithmetic boundary checks.",
      "description_length": 523,
      "index": 544,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Notation.NotationSet",
      "library": "rocq-runtime.interp",
      "description": "This module provides a functional interface for managing immutable sets of syntax notations, supporting standard set operations such as membership, union, intersection, and difference, along with ordered iteration and efficient queries for cardinality and min/max values. It enables transformations through folding and filtering, making it suitable for deduplicating notation definitions, analyzing grammar overlaps, or building hierarchical syntax structures. A child module extends this functionality by aggregating multiple sets from a list into a unified set through union operations. For example, it can combine disjoint notation sets from different sources into a single coherent set for unified processing.",
      "description_length": 713,
      "index": 545,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Smartlocate",
      "library": "rocq-runtime.interp",
      "description": "This module resolves global references in Coq, handling aliasing through notations, and extracting references from potentially complex terms. It supports operations like locating global constants, inductive types, and constructors, either directly by qualified name or through notation. Use cases include resolving identifiers during tactic execution or term elaboration, particularly when notations may obscure the actual referenced entity.",
      "description_length": 441,
      "index": 546,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constrexpr",
      "library": "rocq-runtime.interp",
      "description": "This module supports operations for managing universe constraints, polymorphic universe declarations, and notation scoping in type-theoretic constructs, working with identifiers, sorts, universe levels, and notation entries. It also handles pattern matching expressions, module-related AST nodes, and with-declarations, enabling parsing and pretty-printing of complex expressions with delimiters, binding kinds, and explicitation flags. Specific use cases include representing cumulativity, relevance, custom notation levels, and modular code organization through scoped syntax extensions.",
      "description_length": 589,
      "index": 547,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Genintern",
      "library": "rocq-runtime.interp",
      "description": "This module orchestrates the internalization of terms and patterns during Coq's parsing, transforming raw syntax into structured global representations while managing variable bindings, notations, and environment tracking. It provides core operations like `intern`, `intern_pat`, and `substitute_notation`, working with types such as `glob_sign` and `glob_constr_and_expr`, enabling precise term resolution and notation handling. Its child module maintains a dynamic store of typed fields, supporting runtime configuration, state tracking, and metadata management through operations like merge, set, and retrieve. Together, they facilitate both syntactic translation and flexible, structured data manipulation within Coq's ecosystem.",
      "description_length": 733,
      "index": 548,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NumTok",
      "library": "rocq-runtime.interp",
      "description": "This module processes numeric literals in various formats, including signed and unsigned integers and decimals, with support for hexadecimal and decimal representations. It stores numbers as raw strings alongside sign and classification flags to maintain exact input formatting, enabling precise matching of custom notations that override standard numeric interpretations. Key operations include parsing from strings and character streams, converting to normalized forms, and comparing signed and unsigned values. It supports use cases such as parsing notation-sensitive numeric literals, preserving leading zeros and underscores, and handling mixed-sign arithmetic and classification in formal verification or DSL contexts.",
      "description_length": 724,
      "index": 549,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation_ops",
      "library": "rocq-runtime.interp",
      "description": "This module handles notation interpretation and matching for Coq's concrete syntax, focusing on operations that translate between `glob_constr` and `notation_constr`, and compare or refine notation interpretations. It works with data types such as `notation_constr`, `interpretation`, and `glob_constr`, along with associated binder and pattern structures. Concrete use cases include parsing and pretty-printing notations, resolving recursive patterns, and checking whether a term matches a given notation or is a refinement of another.",
      "description_length": 536,
      "index": 550,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dumpglob",
      "library": "rocq-runtime.interp",
      "description": "This module provides operations for generating and managing legacy `.glob` files that capture Coq object definitions, references, and metadata for documentation tools. It works with global references, constants, modules, and logical kinds, enabling tools like `coqdoc` and `coq2html` to create hyperlinks and structured documentation by logging entities with source locations and type information.",
      "description_length": 397,
      "index": 551,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Notation",
      "library": "rocq-runtime.interp",
      "description": "This component manages notation scope lifecycles, delimiter handling, and primitive token interpretation while enabling syntax customization through notation keys, global references, and entry levels. It supports advanced operations like context-sensitive parsing, precedence control, and polymorphic notation resolution, with core data types including maps and sets keyed by `Constrexpr.notation` and `specific_notation`. The module's direct API orchestrates scope activation and visibility, while its child modules enable efficient manipulation of notation environments using map and set algebra, monadic traversal, and structural sharing. Example uses include merging disjoint notation scopes, validating structured contexts, deduplicating notation definitions, and resolving ambiguous parses using set operations across multiple sources.",
      "description_length": 841,
      "index": 552,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Notationextern",
      "library": "rocq-runtime.interp",
      "description": "This module defines equality checks for various components of notations, including entries, levels, and interpretations, ensuring precise comparisons during uninterpretation. It provides functions to declare and remove uninterpretation rules, track applicative status, and retrieve notation rules for terms, inductive types, and case patterns. These operations support concrete tasks like pretty-printing terms using their original notations and managing notation behavior during parsing and printing.",
      "description_length": 501,
      "index": 553,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Implicit_quantifiers",
      "library": "rocq-runtime.interp",
      "description": "This module handles the detection and management of implicit variables and generalizable identifiers in Coq's term structures. It provides operations to identify free variables, compute generalizable variables, resolve implicit arguments, and generate fresh identifiers, working with types like `constr_expr`, `glob_constr`, and identifier sets. Concrete use cases include processing user input in proof terms, managing variable capture during substitution, and supporting implicit argument inference in definitions and applications.",
      "description_length": 533,
      "index": 554,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constrexpr_ops",
      "library": "rocq-runtime.interp",
      "description": "This module offers operations for constructing, comparing, and transforming Coq's pre-typechecking terms (`constr_expr`) and related structures. It provides smart constructors for building lambda abstractions, applications, and casts, alongside utilities for binder manipulation, variable substitution, and analyzing expression content (e.g., free variable extraction, occurrence checks). These tools are particularly useful for tasks like programmatically generating Coq terms, handling notation bindings, or implementing transformations that require precise control over term structure and variable scoping.",
      "description_length": 609,
      "index": 555,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Reserve",
      "library": "rocq-runtime.interp",
      "description": "This module associates logical identifiers with specific notation constructs, enabling the registration and retrieval of reserved type notations. It operates on lists of logical identifiers and notation terms, supporting direct lookups by identifier. This is used to manage syntactic abbreviations for complex types during parsing and printing.",
      "description_length": 344,
      "index": 556,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Decls",
      "library": "rocq-runtime.interp",
      "description": "This module defines core data types for representing theorem and definition kinds, along with logical object classifications. It provides operations to store and query variable metadata, including opacity, logical kind, and namespace path. These types and functions are used to track and retrieve detailed information about declared variables in a proof assistant's context.",
      "description_length": 374,
      "index": 557,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Abbreviation",
      "library": "rocq-runtime.interp",
      "description": "This module manages abbreviations in a global context, providing operations to declare, search, import, and toggle their activation state. It works with global references, identifiers, and notation interpretations to define shorthand representations for terms. Concrete use cases include defining and managing symbolic abbreviations for complex expressions, enabling or disabling their use during parsing or printing, and filtering abbreviations based on custom criteria.",
      "description_length": 471,
      "index": 558,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Notation_term",
      "library": "rocq-runtime.interp",
      "description": "This module defines a syntax tree for a subset of Coq's global terms used in notations, supporting constructs like references, variables, applications, projections, lambdas, products, let bindings, and case analysis. It includes types for handling binders, scopes, and interpretation environments to manage variable binding and type inference during notation expansion. It is used to represent and manipulate syntactic extensions without locations, ensuring substitutability and excluding complex or non-global expressions.",
      "description_length": 523,
      "index": 559,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Impargs",
      "library": "rocq-runtime.interp",
      "description": "This module configures implicit argument policies and manages their declarations in Coq's type system, focusing on strictness, reversibility, and binding behaviors. It operates on global references, inductive types, and proof terms, using data structures like `implicit_status` and `implicits_list` to track inferability, dependency, and explicitation rules. Key use cases include resolving unification constraints during type checking and controlling implicit argument propagation in dependent contexts.",
      "description_length": 504,
      "index": 560,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constrextern",
      "library": "rocq-runtime.interp",
      "description": "This component translates Coq's internal terms, patterns, and constructions into printable syntax trees while managing detailed formatting controls. It processes data like environments, identifiers (`GlobRef.t`, `qualid`), and term representations (`constr`, `glob_constr`) to handle tasks such as resolving references, printing universes, and expanding implicit arguments. Its operations directly support pretty-printing Coq code with customizable parentheses, coercion visibility, and scoped name resolution.",
      "description_length": 510,
      "index": 561,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Modintern",
      "library": "rocq-runtime.interp",
      "description": "This module handles the internalization and interpretation of module expressions during compilation. It translates abstract syntax trees into typed module structures, resolving identifiers and checking module kinds like `Module` or `ModType`. It works with module paths, constraints, and universe expressions, supporting operations like module application and `with`-path validation.",
      "description_length": 383,
      "index": 562,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.OblState.View.Obl",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the state of obligations during interactive proof construction, tracking their solved status, location, and definition metadata. It provides operations to update and query obligation states, including marking them as solved or updating their definition status. Concrete use cases include coordinating proof editing in interactive mode and maintaining obligation metadata during tactic-based term construction.",
      "description_length": 429,
      "index": 563,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacstate.Interp.System",
      "library": "rocq-runtime.vernac",
      "description": "Stores and manages the state of the proof engine during tactic execution, including goals, hypotheses, and proof terms. It provides operations to update and retrieve the current proof context, apply tactics, and maintain consistency across proof steps. This module is used internally by the Coq proof assistant to handle interactive proof development and tactic scripting.",
      "description_length": 372,
      "index": 564,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.OblState.View",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the state of proof obligations during interactive development, using a custom type `t` to track unresolved obligations and their metadata, such as solved status and location. It supports operations to update obligation states, mark them as solved, and query their progress, enabling coordination of tactic applications and partial proof saves. Submodules extend this functionality to handle detailed metadata during term construction. Example uses include maintaining obligation status across interactive edits and synchronizing proof state in program mode.",
      "description_length": 577,
      "index": 565,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.Internal.Constant",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the internal representation and registration of constants during declaration, providing operations to tag constants with identifiers and determine their logical kind. It works with constants in the context of the global environment, interacting with structures like `Libobject.Dyn.tag` and `Decls.logical_kind`. Concrete use cases include associating metadata with constants and classifying them based on their logical role during proof construction or program mode declaration.",
      "description_length": 498,
      "index": 566,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Declare.Hook.S",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a hook action that runs when a constant is saved, carrying context such as universe constraints, obligation terms, declaration scope, and the global reference of the declared entity. It supports operations like registering coercions, updating databases, or handling obligations by providing access to the declaration's final state. The hook is triggered at save time, allowing side effects based on the completed definition.",
      "description_length": 444,
      "index": 567,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Library.Intern.Provenance",
      "library": "rocq-runtime.vernac",
      "description": "This module tracks the origin of loaded libraries by associating each with a source file path and a checksum. It ensures consistency by validating that the checksum of a library matches its recorded provenance. Use cases include verifying integrity during library loading and resolving conflicts due to outdated or mismatched files.",
      "description_length": 332,
      "index": 568,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pvernac.Unsafe",
      "library": "rocq-runtime.vernac",
      "description": "Sets the current tactic entry point for proof mode in the vernacular system. It directly modifies the global state of the proof engine, allowing customization of tactic behavior during proof construction. This operation is used internally to control how tactics are applied in interactive theorem proving sessions.",
      "description_length": 314,
      "index": 569,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernactypes.Prog",
      "library": "rocq-runtime.vernac",
      "description": "Handles program state transitions and stack manipulations during the processing of extended vernacular phrases. It provides operations to manage a non-empty list of states, supporting actions like pushing new states, applying transformations, and handling obligations in proof scripts. Useful for implementing tactics that modify the proof context or manage multiple proof obligations.",
      "description_length": 385,
      "index": 570,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.Info",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the metadata and configuration for declarations, including parameters shared across mutual constants. It provides the `make` function to construct declaration info with optional settings like universes, scope, and typing flags. It is used to configure both interactive and non-interactive constant declarations, supporting features like hooks, inline directives, and notation interpretations.",
      "description_length": 412,
      "index": 571,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernacstate.Stm",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the state of the Coq proof assistant during interactive proof editing, specifically handling the separation between proof state and non-proof state components. It provides operations to extract and set the proof state (`pstate`), compare environments for equality, and create a shallow copy of the state by dropping transient objects. Concrete use cases include checkpointing proof progress, restoring proof contexts, and managing state transitions during tactic execution.",
      "description_length": 493,
      "index": 572,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Future.UUID",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a type `t` representing UUIDs and provides operations to compare and check equality between UUID values. It includes a constant `invalid` for representing a placeholder or default UUID. The module is used to uniquely identify entities in distributed systems or persistent data stores.",
      "description_length": 304,
      "index": 573,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Future.UUIDMap",
      "library": "rocq-runtime.vernac",
      "description": "This module implements a map structure with UUID keys and arbitrary values, offering insertion, deletion, merging, and ordered traversal while preserving physical equality. It supports ordered operations like range queries, filtered transformations, and bulk conversions to and from sequences, leveraging UUIDs' total ordering. It is suited for managing unique identifiers with ordered relationships, such as tracking distributed entities, aggregating event logs, or maintaining sorted collections for incremental processing.",
      "description_length": 525,
      "index": 574,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacstate.Declare",
      "library": "rocq-runtime.vernac",
      "description": "This module manages proof state operations, including tracking open goals, retrieving and modifying the current proof, and handling proof closure with optional opacity settings. It works with proof-related data structures such as `Proof.t`, `closed_proof_output`, and `evar_map`, along with lemma stacks and obligation states. Concrete use cases include finalizing proofs, querying the current proof context, and managing multiple proofs during tactic execution.",
      "description_length": 462,
      "index": 575,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernactypes.OpaqueAccess",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a generalized algebraic data type (`t`) with two constructors: `Ignore`, representing an ignored operation, and `Access`, encapsulating a global indirect accessor. It works with extended vernacular phrase interpretations, specifically handling opaque access scenarios in Coq's proof engine. Concrete use cases include managing access control and visibility during proof term reconstruction and tactic execution.",
      "description_length": 431,
      "index": 576,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.OblState",
      "library": "rocq-runtime.vernac",
      "description": "This module tracks and manages proof obligations during development, using a custom type `t` to represent unresolved obligations with metadata like solved status and location. It provides operations to create, update, and query obligation states, supporting interactive proof editing and partial proof saves by coordinating tactic applications and delayed resolution. Submodules enhance this functionality by handling detailed metadata during term construction, enabling features like obligation tracking across edits and synchronization in program mode. Example uses include marking obligations as solved during proof scripting and maintaining obligation state when saving incomplete proofs.",
      "description_length": 692,
      "index": 577,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Opaques.Summary",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the lifecycle of summary data through initialization, freezing, and unfreezing operations. It works with opaque summary structures and supports joining operations, optionally excluding specific futures by UUID set. It is used to coordinate and capture state snapshots in distributed or concurrent contexts.",
      "description_length": 326,
      "index": 578,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Record.Data",
      "library": "rocq-runtime.vernac",
      "description": "This module defines data structures and operations for managing record projections and their properties. It works with identifiers, projection flags, and raw data to represent record fields and their behaviors. Concrete use cases include handling coercion, reversibility, and priority settings for projections during record definition and manipulation.",
      "description_length": 352,
      "index": 579,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacstate.Synterp",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the state of the Coq syntactic preprocessor, including the parser state. It provides operations to initialize, freeze, and restore the state, as well as extract the parsing state for use in processing Coq input. It is used during the interactive execution of Coq commands to maintain and restore the syntactic context across different input segments.",
      "description_length": 370,
      "index": 580,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernacstate.Interp",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the state of the Coq interpreter during proof processing, tracking lemmas, programs, and opaque proofs, while allowing state freezing, restoration, and cache invalidation. It works with its child module to maintain and update the proof context, apply tactics, and ensure consistency across proof steps. Together, they enable checkpointing during proof development, restoring state after failed attempts, and interactive proof scripting with tactic application. Key data types include proof terms, goals, and hypotheses, with operations to manipulate and query them during proof execution.",
      "description_length": 608,
      "index": 581,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mltop.PluginSpec",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a data type `t` representing Coq plugins identified by their OCaml library names in Findlib format. It provides operations to convert a plugin specification to its corresponding Findlib package name and to pretty-print the plugin identifier. This module is used to manage and display plugin identities when loading or referencing Coq plugins through their associated OCaml libraries.",
      "description_length": 403,
      "index": 582,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.Hook",
      "library": "rocq-runtime.vernac",
      "description": "This module manages imperative hooks that execute when constants are saved, using the `t` type to represent hook functions and the `call` function to trigger them with context from the `S` submodule. The `S` submodule provides detailed information during hook execution, including universe constraints, obligation terms, and the global reference of the saved constant. Concrete operations include registering coercions, updating external databases, or handling obligations based on the final state of a declaration. These hooks enable side effects like logging or state synchronization at save time, though they should be used cautiously due to potential future restrictions on imperative effects.",
      "description_length": 697,
      "index": 583,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacstate.LemmaStack",
      "library": "rocq-runtime.vernac",
      "description": "This module manages a stack of proofs, supporting operations to add, remove, and transform proofs at the top of the stack. It provides direct access to the current proof, applies functions to the top or all proofs, and retrieves proof names. It is used during proof construction and manipulation in Coq's vernacular processing.",
      "description_length": 327,
      "index": 584,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Record.Ast",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a record type for representing abstract syntax trees of record declarations, including fields, binders, and attributes. It provides operations to construct and manipulate record ASTs with precise metadata like coercion flags, sort annotations, and builder identifiers. Concrete use cases include parsing and type-checking record definitions in a formal proof assistant or programming language frontend.",
      "description_length": 422,
      "index": 585,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "DebugHook.Action",
      "library": "rocq-runtime.vernac",
      "description": "This module defines actions sent by the IDE to control the debugger, including stepping, continuing, updating breakpoints, and retrieving stack or variable information. It operates on string inputs parsed into action types like `StepIn`, `UpdBpts`, or `GetVars`, which trigger corresponding debugger responses. Concrete use cases include handling user commands from an IDE to navigate execution flow, manage breakpoints, or inspect program state during debugging sessions.",
      "description_length": 472,
      "index": 586,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DebugHook.Answer",
      "library": "rocq-runtime.vernac",
      "description": "Accepts and processes debugger input responses, mapping them to structured values for interaction with the proof environment. It handles parsing and interpretation of user input during debugging sessions, translating raw responses into typed actions like goal updates or command outputs. Useful for implementing custom debugging interfaces that react to specific proof state changes or user commands.",
      "description_length": 400,
      "index": 587,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Declare.CInfo",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the creation and manipulation of constant declaration information, including the type, optional arguments, and implicit parameters. It provides functions to construct constant metadata, retrieve the type of a declared constant, and convert between different constraint representations. It is used when defining new constants interactively or programmatically, particularly when handling evar maps or preparing terms for the global environment.",
      "description_length": 463,
      "index": 588,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Record.Record_decl",
      "library": "rocq-runtime.vernac",
      "description": "This module defines the structure and metadata for records, including fields for inductive entries, projections, universe binders, and implementation details. It supports operations for creating and manipulating record types with associated universes and dependencies. Concrete use cases include defining inductive records with primitive projections and managing their global universe constraints during type checking.",
      "description_length": 418,
      "index": 589,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComInductive.Internal",
      "library": "rocq-runtime.vernac",
      "description": "Handles inductive type definitions with support for universe polymorphism, returning updated arities and elimination principles. Works with Coq's internal structures like environments, evar maps, and constr terms. Used during the declaration of inductive types to manage parameters and ensure consistency across definitions.",
      "description_length": 324,
      "index": 590,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Library.Intern",
      "library": "rocq-runtime.vernac",
      "description": "This module loads compiled libraries from disk, resolving their paths using a library resolver and returning both the loaded library and its provenance metadata. It operates on library paths and provides a result type that captures success or failure alongside source file paths and checksums for integrity verification. It ensures correct library versions are loaded by validating checksums against recorded provenance, supporting use cases such as initializing or importing Coq modules with version consistency. Submodules track and verify library origins, enabling conflict resolution and integrity checks during loading.",
      "description_length": 624,
      "index": 591,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declaremods.Synterp",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the declaration and manipulation of modules and module types within a Coq-like environment. It provides operations for starting, ending, and including modules and module types, as well as registering libraries and managing imports. Functions work with identifiers, module paths, module expressions, and signatures, supporting concrete tasks like module nesting, type abstraction, and structured library loading.",
      "description_length": 431,
      "index": 592,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Classes.Event",
      "library": "rocq-runtime.vernac",
      "description": "Handles event-driven logic for class and instance declarations. Works with `t` type values representing either new class or instance events. Used to trigger and manage callbacks when classes or instances are defined, supporting dynamic registration and monitoring of typeclass and instance creation.",
      "description_length": 299,
      "index": 593,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernactypes.Proof",
      "library": "rocq-runtime.vernac",
      "description": "Handles proof-related operations during the interpretation of vernacular phrases. Works with proof states and related data structures to manage proof construction, validation, and transformation. Used in processing tactics, proof terms, and proof scripts within the proof assistant.",
      "description_length": 282,
      "index": 594,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Future.UUIDSet",
      "library": "rocq-runtime.vernac",
      "description": "This module provides pure functional set operations for managing immutable collections of UUIDs, including membership tests, union/intersection/difference calculations, and ordered element access through exception-safe selectors. It supports transformations via mapping, filtering, and folding, along with conversions to lists and sequences for ordered traversal and bulk updates. Designed for scenarios requiring efficient set semantics with predictable iteration order, it handles use cases like tracking unique identifiers across distributed systems or maintaining sorted UUID inventories.",
      "description_length": 592,
      "index": 595,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pvernac.Vernac_",
      "library": "rocq-runtime.vernac",
      "description": "This module defines entry points for parsing various Coq vernacular constructs, including Gallina expressions, commands, inductive and fixpoint definitions, and reduction expressions. It works with Coq's internal syntax trees, such as `Vernacexpr.vernac_expr`, `inductive_expr`, and `fixpoint_expr`. These entries are used directly by the Coq parser to process Coq source files into abstract syntax trees for further processing.",
      "description_length": 428,
      "index": 596,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Attributes.Notations",
      "library": "rocq-runtime.vernac",
      "description": "This module provides monadic operations for composing and transforming attributes, including binding (`>>=`), sequencing (`>>`), mapping, and combining (`++`). It works with attribute values that encapsulate both a transformation of flags and a computed value. Use it to build complex attribute logic by chaining transformations and combining independent attributes safely.",
      "description_length": 373,
      "index": 597,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "DeclareInd.Internal",
      "library": "rocq-runtime.vernac",
      "description": "This module handles internal representations and registrations of mutual inductive definitions, including their schemes. It operates on inductive types and associated metadata, supporting the declaration and management of inductive objects within the system. Concrete use cases include registering inductive definitions and retrieving their associated schemes for further processing.",
      "description_length": 383,
      "index": 598,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Record.Internal",
      "library": "rocq-runtime.vernac",
      "description": "This module defines and manages projection flags and structures for inductive types, handling operations like declaring projections with associated metadata and registering structure entries. It works with inductive definitions, universe entries, and projection contexts, producing and consuming structures that represent record fields and their properties. Concrete use cases include setting up canonical projections with specific priorities and declaring structured inductive types with associated universe binders.",
      "description_length": 517,
      "index": 599,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declaremods.Interp",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the declaration and management of modules and module types, supporting operations like defining modules with parameters and signatures, starting and ending module scopes, and registering or importing libraries. It works with module paths, expressions, and signatures, enabling concrete use cases such as building modular structures in a compiler or interpreter, and managing module inclusions and exports. Functions like `declare_include` and `import_module` directly support composing and linking modular code components.",
      "description_length": 542,
      "index": 600,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Loadpath.Error",
      "library": "rocq-runtime.vernac",
      "description": "This module defines error types for handling library resolution failures during load path operations. It includes the `t` type with variants `LibUnmappedDir` and `LibNotFound`, representing cases where a directory has no logical mapping or a library is not found. The `raise` function signals these errors with a given logical path, typically used when locating libraries fails in the file system traversal.",
      "description_length": 407,
      "index": 601,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernacstate.System",
      "library": "rocq-runtime.vernac",
      "description": "This module provides a function `protect` that executes a given function and discards any changes to the system state, specifically `Synterp.t` and `Interp.System.t`. It ensures that operations like parsing or evaluation do not leave lasting effects on the system state. Useful for safely running commands that should not alter the global environment, such as in error recovery or speculative execution.",
      "description_length": 403,
      "index": 602,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernacentries.Preprocessed_Mind_decl",
      "library": "rocq-runtime.vernac",
      "description": "This module processes and validates inductive and record type declarations in Coq's vernacular language. It handles universe declarations, typing flags, and primitive projections, preparing data structures for further compilation or type checking. Concrete use cases include parsing and checking `Inductive`, `Record`, and `Primitive` vernacular commands before type inference or kernel interaction.",
      "description_length": 399,
      "index": 603,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ComInductive.Mind_decl",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a structured representation for inductive type declarations, including metadata such as universe binders, parameters, and coercions. It supports operations to build and manipulate inductive entries with associated implicits, universes, and elimination schemes. Concrete use cases include parsing and type-checking inductive definitions in Coq's logic.",
      "description_length": 371,
      "index": 604,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Classes.Internal",
      "library": "rocq-runtime.vernac",
      "description": "This module provides low-level operations for registering typeclass instances, including the `add_instance` function. It works with typeclass definitions, hint information, and global references. It is used internally to support instance resolution during typeclass inference.",
      "description_length": 276,
      "index": 605,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare.Internal",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the core mechanisms for declaring and manipulating variables, constants, and inductive types within the global environment, handling name resolution, notation tables, and proof state management. It supports direct operations such as one-step declarations, interactive proof-based definitions, and program-mode declarations with hole-filling, while the child module handles constant representation, tagging with identifiers, and logical classification using structures like `Libobject.Dyn.tag` and `Decls.logical_kind`. Together, they enable defining and classifying global constants with metadata, managing proof context evolution, and exporting tactic side effects into the global state. Example uses include tagging a newly defined constant with its logical role, resolving identifiers during proof construction, and registering constants with deferred definitions in program mode.",
      "description_length": 903,
      "index": 606,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacentries.DefAttributes",
      "library": "rocq-runtime.vernac",
      "description": "This module defines a record type for attributes used in definition entries, including scope, locality, polymorphism, and typing flags. It provides a specific value `def_attributes` that serves as an attribute instance for attaching these properties to definitions. Concrete use cases include configuring the behavior of definitions in Coq's vernacular language, such as setting typing flags or controlling polymorphic and program modes.",
      "description_length": 437,
      "index": 607,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Declare.Obls",
      "library": "rocq-runtime.vernac",
      "description": "This module manages obligations for program definitions and proofs, providing operations to prepare, solve, and track unresolved obligations. It works with identifiers, proof states, and obligation metadata to support interactive and batch definition workflows. Concrete use cases include handling `Program Definition` and `Program Fixpoint` declarations, where obligations are generated and later discharged using tactics or admitted explicitly.",
      "description_length": 446,
      "index": 608,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DebugHook.Intf",
      "library": "rocq-runtime.vernac",
      "description": "This module defines an interface for interacting with a debugger, providing functions to read commands, submit answers, and check terminal status. It works with the `t` record type containing `read_cmd`, `submit_answer`, and `isTerminal`. Concrete use cases include integrating a custom debugger frontend with the Ltac engine, allowing clients to handle command input and response output during debugging sessions.",
      "description_length": 414,
      "index": 609,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernacprop",
      "library": "rocq-runtime.vernac",
      "description": "This module provides boolean checks on Coq's vernacular expressions and control structures. It includes predicates to determine if a command is a query, navigation command, reset, debug, or undo operation. These functions are used to analyze and classify Coq top-level commands during proof script processing or interactive session management.",
      "description_length": 343,
      "index": 610,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComDefinition",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the internalization and declaration of definitions in both standard and program modes, supporting operations like type checking, reduction, and implicit argument handling. It works with Coq's core data structures including environments, evar maps, constr expressions, and declaration hooks. Concrete use cases include defining constants interactively, in batch mode, or with obligation handling in program mode, supporting features like polymorphism, universe declarations, and section localization.",
      "description_length": 519,
      "index": 611,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernac_classifier",
      "library": "rocq-runtime.vernac",
      "description": "This module classifies vernacular commands and provides string representations of those classifications. It works with `vernac_classification` and `vernac_control` types from the Coq system. It is used to determine the effect of commands in the Coq proof assistant, such as identifying whether a command starts a proof or modifies the proof state.",
      "description_length": 347,
      "index": 612,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Himsg",
      "library": "rocq-runtime.vernac",
      "description": "This module formats detailed error messages for type-checking and pretyping errors in Coq. It works with environments, evar_maps, and specific error types like type_error, pretype_error, and refiner_error. Concrete use cases include generating human-readable explanations for type mismatches and guard condition violations during proof checking.",
      "description_length": 345,
      "index": 613,
      "embedding_norm": 1.0
    },
    {
      "module_path": "G_vernac",
      "library": "rocq-runtime.vernac",
      "description": "This component provides parsing and validation mechanisms for Coq's interactive proof language, handling syntactic constructs like theorem declarations, query commands, and attribute modifiers. It operates on token streams and parsing states to manage identifier resolution, goal selection, and warning generation during vernacular script processing. Its utilities support interactive environments by enabling precise error recovery and notation parsing for formal verification workflows.",
      "description_length": 488,
      "index": 614,
      "embedding_norm": 1.0
    },
    {
      "module_path": "G_redexpr",
      "library": "rocq-runtime.vernac",
      "description": "This module defines parsing entries for various reduction-related expressions, including integers, natural numbers, patterns with occurrences, and unfold directives. It supports data types like `r_trm`, `r_cst`, `r_pat`, and `occurrences_expr`, primarily used in tactic definitions for specifying reduction strategies and term selection. Concrete use cases include parsing arguments for tactics that control reduction behavior, such as selecting specific occurrences of terms or specifying redexes to unfold.",
      "description_length": 508,
      "index": 615,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComCoercion",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the declaration and manipulation of coercions and subclasses in a type system. It provides operations to add coercions between types, declare identity coercions, and handle coercion hooks, working with global references and class types. Use cases include enriching the environment with new coercions, defining subclass relationships, and modifying coercion reversibility.",
      "description_length": 391,
      "index": 616,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Loadpath",
      "library": "rocq-runtime.vernac",
      "description": "This module manages associations between physical file system paths and logical Rocq module hierarchies, enabling operations like registering load paths, resolving logical paths to physical paths, and locating libraries during compilation or execution. It includes core functions to manipulate and query these mappings, such as adding new paths, searching for files, and translating between logical and physical representations. The error submodule defines specific failure cases\u2014`LibUnmappedDir` and `LibNotFound`\u2014used when resolving library paths fails, with a `raise` function to signal these errors based on a given logical path. Together, the module and its submodules support concrete tasks like loading Rocq source files from specified directories and resolving qualified library names during execution.",
      "description_length": 810,
      "index": 617,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacextend",
      "library": "rocq-runtime.vernac",
      "description": "This module defines data structures and functions for extending Coq's vernacular language, including classification of commands (proof steps, side effects, queries), handling of proof modes, and argument parsing. It supports static and dynamic registration of new vernacular commands, command argument extensions, and classification logic used during parsing and execution. Concrete use cases include adding new top-level commands like custom tactics or proof control constructs, defining how they interact with the proof state, and specifying their parsing behavior.",
      "description_length": 567,
      "index": 618,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Assumptions",
      "library": "rocq-runtime.vernac",
      "description": "This module provides functions to analyze dependencies and assumptions of terms in a Coq context. It works with global references, terms, and context objects to extract direct and recursive dependencies, including transparent or opaque definitions. Concrete use cases include tracking which global objects a term relies on, and collecting assumptions with their types for proof analysis or term inspection tasks.",
      "description_length": 412,
      "index": 619,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernacoptions",
      "library": "rocq-runtime.vernac",
      "description": "This module provides operations to set, add, remove, check, and print Coq's global options, typically used to configure system behavior during proof development. It works with option names and table values, handling both string and structured settings. Concrete use cases include enabling or disabling proof automation features, adjusting pretty-printing settings, and querying current configuration values.",
      "description_length": 407,
      "index": 620,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declare",
      "library": "rocq-runtime.vernac",
      "description": "This module orchestrates the declaration of variables, constants, and inductive types while managing associated metadata, proof obligations, and imperative hooks. It supports one-step definitions, interactive proofs with tactic-based editing, and program-mode declarations with deferred hole-filling, using data types like `t` for obligations and hooks, and `S` for save-time context. You can configure declarations with optional parameters via the `make` function, track unresolved proof obligations across edits, or register actions that trigger when constants are saved. Specific workflows include defining a constant with implicits, marking obligations as solved during proof scripting, or synchronizing external state on declaration save.",
      "description_length": 743,
      "index": 621,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Record",
      "library": "rocq-runtime.vernac",
      "description": "This module processes record definitions during type checking, converting abstract syntax trees into internal representations with support for universe polymorphism, inductive flags, and primitive projections. It defines core data structures for records, including fields, binders, attributes, and projection metadata, while handling class declarations and global universe constraints. Operations include constructing and manipulating record ASTs, declaring projections with flags and priorities, and managing inductive entries with universe binders. Specific use cases include parsing and type-checking record definitions, setting up coercions and canonical projections, and defining inductive records with precise sort annotations and dependency tracking.",
      "description_length": 757,
      "index": 622,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Indschemes",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the declaration and management of induction, equality, and rewriting schemes for inductive types. It works with inductive definitions, constants, and term constructions to generate and register associated elimination and congruence rules. Concrete use cases include automatically deriving equality schemes, mutual induction principles, and rewriting rules for user-defined inductive types.",
      "description_length": 409,
      "index": 623,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComFixpoint",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the declaration and type-checking of mutually recursive functions defined using `Fixpoint` and `CoFixpoint`. It processes recursive function definitions, infers types, and manages obligations for dependent pattern matching. Concrete use cases include defining recursive functions with custom well-founded recursion and specifying coinductive values with guardedness conditions.",
      "description_length": 397,
      "index": 624,
      "embedding_norm": 1.0
    },
    {
      "module_path": "G_proofs",
      "library": "rocq-runtime.vernac",
      "description": "This module defines parsers for theorem declarations and hint expressions used in proof scripts. It processes entries related to theorem kinds and hint structures, enabling the integration of custom proof automation and tactic hints. It is used to extend the proof engine's syntax for managing proof states and tactic applications.",
      "description_length": 331,
      "index": 625,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacentries",
      "library": "rocq-runtime.vernac",
      "description": "This module translates and interprets Coq's vernacular commands, handling expression evaluation, inductive declarations, and module requirements using core structures like `constr_expr` and `inductive_expr`. It processes commands such as `Require`, `Inductive`, and `Record`, preparing them for type checking or kernel interaction. A child module validates inductive and record declarations, managing universes and primitive projections, while another defines attributes for definitions, such as scope and polymorphism, with a built-in `def_attributes` instance. Together, they enable parsing Coq source files, defining typed inductive structures, and configuring definition behavior during command execution.",
      "description_length": 709,
      "index": 626,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Future",
      "library": "rocq-runtime.vernac",
      "description": "This module orchestrates asynchronous computations through futures that are explicitly managed using UUIDs to define dependencies and ensure deterministic execution. It enables creating and chaining futures with error handling, while allowing results to be forced or peeked at, supporting parallel task execution and lazy value resolution in distributed contexts. UUIDs serve as stable identifiers for computations, with maps and sets providing structured ways to track, query, and transform collections of futures based on their identifiers. For example, a map can maintain futures indexed by UUID with ordered traversal for processing event logs, while set operations can efficiently manage disjoint or overlapping groups of identifiers during distributed coordination tasks.",
      "description_length": 777,
      "index": 627,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Attributes",
      "library": "rocq-runtime.vernac",
      "description": "This module handles structured attributes and metadata in Coq's vernacular, focusing on parsing, validation, and manipulation of configurations like polymorphism flags, deprecation notices, and hint locality. It defines core data types such as `vernac_flags` and `vernac_flag`, and uses key-value parsers to process boolean flags, strings, and global references, enabling attribute-based configuration and error checking during declaration processing. The child module adds monadic operations\u2014binding, sequencing, mapping, and combining\u2014for building and transforming attribute logic that encapsulates both flag modifications and computed values. Together, they support tasks like composing complex attributes, managing universe polymorphism, and safely merging independent attribute settings.",
      "description_length": 792,
      "index": 628,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printmod",
      "library": "rocq-runtime.vernac",
      "description": "This module provides functions to print representations of Coq modules and inductive types. It operates on environments, module paths, and inductive body declarations, producing formatted output for debugging or user feedback. Concrete use cases include displaying module contents, module types, and detailed inductive type information in Coq's interactive environment.",
      "description_length": 369,
      "index": 629,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComExtraDeps",
      "library": "rocq-runtime.vernac",
      "description": "This module tracks additional dependencies between files and identifiers. It allows declaring a dependency with `declare_extra_dep` and querying the associated file path for an identifier using `query_extra_dep`. Useful for managing cross-file references in compilation or analysis tools.",
      "description_length": 288,
      "index": 630,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pvernac",
      "library": "rocq-runtime.vernac",
      "description": "This module orchestrates proof mode management and vernacular command parsing in a proof assistant. It enables registration and conversion of proof modes while providing parsing functions for Coq constructs like Gallina expressions, inductive definitions, and reduction expressions. The system supports custom proof modes and interactive tactic behavior through global state modification, and directly processes top-level commands into internal syntax trees such as `Vernacexpr.vernac_expr` for execution or further compilation.",
      "description_length": 528,
      "index": 631,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Egramrocq",
      "library": "rocq-runtime.vernac",
      "description": "This module maps grammar productions to camlp5 actions for parsing term notations and tactic notations at the Rocq level. It provides functions to extend the constr grammar with notation rules, create and check custom grammar entries, and query their locality. It operates on grammar structures defined in `Notation_gram` and manages entry-specific parsing behavior for notations in the Rocq language.",
      "description_length": 401,
      "index": 632,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "RecLemmas",
      "library": "rocq-runtime.vernac",
      "description": "This module identifies mutually recursive statements in a list of types by analyzing their dependencies using a guard checking function. It operates on environments, type contexts, and terms, specifically working with evar_maps, rel_context lists, and constr terms. A concrete use case is determining which definitions in a recursive block can safely be used in the bodies of others without violating the guard condition.",
      "description_length": 421,
      "index": 633,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Metasyntax",
      "library": "rocq-runtime.vernac",
      "description": "This module provides operations for defining and managing notation syntax, including adding custom notations, scopes, and grammar entries, alongside validation and pretty-printing utilities. It works with structured data like `notation_interpretation_decl`, `syntax_rules`, and `scope_name` to enforce syntactic correctness and format expressions with level annotations. These capabilities are essential in environments requiring precise notation control, such as proof assistants or domain-specific language implementations, where users need to extend or customize parsing and printing behavior dynamically.",
      "description_length": 608,
      "index": 634,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Egramml",
      "library": "rocq-runtime.vernac",
      "description": "This module defines functions for declaring and extending grammatical rules for vernacular commands, specifically mapping grammar productions to camlp5 actions. It operates on grammar entries, extension names, and production items, enabling the customization of Coq's syntax for commands and tactics. Concrete use cases include defining new vernacular syntax, extending existing command grammars, and retrieving grammar rules for later use in parsing or error reporting.",
      "description_length": 470,
      "index": 635,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComRewriteRule",
      "library": "rocq-runtime.vernac",
      "description": "This module processes symbolic expressions and rewrite rules for Coq's vernacular commands. It handles operations like unfolding fixpoints and applying coercion flags to lists of identifiers and constraint expressions. The primary use case involves transforming and simplifying Coq terms during proof or definition processing.",
      "description_length": 326,
      "index": 636,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Topfmt",
      "library": "rocq-runtime.vernac",
      "description": "This module adjusts formatting settings like margins and maximum print depth, manages output routing to consoles, files, or editors, and applies color schemes to enhance readability. It operates on formatters, logging channels, and execution phase handlers to tailor output behavior during interactive sessions or batch processing. Specific applications include directing diagnostic logs to disk, adapting display aesthetics across environments, and dynamically modifying print limits during debugging.",
      "description_length": 502,
      "index": 637,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DeclareUniv",
      "library": "rocq-runtime.vernac",
      "description": "This module manages universe declarations and constraints in the context of type theory, handling operations such as binding universe variables, adding constraints, and associating constraints with global references. It works with data types like `GlobRef.t`, `universes_entry`, `Level.Set.t`, and constraint expressions. It is used to implement commands like `Universes` and `Constraint`, and to track and retrieve universe constraints linked to specific constants or inductive types.",
      "description_length": 485,
      "index": 638,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Synterp",
      "library": "rocq-runtime.vernac",
      "description": "This module processes Coq vernacular commands during the syntactic interpretation phase, converting high-level command representations into structured control entries. It operates on data types like `vernac_control`, `vernac_control_entry`, and various module-related structures such as `module_entry` and `synterp_entry`. Concrete use cases include interpreting `Require`, `Import`, `Module`, and `Section` commands, as well as handling option settings and proof mode configurations during Coq's command processing pipeline.",
      "description_length": 525,
      "index": 639,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Library",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the lifecycle of libraries, from loading and compiling to saving, ensuring consistency through checksum validation. It supports operations to load libraries from file paths, compile them with optional native code generation, and query by directory, while its child module focuses on resolving and verifying library paths during load time, returning both the library and its metadata. Together, they enable use cases such as loading precompiled modules with version checks, compiling new libraries with proof handling, and validating dependencies. The main data types include library paths, directories, and provenance metadata, with operations that combine file system access and integrity verification.",
      "description_length": 723,
      "index": 640,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComPrimitive",
      "library": "rocq-runtime.vernac",
      "description": "Handles the definition and registration of primitive operations and types during the compilation process. It processes identifiers, universe declarations, and expressions to bind them to primitive constructs. Used when implementing low-level primitives in the compiler, such as arithmetic operations or type-level constants.",
      "description_length": 324,
      "index": 641,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ComArguments",
      "library": "rocq-runtime.vernac",
      "description": "Handles the parsing and processing of arguments in Coq vernacular commands, specifically managing section-local declarations, qualified identifiers, and argument status. Works with lists of names, binding kinds, and argument modifiers to structure command inputs. Used when defining or modifying Coq commands that require precise argument handling, such as tactic definitions or command extensions.",
      "description_length": 398,
      "index": 642,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Canonical",
      "library": "rocq-runtime.vernac",
      "description": "This module provides a function to declare a canonical structure in the context of type class resolution. It operates on global references and allows marking a structure as canonical, enabling automatic resolution during type inference. Use cases include setting up default instances for type classes without requiring explicit annotations.",
      "description_length": 340,
      "index": 643,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernacstate",
      "library": "rocq-runtime.vernac",
      "description": "This module coordinates the global state management of the Coq proof assistant during command-line interactions, integrating proof editing, syntax processing, and interpreter execution. It supports freezing and restoring state, handling data types like `pstate`, `Proof.t`, `evar_map`, and parser state, with operations for checkpointing, proof manipulation, and context restoration. Users can apply tactics interactively, revert to prior states after failed commands, or parse input without altering the global environment using the `protect` function. Submodules handle proof stacks, syntactic preprocessing, and interpreter consistency to enable robust proof development and error-resilient command execution.",
      "description_length": 712,
      "index": 644,
      "embedding_norm": 1.0
    },
    {
      "module_path": "VernacControl",
      "library": "rocq-runtime.vernac",
      "description": "Handles control flow for Coq commands with functions to translate syntax into control entries, execute code in controlled contexts, and manage final phases like error handling or message printing. Works with control flags, location data, and state wrappers to manage command execution lifecycle. Used to implement custom command behaviors, enforce timeouts, and handle post-execution cleanup in Coq's REPL loop.",
      "description_length": 411,
      "index": 645,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DeclareInd",
      "library": "rocq-runtime.vernac",
      "description": "This module coordinates the registration of mutual inductive definitions and their elimination schemes, integrating internal representations and metadata handling from its child modules. It supports advanced type theory features through operations on inductive type entries, universes, and implicit arguments, enabling custom elimination rules and optimized pattern matching via primitive projections. Key data types include inductive definitions and schemes, with operations for declaration, retrieval, and dependency management. Example uses include defining inductive types with tailored elimination behavior and registering them for use in larger proofs or computations.",
      "description_length": 674,
      "index": 646,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ComAssumption",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the declaration and interpretation of assumptions, variables, and global definitions in Coq's logical context. It operates on Coq's internal data structures like `Constr`, `Evd.evar_map`, and `Constrexpr`, supporting concrete operations such as defining axioms, hypotheses, and parameters with support for universes, implicits, and coercion. It is used during the processing of Coq vernacular commands like `Variable`, `Axiom`, and `Context`, directly enabling the construction of logical environments and type-checked declarations.",
      "description_length": 552,
      "index": 647,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ComSearch",
      "library": "rocq-runtime.vernac",
      "description": "This module processes Coq's search commands by translating high-level search requests and restrictions into internal representations. It handles environment and evar_map contexts, interpreting searchables like identifiers and qualifiers within specific directory paths. Concrete use cases include command-line query parsing and integration with Coq's interactive proof environment for symbol and theorem searches.",
      "description_length": 413,
      "index": 648,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proof_using",
      "library": "rocq-runtime.vernac",
      "description": "This module processes section variable dependencies in proof contexts, handling expressions that specify which variables are used in definitions. It works with environments, evar maps, and section subsets to extract and manage sets of identifiers. Concrete use cases include determining the subset of section variables used in a definition and suggesting appropriate `using` clauses based on context.",
      "description_length": 400,
      "index": 649,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RetrieveObl",
      "library": "rocq-runtime.vernac",
      "description": "This module processes existential variables in Coq's proof environment, specifically extracting and managing obligations from terms. It works with environments, evar maps, and Coq's internal term structures to identify and structure proof obligations. It is used during the elaboration of definitions with holes, where obligations must be collected and handled explicitly.",
      "description_length": 372,
      "index": 650,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernacexpr",
      "library": "rocq-runtime.vernac",
      "description": "This module's types enable user-facing interactions with Coq's proof assistant, focusing on operations like defining terms, managing proofs, declaring inductive structures, and controlling notations or module behavior. They work with identifiers, abstract syntax trees for terms and binders, scopes, universes, and command-specific constructs like `synterp_vernac_expr` and `hints_expr`. Specific use cases include proof management, inductive type declarations with metadata, notation customization, and tactic execution within Coq's top-level command system.",
      "description_length": 559,
      "index": 651,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComHints",
      "library": "rocq-runtime.vernac",
      "description": "Converts high-level hint expressions into internal hint entries, supporting both polymorphic and monomorphic interpretations. It processes `hints_expr` syntax trees into executable hint data structures used during proof search. This function is essential for implementing custom hint databases and tactic automation in proof scripts.",
      "description_length": 333,
      "index": 652,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mltop",
      "library": "rocq-runtime.vernac",
      "description": "This module orchestrates the dynamic integration and execution of OCaml code within a host environment, supporting plugin loading, search path configuration, and toplevel initialization. It enables operations such as loading Findlib libraries, adding directories, running the OCaml toplevel loop, and registering initialization functions, facilitating use cases like embedding interpreters or loading compiler extensions. A key data type in a child module represents Coq plugins via Findlib library names, offering conversions and pretty-printing for plugin identifiers. These capabilities combine to support structured plugin management and interactive ML module initialization with precise identity tracking.",
      "description_length": 710,
      "index": 653,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DebugHook",
      "library": "rocq-runtime.vernac",
      "description": "This module enables interaction with a debugger through command parsing, response handling, and terminal communication. It defines actions like `StepIn`, `UpdBpts`, and `GetVars` to control execution flow and inspect state, while structured responses update goals or process user input. The `t` record provides `read_cmd`, `submit_answer`, and `isTerminal` for custom frontend integration. Example uses include implementing IDE debugger controls, managing breakpoints, and inspecting variables during proof execution.",
      "description_length": 517,
      "index": 654,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ComTactic",
      "library": "rocq-runtime.vernac",
      "description": "This module handles the interpretation and execution of tactics within a proof context, providing functions to register tactic interpreters and solve goals using both sequential and parallel strategies. It works with proof states, tactic expressions, and goal selectors, supporting operations like tactic application, goal focusing, and parallel execution control. Concrete use cases include implementing custom tactics, executing tactic scripts on selected goals, and integrating parallel proof solving in interactive environments like CoqIDE or LSP-based editors.",
      "description_length": 565,
      "index": 655,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Classes",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the declaration and registration of type class instances, combining dynamic event handling with low-level instance resolution support. It provides data types like `t` for representing class and instance events, along with operations for defining instances, registering hints, and controlling instance transparency. The event-driven submodule triggers callbacks on instance creation, enabling dynamic monitoring and registration, while the low-level submodule offers functions like `add_instance` for direct instance manipulation. Together, they support use cases such as defining typeclass instances, managing proof obligations, and customizing instance resolution behavior.",
      "description_length": 694,
      "index": 656,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernacinterp",
      "library": "rocq-runtime.vernac",
      "description": "This module evaluates Coq vernacular expressions using a stateful interpreter, supporting operations like `interp` for processing controlled vernacular commands and `interp_entry` for interpreting syntactic entries. It works with data types such as `Vernacstate.t` for maintaining interpreter state, `vernac_control` for structured commands, and `proof_object` for handling proof terms. Concrete use cases include executing top-level commands in Coq's interactive environment and finalizing proofs with `Qed` when the proof term may contain delayed computations.",
      "description_length": 562,
      "index": 657,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ComInductive",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the definition and elaboration of inductive and coinductive types, integrating universe polymorphism, cumulativity, and template instantiation. It processes declarations to resolve universe constraints, generate case analysis principles, and ensure consistency using environments, evar maps, and constr terms. The structured representation of inductive entries supports building and manipulating declarations with parameters, coercions, and elimination schemes. It enables parsing and type-checking inductive definitions like natural numbers or lists in Coq, while maintaining correct universe management during declaration.",
      "description_length": 644,
      "index": 658,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Search",
      "library": "rocq-runtime.vernac",
      "description": "This module implements search operations over Coq's global environment and proof goals, supporting pattern matching, module restrictions, and customizable filtering. It processes glob search requests using data types like `glob_search_item` and `glob_search_request`, and applies filters based on module membership, blacklists, or logical kinds. Concrete use cases include searching for rewrite candidates, matching type patterns, and querying declarations by name or module affiliation.",
      "description_length": 487,
      "index": 659,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declaremods",
      "library": "rocq-runtime.vernac",
      "description": "This module manages the declaration, inclusion, and lifecycle of modules and module types during compilation, working with module paths, expressions, and signatures to support structured code organization. It enables tasks like defining parameterized modules, finalizing module types with `end_modtype`, and embedding inclusions via `declare_include`, while also handling imports and library registrations through functions like `import_module`. Submodules provide operations for starting and ending module scopes, managing nested structures, and linking modular components, making it suitable for building compilers or interpreters with rich module systems. Concrete uses include composing modular codebases with type abstractions, handling inline module directives, and structuring library dependencies during compilation.",
      "description_length": 824,
      "index": 660,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Prettyp",
      "library": "rocq-runtime.vernac",
      "description": "This module provides operations for formatting and inspecting Coq's internal structures, such as environments, evar_maps, and library elements, through commands like Print and Locate. It supports pretty-printing judgments, identifiers, and typeclass instances while enabling location resolution for objects like coercions and qualified names. Specific use cases include generating human-readable output for interactive queries and extending locatable object types in Coq's development environment.",
      "description_length": 497,
      "index": 661,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Opaques",
      "library": "rocq-runtime.vernac",
      "description": "This module manages opaque proof terms and their metadata, enabling declaration, retrieval, and update of opaque constants and their disk representations. It coordinates with submodules that handle summary lifecycle operations\u2014initialization, freezing, and joining\u2014allowing state snapshots in concurrent contexts while excluding specific futures. Key data types include `opaque_handle`, `opaque_disk`, and `opaque_proofterm`, supporting use cases like proof serialization and controlled export of opaque constants. Together, the module and its submodules provide a cohesive interface for managing proof terms and summary state across storage and distribution boundaries.",
      "description_length": 670,
      "index": 662,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Auto_ind_decl",
      "library": "rocq-runtime.vernac",
      "description": "This module provides operations to automatically generate schemes for boolean equality and decidability of equality for mutual inductive types. It works with inductive type definitions and produces functions that compare values for equality, returning either a boolean result or a decidable proof. Concrete use cases include deriving equality checks for complex, user-defined data structures like trees, lists, or algebraic types with multiple constructors.",
      "description_length": 457,
      "index": 663,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernactypes",
      "library": "rocq-runtime.vernac",
      "description": "This module orchestrates the interpretation of extended vernac phrases by managing typed command execution and state transitions that affect Coq's proof and program environments. It directly supports operations on proof states and obligation handling through data types like `Declare.OblState.t` and `Declare.Proof.t`, while submodules provide stack-based state management, opaque value access via indirectors, and proof validation mechanics. You can use it to implement custom tactics that manipulate proof contexts, sequence effectful commands, or control access during proof reconstruction. Specific capabilities include pushing and transforming proof states, accessing opaque terms, and managing multi-obligation workflows in interactive theorem proving.",
      "description_length": 758,
      "index": 664,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppvernac",
      "library": "rocq-runtime.vernac",
      "description": "This module provides functions to pretty-print Coq vernacular expressions and their components, such as syntax modifiers, recursive definitions, schemes, and proof using clauses. It operates on data types like `vernac_expr`, `syntax_modifier`, `recursive_expr_gen`, and `scheme`, producing formatted output suitable for display or logging. Use cases include rendering Coq commands for user feedback, pretty-printing proof scripts, and generating readable output for Coq terms in tools or IDE integrations.",
      "description_length": 505,
      "index": 665,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrview.AdaptorDb",
      "library": "ssreflect_plugin",
      "description": "This module manages a database of global Coq terms associated with specific directional or equivalence-based views. It provides operations to retrieve and register lists of global terms based on their kind, such as forward, backward, or equivalence. Use cases include maintaining and querying predefined term transformations for proof automation or term rewriting.",
      "description_length": 364,
      "index": 666,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrparser.Internal",
      "library": "ssreflect_plugin",
      "description": "This module handles parsing, introspection, and pretty-printing of SSReflect proof scripts, working with data types like `ssripats`, `ssrmult`, `ssrfwdkind`, and `ssrhint`. It provides operations for registering tactics, manipulating intro patterns, binding forward hints, and formatting output. Concrete use cases include parsing SSReflect introductions, interpreting pattern bindings, and printing structured proof terms during tactic execution.",
      "description_length": 447,
      "index": 667,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ssreflect_plugin.Ssrcommon.MakeState",
      "library": "ssreflect_plugin",
      "description": "This module provides tactics for manipulating a state within a proof context, specifically retrieving and updating the state using functions like `tclGET`, `tclSET`, and `tacUPDATE`. It works with the `S.state` type defined in the parameter module `S` and interacts directly with the `Proofview` monad. Concrete use cases include managing proof-specific data during tactic execution, such as tracking progress or maintaining context across multiple proof steps.",
      "description_length": 461,
      "index": 668,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ssreflect_plugin.Ssrcommon.StateType",
      "library": "ssreflect_plugin",
      "description": "This module defines a state type and associated operations for managing a named state, including initialization and access to the state's name. It works with a concrete `state` type that encapsulates internal data, exposing only the name as a string. A concrete use case is tracking and initializing distinct states within a larger system where each state must have a unique identifier.",
      "description_length": 386,
      "index": 669,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssripats.Internal",
      "library": "ssreflect_plugin",
      "description": "Handles operations for abstracting terms and finding proof terms in a Coq environment. It provides functions to examine abstracted constructions and retrieve proof terms for existential variables. Used during proof elaboration to manage term abstraction and proof search in tactic execution.",
      "description_length": 291,
      "index": 670,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrfwd",
      "library": "ssreflect_plugin",
      "description": "This module implements tactics for structured proof scripting, focusing on forward reasoning and hypothesis management. It provides operations for setting goals, asserting intermediate lemmas, and manipulating proof terms using pattern-based matching and rewriting. Key data structures include proof terms, rewrite patterns, and tactic arguments like `ssrfwdfmt` and `ssripats`. Concrete use cases include the `have` tactic for introducing local lemmas, `suff` for sufficiency reasoning, and `wlog` for without-loss-of-generality arguments in proofs.",
      "description_length": 550,
      "index": 671,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ssreflect_plugin.Ssrparser",
      "library": "ssreflect_plugin",
      "description": "This module parses and processes SSReflect proof scripts, handling generalized tactic arguments, introspection patterns, and clause structures over Coq's syntax trees and SSReflect ASTs like `ssripats` and `ssrterm`. It supports view-based rewriting, binder syntax, and tactic composition through operations on `Genarg`, `constr_expr`, and `ssrclausehyps`, enabling precise manipulation of proof goals and hypotheses. Submodules extend this functionality with utilities for intro pattern parsing, hint registration, and structured output formatting using types such as `ssrmult` and `ssrhint`. Examples include interpreting custom tactics, binding forward hints during proof construction, and pretty-printing complex intro patterns in interactive proofs.",
      "description_length": 754,
      "index": 672,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ssreflect_plugin.Ssrequality",
      "library": "ssreflect_plugin",
      "description": "This module implements tactics for equality-based rewriting and simplification in proof scripts. It processes rewrite rules with directional and occurrence constraints, supporting operations like `rewrite`, `unlock`, and congruence application. It works directly with terms, patterns, and proof states, handling rule instantiation and redex matching against goals.",
      "description_length": 364,
      "index": 673,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrprinters",
      "library": "ssreflect_plugin",
      "description": "This module transforms internal SSReflect constructs like tactic language elements, AST nodes, and occurrence specifications into human-readable formatted output using Coq's `Pp.t` type. It handles structured data such as lists of terms, patterns, hypotheses, and control flow elements with customizable separators, while supporting debugging workflows through diagnostic flags and occurrence inspection tools. Key applications include rendering proof terms during plugin development, generating diagnostic output for tactic execution, and providing structured visualizations of SSReflect's internal representations.",
      "description_length": 616,
      "index": 674,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrtacs",
      "library": "ssreflect_plugin",
      "description": "This module supports parsing and manipulating tactic expressions in Coq's SSReflect extension, focusing on rewrite rules and pattern matching operations. It works with generalized argument types for handling rewrite occurrences, non-empty or optional rewrite rules, and square-patterns, enabling precise term matching and transformation in theorem proving scenarios. These components are particularly useful for scripting complex tactics that require fine-grained control over rewriting and structured term analysis.",
      "description_length": 516,
      "index": 675,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrcommon",
      "library": "ssreflect_plugin",
      "description": "This module provides foundational operations for term construction, hypothesis management, and tactic development in Coq's proof engine, particularly for SSReflect workflows. It supports direct manipulation of Coq's AST types like `glob_constr`, `constr_expr`, and `EConstr.t`, along with environments, evar maps, and identifiers, enabling tasks such as rewriting, generalization, and typeclass resolution. Submodules offer state management capabilities within proof contexts using the `Proofview` monad via operations like `tclGET` and `tclSET`, while another introduces a named state abstraction for tracking and initializing distinct states with unique identifiers. Examples include implementing custom tactics like `rewritetac`, managing proof-specific data during tactic execution, and maintaining identifiable state instances in larger systems.",
      "description_length": 850,
      "index": 676,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrast",
      "library": "ssreflect_plugin",
      "description": "This module defines abstract syntax tree (AST) types for representing SSReflect tactics in Coq, focusing on structured operations like tactic composition, goal manipulation, and term rewriting. It works with data structures such as identifiers, patterns, simplification modes, and tactic expressions to enable precise control over proof term transformations and hypothesis management. These constructs are used to implement advanced proof scripting features like forward reasoning, clause sequencing, and automated term generation in interactive theorem proving.",
      "description_length": 562,
      "index": 677,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrbwd",
      "library": "ssreflect_plugin",
      "description": "Implements backward reasoning tactics for term application in proof scripts. Operates on ssrterms and ssragens structures to apply hypotheses or lemmas during interactive proving. Useful for automating stepwise refinement of goals by matching and instantiating terms.",
      "description_length": 267,
      "index": 678,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrelim",
      "library": "ssreflect_plugin",
      "description": "This module implements tactics for elimination and case analysis, handling constructor-based reasoning and hypothesis manipulation. It operates on proof terms and patterns, supporting operations like injection, case splitting, and generalized elimination. Concrete use cases include structured case analysis on inductive types and deriving equalities from injective constructors.",
      "description_length": 379,
      "index": 679,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrview",
      "library": "ssreflect_plugin",
      "description": "This module provides tactics for applying views in proof scripts, handling both direct application and pattern-based rewriting of terms and hypotheses. It works with views represented as closures, enabling structured proof transformations through forward application or lemma-based rewrites. The associated sub-module manages a database of global Coq terms mapped to directional or equivalence views, allowing registration and retrieval of transformation rules. Together, they support automated proof structuring by applying registered lemmas as views to manipulate goals or hypotheses based on pattern matches.",
      "description_length": 611,
      "index": 680,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssripats",
      "library": "ssreflect_plugin",
      "description": "This module processes and compiles pattern-directed tactics for goal manipulation, supporting introduction, clearing, rewriting, and case analysis through identifiers and tactic combinators. It enables high-level proof automation like `move`, `elim`, and `case`, transforming proof states based on pattern matching and structured branching. A child module handles term abstraction and proof term retrieval in a Coq environment, supporting tactic execution during proof elaboration. Together, they facilitate precise goal-directed proof transformations and automated term handling.",
      "description_length": 580,
      "index": 681,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrtacticals",
      "library": "ssreflect_plugin",
      "description": "This module implements tactics for structured proof scripting, including sequence and clause handling, with support for hint-based automation and dot notation. It operates on Coq's tactic state, interpretation environments, and pattern-matching structures, integrating with the SSReflect proof language. Concrete use cases include writing compact, readable proofs with precise control over hypothesis management and goal manipulation.",
      "description_length": 434,
      "index": 682,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssreflect_plugin.Ssrvernac",
      "library": "ssreflect_plugin",
      "description": "This module defines generalized argument types for handling Coq expressions and view positions in the context of the Ssreflect proof language. It provides `wit_ssrhintref` for constraint expressions and `wit_ssrviewpos`/`wit_ssrviewposspc` for managing view position annotations during tactic application. These are used internally to support parsing, type checking, and execution of Ssreflect-specific tactics involving views and hints.",
      "description_length": 437,
      "index": 683,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ssreflect_plugin",
      "library": "ssreflect_plugin",
      "description": "This module provides a comprehensive framework for structured proof scripting in Coq, centered on forward and backward reasoning, rewriting, and hypothesis manipulation. It introduces key data types such as `ssripats`, `ssrterm`, `ssrclausehyps`, and `Pp.t` for representing proof terms, patterns, tactic arguments, and formatted output, alongside operations for rewriting, case analysis, lemma assertion, and view application. Users can implement and execute advanced proof strategies like `have`, `suff`, `wlog`, and `rewrite`, automate goal transformations with `move`, `elim`, and `case`, and inspect or format internal proof states for debugging and readability. It also supports parsing and processing of tactic expressions, hint registration, and state management within the `Proofview` monad for custom tactic development.",
      "description_length": 830,
      "index": 684,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Funind_plugin.Functional_principles_types",
      "library": "funind_plugin",
      "description": "This module defines core operations for computing new principle types based on relations. It works with environments, constraints, sorts, and type expressions. A concrete use case is determining the resulting type of a principle when applied to a given relation in a specific context.",
      "description_length": 284,
      "index": 685,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Funind_plugin.Functional_principles_proofs",
      "library": "funind_plugin",
      "description": "This module implements tactics for proving functional induction principles for inductive structures. It operates on Coq's internal constructions and constants, generating proofs based on provided lemma values and type information. It is used to automate the verification of induction principles tied to generated functions, particularly in contexts involving complex inductive definitions.",
      "description_length": 389,
      "index": 686,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Glob_term_to_relation",
      "library": "funind_plugin",
      "description": "Converts inductive definitions from global terms into relational constraints. It processes lists of constants, named global constraints, and optional expressions to generate relational representations. This module is used during proof search to encode inductive structures into a form suitable for automated reasoning.",
      "description_length": 318,
      "index": 687,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Funind_plugin.Indfun_common",
      "library": "funind_plugin",
      "description": "This module offers utilities for identifier manipulation, function metadata tracking, and lambda calculus term handling in Coq's internal language. It operates on Coq-specific data structures like identifiers (Names.Id.t), global and evaluated constraints (Glob_term.glob_constr, EConstr.constr), and inductive definitions, with patterns involving term decomposition, delayed evaluation, and context management. Key applications include automated lemma generation, equality constraint resolution for inductive functions, and structured manipulation of proof terms and lambda expressions.",
      "description_length": 587,
      "index": 688,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Glob_termops",
      "library": "funind_plugin",
      "description": "This module provides utilities for constructing, transforming, and comparing Gallina terms (`glob_constr`) and case patterns (`cases_pattern`), including operations like term building (`mkGApp`, `mkGLambda`), variable renaming (`alpha_rt`), unifiability checks, and implicit argument resolution. It supports advanced manipulation tasks such as pattern matching, substitution, and expansion of \"as\" bindings, primarily used in Coq's tactic system for goal rewriting and case analysis during proof construction. The functionality is tightly integrated with Coq's type-checking machinery, enabling precise term analysis and environment-aware transformations.",
      "description_length": 655,
      "index": 689,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Gen_principle",
      "library": "funind_plugin",
      "description": "This module handles the generation of induction principles and related constructs in Coq. It provides functions to build case analysis schemes, warn about failed definitions, and generate principles interactively or silently. It operates on Coq's global references, identifiers, qualified names, and sorts, working with expressions for fixpoints and proofs. Concrete use cases include automatically deriving induction schemes for inductive types and handling graph definitions during proof construction.",
      "description_length": 503,
      "index": 690,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Indfun",
      "library": "funind_plugin",
      "description": "This module implements functional induction tactics for Coq proofs, enabling induction based on function structure. It works with Coq's internal proof terms and binding structures to apply induction principles derived from function definitions. A concrete use case is proving properties about recursive functions by inductively reasoning on their computational behavior within Coq's tactic system.",
      "description_length": 397,
      "index": 691,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Recdef",
      "library": "funind_plugin",
      "description": "This module provides tactics and utilities for defining recursive functions in Coq, particularly handling user-defined recursion conditions and generating the necessary proof obligations. It works with Coq's tactic system, identifiers, constants, and various Coq-specific data structures like `Constr` and `Constrexpr`. Concrete use cases include implementing custom recursion schemes, such as well-founded recursion or structural recursion with user-specified measures.",
      "description_length": 470,
      "index": 692,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin.Invfun",
      "library": "funind_plugin",
      "description": "This module defines the `invfun` tactic, which performs inversion on a quantified hypothesis, optionally using a global reference to guide the process. It operates on hypotheses within the proof context, leveraging inversion principles to generate new subgoals based on the structure of the hypothesis. A typical use case involves reasoning about inductive properties or equalities by breaking them down into their possible constructors.",
      "description_length": 437,
      "index": 693,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Funind_plugin.G_indfun",
      "library": "funind_plugin",
      "description": "This module defines generalized arguments and entry points for tactics related to function induction and definition schemes. It handles concrete syntax expressions, globally resolved terms, and delayed-opening bindings, supporting tactic operations that involve naming patterns and fixpoint constructions. Specific use cases include parsing and processing custom induction schemes, function definitions with explicit binders, and structured term manipulation in proof scripts.",
      "description_length": 476,
      "index": 694,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Funind_plugin",
      "library": "funind_plugin",
      "description": "This module suite supports advanced proof construction and function definition in Coq, centered around functional induction, inductive reasoning, and term manipulation. It provides core data types such as Coq identifiers, constraints (`glob_constr`, `EConstr.constr`), inductive definitions, and proof terms, along with operations for term building, substitution, inversion, and induction principle generation. Users can automate verification of recursive functions, derive induction schemes for inductive types, encode inductive structures into relational constraints, and manipulate proof goals using tactics like `invfun` and function-based induction. Specific tasks include proving properties of generated functions, resolving equality constraints, and structuring complex case analysis with environment-aware transformations.",
      "description_length": 830,
      "index": 695,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Projection.Repr.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines comparison, equality, and hashing operations for the `Names.Projection.Repr.t` type. It enables ordering and identity checks on projection representations, primarily used for managing user-level names in the kernel. Typical use cases include comparing and hashing projection paths to ensure consistent handling of named objects during type checking and evaluation.",
      "description_length": 384,
      "index": 696,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sorts.QVar.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides `map` and `mapi` functions that transform values in a map while attempting to preserve structural sharing. It operates specifically on maps with keys of type `Sorts.QVar.Map.key` and values of a generic type `'a`. These functions are useful when updating mapped values in a way that avoids unnecessary allocations, particularly in performance-sensitive contexts involving large or frequently modified maps.",
      "description_length": 427,
      "index": 697,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Id.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over finite maps of identifiers (`Names.Id.Map.t`). It supports `fold`, `mapi`, `fold_left`, and `fold_right`, enabling effectful iteration and mapping within a monadic context `M`. These operations are used when applying stateful or effectful computations to maps of named objects, such as accumulating results with side effects or handling maps under a monadic layer during transformations.",
      "description_length": 461,
      "index": 698,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.Quality.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module implements monadic traversal and transformation operations over maps with quality-sorted keys. It provides `fold`, `mapi`, `fold_left`, and `fold_right` functions that apply monadic actions during iteration, enabling effectful computations while preserving key order. These operations are used for tasks like validating, transforming, or aggregating map values in sequence where each step depends on external effects tracked by the monad `M`.",
      "description_length": 454,
      "index": 699,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.GlobRef.Map_env.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic fold and map operations over a map structure where keys are globally referenced names and values are arbitrary. It supports traversing and transforming the map with functions that sequence effects through a parameterized monad. Concrete use cases include accumulating results with error handling or state during map traversal, or building new maps by applying effectful transformations to existing entries.",
      "description_length": 435,
      "index": 700,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Univ.Universe.Set.List",
      "library": "rocq-runtime.kernel",
      "description": "Operates on lists of sets to compute unions and manage set collections. Provides functions to combine multiple sets into a single set and handle set membership across list elements. Useful for aggregating disjoint sets or merging set-based configurations from a list.",
      "description_length": 267,
      "index": 701,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Names.Projection.Repr.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for values of type `Names.Projection.Repr.t`. It enables ordering and identity checks on syntactic representations of projections, which are used to uniquely identify and compare projection paths in the system. These operations support concrete tasks such as efficient lookup in data structures and ensuring consistency in name resolution.",
      "description_length": 405,
      "index": 702,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Label.Set.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a function to compute the union of a list of label sets. It operates on lists of sets where each set contains labels\u2014distinct identifiers with specific semantic meaning. A concrete use case is merging multiple collections of labels into a single set, such as combining declared labels from different scopes or modules.",
      "description_length": 339,
      "index": 703,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized `map` and `mapi` functions for transforming values in a `GlobRef.Map`, preserving structural sharing to improve efficiency. It operates specifically on `Names.GlobRef.Map.t`, a map indexed by global references, with values of arbitrary type. It is useful when updating or transforming entries in a mapping from global references to structured data, such as during name resolution or environment manipulation.",
      "description_length": 439,
      "index": 704,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Id.Set.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations to manipulate lists of identifier sets, primarily supporting the union of multiple identifier sets into a single set. It works with `Names.Id.Set.t` values, which represent finite sets of identifiers, and processes these in list form to aggregate their contents. A concrete use case is combining multiple sets of identifiers into one when merging environments or contexts in the kernel.",
      "description_length": 418,
      "index": 705,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Universe.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve sharing when possible, operating on `Univ.Universe.Map.t` structures. It is useful when transforming maps with functions that may return structurally shared results, reducing unnecessary duplication. Concrete use cases include efficiently updating values in large maps while maintaining referential equality where applicable.",
      "description_length": 399,
      "index": 706,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Projection.Repr.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for the `t` type, which represents canonical names in the kernel. It enables efficient ordering and identity checks on name projections, ensuring consistent handling of unique identifiers during compilation and proof processing. These operations are critical for internal kernel tasks such as name resolution and object referencing.",
      "description_length": 398,
      "index": 707,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.Quality.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "Performs efficient transformations on maps with quality-assessed keys, preserving structural sharing where possible. It applies functions to values or key-value pairs, maintaining the map's internal structure to optimize memory usage. Useful for updating values in large maps without duplicating unchanged branches, such as refining quality metrics in a dataset indexed by keys.",
      "description_length": 378,
      "index": 708,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Level.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic variants of map operations, enabling folding and mapping over universe level maps with effects. It works with `Univ.Level.Map.t` structures, applying monadic functions to keys and values. Concrete use cases include transforming or aggregating universe maps while handling side effects like state or error handling within the monad `M`.",
      "description_length": 364,
      "index": 709,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Label.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module implements monadic traversals over maps with keys of type `Label.t`, supporting operations like `fold`, `mapi`, `fold_left`, and `fold_right` within a monadic context `M`. It is designed for processing mappings from labels to values, where each function applies a monadic transformation or accumulation over the map's bindings. Concrete use cases include propagating errors or state while transforming or analyzing labeled data structures, such as processing named fields in a record or tracking dependencies during compilation.",
      "description_length": 540,
      "index": 710,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Level.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized map operations over universe levels with sharing preservation. It supports efficient transformations of maps where keys are universe levels and values can be arbitrary, ensuring structural sharing is maintained during `map` and `mapi` operations. It is particularly useful in type systems or proof assistants where universe management requires performance-critical map manipulations with minimal memory overhead.",
      "description_length": 443,
      "index": 711,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Id.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized versions of `map` and `mapi` for identifier maps, preserving sharing during transformation to improve performance. It operates specifically on `Names.Id.Map.t`, which are finite maps keyed by identifiers (`Names.Id.t`). These functions are useful when updating values in large maps where maintaining structural equality and reducing memory usage is critical, such as in symbol table manipulations or environment tracking in compilers and interpreters.",
      "description_length": 482,
      "index": 712,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Universe.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation functions for associative maps with typed keys. It supports operations like `fold`, `mapi`, `fold_left`, and `fold_right`, which process map entries using monadic actions from the `M` module. It is used to build and manipulate heterogeneous maps where each key determines the value type, enabling precise type handling during monadic computations.",
      "description_length": 405,
      "index": 713,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.GlobRef.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic variants of map traversal operations, specifically `fold` and `mapi`, which process key-value pairs in a `Names.GlobRef.Map.t`. It works with maps where keys are `Names.GlobRef.Map.key` and values are arbitrary types, applying monadic functions during iteration. Concrete use cases include accumulating results across map entries with effectful computations or transforming map values within a monadic context.",
      "description_length": 439,
      "index": 714,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.Map_env.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized `map` and `mapi` functions that transform values in a `GlobRef.Map_env.t` structure while preserving structural sharing where possible. It operates specifically on maps with keys from `Names.GlobRef.Map_env.key` and arbitrary value types. These functions are useful when updating environment mappings in the Coq kernel, such as during renaming or substitution passes over named objects.",
      "description_length": 417,
      "index": 715,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Label.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized `map` and `mapi` functions for transforming values in a `Label.Map`, preserving structural sharing during traversal. It operates specifically on maps keyed by `Label.t`, a distinct identifier type semantically equivalent to `Id.t`. These functions are useful when updating associated data across a map of named components, such as propagating transformations through a symbol table keyed by semantic labels.",
      "description_length": 438,
      "index": 716,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sorts.QVar.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations for maps with keys of type `Sorts.QVar.Map.key`. It supports `fold`, `mapi`, `fold_left`, and `fold_right`, which allow accumulating values or transforming bindings while sequencing effects through the monad `M`. These operations are useful for processing map data structures in a monadic context, such as accumulating state or handling effectful computations during iteration.",
      "description_length": 446,
      "index": 717,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Names.Indset.List",
      "library": "rocq-runtime.kernel",
      "description": "Operates on sets of identifiers, providing a union function to combine multiple sets into one. Works with `Names.Indset.t` values, which represent sets of unique identifiers. Useful for aggregating disjoint collections of names, such as merging sets of variable names or labels in a type-checking context.",
      "description_length": 305,
      "index": 718,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines comparison, equality, and hashing operations for `Names.GlobRef.t` values based on their syntactic structure. It enables ordering and identity checks on global references using their concrete name components, such as identifiers and paths. Useful in contexts like environment lookups, reference resolution, and data structure keys where structural identity matters.",
      "description_length": 385,
      "index": 719,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MutInd.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for values of type `Names.MutInd.t`. It enables ordering and identity checks based on the syntactic structure of mutual inductive definitions. These functions are used when storing or comparing inductive types in data structures like maps or sets.",
      "description_length": 313,
      "index": 720,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.KNmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic variants of fold and map operations over KNmap structures. It works with key-value maps where keys are KNmap keys and values are arbitrary, enabling traversal and transformation within a monadic context. Concrete use cases include accumulating results with effects like error handling or state during map traversal, or building new KNmaps from existing ones using monadic logic.",
      "description_length": 407,
      "index": 721,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Indmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over `Indmap.t`, a map structure keyed by identifiers. It supports folding, mapping, and iterating with functions that return values in a monadic context `M`, enabling effectful computations over maps of named objects. Concrete use cases include propagating state or handling errors while processing identifier-indexed data, such as tracking defined names during compilation or validating module paths.",
      "description_length": 471,
      "index": 722,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Indmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over integer-indexed maps, preserving structural sharing during transformations. It works with polymorphic maps where keys are integers and values can be of any type. These functions are particularly useful when efficiently updating large, persistent maps with identity-preserving modifications.",
      "description_length": 345,
      "index": 723,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Mindmap_env.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module implements monadic fold and map operations over map structures defined in Names.Mindmap_env. It works with key-value pairs where keys are based on identifier types from the Names module and values are arbitrary. It enables traversing and transforming maps in a monadic context, useful for stateful or effectful computations over named object mappings.",
      "description_length": 363,
      "index": 724,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Construct.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for canonical names represented as `Names.Construct.t`. It enables efficient ordering and identity checks on structured names used in the kernel, such as identifiers, labels, and paths. Concrete use cases include managing name-based maps and sets, and ensuring consistent ordering in internal data structures.",
      "description_length": 375,
      "index": 725,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Constrset.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations to compute the union of multiple sets of names, where each set is represented as a `Names.Constrset.t`. It works with lists of sets containing identifiers, labels, or other name variants defined in the `Names` module. A concrete use case is merging collections of free variables or dependencies from multiple terms in the type checker or proof engine.",
      "description_length": 383,
      "index": 726,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Cmap_env.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized operations for mapping functions over constant-indexed environments while preserving structural sharing. It works with constant keys and associated values stored in a map structure. Concrete use cases include efficiently transforming environments that bind constants to metadata, such as during compilation or analysis passes over a program.",
      "description_length": 372,
      "index": 727,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.DPmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over dictionary-like structures keyed by `Names.DPmap.key`, which corresponds to directed paths of identifiers. It supports transforming values while preserving structural sharing to improve performance and reduce memory usage. Concrete use cases include efficiently updating values in large, nested path-indexed maps during compilation or program transformation tasks.",
      "description_length": 419,
      "index": 728,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Constraints.List",
      "library": "rocq-runtime.kernel",
      "description": "Handles operations on lists of constraint sets, primarily providing functions to compute unions and intersections. Works with lists of `Univ.Constraints.t` values, enabling aggregation and combination of constraint sets from multiple sources. Useful for merging and analyzing collections of constraints in type inference or configuration systems.",
      "description_length": 346,
      "index": 729,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Id.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for working with lists of identifiers, including equality checks, membership tests, and association list manipulations. It supports data types such as lists of `Id.t` and pairs of `Id.t` with arbitrary values. Concrete use cases include managing symbol tables, tracking named objects in the kernel, and handling mappings between identifiers and their associated data.",
      "description_length": 399,
      "index": 730,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Indset_env.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a function to compute the union of multiple sets from a list, operating on sets defined in the `Names.Indset_env` module. It works with lists of `Names.Indset_env.t` sets, which represent collections of identifiers or names. A concrete use case is merging multiple name sets when combining results from different branches of a program analysis or processing multiple input sources.",
      "description_length": 402,
      "index": 731,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.QVar.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module manages associative maps with keys of type `Sorts.QVar.t`, supporting core operations like insertion, deletion, and ordered traversal, along with advanced transformations via merging, splitting, and domain manipulation. It provides polymorphic value mapping, filtering, and folding, enabling symbolic computation and environment management tasks such as variable binding analysis. The first child module enhances value transformation with `map` and `mapi` functions that preserve structural sharing to optimize performance in large-scale or frequent updates. The second child module extends map processing into monadic contexts, allowing effectful traversals and transformations that sequence state or other computational effects during iteration.",
      "description_length": 759,
      "index": 732,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.KNmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations that preserve sharing for efficiency. It works with key-value structures where keys are absolute names (`KerName.t`) and values can be of any type. It is used to efficiently transform value data across large named object maps without duplicating shared components.",
      "description_length": 314,
      "index": 733,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.MBImap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over persistent immutable maps, specifically preserving structural sharing during transformations. It works with key-value structures where values support equality and keys align with identifier types like `Id.t` or `Label.t`. Concrete use cases include efficiently updating named environments in the kernel, such as managing local contexts or module hierarchies without duplicating unchanged branches.",
      "description_length": 452,
      "index": 734,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Constrmap_env.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module implements monadic traversal and transformation operations over a constrained map environment. It provides functions to fold, map, and iterate with monadic effects, specifically handling key-value pairs where keys are from `Names.Constrmap_env.key` and values are user-defined. It is used to manipulate structured environments in a monadic context, such as accumulating state or handling side effects during traversal.",
      "description_length": 430,
      "index": 735,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cmap_env.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic variants of fold and map operations over a constant map structure. It works with `Names.Cmap_env.t`, a map keyed by constants ordered by their user form. These functions enable traversing and transforming the map within a monadic context, allowing for effectful computations during iteration.",
      "description_length": 321,
      "index": 736,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.Quality.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a comprehensive set of functional operations for managing immutable collections of quality elements, including set algebra (union, intersection, difference), membership checks, extremum queries (min/max), and transformations via higher-order functions. It works with immutable sets of `Sorts.Quality.t` values, supporting efficient cardinality tracking, iteration, and conversion from sequences. Typical use cases include data analysis pipelines requiring pure functional transformations, deduplication of quality values, and scenarios where set-theoretic operations are needed to compare or combine collections of qualities.",
      "description_length": 646,
      "index": 737,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.QVar.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module supports functional set operations like membership testing, insertion, deletion, and set algebra on immutable collections of `QVar` elements, ensuring non-destructive transformations. It provides utilities for ordered traversal, extremal value extraction, and sequence-to-set conversions, enabling efficient data analysis workflows where ordered set manipulation is critical. Applications include algorithms requiring persistent data structures for incremental set updates or ordered element processing.",
      "description_length": 515,
      "index": 738,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized map operations for constant keys, specifically supporting efficient key comparison and sharing preservation during transformations. It works with constant values wrapped in the `Constant.t` type, leveraging their canonical forms for ordering. Concrete use cases include managing and transforming constant-based mappings in the Rocq kernel, such as tracking definitions or optimizing constant evaluation paths.",
      "description_length": 440,
      "index": 739,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.DPset.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for working with sets of directory paths (`DirPath.t`), including the union of multiple sets. It supports efficient set manipulation and querying on sequences of identifiers representing hierarchical paths. Concrete use cases include managing and combining sets of module or file paths in the Rocq kernel.",
      "description_length": 337,
      "index": 740,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.Map_env",
      "library": "rocq-runtime.kernel",
      "description": "This module manages efficient finite maps associating globally referenced keys with arbitrary values, supporting standard operations like insertion, lookup, and filtering, along with optimized transformations when key presence is guaranteed. It includes structured key domains from `Names.GlobRef.Map_env.key` and integrates with `Names.GlobRef.Set_env` for domain manipulation, enabling environment tracking, identifier resolution, and hierarchical structure management in symbolic computation contexts. The module supports monadic traversal and transformation, allowing effectful operations like error handling or state accumulation during map processing, and provides optimized `map` and `mapi` functions that preserve structural sharing during value transformations. These capabilities facilitate high-performance updates to large maps, such as those encountered during renaming or substitution passes in the Coq kernel.",
      "description_length": 924,
      "index": 741,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Environ.QProjection.Repr",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for comparing, hashing, and normalizing projection representations within an environment context. It works directly with `Environ.QProjection.Repr.t`, which represents projections in a de Bruijn-indexed environment. Concrete use cases include ensuring structural equivalence of projections during type checking and optimizing projection comparisons in proof search.",
      "description_length": 397,
      "index": 742,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic variants of fold and map operations over constant-keyed maps. It works with `Names.Cmap.t`, a map structure where keys are constants ordered by their canonical form. Concrete use cases include accumulating results across a map while handling effects like state or error propagation, or transforming map values while sequencing monadic actions.",
      "description_length": 372,
      "index": 743,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.Quality.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module manages ordered key-value maps with quality-sorted keys and polymorphic values, supporting insertion, deletion, lookup, and ordered traversal, along with advanced operations like merging, splitting, and symmetric difference folding. It enables effectful, monadic traversal and transformation while preserving key order, as well as efficient, shared-structure updates that minimize memory duplication during large-scale value refinements. Main data types include maps indexed by `Sorts.Quality.t` keys, with operations such as `insert`, `remove`, `find`, `merge`, and `fold`, extended by submodules offering monadic iteration and structural-sharing optimizations. Examples include aggregating quality-assessed data with effectful folds, or refining values in a large map while reusing unchanged key branches.",
      "description_length": 819,
      "index": 744,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Universe.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module implements standard set operations such as union, intersection, difference, and subset checks, while supporting queries on membership, cardinality, and extremal elements. It enables transformations through iterators, ordered traversal, and conversions to and from lists and sequences, facilitating the management of unique element collections and set-based computations. The child module extends this by aggregating unions and managing set membership across lists of sets, allowing tasks like merging multiple configurations or combining disjoint sets. Together, they support operations like computing the union of a list of sets, checking if an element exists in any of several sets, or transforming a list into a uniquely valued sequence.",
      "description_length": 752,
      "index": 745,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Ind.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module implements comparison, equality, and hashing operations for the `Names.Ind.t` type, which represents inductive type identifiers. It enables efficient ordering and identity checks on syntactic names used in the Rocq kernel, particularly for managing and distinguishing inductive definitions. These operations are essential for data structures requiring key-based lookup or ordered traversal, such as maps and sets.",
      "description_length": 425,
      "index": 746,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Ind.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines comparison, equality, and hashing operations for user names represented as `Names.Ind.t` values. It enables ordering and identity checks on identifiers used in the kernel, such as those for modules, labels, and object names. These functions support tasks like sorting name-based data structures and ensuring referential consistency in name resolution.",
      "description_length": 371,
      "index": 747,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Construct.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines comparison, equality, and hashing operations for user names in the kernel. It works directly with the `Names.Construct.t` type, which represents user-defined names in Rocq's internal naming system. These functions are used to support name-based lookups, comparisons, and caching in the kernel's object management and module system.",
      "description_length": 351,
      "index": 748,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evar.Map.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation functions for maps with existential variables as keys. It supports operations like `fold`, `mapi`, `fold_left`, and `fold_right`, which allow processing map entries within a monadic context. It is used when manipulating maps that track existential variables, such as managing substitutions or environments in type inference systems.",
      "description_length": 390,
      "index": 749,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constrset_env.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a function to compute the union of multiple sets, where each set contains elements of the `Names` module's core types, such as identifiers and names. It operates specifically on lists of `Names.Constrset_env.t` sets, which are built on top of the underlying `Set` library. A concrete use case is merging collections of named objects, such as combining sets of identifiers during type checking or environment processing.",
      "description_length": 440,
      "index": 750,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Construct.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for values of type `Names.Construct.t`. It enables ordering and identity checks on syntactic constructs, primarily used during low-level manipulation or normalization of terms in the kernel. These functions are essential for implementing efficient data structures like maps or sets over syntactic elements.",
      "description_length": 372,
      "index": 751,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.Quality.Constants",
      "library": "rocq-runtime.kernel",
      "description": "This module defines operations for comparing and printing quality constants. It provides equality checking, ordering comparison, and pretty-printing for values of type `Sorts.Quality.constant`. These functions are used to analyze and display quality metrics in sorting algorithms.",
      "description_length": 280,
      "index": 752,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Indmap_env.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over environments indexed by identifiers, preserving structural sharing during transformations. It works with environments (`Indmap_env.t`) that associate values to identifier-keyed entries, typically used for managing named objects in the kernel. Concrete use cases include efficiently updating or transforming environments of definitions, such as substituting values under specific identifier keys during type-checking or compilation passes.",
      "description_length": 493,
      "index": 753,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.MPmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over `MPmap.t`, a map structure keyed by module paths. It supports `fold`, `mapi`, `fold_left`, and `fold_right`, enabling effectful computations across bindings while preserving the map's structure. It is used to process module path-indexed data with monadic sequencing, such as accumulating state or handling errors during map iteration.",
      "description_length": 408,
      "index": 754,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Id.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module implements finite sets of identifiers (`Id.t`) with core operations like membership testing, union, intersection, difference, filtering, and iteration. It includes utilities for cardinality, extremal element access, and conversions from lists or sequences, enabling tasks like tracking unique names in compilers or validating identifier collections. A child module extends this functionality by aggregating lists of identifier sets into a single set, useful for merging environments or contexts. Together, they support precise manipulation and combination of identifier collections in formal verification and language processing tasks.",
      "description_length": 647,
      "index": 755,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.GlobRef.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module implements standard set operations on global references, including union, intersection, difference, and membership testing, alongside querying capabilities like cardinality, element enumeration, and arbitrary element selection. It operates on sets of `Names.GlobRef.t` values, which represent absolute references to objects within the system. These operations are particularly useful for dependency tracking, scope resolution, and managing cross-module references where set-based analysis of globally named entities is required.",
      "description_length": 540,
      "index": 756,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Indmap_env.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over `Indmap_env.t` structures, which map keys to values within a monadic context. It supports folding and mapping with functions that incorporate monadic effects, enabling sequential computation over key-value pairs. Use cases include propagating state or handling side effects during environment processing in compiler or interpreter workflows.",
      "description_length": 415,
      "index": 757,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Context.Rel.Declaration",
      "library": "rocq-runtime.kernel",
      "description": "This module provides functions to inspect and transform local declarations in a relational context, including retrieving or modifying names, types, and values, checking whether a declaration is an assumption or definition, and mapping over or comparing components. It operates on parametrized declarations that support both homogeneous and heterogeneous transformations, enabling operations like iteration, folding over terms, and converting definitions into assumptions by discarding their bodies. These capabilities are used for tasks such as term traversal during analysis, restructuring contexts in type-checking pipelines, and deconstructing complex declarations into simpler forms.",
      "description_length": 687,
      "index": 758,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Id.Pred",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a set-like structure for testing membership of identifier values, supporting operations such as union, intersection, difference, and complement. It works with identifiers (`Id.t`) and provides concrete functions to construct and query sets, including checking emptiness, fullness, inclusion, and equality. Use cases include tracking reserved identifiers, managing sets of used names during compilation, and filtering identifiers based on inclusion in a defined set.",
      "description_length": 488,
      "index": 759,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.GlobRef.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines comparison, equality, and hashing operations for user names in the context of global references. It works directly with the `Names.GlobRef.t` type, which represents globally unique references in the system. These functions enable consistent ordering and identification of global references, particularly in data structures that rely on key comparison or hashing, such as maps and sets.",
      "description_length": 405,
      "index": 760,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Constrmap_env.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over environments where keys are based on constructor names and values are arbitrary. It supports transformations that preserve structural sharing to improve efficiency when updating mapped values. It is particularly useful in contexts where environments are frequently modified but share common structure, such as managing named definitions or tracking identifier mappings during type checking.",
      "description_length": 445,
      "index": 761,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Projection.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for values of type `Names.Projection.t`. It enables ordering and identity checks on syntactic projections, which are used to represent field selections from inductive types. These operations are essential for using projections as keys in maps, sets, and other data structures requiring equality or ordering.",
      "description_length": 373,
      "index": 762,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Projection.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for canonical names represented as `Names.Projection.t`. It enables efficient ordering and identity checks on structured name projections, which are used to uniquely identify objects within the kernel. These operations support internal mechanisms such as name resolution and object referencing.",
      "description_length": 360,
      "index": 763,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.GlobRef.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module implements associative maps keyed by globally unique references (`GlobRef.t`), supporting operations like insertion, deletion, lookup, and structural merging, alongside optimized transformations (`map`, `mapi`), domain manipulation (`domain`, `filter_map`), and symmetric difference comparisons. It provides direct access to finite dictionaries mapping `GlobRef.t` to arbitrary typed values, leveraging key-based equality and ordering constraints, useful for managing named entities in formal systems such as tracking dependencies or resolving symbolic references. The module includes submodules that enhance transformation efficiency through structural sharing and support monadic traversal for effectful computations across map entries. For example, it can merge environments during type checking, transform structured data under global keys, or accumulate state while iterating over scoped identifiers.",
      "description_length": 917,
      "index": 764,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.Set_env",
      "library": "rocq-runtime.kernel",
      "description": "This module implements set operations for managing environment-qualified global references, including union, intersection, difference, and membership checks, alongside iteration and predicate-based filtering. It operates on collections of `Names.GlobRef.t` values, providing utilities to query cardinality, extract elements as lists, and select arbitrary members. These capabilities are used in the Coq kernel to resolve dependencies between modules, track named objects across environments, and enforce scoping constraints during type-checking or compilation.",
      "description_length": 560,
      "index": 765,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Constant.SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides syntactic comparison, equality, and hashing operations for constant names. It works directly with the `Names.Constant.t` type, which represents absolute names of objects in Rocq. These functions are used in low-level contexts where direct name-based identity checks and orderings are required, such as managing global definitions or ensuring name uniqueness in the kernel.",
      "description_length": 393,
      "index": 766,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MutInd.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for canonical names represented as `Names.MutInd.t`. It enables efficient ordering and identity checks on mutual inductive type identifiers, primarily used in the kernel for managing definitions and references. These operations support concrete tasks such as indexing in hash tables or maintaining ordered collections of named kernel objects.",
      "description_length": 408,
      "index": 767,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MutInd.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for user names in the context of mutual inductives. It works directly with the `Names.MutInd.t` type, which represents identifiers for mutual inductive definitions. Concrete use cases include ordering and deduplicating mutual inductive declarations based on user-provided names.",
      "description_length": 344,
      "index": 768,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MBIset.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a function to compute the union of multiple sets of module base identifiers. It operates on lists of `Names.MBIset.t` values, combining them into a single set. A concrete use case is merging collections of module identifiers when resolving dependencies or aggregating components in the module system.",
      "description_length": 321,
      "index": 769,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Context.Named.Declaration",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations to inspect, transform, and traverse named local declarations, distinguishing between assumptions (type-only) and definitions (value-bearing). It works with parameterized declaration structures like `Context.Named.Declaration.pt` and `Context.Rel.Declaration.pt`, supporting conversions between named and relational forms, dropping definition bodies, and translating names to identifiers. These tools are used in type checking, variable management, and formal verification workflows where structured context manipulation is required.",
      "description_length": 564,
      "index": 770,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Label.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module implements standard set operations over immutable collections of semantic identifiers, supporting union, intersection, difference, membership tests, and iteration. It provides functions to convert sequences into sets and perform order-based queries, cardinality checks, and subset comparisons, enabling management of hierarchical naming contexts, module path analysis, and kernel object resolution. A child module extends this functionality by computing the union of a list of label sets, useful for merging label collections from different scopes or modules into a single set. Together, the module and its submodules facilitate precise manipulation and analysis of distinct identifier semantics through set theory.",
      "description_length": 727,
      "index": 771,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.PRmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized versions of `map` and `mapi` for PRmaps that attempt to preserve structural sharing during traversal. It operates specifically on `PRmap.t` structures, which are maps from keys (such as identifiers or paths) to arbitrary values. These functions are useful when transforming values within large, persistent maps\u2014such as during name resolution or environment updates\u2014while minimizing memory allocation and maintaining efficiency.",
      "description_length": 458,
      "index": 772,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Mindmap_env.Set",
      "library": "rocq-runtime.kernel",
      "description": "The module implements standard set-theoretic operations\u2014such as membership checks, unions, intersections, and element selection\u2014for managing collections of keys tied to a mindmap environment. It operates on sets built from key types that interface with map-like structures, enabling efficient size queries, iteration, and arbitrary element retrieval. These sets are used to handle domains of keys in mindmap-specific computations, such as tracking dependencies or managing identifier collections in formal environments.",
      "description_length": 519,
      "index": 773,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Ind.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for canonical names represented as `Names.Ind.t`. It enables efficient ordering and identity checks on inductive type identifiers within the kernel. These operations are specifically used during type checking and compilation to ensure consistent handling of named inductive definitions.",
      "description_length": 352,
      "index": 774,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Level.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module manages associations between universe levels and arbitrary values, supporting core dictionary operations like insertion, deletion, and lookup, along with advanced transformations such as merging, filtering, and domain manipulation. It provides polymorphic maps with structural comparison, range-based filtering, and pretty-printing, enabling tasks like tracking universe level constraints or analyzing type hierarchies. One submodule extends these maps with monadic operations for effectful traversals, allowing stateful or error-aware transformations of universe level mappings. Another submodule optimizes map transformations to preserve structural sharing, reducing memory usage in performance-critical applications like type checking or proof assistant backends.",
      "description_length": 778,
      "index": 775,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evar.Map.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized versions of `map` and `mapi` that preserve sharing when transforming values in a map keyed by existential variables. It works with `Evar.Map.t`, a map structure where keys are existential variables (logically integers) and values can be of any type. These functions are useful when efficiently updating or inspecting map contents without duplicating unchanged parts of the structure, particularly in proof assistants or symbolic computation systems.",
      "description_length": 480,
      "index": 776,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.DPmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over `Names.DPmap.t`, a map structure keyed by `Names.DPmap.key`, which corresponds to directory paths. It supports `fold`, `mapi`, `fold_left`, and `fold_right`, enabling effectful iteration and value transformation within a monadic context `M`. These operations are used to process and manipulate hierarchical name mappings with side effects, such as state or error handling, during traversal.",
      "description_length": 464,
      "index": 777,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constrmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over `Constrmap.t` structures, which are maps keyed by `Constrmap.key`. It supports `fold`, `mapi`, `fold_left`, and `fold_right`, enabling accumulation and per-binding transformations within a monadic context `M`. Concrete use cases include analyzing or transforming compiler intermediate representations where name tracking and monadic effects like error handling or state threading are required.",
      "description_length": 467,
      "index": 778,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Constrmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over a specialized map structure for keys from the `Names` module, particularly working with identifiers and names such as `Id.t`, `Name.t`, and related types. It supports efficient transformations of map values while preserving structural sharing where possible. Concrete use cases include optimizing name-based symbol tables and managing mappings in the Rocq kernel where performance and memory usage are critical.",
      "description_length": 466,
      "index": 779,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MPset.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for working with sets of module paths, including efficient union operations over lists of sets. It manipulates values of type `Names.MPset.t`, which represent collections of `ModPath.t` elements. Concrete use cases include combining sets of module paths during import resolution or dependency tracking in the kernel.",
      "description_length": 348,
      "index": 780,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Level.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module offers operations for constructing, modifying, and querying sets of universe levels, including membership checks, union/intersection/difference, element selection, and cardinality tracking. It works with sets represented as `Univ.Level.Set.t` containing elements of type `Univ.Level.t`, enabling both functional transformations and imperative updates. These capabilities are critical for managing universe hierarchies in type systems, such as resolving polymorphic constraints or validating level consistency in formal verification tasks.",
      "description_length": 550,
      "index": 781,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.ModIdmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over `ModIdmap.t` structures, which map module identifiers to values. It supports `fold`, `mapi`, `fold_left`, and `fold_right`, enabling accumulation and per-binding computations within a monadic context `M`. Concrete use cases include propagating state or handling effects while processing module identifier mappings during compilation or analysis tasks.",
      "description_length": 425,
      "index": 782,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constant.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines comparison, equality, and hashing operations for user names represented as `Names.Constant.t`. It enables ordering and identity checks on name values, which are used to identify objects in the system. These functions support tasks like sorting named entities or checking name equivalence during compilation or runtime operations.",
      "description_length": 349,
      "index": 783,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Projection.Repr",
      "library": "rocq-runtime.kernel",
      "description": "This module handles projections in the kernel, particularly for record fields and inductive parameters, offering operations to build and manipulate projection values, extract metadata such as inductive types and argument indices, and manage projection paths during type checking and compilation. Its submodules provide comparison, equality, and hashing functions for projection types, enabling efficient identity checks, ordering, and data structure integration for tasks like name resolution and object referencing. It supports concrete operations such as tracking field access in records, resolving projection paths during evaluation, and ensuring consistent handling of named entities across the system. The combination of direct projection manipulation and robust comparison utilities ensures reliable and efficient handling of projection-related data throughout the kernel.",
      "description_length": 878,
      "index": 784,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Mindmap_env.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized map and mapi functions that transform values in a persistent map while preserving structural sharing. It operates on maps where keys are specific name types from the Names module, such as Id.t or KerName.t, and values can be arbitrary. It is used in scenarios requiring efficient, identity-preserving updates of named objects in environments, such as managing definitions or references in a proof assistant's kernel.",
      "description_length": 447,
      "index": 785,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.ModIdset.List",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a function to compute the union of multiple sets of module identifiers, combining them into a single set. It operates on lists of `Names.ModIdset.t` values and returns a new `Names.ModIdset.t` containing all unique elements from the input sets. A typical use case is merging collections of module identifiers when resolving imports or tracking dependencies across multiple files.",
      "description_length": 400,
      "index": 786,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MBImap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module provides monadic traversal and transformation operations over `MBImap.t` structures, which are maps keyed by identifiers. It supports `fold`, `mapi`, `fold_left`, and `fold_right`, enabling accumulation and per-binding transformations within a monadic context `M`. These operations are used to process mappings of identifiers to values in scenarios like name resolution, environment manipulation, or structured data transformation.",
      "description_length": 443,
      "index": 787,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constant.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for canonical names represented as `Names.Constant.t`. It enables efficient ordering and identity checks on constant identifiers within the kernel. These operations are specifically used during internal kernel processing to manage and track named entities like constants and modules.",
      "description_length": 349,
      "index": 788,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.PRmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module implements monadic fold and map operations over maps with keys of type `Names.PRmap.key` and values of arbitrary types. It allows applying functions across map bindings within a monadic context, enabling effectful computations during traversal. Use this module to perform stateful transformations or accumulate results in a monad like `Result` or `Option` over maps defined in the `Names.PRmap` library.",
      "description_length": 415,
      "index": 789,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Projection.UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines comparison, equality, and hashing operations for user names in the context of projections. It works directly with `Names.Projection.t`, a type representing projection values in the system. These functions are used to support efficient data structure manipulation and comparison of projection-based names in the kernel.",
      "description_length": 338,
      "index": 790,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Context.Compacted.Declaration",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations to transform and convert compacted declarations, including mapping over their components, converting from named declarations, and translating them into named contexts. It works with compacted declaration structures that represent local assumptions and definitions in a local context. Concrete use cases include processing and restructuring local contexts during type-checking or proof construction.",
      "description_length": 430,
      "index": 791,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Label.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module organizes key-value data using `Label.t` identifiers, offering operations to bind, filter, and transform values while supporting structural analysis through union and difference folds. It enables efficient traversal and iteration, making it ideal for managing hierarchical data like module dependencies or object namespaces. Submodule 1 extends this with monadic versions of `fold`, `mapi`, and related combinators, allowing effectful traversals that accumulate state or handle errors across label-keyed maps. Submodule 2 optimizes `map` and `mapi` for performance, preserving structural sharing during transformations, which is especially useful when applying updates across symbol tables or semantic label mappings.",
      "description_length": 729,
      "index": 792,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.GlobRef.CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines comparison, equality, and hashing operations for a canonical name type derived from `Names.GlobRef.t`. It supports efficient ordering and identity checks on global reference names within the kernel. Concrete use cases include managing and comparing globally unique identifiers during type checking and proof processing.",
      "description_length": 339,
      "index": 793,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Mindmap.Monad",
      "library": "rocq-runtime.kernel",
      "description": "This module implements monadic fold and map operations over a map structure with keys from `Names.Mindmap.key`. It supports transforming and accumulating values within a monadic context, enabling effectful iterations such as error handling or state manipulation. Useful for traversing and modifying maps where each operation may fail or produce side effects, like validating or renaming entries during a compilation pass.",
      "description_length": 421,
      "index": 794,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Id.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module manages finite maps keyed by normalized Unicode identifiers, enabling ordered traversal, structural comparison, and bulk transformations over arbitrary value types. It supports operations like filtered iteration, stateful folding with value mapping, and symmetric difference detection, directly addressing tasks such as module path resolution and semantic label association. The first child module extends these maps with monadic traversal and transformation capabilities, allowing effectful computations like stateful iteration and monadic mapping, which are essential for handling named objects with side effects. The second child module optimizes `map` and `mapi` to preserve sharing during transformations, improving performance in memory-sensitive contexts like compiler symbol tables and environment tracking.",
      "description_length": 827,
      "index": 795,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.ModIdmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations for ModIdmap structures, preserving sharing during transformations. It works with ModIdmap.t, a map indexed by module identifiers, and supports functions that apply transformations to values or key-value pairs. Concrete use cases include efficiently updating module identifier-indexed data structures during compilation or name resolution passes.",
      "description_length": 396,
      "index": 796,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Mindmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations that preserve structural sharing for efficient updates of map values. It works with the `Names.Mindmap.t` associative data structure, which is based on balanced trees and used for managing named entities in the Rocq kernel. Concrete use cases include updating identifier mappings during type checking and transforming module path environments while maintaining performance and memory efficiency.",
      "description_length": 445,
      "index": 797,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.MPmap.Smart",
      "library": "rocq-runtime.kernel",
      "description": "This module provides optimized mapping operations over a structure that associates module paths to values. It supports transformations of values through functions applied to each binding, with `map` and `mapi` preserving structural sharing to improve efficiency. It is useful when updating or transforming environments or mappings that track named objects in the context of module paths.",
      "description_length": 387,
      "index": 798,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Univ.Universe.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module extends map manipulation with advanced transformations and typed, monadic operations. It offers optimized `map` and `mapi` functions that preserve structural sharing in large maps, improving efficiency when updating values. The typed key module enables monadic traversals like `fold` and `mapi` over heterogeneous maps, ensuring type-safe value handling during effects. Examples include efficiently updating subsets of a map while preserving identity, or folding over a map with IO-bound operations keyed by typed identifiers.",
      "description_length": 538,
      "index": 799,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Context.Compacted",
      "library": "rocq-runtime.kernel",
      "description": "This module combines operations for folding over and manipulating compacted local contexts with tools to transform and convert compacted declarations. It works with structured representations of typed variable declarations, supporting operations like mapping over components, converting from named declarations, and translating into named contexts. Main data types include compacted declarations and local contexts, with functions to traverse, restructure, and process them during type checking or proof construction. Examples include transforming assumptions into definitions or extracting variable names and types from a compacted context.",
      "description_length": 641,
      "index": 800,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Construct",
      "library": "rocq-runtime.kernel",
      "description": "This module manages the construction and manipulation of named objects, focusing on identifiers, module paths, and kernel names. It provides core operations to extract module paths from names and enforce canonical ordering through integrated submodules that handle comparison, equality, and hashing for both user and kernel-defined names. These capabilities support structured name comparisons, unique identifier management, and efficient name-based data structures used in type-checking and compilation. Specific uses include normalizing syntactic terms, caching named objects, and maintaining consistent name equivalence across the kernel.",
      "description_length": 641,
      "index": 801,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sorts.QUConstraints",
      "library": "rocq-runtime.kernel",
      "description": "This module manages combined universe and quasi-universe constraints using a pair of constraint sets. It provides operations to compute the union of two constraint sets and to obtain an empty set. It is used to track and merge constraints during type inference and checking in the presence of universe polymorphism.",
      "description_length": 315,
      "index": 802,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Univ.Level",
      "library": "rocq-runtime.kernel",
      "description": "This module manages universe levels essential for type hierarchy representation, offering creation, comparison, equality, and hashing operations over the abstract type `t`, along with global universe names via `Univ.UGlobal.t`. It supports detailed manipulation of universe level sets with membership checks, union, intersection, and difference operations, enabling precise tracking and validation of type universes in Coq's kernel. Child modules extend this functionality by providing polymorphic maps for associating values with levels, supporting transformations, filtering, and monadic traversals, while also offering optimized set operations crucial for managing constraints and ensuring level consistency in type inference and proof checking. Specific use cases include resolving polymorphic constraints, analyzing type hierarchies, and reducing memory overhead in performance-critical components like type checkers and proof assistant backends.",
      "description_length": 951,
      "index": 803,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.PRpred",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a set-like structure for predicates over projection representations, ignoring unfolding state. It provides standard set operations such as union, intersection, difference, and complement, along with membership testing, element insertion, and removal. The module is used to track and manipulate sets of projection representations in a way that supports both finite and potentially infinite sets, with efficient handling of full and empty sets.",
      "description_length": 465,
      "index": 804,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.GlobRef",
      "library": "rocq-runtime.kernel",
      "description": "This module represents and manipulates global references in the proof assistant, handling variables, constants, inductive types, and constructors. It provides core operations for equality checking, canonicalization, and binding detection, along with efficient sets and maps for structured key domains, enabling environment tracking and identifier resolution. Submodules refine these capabilities with specialized set and map operations, comparison logic, and hash-consed name handling, supporting tasks like dependency tracking, scope resolution, and symbolic transformation. Examples include merging environments during type checking, filtering named objects under scoping constraints, and performing efficient updates on large reference maps during substitution passes.",
      "description_length": 771,
      "index": 805,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UVars.UContext",
      "library": "rocq-runtime.kernel",
      "description": "This module manages universe contexts, which consist of named universe levels and associated constraints. It supports operations like creating, merging, and refining contexts, as well as extracting instance data and constraint sets. Use cases include handling universe polymorphism in type theory implementations and managing universe dependencies during proof checking.",
      "description_length": 370,
      "index": 806,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.KNset",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a functional set data structure for managing collections of kernel names (`KerName.t`), supporting standard operations like membership testing, union, intersection, difference, filtering, and comparison. It includes utilities for inspecting set contents through cardinality queries, element enumeration, and arbitrary element selection, all without modifying the underlying set. Designed for efficient handling of named objects in the Rocq system, it facilitates tasks such as dependency tracking, name resolution, and set-based analyses over hierarchical identifiers.",
      "description_length": 589,
      "index": 807,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Environ.QConstruct",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for comparing, hashing, and normalizing qualified constructions within an environment. It works with the `t` type, representing qualified constructions, and uses the environment to contextualize comparisons and normalization. Concrete use cases include ensuring consistent representation of constructions during type checking and supporting efficient equality checks in proof automation.",
      "description_length": 419,
      "index": 808,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Primred.RedNative",
      "library": "rocq-runtime.kernel",
      "description": "This module evaluates native primitive operations during reduction, handling environment and universe instance interactions. It works with types representing environments, primitive operations, and reduction arguments. A concrete use case is reducing constant applications in the kernel's type-checking process.",
      "description_length": 311,
      "index": 809,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.UGlobal",
      "library": "rocq-runtime.kernel",
      "description": "This module represents and manipulates qualified global universe levels using a concrete type `t`. It provides operations to construct, deconstruct, compare, and hash universe identifiers based on directory paths, names, and indices. Concrete use cases include managing universe variables in a type checker or handling global universe constraints in formal verification systems.",
      "description_length": 378,
      "index": 810,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cpred",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a set-like structure for handling predicates over elements of type `Names.Constant.t`, supporting standard set operations such as union, intersection, difference, and complement. It works with finite or potentially infinite sets, using a symbolic representation to handle cases where enumeration is not feasible. Concrete use cases include tracking sets of constants in the Rocq kernel for purposes like dependency analysis or name resolution.",
      "description_length": 466,
      "index": 811,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Projection",
      "library": "rocq-runtime.kernel",
      "description": "This module enables the construction, comparison, and manipulation of projection values that represent accessors for inductive types and constants, encapsulating components like labels and argument indices. It supports operations for building and analyzing projections, extracting metadata such as inductive types and argument positions, and controlling unfolding behavior during reductions. Submodules provide comparison, equality, and hashing functions for projection values, enabling their use in maps, sets, and other structures that require identity checks and ordering. Specific uses include tracking record field access, resolving projection paths during evaluation, and managing structured names for kernel objects.",
      "description_length": 723,
      "index": 812,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Constrset",
      "library": "rocq-runtime.kernel",
      "description": "This module implements standard set operations\u2014union, intersection, difference, membership testing, and extremal element access\u2014over immutable sets of constructor elements from the `Names` module. It combines these with utilities for cardinality tracking and sequence conversion, enabling efficient management of dependencies or constraints in kernel-level logic. A key use case involves aggregating free variables from multiple terms, such as merging sets of identifiers or labels during type checking. Submodules extend this functionality to batch operations like combining lists of sets into a single unified set.",
      "description_length": 616,
      "index": 813,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Environ.QNameS",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for comparing, hashing, and normalizing qualified names within an environment context. It works with the abstract type `t` representing qualified names and uses an environment to determine equality, ordering, and canonical forms. Concrete use cases include ensuring consistent representation of identifiers across different contexts and supporting efficient lookups and comparisons in larger symbolic processing tasks.",
      "description_length": 450,
      "index": 814,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Environ.QConstant",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations to compare, hash, and normalize qualified constant identifiers within an environment context. It works with `Environ.env` and `Environ.QConstant.t`, which represent environments and qualified constants, respectively. Concrete use cases include ensuring consistent representation of constants during compilation or comparison tasks in the type-checking pipeline.",
      "description_length": 393,
      "index": 815,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Indmap_env",
      "library": "rocq-runtime.kernel",
      "description": "This module manages environments as persistent, ordered maps keyed by inductive identifiers, supporting standard operations like insertion, lookup, and iteration, along with advanced transformations such as merging, splitting, and ordered traversal. Its core type `t` represents environments mapping identifiers to arbitrary values, enabling precise tracking and resolution of named objects, module hierarchies, or type-safe associations in kernel or compiler contexts. The module supports efficient, structurally shared updates and transformations, allowing operations like substituting values under specific keys during compilation or type-checking. Additionally, it enables monadic traversal and effectful processing of environments, facilitating state propagation or side-effect handling during map transformations.",
      "description_length": 819,
      "index": 816,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Environ.QInd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines operations for comparing, hashing, and normalizing inductive type identifiers within an environment. It works with the `t` type, representing inductive types via de Bruijn indices, and uses the environment to contextualize comparisons and normalization. Concrete use cases include ensuring consistent representation of inductive types during type checking and supporting efficient lookups in compilation pipelines.",
      "description_length": 434,
      "index": 817,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Indmap",
      "library": "rocq-runtime.kernel",
      "description": "This module manages key-value associations derived from inductive types, supporting insertion, deletion, ordered traversal, and symmetric difference folding over `t` structures that map keys to arbitrary values. It enables efficient filtering, domain transformations, and bidirectional stateful mappings, particularly in kernel-level logic for hierarchical definitions and dependency tracking. The first child module adds monadic traversal and transformation capabilities, allowing effectful computations like state propagation and error handling over maps indexed by identifiers, useful in compilation and module path validation. The second child module optimizes mapping operations for integer-indexed maps, enabling efficient, structure-preserving updates on large, persistent data.",
      "description_length": 785,
      "index": 818,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.DirPath",
      "library": "rocq-runtime.kernel",
      "description": "This module represents directory paths as sequences of module identifiers, providing operations to construct, compare, and hash these paths. It supports creating paths from reversed lists of module identifiers and converting them to string representations. Use cases include managing hierarchical module structures and ensuring canonical forms for efficient comparison in environments like Safe_typing.",
      "description_length": 402,
      "index": 819,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.MPmap",
      "library": "rocq-runtime.kernel",
      "description": "This module manages finite mappings from module paths to values, supporting standard operations like insertion, deletion, and lookup, along with advanced transformations such as merging, splitting, and symmetric difference. It enables ordered traversal with monadic accumulation and set-theoretic queries over domains, facilitating structured namespace manipulation in compiler symbol tables. The module supports efficient value transformations with `map` and `mapi`, preserving structural sharing, and allows effectful traversals with `fold`, `fold_left`, and `fold_right` for stateful or error-aware processing. Examples include updating module path-indexed environments, computing dependencies, or validating hierarchical symbol structures.",
      "description_length": 743,
      "index": 820,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.ModPath",
      "library": "rocq-runtime.kernel",
      "description": "This module defines operations for constructing and manipulating module paths, which represent the hierarchical structure of modules in the system. It supports path resolution through constructors like `MPdot` and provides comparison, hashing, and string conversion functions. Concrete use cases include tracking module hierarchies during compilation and generating human-readable representations for debugging and error reporting.",
      "description_length": 431,
      "index": 821,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Environ.Globals",
      "library": "rocq-runtime.kernel",
      "description": "This module directly provides operations to inspect and manipulate global contexts in an environment, specifically extracting constants, inductives, modules, and module types. It works with the `t` type representing environments and a `view` type that exposes structured access to global definitions. Concrete use cases include querying global constants and inductive types during type-checking or extracting module and module type declarations for compilation or inspection tasks.",
      "description_length": 481,
      "index": 822,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cmap_env",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a polymorphic map keyed by constants, ordered by their user-facing representation, supporting associative operations like insertion, lookup, and transformation, along with domain-specific utilities for filtering and structural comparison. It provides optimized operations for mapping functions over constant-indexed environments while preserving structural sharing, and extends to monadic variants of fold and map operations, enabling effectful computations during traversal. The main data types include `t` for the map structure and functions for key-based manipulation, with operations that support both pure and monadic transformations. Example uses include tracking definitions or metadata in symbolic systems, efficiently transforming environments during compilation, or analyzing constant-bound data through effectful iterations.",
      "description_length": 858,
      "index": 823,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Ind",
      "library": "rocq-runtime.kernel",
      "description": "This module represents inductive type identifiers as pairs of mutual inductive types and indices, enabling unique identification and canonical normalization of inductive definitions. It provides operations to extract module paths, compare names under different orderings, and produce canonical forms, which support type checking and proof management. Submodules define comparison, equality, and hashing for `Names.Ind.t` values in the contexts of syntactic names, user names, and canonical names, enabling efficient key-based lookups, ordered traversals, and referential consistency checks. These capabilities allow tasks such as sorting name-based structures, managing inductive definitions in maps or sets, and ensuring consistent name resolution during compilation and type checking.",
      "description_length": 786,
      "index": 824,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.QConstraint",
      "library": "rocq-runtime.kernel",
      "description": "This module represents and manipulates quality constraints, which are inequalities or equalities between quality values. It provides comparison, equality checking, pretty-printing, and detection of trivial constraints. These constraints are used to express relationships between quality variables in a constraint-solving context.",
      "description_length": 329,
      "index": 825,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UVars.Instance",
      "library": "rocq-runtime.kernel",
      "description": "This module represents and manipulates universe variable instances, handling operations like creation from arrays, concatenation, equality checks, and hash-consing. It works with pairs of arrays containing `Sorts.Quality.t` and `Univ.Level.t`, tracking lengths, sets of levels, and supporting substitution and pattern matching. It is used in the context of universe polymorphism, particularly during type checking and rewriting where instance manipulation and matching are required.",
      "description_length": 482,
      "index": 826,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Indset",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a functional API for managing immutable sets of inductive identifiers, supporting standard set operations such as union, intersection, difference, and membership testing. It enables efficient construction from and conversion to sequences, tracks cardinality, and retrieves extremal values, making it suitable for managing unique inductive definitions in type systems. A child module specializes in combining identifier sets, offering a union function to merge multiple `Names.Indset.t` values, which is useful for aggregating disjoint name collections during type checking. Together, these components facilitate hierarchical name resolution and set manipulation in compilation or semantic analysis tasks.",
      "description_length": 725,
      "index": 827,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Esubst.Internal",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a single key operation, `repr`, which converts a substitution into a high-level representation consisting of a list of value-to-index associations and a relocation shift. It operates directly on substitution data structures, producing a format that simplifies debugging by exposing the internal mapping and shift values. This is particularly useful when inspecting substitutions during evaluation or compilation stages involving variable binding and renaming.",
      "description_length": 480,
      "index": 828,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.Constraints",
      "library": "rocq-runtime.kernel",
      "description": "This module extends the underlying Set library to manage collections of constraint sets, offering operations to compute unions and intersections across lists of constraints. It introduces functions for aggregating and combining `Univ.Constraints.t` values, enabling analysis of constraint relationships from multiple sources. With both direct operations on constraint sets and utilities for batch processing through its submodules, it supports tasks like merging type inference constraints or resolving configuration dependencies. Examples include consolidating constraints from different code paths or determining common constraints across multiple configurations.",
      "description_length": 665,
      "index": 829,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Indset_env",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a set-like structure for managing collections of inductive identifiers, offering standard operations such as membership testing, union, intersection, and difference, along with transformations like `fold`, `filter`, and `partition`. It supports efficient queries for extremal elements and arbitrary members, and includes utilities for converting sequences to sets. A child module extends this functionality by providing a function to compute the union of multiple sets from a list, enabling aggregation of identifier collections across program analysis branches or input sources. Together, these components facilitate dependency tracking, name resolution, and identifier relationship analysis in compiler or kernel contexts.",
      "description_length": 747,
      "index": 830,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Mindmap",
      "library": "rocq-runtime.kernel",
      "description": "This module extends the core map functionality with monadic traversals and structure-preserving transformations over key-value associations. It supports effectful operations like validation and renaming through monadic folds, while optimized mapping maintains efficiency during large-scale updates to named entities. Key data types include `Names.Mindmap.key` for identifiers and `Names.Mindmap.t` for the balanced tree-based map structure. Examples include safely transforming module paths during compilation or updating type-checked identifier mappings with minimal memory overhead.",
      "description_length": 584,
      "index": 831,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Name",
      "library": "rocq-runtime.kernel",
      "description": "This module represents identifiers that may be anonymous, providing constructors, predicates, and comparisons for handling optional naming. It works with the `t` type, which is a variant of `Anonymous` or `Name of Id.t`, alongside standard operations like `compare`, `equal`, and `hash`. Concrete use cases include managing optional names in the kernel's object representation and supporting pretty-printing of identifiers where anonymity is semantically significant.",
      "description_length": 467,
      "index": 832,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constrmap_env",
      "library": "rocq-runtime.kernel",
      "description": "This module manages constructor-keyed maps with support for functional transformations like folding, filtering, and merging, operating over `Constrmap_env.t` structures indexed by `Names.constructor`. It includes submodules for monadic traversal and stateful manipulation of these maps, enabling operations such as effectful folds and transformations that preserve structural sharing for efficiency. Direct operations allow precise updates and queries on constructor-indexed data, while the monadic submodule supports side-effecting or stateful iterations over key-value pairs. Examples include managing type definitions, tracking identifier mappings during type checking, or handling kernel-level name resolution with efficient, structured updates.",
      "description_length": 749,
      "index": 833,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.KNmap",
      "library": "rocq-runtime.kernel",
      "description": "This module implements associative maps keyed by absolute Rocq object names (`KerName.t`), supporting insertion, deletion, domain manipulation, and structural comparison. It enables polymorphic value handling through `'a`-typed entries, allowing efficient lookups, transformations, and set-theoretic combinations for managing symbol tables or metadata registries. The first child module adds monadic fold and map operations, enabling effectful traversals that accumulate state or handle errors, while the second optimizes mapping to preserve sharing, improving performance when transforming large maps with shared components. Example uses include building and transforming persistent environments or analyzing structured collections of named entities.",
      "description_length": 751,
      "index": 834,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.KerName",
      "library": "rocq-runtime.kernel",
      "description": "This module represents absolute names of objects in Rocq using a combination of module paths and labels. It provides operations to construct, deconstruct, and project these names, along with comparison, equality checks, and hashing. Use cases include uniquely identifying kernel objects and managing their symbolic references during compilation and introspection.",
      "description_length": 363,
      "index": 835,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.KNpred",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a set-like structure for representing predicates over `KerName.t` values, supporting standard set operations such as union, intersection, difference, and complement. It works directly with `KerName.t` elements and provides functions to test membership, check emptiness, and determine finiteness of the set representation. Concrete use cases include tracking named objects in the Rocq kernel, such as managing visibility or inclusion of definitions during type checking or proof processing.",
      "description_length": 512,
      "index": 836,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IndTyping.NotPrimRecordReason",
      "library": "rocq-runtime.kernel",
      "description": "This module defines a variant type `t` representing reasons why a record type cannot be primitive. It includes four specific cases: `MustNotBeSquashed`, `MustHaveRelevantProj`, `MustHaveProj`, and `MustNotHaveAnonProj`. These variants are used to classify constraints on record types during type checking, particularly in scenarios involving projections and squashing in a dependently typed system.",
      "description_length": 398,
      "index": 837,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Univ.Universe",
      "library": "rocq-runtime.kernel",
      "description": "This module manages universe values and their algebraic structures in type theory, offering operations like level normalization with `hcons`, suprema computation, and membership testing. It integrates set and map functionalities to handle collections of levels and level-indexed data, supporting efficient union, intersection, and traversal over unique elements, as well as typed, monadic transformations on large or heterogeneous maps. You can normalize universe representations during type checking, compute the union of multiple level sets, or update map values while preserving structural identity. Advanced use cases include merging disjoint type hierarchies, comparing extremal levels across sets, and performing effectful, type-safe traversals over keyed data structures.",
      "description_length": 778,
      "index": 838,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constr.UnsafeMonomorphic",
      "library": "rocq-runtime.kernel",
      "description": "This module provides low-level, unsafe functions for constructing and manipulating monomorphic kernel terms. It works directly with inductive types, constants, and constructors, enabling direct term assembly without type checking. Concrete use cases include building custom terms during proof automation or optimizing term generation in certified code.",
      "description_length": 352,
      "index": 839,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.DPset",
      "library": "rocq-runtime.kernel",
      "description": "This module implements an immutable set structure for managing collections of hierarchical directory paths (`DirPath.t`), enabling operations like membership testing, union, intersection, difference, and ordered traversal. It supports efficient set manipulation and conversion from sequences, with utilities for cardinality checks and filtering based on path properties. Submodules extend these capabilities to handle unions of multiple sets and provide optimized querying for sequences of identifiers. Example uses include organizing module paths, tracking dependencies between named objects, and merging file path sets in the Rocq kernel.",
      "description_length": 640,
      "index": 840,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.PRset",
      "library": "rocq-runtime.kernel",
      "description": "This module provides a set data structure for managing collections of projection representations (`Projection.Repr.t`), supporting standard operations like membership testing, union, intersection, difference, and filtering. It includes inspection functions to retrieve cardinality, list elements, or select arbitrary members, enabling efficient analysis and transformation of identifier-based data. These capabilities are particularly useful in scenarios involving hierarchical name resolution, module path manipulation, or tracking named entities within the system's core infrastructure.",
      "description_length": 588,
      "index": 841,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Evar.Set",
      "library": "rocq-runtime.kernel",
      "description": "This module offers a suite of operations for managing ordered collections of existential variables, including set-theoretic operations (union, intersection, difference), element-wise transformations (map, filter), and ordered traversal utilities. It operates on sets structured as ordered elements, supporting conversions to and from lists and sequences, while enabling efficient membership checks, subset comparisons, and predicate-driven manipulations. These capabilities are particularly useful for tasks requiring ordered processing of variables, such as dependency resolution or incremental set construction from sequential data.",
      "description_length": 634,
      "index": 842,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Id",
      "library": "rocq-runtime.kernel",
      "description": "This module manages identifiers with strict validity checks, supporting creation from strings or bytes, equality, comparison, hashing, and pretty-printing, along with hashconsing for memory efficiency. It enables working with individual identifiers and structured collections through submodules that support lists, finite sets, membership structures, and ordered maps keyed by identifiers. These submodules allow tasks like managing symbol tables, tracking used names, merging identifier sets, and mapping identifiers to arbitrary values with effectful or optimized transformations. Examples include validating unique names in compilers, aggregating identifier contexts, and resolving module paths with normalized identifiers.",
      "description_length": 726,
      "index": 843,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MBImap",
      "library": "rocq-runtime.kernel",
      "description": "This module implements persistent associative maps for identifier-keyed data, supporting efficient insertion, deletion, lookup, and ordered traversal over immutable structures. It provides advanced operations like symmetric difference folds, monadic transformations through the `Monad` submodule, and structural sharing-preserving updates for environments such as module hierarchies or local contexts. The core type `t` holds values of arbitrary type indexed by `Names.MBId.t`, enabling key-based manipulations critical for symbol resolution and path management in the kernel. Submodules enhance functionality with monadic folds and optimized structural transformations, allowing efficient evolution of large-scale mappings without full duplication.",
      "description_length": 749,
      "index": 844,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UVars.Variance",
      "library": "rocq-runtime.kernel",
      "description": "This module defines a type `t` representing variance kinds (`Irrelevant`, `Covariant`, `Invariant`) and provides operations to check subtyping relationships, compute suprema, and compare variances. It supports use cases like enforcing correct variance subtyping in type systems or managing variance annotations in generic type parameters. Functions include `check_subtype` to validate variance compatibility, `sup` to find the least upper bound, and `equal` for direct comparison.",
      "description_length": 480,
      "index": 845,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.Quality",
      "library": "rocq-runtime.kernel",
      "description": "This module represents and manipulates quality sorts in a type system, supporting variables and constants like `QProp`, `QSProp`, and `QType`. It provides core operations for substitution, comparison, hashing, and pretty-printing, along with pattern matching over quality terms, enabling tasks such as managing sort variables during type inference and enforcing sort constraints in logical expressions. The accompanying set module supports functional manipulation of immutable collections of quality elements with set algebra, membership checks, and extremum queries, useful for data analysis and deduplication. A map module builds on these capabilities, offering ordered key-value storage with quality-sorted keys and polymorphic values, supporting efficient updates, ordered traversal, and monadic transformations for scenarios like aggregating and refining large datasets.",
      "description_length": 875,
      "index": 846,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.DPmap",
      "library": "rocq-runtime.kernel",
      "description": "This module organizes hierarchical mappings keyed by directed paths of identifiers, supporting efficient structural sharing and transformations over nested data. It provides core operations like `mapi`, `fold`, and monadic traversal combinators for effectful processing of path-indexed values. Submodules extend this with optimized updates and monad-based iterations, enabling tasks like stateful rewriting or error-propagating traversals over directory-like structures. Example uses include incremental updates to deeply nested maps and compiling path-scoped name resolutions with shared subtrees.",
      "description_length": 598,
      "index": 847,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Names.Cset_env",
      "library": "rocq-runtime.kernel",
      "description": "This module supports union, intersection, difference, filtering, and iteration over elements of type `Names.Constant.t`, organized into a persistent set structure represented by type `t`. It includes inspection operations like cardinality, element listing, and arbitrary element selection, ensuring efficient handling of unique constants. Such functionality is useful for managing identifier collections, module path dependencies, or kernel-level object tracking where set semantics and immutability are required.",
      "description_length": 513,
      "index": 848,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rtree.Kind",
      "library": "rocq-runtime.kernel",
      "description": "This module defines and manipulates kinds of R-trees, providing functions to construct, inspect, and retrieve the underlying tree representation. It works with abstract types `'a Rtree.Kind.t` and concrete representations `'a Rtree.Kind.rtree`. Use this module to manage different configurations or variants of R-trees, such as varying balancing strategies or node structures, while maintaining type safety.",
      "description_length": 407,
      "index": 849,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UVars.AbstractContext",
      "library": "rocq-runtime.kernel",
      "description": "This module manages abstract contexts of universe variables with associated constraints, supporting operations to build, combine, and query contexts. It works with universe variables and constraints, tracking bound names and enabling instantiation of constraints with specific universe instances. Concrete use cases include handling universe-level polymorphism and managing constraints during type checking in a proof assistant or compiler.",
      "description_length": 440,
      "index": 850,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Names.Constant",
      "library": "rocq-runtime.kernel",
      "description": "This module handles the representation and manipulation of constant names using identifiers, module paths, and labels, offering operations to construct, compare, and hash these names. It supports syntactic and semantic identity checks, ordering, and debugging through its submodules, all centered around the `Names.Constant.t` type. Use cases include managing global definitions, sorting named entities, and tracking constants during kernel processing. The module enables precise name-based operations in both low-level and user-facing contexts.",
      "description_length": 545,
      "index": 851,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Cset",
      "library": "rocq-runtime.kernel",
      "description": "This module provides set operations for managing collections of constants, including membership checks, union, intersection, and iterative transformations. It works with sets of `Names.Constant.t` elements, supporting size queries, element retrieval as lists, and selection of arbitrary members. These capabilities are useful for tracking dependencies, filtering constants during compilation, and comparing constant sets in semantic analysis tasks.",
      "description_length": 448,
      "index": 852,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evar.Map",
      "library": "rocq-runtime.kernel",
      "description": "This module manages associations between existential variables and arbitrary values using purely functional operations, supporting insertion, deletion, traversal, and advanced combinators like merging and symmetric difference. It includes a monadic submodule for processing maps within computational contexts, enabling operations such as `fold` and `mapi` that carry effects through transformations, ideal for environments in type inference. An optimized submodule enhances performance by preserving structural sharing during value transformations, crucial for efficient updates in symbolic computation. Together, these components allow precise, type-safe manipulation of variable mappings in systems like proof assistants and constraint solvers.",
      "description_length": 746,
      "index": 853,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Environ.QGlobRef",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for comparing, hashing, and normalizing globally referenced identifiers within an environment context. It works with `Environ.env` and `Names.GlobRef.t` types, enabling precise identity checks and ordering of global references. Concrete use cases include managing and comparing global constants, axioms, and inductive definitions during type-checking or proof construction.",
      "description_length": 405,
      "index": 854,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Context.Rel",
      "library": "rocq-runtime.kernel",
      "description": "This module manages relational contexts built from ordered lists of declarations, using de Bruijn indices to represent both anonymous and named variables. It supports core operations such as binder-aware mapping, extracting variables, dropping definitions, and converting contexts into arrays or lists for type checking and term evaluation. The child module enables fine-grained inspection and transformation of individual declarations, allowing retrieval and modification of names, types, and values, as well as converting definitions into assumptions. Together, they support tasks like term traversal, context restructuring, and instantiation list generation in a type-safe manner.",
      "description_length": 683,
      "index": 855,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Primred.RedNativeEntries",
      "library": "rocq-runtime.kernel",
      "description": "This module provides low-level construction and deconstruction operations for primitive values and structured data representations in a virtual machine context. It works with abstract `elem` values representing evaluated terms, manipulating them through environment-based creation of integers, floats, strings, arrays, and tagged states (like NaN or ordering), alongside comparison and composition operations for intermediate representation nodes. These capabilities are specifically used in compiler pipelines or formal verification systems to model low-level data transformations and semantic evaluations.",
      "description_length": 607,
      "index": 856,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts.QVar",
      "library": "rocq-runtime.kernel",
      "description": "This module represents qualified variables with support for indexing, unification keys, and efficient equality, comparison, and hashing through a concrete algebraic data type `repr` that distinguishes variables from unification placeholders. It enables precise manipulation and debugging in tasks like type inference and term rewriting, while its child modules provide associative maps and functional sets for structured and persistent variable-centric computations. The map module supports polymorphic value mapping, structural sharing, and effectful traversals, ideal for environment management and symbolic computation, and the set module enables ordered, non-destructive set operations useful for incremental updates and data analysis workflows. Together, they form a cohesive system for managing variable identity and relationships in logic engines, compilers, and formal reasoning tools.",
      "description_length": 893,
      "index": 857,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Environ.QProjection",
      "library": "rocq-runtime.kernel",
      "description": "This module handles comparison, hashing, and normalization of projections qualified by environments, operating on `Environ.QProjection.t` to support type checking and proof construction. Its core functions process global constants and inductive fields, determining equivalence and canonical forms within a context. The Repr submodule extends this by working with de Bruijn-indexed projection representations, optimizing structural comparisons and enabling efficient proof search operations. Together, they enable precise manipulation of projections at both abstract and concrete levels.",
      "description_length": 586,
      "index": 858,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.Label",
      "library": "rocq-runtime.kernel",
      "description": "This module manages string-based identifiers called labels, offering core operations to create, compare, and convert them, ensuring clear semantic distinctions between identifiers and enabling efficient lookups via hashed sets and maps. Its first child module provides standard set operations for immutable collections of labels, including union, intersection, and difference, with a helper submodule to merge multiple label sets, supporting hierarchical naming and module path analysis. The second child module organizes key-value data using labels as keys, offering binding, filtering, and transformation operations, with submodules adding monadic folds for effectful traversals and optimized map functions that preserve structural sharing. Together, these components enable precise manipulation and analysis of label-based data across complex, hierarchical systems.",
      "description_length": 868,
      "index": 859,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Cmap",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a polymorphic map structure keyed by canonicalized constants, supporting efficient insertion, lookup, union, intersection, and transformation operations. It works with `Constant.t` keys ordered by their canonical form and values of arbitrary types, offering filtering, domain manipulation, and structural comparison, particularly suited for performance-sensitive tasks like kernel symbol resolution. The first child module enhances key comparison and sharing preservation during transformations, enabling efficient handling of constant-based mappings in contexts such as definition tracking or evaluation path optimization. The second child module introduces monadic fold and map operations, allowing effectful traversals and value transformations over constant-keyed maps.",
      "description_length": 796,
      "index": 860,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constr.GenHCons",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a heterogeneous cons operation, combining values of type `C.t` into a structured term representation. It provides the `hcons` function to build and normalize terms within a specific kernel context. Use cases include constructing and manipulating abstract syntax trees with mixed-type components in a type-safe manner.",
      "description_length": 340,
      "index": 861,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.QNameS",
      "library": "rocq-runtime.kernel",
      "description": "This module represents qualified names with operations to manipulate and compare them canonically, syntactically, or from a user perspective. It defines a core type `t` for qualified names and three submodules that provide distinct ordering relations. The module supports concrete use cases such as name resolution, path comparison, and canonicalization in the context of module and object references.",
      "description_length": 401,
      "index": 862,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constrmap",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a map structure keyed by constructor identifiers, supporting standard associative operations like insertion, deletion, and lookup, along with higher-order transformations such as folding, filtering, and merging. It enables monadic traversal and transformation of map contents, allowing effects like error handling or state management during iteration, and also provides optimized operations for mappings involving identifier types from the `Names` module. Direct operations include `add`, `find`, and `remove`, while submodules support `mapi`, `fold_left`, and specialized name-based transformations, enabling efficient symbol table management and compiler pipeline stages. Examples include tracking named variables in a type checker or transforming abstract syntax trees with monadic effects.",
      "description_length": 816,
      "index": 863,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MBId",
      "library": "rocq-runtime.kernel",
      "description": "This module implements unique bound names with support for equality, comparison, and hashing. It works with identifiers and directory paths to ensure name uniqueness across different files. Used to manage internal names in a way that avoids conflicts during compilation and debugging.",
      "description_length": 284,
      "index": 864,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Constrset_env",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a persistent set interface for managing constructor elements with efficient membership checks and transformations. It supports core operations like union, intersection, difference, and predicate-based modifications, operating on immutable sets derived from ordered elements. The module enables bulk conversions between sequences and sets, and its child module specializes in combining lists of sets containing identifiers and names, such as merging constructor environments during type checking or compilation. Specific use cases include tracking constructor definitions and resolving name collisions across multiple scopes.",
      "description_length": 647,
      "index": 865,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MutInd",
      "library": "rocq-runtime.kernel",
      "description": "This module manages mutual inductive names by combining direct operations with specialized submodules to support construction, decomposition, and comparison of inductive identifiers. It provides core data types like `KerName.t`, `ModPath.t`, and `Label.t` for building and accessing components of `MutInd.t` values, along with functions for converting, comparing, and hashing these names. The submodules refine these capabilities by enabling syntactic equality checks, canonical name comparisons, and user-level name handling, which are essential for maintaining inductive definitions in maps, sets, and hash tables during type checking. Examples include resolving name collisions, indexing inductive types in the kernel, and preserving user-provided naming structure across compilation stages.",
      "description_length": 794,
      "index": 866,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.QNameS-CanOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides comparison, equality, and hashing operations for canonical names. It works directly with the `t` type, which represents absolute names in a canonical form. These functions are used internally in the kernel to ensure consistent and efficient name handling during compilation and term manipulation.",
      "description_length": 317,
      "index": 867,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.QNameS-SyntacticOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module implements syntactic comparison and hashing operations for name-like data types, including identifiers, optional names, paths, and labels. It provides `compare`, `equal`, and `hash` functions that directly operate on the structural representation of names, ensuring consistent ordering and equality checks. These operations are used in contexts requiring precise lexical or syntactic identity, such as name resolution, path comparison, and module structure management.",
      "description_length": 480,
      "index": 868,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Mindset",
      "library": "rocq-runtime.kernel",
      "description": "This module provides set-theoretic operations and inspection utilities for finite collections of mutable inductive identifiers. It works with polymorphic set structures containing `Names.MutInd.t` elements, supporting membership tests, unions, intersections, and element traversal. These capabilities are particularly useful for managing dependencies or relationships between inductive types in type-checking or module resolution workflows.",
      "description_length": 440,
      "index": 869,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UGraph.Bound",
      "library": "rocq-runtime.kernel",
      "description": "This module defines a polymorphic bound type used to distinguish between proposition and set levels in inductive type templates. It supports operations that differentiate between `Prop` and `Set` during type inference and template instantiation. Concrete use cases include managing universe levels in Coq-like inductive definitions and ensuring correct type propagation during unification.",
      "description_length": 389,
      "index": 870,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.PRmap",
      "library": "rocq-runtime.kernel",
      "description": "This module provides polymorphic map structures keyed on projection representations, supporting associative lookups, transformations, and domain manipulations. It enables efficient filtering, merging, and structural comparisons on maps from `Projection.Repr.t` keys to arbitrary values, particularly useful for managing projection-specific metadata in type-checking or compilation pipelines. The `Optimized` submodule offers `map` and `mapi` variants that preserve structural sharing during traversal, ideal for minimizing memory use in large persistent maps during name resolution or environment updates. The `Monad` submodule adds monadic fold and map operations, allowing effectful computations like stateful transformations or error propagation using monads such as `Result` or `Option`.",
      "description_length": 791,
      "index": 871,
      "embedding_norm": 1.0
    },
    {
      "module_path": "HConstr.Tbl",
      "library": "rocq-runtime.kernel",
      "description": "Implements imperative hash tables keyed by `HConstr.t` values, supporting efficient insertion and lookup operations. Provides `add` to bind keys to values and `find_opt` to retrieve values without raising exceptions. Useful for managing dynamic mappings between proof terms and associated data in Coq's kernel.",
      "description_length": 310,
      "index": 872,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.ModIdset",
      "library": "rocq-runtime.kernel",
      "description": "This module implements functional set operations for managing collections of module identifiers, supporting common operations like union, intersection, difference, and membership checks. It works with sets of `Names.module_ident`, provides conversion to and from lists and sequences, and includes utilities for element selection, transformation, and predicate application. The child module extends this functionality by computing the union of multiple sets, merging them into a single set of unique elements, which is useful for aggregating module dependencies or import sets across files. Together, they enable precise manipulation and analysis of hierarchical module identifiers in Coq's formal verification workflows.",
      "description_length": 720,
      "index": 873,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ.ContextSet",
      "library": "rocq-runtime.kernel",
      "description": "This module manages sets of universe levels with associated constraints, supporting operations like union, difference, and adding universes or constraints. It works with universe levels (`Univ.Level.t`), constraint sets (`Univ.Constraints.t`), and universe level sets (`Univ.Level.Set.t`). It is used to track and manipulate universe contexts in type checking and inference, particularly in handling universe polymorphism and constraint solving.",
      "description_length": 445,
      "index": 874,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.QNameS-UserOrd",
      "library": "rocq-runtime.kernel",
      "description": "This module defines comparison, equality, and hashing operations for user-defined name types. It works with name structures like identifiers, optional names, paths, and labels. Concrete use cases include comparing and hashing module paths, kernel names, and directory paths for efficient data structure operations.",
      "description_length": 314,
      "index": 875,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vmbytecodes.Label",
      "library": "rocq-runtime.kernel",
      "description": "This module manages label identifiers for bytecode generation, providing functions to create unique labels and reset the label counter. It works with integer-based label values to track positions in generated code. Concrete use cases include assigning branch targets in virtual machine instructions and managing control flow during compilation.",
      "description_length": 344,
      "index": 876,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Genlambda.S",
      "library": "rocq-runtime.kernel",
      "description": "Implements operations for evaluating and inspecting inductive types within an intermediate language. Provides `as_value` to convert arrays of lambda expressions into an optional value, and `check_inductive` to validate inductive type definitions against their declarations. Used during compilation to ensure correctness of inductive constructs in both virtual machine and native code backends.",
      "description_length": 393,
      "index": 877,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rtree.Smart",
      "library": "rocq-runtime.kernel",
      "description": "Performs a conditional map over an R-tree, applying a function to each node only if it would change the node's value. Avoids unnecessary tree reconstruction when the function leaves nodes unchanged. Useful for optimizing transformations like coordinate adjustments in spatial indexing where many nodes may remain the same.",
      "description_length": 322,
      "index": 878,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Environ.QMutInd",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for comparing, hashing, and normalizing qualified mutual inductive type identifiers within an environment. It works with `Environ.QMutInd.t`, which represents references to mutual inductive definitions. Concrete use cases include ensuring consistent representation of inductive types during type checking and enabling efficient lookups and comparisons in the environment.",
      "description_length": 403,
      "index": 879,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Opaqueproof.HandleMap",
      "library": "rocq-runtime.kernel",
      "description": "This component provides map operations for associating metadata with lazily computed proof terms, enabling insertions, deletions, merges, and transformations while supporting custom comparison, equality checks, and folding over key-value pairs. It organizes data using maps where keys are opaque handles referencing proof terms, and values can be arbitrary data, with utilities for efficient lookups, splits, and retrieving extremal bindings. These features are particularly suited for caching intermediate results or managing dependencies in systems handling optionally loaded proof segments from storage.",
      "description_length": 606,
      "index": 880,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sorts.QConstraints",
      "library": "rocq-runtime.kernel",
      "description": "Enables managing collections of quantifier constraints through set operations (union, intersection, difference), ordered set manipulations (cardinality checks, min/max retrieval), and transformations like triviality checks and formatting with variable printers. Works with sets of `Sorts.QConstraint.t` values, ordered elements, and sequences, supporting efficient searching, traversal, and consistency enforcement. Useful in constraint systems where precise analysis and optimization of quantifier constraints are required.",
      "description_length": 524,
      "index": 881,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Names.MPset",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a functional set structure for `ModPath.t` elements, supporting standard operations like union, intersection, difference, membership testing, and predicate-based filtering. It provides utilities to query set properties such as cardinality and min/max elements, and to transform or convert sets to lists and sequences. The child module extends this with efficient union operations over lists of sets, enabling scalable management of module path collections during import resolution or dependency tracking. Together, they facilitate hierarchical module path manipulation in tasks like namespace organization and static analysis of module relationships.",
      "description_length": 673,
      "index": 882,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.ModIdmap",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a map structure keyed by module identifiers with associative operations for insertion, deletion, and merging, along with ordered key comparisons, filtering, and transformations. It supports precise traversal control, set conversions, and incremental updates via symmetric difference folding, enabling efficient manipulation of hierarchical data like module paths and dependency graphs. The first child module adds monadic traversal and transformation operations such as `fold`, `mapi`, and directional folds, allowing effectful computations over module identifier mappings during compilation or analysis. The second child module provides optimized, sharing-preserving mapping operations for transforming values or key-value pairs in ModIdmap structures, supporting efficient updates during compilation or name resolution passes.",
      "description_length": 851,
      "index": 883,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genlambda.Make",
      "library": "rocq-runtime.kernel",
      "description": "Converts Coq terms into an intermediate representation suitable for execution in a virtual machine or native compilation. It processes lambda expressions using environment and evar information, producing values compatible with a specified value type. This supports compilation of Coq definitions into executable code or interpretable structures.",
      "description_length": 345,
      "index": 884,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.MBIset",
      "library": "rocq-runtime.kernel",
      "description": "This module implements an immutable set structure for `MBId.t` elements using balanced trees, enabling efficient membership checks, unions, intersections, and ordered iterations. It supports conversions between sets and sequences, allowing bulk construction from lists and extraction of elements in sorted order. A typical use case involves managing unique module identifiers during dependency resolution, where operations like union or intersection help aggregate or compare component sets. The child module extends this functionality by providing a function to merge multiple sets, simplifying tasks such as combining identifier collections across different module groups.",
      "description_length": 674,
      "index": 885,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.Mindmap_env",
      "library": "rocq-runtime.kernel",
      "description": "This module provides associative map operations for environment-like manipulation of mutable inductive type identifiers, supporting key-based access, functional transformations, and structural comparisons over polymorphic maps. It includes submodules for monadic traversal and transformation of maps, set-theoretic operations over key domains, and optimized value-preserving map updates, enabling efficient management of hierarchical name environments. Main data types include polymorphic maps and key sets, with operations such as merge, filter, fold, union, and mapi. Examples include tracking dependencies during type-checking, managing definitions in a proof assistant's kernel, and performing stateful transformations over named objects.",
      "description_length": 742,
      "index": 886,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names.EqType",
      "library": "rocq-runtime.kernel",
      "description": "This module defines a type `t` equipped with operations for comparison, equality checking, and hashing. It works with values of type `t`, supporting concrete use cases such as efficient key-based lookups in hash tables or ordered data structures. The module ensures that values can be reliably compared and hashed, enabling their use in sets, maps, and memoization tables where identity and ordering matter.",
      "description_length": 407,
      "index": 887,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Context.Named",
      "library": "rocq-runtime.kernel",
      "description": "This module manages named local contexts composed of ordered declarations, either as assumptions or definitions, each bound to a unique identifier. It supports operations to construct, extend, and query contexts, including adding declarations, mapping over terms, comparing contexts, and extracting bound variables or instances. The child module provides operations to inspect, transform, and traverse these declarations, distinguishing between assumptions and definitions, and supports conversions between named and relational forms. Together, they enable building and manipulating typing environments for lambda calculus, handling variable bindings in theorem proving, and generating substitution instances for proof terms.",
      "description_length": 725,
      "index": 888,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Partial_subst",
      "library": "rocq-runtime.kernel",
      "description": "This module manages partial substitutions for terms, qualities, and universes using a tuple-based structure. It supports adding or conditionally inserting elements into substitution maps by integer keys and converting the results to arrays. It is used for constructing and manipulating incomplete substitution mappings during type checking or term processing.",
      "description_length": 359,
      "index": 889,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Esubst",
      "library": "rocq-runtime.kernel",
      "description": "This module manages explicit substitutions for variable bindings and environments in type theory systems, offering core operations like `subs_id`, `subs_cons`, `subs_shft`, and `subs_liftn` to construct and manipulate substitutions and lifts. It includes utilities such as `expand_rel` and `reloc_rel` for variable expansion and relocation, alongside identity checks like `is_subs_id`. The child module enhances introspection by converting substitutions into a readable list-based form via `repr`, aiding debugging in complex binding scenarios. Together, they support capture-avoiding substitution and environment transformations in higher-order or dependent type systems.",
      "description_length": 672,
      "index": 890,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vmemitcodes",
      "library": "rocq-runtime.kernel",
      "description": "This module handles code generation and patching for virtual machine instructions, managing relocations for constants, global references, and primitives. It works with bytecode structures and substitution environments to produce executable code bodies and track fixup information. Concrete use cases include compiling function bodies with proper constant and symbol references, and applying substitutions during module linking.",
      "description_length": 427,
      "index": 891,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genlambda",
      "library": "rocq-runtime.kernel",
      "description": "This module defines an intermediate language representation for compilation, centered around lambda terms with annotations, case expressions, and environment variables. It provides core operations for constructing and manipulating lambda expressions, tracking free variables, and handling inductive types through functions like lambda application, abstraction decomposition, and alias resolution. The inductive submodule validates and inspects inductive definitions, while the conversion submodule translates Coq terms into executable intermediate values. Examples include optimizing lambda expressions, checking inductive type correctness, and generating debug-printable intermediate forms.",
      "description_length": 691,
      "index": 892,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sorts",
      "library": "rocq-runtime.kernel",
      "description": "This module enforces relationships between sort families, substitutes sort variables, and generates partial substitutions through pattern matching, working with sorts, universes, and quality annotations. It coordinates constraint management across submodules that handle universe constraints, quality constraints, and quantifier constraints using set and map structures for efficient querying and transformation. You can unify sort variables, merge constraint sets, classify sort expressions, and analyze quantifier dependencies in type systems requiring precise sort manipulation. Functional collections and maps support persistent, ordered operations over quality and variable data, enabling scalable type inference and logical reasoning.",
      "description_length": 740,
      "index": 893,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mod_subst",
      "library": "rocq-runtime.kernel",
      "description": "This module provides mechanisms for managing substitutions and delta resolvers to handle module and kernel name resolution, supporting composition, emptiness checks, and domain transformations. It operates on module paths, kernel names, and Coq internal structures like inductives, constants, projections, and terms, with applications in Coq's module system for dynamic reference resolution during compilation and term manipulation.",
      "description_length": 432,
      "index": 894,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Univ",
      "library": "rocq-runtime.kernel",
      "description": "This module coordinates universe level management with constraint handling and set operations, enabling dynamic resolution of type hierarchies and constraint validation. It defines core types like `Level.t`, `Constraints.t`, and `Level.Set.t`, supporting level creation, comparison, constraint aggregation, and set manipulation with union, intersection, and difference. You can resolve polymorphic type constraints, merge universe contexts from different code paths, or normalize universe representations during type checking. Submodules enhance these capabilities with polymorphic maps, global universe handling, and optimized constraint set processing for use in type inference and formal verification systems.",
      "description_length": 712,
      "index": 895,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Section",
      "library": "rocq-runtime.kernel",
      "description": "This module manages nested sections with support for universe polymorphism, allowing sections to be opened with custom data and closed to retrieve defined entries, constraints, and custom information. It provides operations to extend sections with local/global definitions, universe contexts, and constraints, while tracking data like polymorphic universes and section depth. Concrete use cases include managing Coq's proof environments where local and global declarations are incrementally added within scoped, polymorphic sections.",
      "description_length": 533,
      "index": 896,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "UVars",
      "library": "rocq-runtime.kernel",
      "description": "This module coordinates universe-level polymorphism by enforcing equality and subtyping constraints, substituting levels within abstract contexts, and mapping over polymorphic universe data. It directly supports operations on `Instance.t`, `Variance.t`, `AbstractContext.t`, and `Univ.Universe.t`, enabling tasks like constraint solving, context merging, and variance checking during type checking. Submodules handle universe context management, instance manipulation with hash-consing and substitution, variance relation checking, and abstract context construction. Specific uses include resolving universe dependencies in Coq's kernel, validating polymorphic type definitions, and managing sort-level constraints during proof checking.",
      "description_length": 737,
      "index": 897,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "HConstr",
      "library": "rocq-runtime.kernel",
      "description": "This module provides hash-consed Coq terms with reference counting, enabling efficient term construction, structural inspection via `kind`, and term reconstruction through `self` and `hcons`. It supports working with Coq's internal `Constr.constr` terms and their decomposed forms, optimizing memory usage through subterm tracking. The included imperative hash tables allow mappings keyed by hash-consed terms, with operations like `add` and `find_opt` for managing dynamic associations during proof automation. Specific uses include term traversal, comparison, and handling shared subterms efficiently in kernel-level code.",
      "description_length": 624,
      "index": 898,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vars",
      "library": "rocq-runtime.kernel",
      "description": "This module handles substitution and transformation operations on Coq's term and context structures, focusing on de Bruijn index manipulation, parallel substitution, and universe management. It operates on internal representations like `Constr.constr`, `rel_context`, and `rel_declaration`, enabling tasks such as variable replacement, instance substitution, and relevance-preserving transformations while maintaining type correctness. Key use cases include proof term manipulation, context-aware index shifting, and universe-level adjustments during term transformations.",
      "description_length": 572,
      "index": 899,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmerrors",
      "library": "rocq-runtime.kernel",
      "description": "This module defines an `error` type and handles compilation-related error reporting. It includes functions to print errors, raise a specific error for oversized code, and validate compilable inductive types based on argument and constant counts. It is used to enforce constraints during compilation and provide diagnostic output.",
      "description_length": 329,
      "index": 900,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmsymtable",
      "library": "rocq-runtime.kernel",
      "description": "This module provides functions for evaluating and interpreting terms in a virtual machine environment. It operates on symbolic values, environments, and compiled code structures. Concrete use cases include executing lambda terms with variable binding and performing value interpretation in a virtual machine context.",
      "description_length": 316,
      "index": 901,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parray",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a persistent array structure with fixed maximum size, supporting efficient indexing, updates, and folds over elements. It works with polymorphic elements and uses `Uint63.t` for indices and lengths, ensuring safe access within bounds. Concrete use cases include managing state snapshots, implementing bounded collections, and handling indexed data in performance-sensitive contexts.",
      "description_length": 405,
      "index": 902,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cooking",
      "library": "rocq-runtime.kernel",
      "description": "This module handles the abstraction and instantiation of generalized declarations during type checking, primarily working with contexts, universes, and constraints. It transforms declarations by applying instantiations that simulate non-generalized behavior, using structures like `abstr_inst_info`, `cooking_info`, and `cooking_cache`. Concrete use cases include managing universe polymorphism, lifting constraints, and abstracting types and terms in a context-aware manner during compilation.",
      "description_length": 494,
      "index": 903,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Discharge",
      "library": "rocq-runtime.kernel",
      "description": "This module transforms proof terms, constants, inductive types, and contexts according to specified cooking policies. It processes opaque proof terms, constant bodies, mutual inductive definitions, and relational contexts, applying environment-aware transformations. It is used during proof term serialization and reduction to manage definitional content.",
      "description_length": 355,
      "index": 904,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Indtypes",
      "library": "rocq-runtime.kernel",
      "description": "This module checks inductive type definitions, validating their structure and universe constraints. It processes mutual inductive entries to produce well-formed inductive bodies, handling universe polymorphism and ensuring correctness of recursive and nested inductives. A key use case is type-checking inductive declarations during compilation in a proof assistant or language with dependent types.",
      "description_length": 399,
      "index": 905,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Context",
      "library": "rocq-runtime.kernel",
      "description": "This module manages local contexts as ordered sequences of variable declarations, supporting creation, transformation, and comparison of binders with relevance annotations. It includes functions to construct and deconstruct annotated binders, extract names and types, and apply mappings across context elements, facilitating tasks like scope management during type checking and proof construction. The first child module processes compacted contexts through transformations, mappings, and conversions, enabling structured manipulation of typed declarations and extraction of variable data. The second child module handles relational contexts using de Bruijn indices for binder-aware traversal and modification, while the third manages named contexts with support for adding, inspecting, and converting declarations, enabling substitution generation and typing environment construction.",
      "description_length": 885,
      "index": 906,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Retroknowledge",
      "library": "rocq-runtime.kernel",
      "description": "This module tracks and maps low-level primitive types and operations to named constants and constructors. It supports operations for registering inductive types and primitives, associating them with identifiers from the `Names` module. It is used to maintain metadata about how specific primitive values like integers, floats, and booleans correspond to their representations in a higher-level system.",
      "description_length": 401,
      "index": 907,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Names",
      "library": "rocq-runtime.kernel",
      "description": "This module organizes identifiers, paths, and names into a structured system for managing Rocq's core naming constructs. It defines key types like `Id.t` for normalized identifiers, `DirPath.t` for hierarchical paths, `ModPath.t` for module hierarchies, and `KerName.t` for absolute object references, along with sets and maps for efficient name resolution and environment management. Operations include path construction, name comparison, module hierarchy manipulation, and kernel name canonicalization, enabling tasks like type checking, dependency tracking, and structured reference resolution. Child modules extend these capabilities with set-theoretic operations over projections, constants, inductive types, and module paths, supporting advanced use cases such as symbolic transformation, hierarchical name aggregation, and effectful environment traversal.",
      "description_length": 862,
      "index": 908,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Reduction",
      "library": "rocq-runtime.kernel",
      "description": "This module performs reduction operations on Coq terms, focusing on beta-reduction, head normal form computation, and decomposition of products and lambdas. It operates on data types like `Constr.constr`, `Constr.types`, and `Constr.rel_context`, using environments and optional evar handlers for context-sensitive reductions. Concrete use cases include normalizing lambda expressions, applying arguments while reducing redexes, and extracting type arities or function contexts during proof checking or term manipulation.",
      "description_length": 521,
      "index": 909,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IndTyping",
      "library": "rocq-runtime.kernel",
      "description": "This module ensures the correctness of inductive definitions during type checking by validating their structure and computing necessary type information such as arities and contexts. It works with environments, inductive entries, and universe constraints to support the elaboration of inductive types. A key part of its functionality involves enforcing constraints on record types through a variant type `t` that identifies specific conditions, such as projection requirements and restrictions on squashing. These constraints are used to maintain logical consistency when processing dependent record types and their projections.",
      "description_length": 628,
      "index": 910,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Entries",
      "library": "rocq-runtime.kernel",
      "description": "This module defines data structures and types for representing global declarations such as constants, inductive types, modules, and module types. It includes specific types like `inductive_universes_entry`, `definition_entry`, and `mutual_inductive_entry` that capture detailed information about declarations, including universe constraints, parameters, and body definitions. It is used to encode Coq's core constructs for storage and manipulation within environments, such as global constants, inductive type definitions, and module structures.",
      "description_length": 545,
      "index": 911,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nativevalues",
      "library": "rocq-runtime.kernel",
      "description": "This module handles low-level value representations and manipulations for OCaml's native compiler, focusing on arithmetic (integer/floating-point), bitwise operations, and structured data handling (strings, arrays, closures, inductive types). It operates on types like `Nativevalues.t`, `atom`, `symbol`, and blocks, enabling direct term assembly, runtime value introspection, and compiler optimizations. Specific use cases include dynamic code generation, unchecked arithmetic for performance-critical paths, and low-level manipulation of compiler-internal data structures like projections and fixpoints.",
      "description_length": 605,
      "index": 912,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Uint63",
      "library": "rocq-runtime.kernel",
      "description": "This module provides arithmetic operations (addition, multiplication, division), bitwise manipulations (shifts, logical operations), and conversions between integers, floats, and 64-bit values. It operates on a 63-bit unsigned integer type, supporting precise numerical computations with functions for overflow handling, bit counting, and hashing. These capabilities are particularly useful in systems programming, cryptographic algorithms, and scenarios requiring strict control over numerical behavior and efficient bit-level operations.",
      "description_length": 539,
      "index": 913,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Mod_typing",
      "library": "rocq-runtime.kernel",
      "description": "This module translates module and module type entries into their compiled forms, handling universe constraints and environment updates. It operates on module paths, inline directives, and module signatures, producing module bodies and associated metadata. It supports use cases like compiling module definitions, finalizing module signatures, and translating include statements with proper delta resolution.",
      "description_length": 407,
      "index": 914,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evar",
      "library": "rocq-runtime.kernel",
      "description": "This module manages existential variables as an abstract type `t` isomorphic to `int`, offering safe operations for equality, comparison, hashing, and printing, while restricting direct type casting to explicit uses of `unsafe_of_int`. Its first child module organizes variables into ordered sets, supporting set operations, element-wise transformations, and ordered traversal, enabling tasks like dependency resolution and incremental set building. The second child module provides functional maps associating variables with arbitrary values, including combinators for merging, filtering, and effectful traversal, with performance optimizations for symbolic computation. Together, these components enable precise, type-safe handling of variable identifiers in proof systems, constraint solvers, and type inference engines.",
      "description_length": 823,
      "index": 915,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Safe_typing",
      "library": "rocq-runtime.kernel",
      "description": "This module supports type-safe manipulation of environments, modules, and constants through operations like environment configuration, incremental module construction, and strategy control for conversion. It operates on data structures including safe environments, module paths, kernel names, and universe constraints, with specific applications in managing opaque terms, handling side effects during type checking, and orchestrating modular code organization using sections and libraries. Key patterns involve oracle-driven strategy tuning, delta resolution, and safe registration of inductive or constant definitions.",
      "description_length": 619,
      "index": 916,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Relevanceops",
      "library": "rocq-runtime.kernel",
      "description": "This module determines the relevance of terms, variables, constants, and constructors in an environment, returning their sort relevance without full term retyping. It operates on Coq's internal constructions, environments, and universe-polymorphic projections. It is used in proof-irrelevant type checking to efficiently assess term inhabitation in SProp.",
      "description_length": 355,
      "index": 917,
      "embedding_norm": 1.0
    },
    {
      "module_path": "InferCumulativity",
      "library": "rocq-runtime.kernel",
      "description": "This module determines the cumulativity of inductive types by analyzing their arities and constructors. It computes universe levels and variances for inductive parameters based on the given environments and constraints. Used during type checking to ensure proper subtyping relations for inductive definitions.",
      "description_length": 309,
      "index": 918,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nativelib",
      "library": "rocq-runtime.kernel",
      "description": "This module provides direct access to the OCaml native compiler and dynamic linking facilities, enabling compilation of OCaml code to native objects, loading of compiled libraries, and execution of dynamically linked code. It operates on native code representations (`Nativecode.global list`, `Nativevalues.t`, `Nativevalues.symbols`) and manages runtime values (`rt1`, `rt2`), library paths, and dynamic linking state. Concrete use cases include compiling `.ml` files into native object files, dynamically loading and linking native libraries, and executing compiled library code with runtime symbol updates.",
      "description_length": 609,
      "index": 919,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nativelambda",
      "library": "rocq-runtime.kernel",
      "description": "This module translates Coq terms into lambda expressions for native compilation. It provides the `lambda_of_constr` function, which converts a Coq term (`Constr.constr`) into a lambda expression using a given environment and evar map. It operates on data types such as environments (`Environ.env`), evar maps (`Genlambda.evars`), and Coq terms, targeting the generation of executable code from Coq definitions.",
      "description_length": 410,
      "index": 920,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rtree",
      "library": "rocq-runtime.kernel",
      "description": "This module represents recursive trees with labeled nodes and variable references, enabling the construction and manipulation of infinite or cyclic structures through core operations like node building, mutual recursion management, and tree lifting. It supports customizable comparison and transformation logic, working with types like `'a Rtree.t` and constructs for deferred resolution of substructures. The Kind submodule defines variants of R-trees with distinct structural properties, allowing type-safe manipulation of different representations such as balanced or annotated trees. The conditional mapping functionality traverses trees to apply changes only where necessary, preserving structure identity and optimizing performance in scenarios like spatial indexing or incremental updates.",
      "description_length": 796,
      "index": 921,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nativeconv",
      "library": "rocq-runtime.kernel",
      "description": "This module provides functions for performing conversion tests by compiling terms to OCaml code. It works with conversion problems (`Conversion.conv_pb`), environments (`Environ.env`), and universe constraints. It is used to implement efficient, native-code-based term conversion checks outside the kernel, supporting use cases like proof term validation and type inference.",
      "description_length": 374,
      "index": 922,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CClosure",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for lazy reduction and normalization of closure-based terms, focusing on efficient manipulation of frozen constructs like `fconstr` and evaluation stacks. It works with encoded terms (`fterm`), substitution tables (`clos_tab`), and context-aware stacks to support core tasks such as function application, case analysis, and inductive constructions in Coq's kernel. Key use cases include weak head normalization, eta-expansion, and handling existential variables during type conversion.",
      "description_length": 517,
      "index": 923,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmopcodes",
      "library": "rocq-runtime.kernel",
      "description": "This module provides low-level virtual machine operations for stack manipulation, arithmetic on 63-bit integers and floats (with overflow/carry checks), function application, and control flow management. It operates on stack-allocated values, heap blocks, and environment pointers to enable bytecode execution in interpreters, closure handling, and memory-safe computations. Specific use cases include evaluating functional constructs via `opCLOSURE`, branching with checked arithmetic, and debugging float operations in OCaml runtime systems.",
      "description_length": 543,
      "index": 924,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Inductive",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for inspecting and transforming inductive, coinductive, and recursive type definitions in Coq's kernel, focusing on tasks like parameter extraction, universe instantiation, and elimination constraint enforcement. It operates on internal representations such as `mind_specif`, `pinductive`, and `cofixpoint` constructs, supporting constructor type computation, case expression expansion, and context manipulation. These functionalities are critical for implementing type-checking algorithms, validating pattern-matching expressions, and managing polymorphic universes in formal proof development.",
      "description_length": 627,
      "index": 925,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Declareops",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for manipulating type declarations, universe polymorphism, and substitution in a proof assistant's core system. It works with constant bodies, inductive types, module structures, and rewrite rules, supporting tasks like opacity checks, projection generation, and cumulativity analysis. These capabilities are used for type-checking, memory-efficient declaration management, and handling recursive or polymorphic definitions in formal verification contexts.",
      "description_length": 488,
      "index": 926,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmlibrary",
      "library": "rocq-runtime.kernel",
      "description": "This module manages the compilation and linking of virtual machine code, handling operations such as adding code segments, resolving references, and exporting compiled libraries. It works with types like `t` for in-memory libraries, `on_disk` for loaded object files, and `indirect_code` for code with unresolved references. Concrete use cases include loading object files, linking them into a complete library, and injecting or exporting compiled code for execution.",
      "description_length": 467,
      "index": 927,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UGraph",
      "library": "rocq-runtime.kernel",
      "description": "This module manages universe levels and inductive type templates, providing a polymorphic bound type to distinguish between proposition and set levels. It supports operations for type inference, template instantiation, and unification, ensuring correct propagation of `Prop` and `Set` during Coq-like inductive definition processing. Submodules handle concrete use cases such as universe level management and type-level differentiation during unification. Example uses include constructing inductive types with proper universe constraints and resolving type variables in dependent contexts.",
      "description_length": 590,
      "index": 928,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constant_typing",
      "library": "rocq-runtime.kernel",
      "description": "This module handles type inference and validation for definitions, parameters, primitives, and opaque terms in a typing context. It processes entries like section definitions, assumptions, and symbols, producing typed constants and constraints. Used during compilation to ensure correctness of global and local declarations.",
      "description_length": 324,
      "index": 929,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Conversion",
      "library": "rocq-runtime.kernel",
      "description": "This module implements core operations for type conversion and cumulativity checking, handling universe constraints and inductive type comparisons. It provides functions to compute cumulativity relations between sorts, check conversion of type instances, and validate constraints for inductive and constructor arguments. Use cases include type equality checks during type inference, cumulativity enforcement in the kernel, and universe subtyping in higher-order unification.",
      "description_length": 474,
      "index": 930,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Subtyping",
      "library": "rocq-runtime.kernel",
      "description": "This module implements subtyping checks between module types in a given environment. It verifies whether one module type is a subtype of another, considering universe constraints and consistency. A key use case is ensuring type compatibility during module inclusion or refinement in the module system.",
      "description_length": 301,
      "index": 931,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Opaqueproof",
      "library": "rocq-runtime.kernel",
      "description": "This module manages opaque proof terms using indexed references into a table, supporting lazy computation and substitution, and provides operations to create, substitute, and discharge these terms while handling their storage and retrieval through opaque handles. It works with maps that associate metadata to proof terms, allowing insertions, deletions, merges, and transformations with custom comparisons and equality checks, as well as efficient lookups and extremal binding retrieval. You can use it to cache intermediate proof results or track dependencies in systems that load proof segments on demand from .vo files. The combination of indexed term management and metadata mapping supports both low-level proof handling and high-level dependency tracking in proof assistants.",
      "description_length": 782,
      "index": 932,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Conv_oracle",
      "library": "rocq-runtime.kernel",
      "description": "This module manages conversion strategies for constants and variables during proof checking, determining when and how to unfold definitions. It works with constants, variables, and projections, assigning them levels like `Expand`, `Opaque`, or numeric `Level` to control transparency. Functions allow setting and querying these levels, comparing evaluation order, and folding over non-transparent entries, primarily guiding the unification and conversion processes in the kernel.",
      "description_length": 479,
      "index": 933,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vm",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for reducing and analyzing functions and fixpoints in a virtual machine context. It works with data types representing functions (`vfun`), fixpoints (`vfix`), cofixpoints (`vcofix`), and switches (`vswitch`), performing tasks such as decomposition, type extraction, and branch resolution. Concrete use cases include evaluating function bodies under lambdas, extracting type information from switches, and applying weak head reduction to values.",
      "description_length": 476,
      "index": 934,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nativecode",
      "library": "rocq-runtime.kernel",
      "description": "This module manages symbol tables and generates native code for compiling a subset of ML constructs, handling entities like constants, inductive types, terms, and module paths. It translates high-level definitions into low-level native code representations, supporting operations such as compiling constants, generating conversion logic, and mapping module hierarchies to identifiers. Key use cases include emitting OCaml code from mllambda fragments, resolving global symbols during compilation, and maintaining consistent state across native code generation stages.",
      "description_length": 567,
      "index": 935,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Environ",
      "library": "rocq-runtime.kernel",
      "description": "This module manages environments tracking de Bruijn variables, section variables, global constants, and inductive definitions, along with universe constraints and impredicativity flags. It supports low-level operations for context manipulation, inductive type processing, and polymorphism checks, working directly on types like `env` and `named_context_val`. Submodules handle comparison, hashing, and normalization of qualified constructions, names, constants, inductive types, and projections, using the environment to ensure consistent representation during type-checking and proof construction. Specific operations include pushing declarations, retrieving projections, normalizing identifiers, and inspecting global contexts for constants and inductives.",
      "description_length": 758,
      "index": 936,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Term",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for constructing, decomposing, and manipulating lambda terms and product types in Coq's internal syntax, focusing on handling binding structures with and without let-in definitions. It works with `Constr.constr` and `Constr.types` to extract binding contexts, apply arguments, and analyze term structures through pseudo-reduction and instantiation. Specific use cases include building nested binders, stripping abstractions, and processing declarations or assumptions in the Calculus of Inductive Constructions.",
      "description_length": 543,
      "index": 937,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vmvalues",
      "library": "rocq-runtime.kernel",
      "description": "This module provides operations for constructing, comparing, and decomposing virtual machine values, with a focus on low-level tagging, type inspection, and conversion between primitive and structured representations. It works with values, environments, stacks, and specialized types like `vblock`, `vcofix`, and `annot_switch`, supporting tasks such as runtime type classification, arity handling, and switch annotation management. Specific use cases include efficient value manipulation during execution, tracing/debugging through pretty-printing, and lexicographical string comparison for branching logic.",
      "description_length": 608,
      "index": 938,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vmbytecodes",
      "library": "rocq-runtime.kernel",
      "description": "This module defines bytecode instructions for a virtual machine, such as `Kacc`, `Kclosure`, and `Kprim`, which manipulate a stack and environment during execution. It includes data types like `instruction`, `caml_prim`, and `fv_elem` to represent VM operations, primitive functions, and free variables, enabling interpretation of functional constructs, closure handling, and execution of primitives like array and string operations. A child module manages label identifiers for bytecode generation, using integer-based labels to assign branch targets and track code positions during compilation. Together, they support building and executing low-level representations of high-level programs, with direct use in compiling and running functional languages.",
      "description_length": 755,
      "index": 939,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RedFlags",
      "library": "rocq-runtime.kernel",
      "description": "This module manages reduction strategies in a proof assistant's kernel by controlling which reduction rules (beta, delta, zeta, let, etc.) apply to terms such as evars, let-ins, projections",
      "description_length": 189,
      "index": 940,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vmbytegen",
      "library": "rocq-runtime.kernel",
      "description": "This module compiles Coq terms and constants into bytecode, handling monomorphic terms, constant bodies, and module aliases. It operates on data types such as environments, constraints, and bytecode structures with patching information. It is used during the compilation of Coq definitions into executable bytecode for the virtual machine.",
      "description_length": 339,
      "index": 941,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vmlambda",
      "library": "rocq-runtime.kernel",
      "description": "This module defines representations for lambda terms and structured values used in the VM. It provides operations to convert between lambda terms and structured values, extract values from lambda expressions, and compile Coq terms into VM-compatible lambda code. It is used during the compilation of Coq terms into executable VM code, particularly in the conversion of constants and expressions for evaluation or extraction.",
      "description_length": 424,
      "index": 942,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Float64_common",
      "library": "rocq-runtime.kernel",
      "description": "This module provides IEEE 754-compliant operations for 64-bit floating-point numbers (`t = float`), including classification, arithmetic, and handling special values like NaNs and infinities.",
      "description_length": 191,
      "index": 943,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CPrimitives",
      "library": "rocq-runtime.kernel",
      "description": "This module provides low-level arithmetic, bitwise, and comparison operations on 63-bit integers and 64-bit floating-point numbers, alongside array and string manipulation primitives. It supports introspection and transformation of Coq's primitive constants and types, handling universe contexts, type contexts, and Coq constructions. These capabilities are particularly useful for parsing, hashing, string conversion, and working with Coq's core type system in formal verification or compilation tasks.",
      "description_length": 503,
      "index": 944,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nativelibrary",
      "library": "rocq-runtime.kernel",
      "description": "This module provides the `dump_library` function, which compiles a module signature into a list of global identifiers and associated symbols for native code generation. It operates on module paths, environments, and module signatures to produce data used in native compilation. It is specifically used during the separate compilation of libraries in the native compiler.",
      "description_length": 370,
      "index": 945,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Typeops",
      "library": "rocq-runtime.kernel",
      "description": "This module provides type inference and environment-sensitive type-checking operations for Coq's core terms, focusing on validating constructions like variables, constants, projections, and primitives against typing rules. It manipulates environments (`Environ.env`), constraints (`Constr`), sorts (`Sorts`), and universe instances to enforce correctness in term judgments, cast validations, and context-sensitive typing. Specific applications include resolving type annotations for case matches during SProp-to-non-SProp conversions and ensuring relevance checks in universe-polymorphic primitive operations.",
      "description_length": 609,
      "index": 946,
      "embedding_norm": 1.0
    },
    {
      "module_path": "TransparentState",
      "library": "rocq-runtime.kernel",
      "description": "This module manages transparency states for variables, constants, and projections using sets from the `Names` module hierarchy. It provides checks to determine if specific identifiers, constants, or projections are marked as transparent in a given state. Use cases include controlling visibility during term printing or simplification, where selective transparency affects how expressions are displayed or reduced.",
      "description_length": 414,
      "index": 947,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Type_errors",
      "library": "rocq-runtime.kernel",
      "description": "This module provides functions to report and transform type-checking errors in Coq's type system, such as unbound variables, incorrect arities, malformed inductive types, and application errors. It operates on environments, judgments, constraints, and constructions to address issues like invalid recursive definitions, unsatisfied constraints, and universe-related inconsistencies during type validation. These utilities are essential for signaling and resolving errors encountered while checking inductive types, applications, and recursive or polymorphic constructs.",
      "description_length": 569,
      "index": 948,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pstring",
      "library": "rocq-runtime.kernel",
      "description": "This module implements a primitive string type with bounded length, supporting operations like creation, concatenation, substring extraction, and comparison. It works with strings limited to a maximum length defined by `max_length_int` and uses `Uint63.t` for character codes and indices. Concrete use cases include handling fixed-size string data in low-level processing, such as parsing binary formats or managing constrained string identifiers.",
      "description_length": 447,
      "index": 949,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Primred",
      "library": "rocq-runtime.kernel",
      "description": "This module manages primitive type operations and retroactive knowledge in type-checking and evaluation environments. It provides direct access to built-in type constants, constructors, and compatibility checks, while its child modules handle primitive operation evaluation and low-level data manipulation. The first child evaluates primitive operations within reduction, working with environments and reduction arguments to process constant applications during type-checking. The second constructs and deconstructs primitive values like integers and floats, operating on abstract `elem` representations to model data transformations in compiler pipelines or semantic evaluations.",
      "description_length": 680,
      "index": 950,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vconv",
      "library": "rocq-runtime.kernel",
      "description": "This module implements conversion functions for comparing and normalizing terms in the Coq kernel, specifically handling universe constraints and existential variables. It provides `vm_conv` for kernel-level term conversion and `vm_conv_gen` for more flexible, parametrized conversions used in external checking. These functions operate on Coq's internal term representations and are used during type checking and proof normalization.",
      "description_length": 434,
      "index": 951,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Constr",
      "library": "rocq-runtime.kernel",
      "description": "This module centers around the `constr` type, representing kernel terms in Rocq's core logic, and provides foundational operations for their construction, decomposition, and analysis. It supports lambda calculus primitives, inductive types, and universe-polymorphic constants, using de Bruijn indices and metavariables for formal reasoning and type checking. The first child module adds low-level, unsafe term manipulation capabilities, useful for proof automation and term generation, while the second extends term assembly with a heterogeneous cons operation for structured, mixed-type term components. Together, they enable precise term inspection, custom term building, and efficient normalization within a kernel context.",
      "description_length": 726,
      "index": 952,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Float64",
      "library": "rocq-runtime.kernel",
      "description": "This module provides arithmetic operations (addition, multiplication, square root), conversions between 64-bit floating-point numbers and strings or integers (Uint63), classification of special values (NaNs, infinities, zeros), and IEEE 754-compliant comparisons and hashing. It operates on `Float64.t` values, which represent double-precision floats, and interacts with `Uint63.t` for precise exponent and integer handling, catering to applications requiring exact numerical control, such as financial calculations or scientific simulations where edge-case precision and round-trip representation are critical.",
      "description_length": 611,
      "index": 953,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vcs.Make.Dag.Property",
      "library": "rocq-runtime.stm",
      "description": "This module provides operations to compare, convert to string, and access the data and node set of a property value. It works with property values parameterized by a data type `'d` and node sets. Concrete use cases include inspecting and validating properties associated with nodes in a directed acyclic graph.",
      "description_length": 310,
      "index": 954,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vcs.Make.Dag.NodeSet",
      "library": "rocq-runtime.stm",
      "description": "This module provides persistent sets of DAG nodes with ordered traversal, supporting standard set operations like union, intersection, and filtering, alongside sequence-based conversions for ordered iteration and bulk modifications. It works with DAG nodes ordered by a custom comparator, enabling functional transformations and structural queries such as subset checks or element ranking. These capabilities are particularly useful for version control systems or dependency management tools requiring precise hierarchical analysis and efficient manipulation of acyclic graph structures.",
      "description_length": 587,
      "index": 955,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vcs.Make.Dag",
      "library": "rocq-runtime.stm",
      "description": "This module provides a directed acyclic graph (DAG) structure with typed edges and node metadata, enabling the modeling of version control commit histories, dependency resolution, and hierarchical data relationships. It supports adding and removing nodes and edges, associating and retrieving node properties, and iterating over the graph, with child modules offering enhanced manipulation of node sets and property values. The first child module handles property inspection and validation, working with node-associated data parameterized by type `'d`, while the second offers ordered, persistent sets of nodes with efficient set operations and sequence-based transformations. Together, they enable precise structural queries, ordered traversal, and functional manipulation of complex DAG-based systems.",
      "description_length": 803,
      "index": 956,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm.DynBlockData.Easy",
      "library": "rocq-runtime.stm",
      "description": "This module simplifies working with dynamically typed block data in a transactional state machine. It provides functions to inject and project values with type tags, enabling type-safe operations on heterogeneous data structures. Use cases include handling tagged transactions and dynamically dispatching operations based on data type.",
      "description_length": 335,
      "index": 957,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dag.Make.NodeSet",
      "library": "rocq-runtime.stm",
      "description": "This module provides standard set operations including union, intersection, difference, and membership checks, alongside transformations like map, filter, and fold over immutable ordered sets. It operates on collections of comparable elements with guaranteed uniqueness, leveraging structural sharing for efficiency and offering conversions to sequences for ordered traversal. Use cases include managing dependencies in hierarchical data, implementing algorithms requiring precise set manipulation, and functional workflows needing safe error-handling variants.",
      "description_length": 561,
      "index": 958,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm.DynBlockData.Map",
      "library": "rocq-runtime.stm",
      "description": "This module implements a type-safe map associating type tags with values parameterized by those tags. It supports operations like adding, removing, and modifying entries with type-preserving transformations, along with iteration, folding, and filtering over heterogeneous entries. Use it to manage dynamic collections of typed state entries in transactional workflows, such as tracking runtime-configured components with varying value types.",
      "description_length": 441,
      "index": 959,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm.DynBlockData.HMap",
      "library": "rocq-runtime.stm",
      "description": "This module transforms or filters heterogeneous maps of dynamic block data using user-defined functions. It operates on maps where each value is associated with a type tag and belongs to either of two value modules. Use it to convert or selectively retain data entries in a type-safe manner during state transitions.",
      "description_length": 316,
      "index": 960,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vcs.Make.Branch",
      "library": "rocq-runtime.stm",
      "description": "This module defines a concrete type `t` representing version control system branches. It provides operations to create a branch from a string, compare branches for equality and ordering, convert a branch to its string representation, and access a predefined `master` branch. Useful for managing and manipulating branch names in a type-safe way within version control workflows.",
      "description_length": 377,
      "index": 961,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dag.Make.Property",
      "library": "rocq-runtime.stm",
      "description": "This module provides operations to compare, convert to string, and access data and node sets from property values. It works with property structures parameterized by data type `'d` and node sets. Concrete use cases include inspecting and validating properties in a directed acyclic graph (DAG) structure.",
      "description_length": 304,
      "index": 962,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vcs.S-Dag-Property",
      "library": "rocq-runtime.stm",
      "description": "This module defines operations for comparing, converting to string, and extracting components of property values associated with nodes in a directed acyclic graph (DAG). It works with property values of type `'d Dag.Property.t`, which encapsulate data of type `'d` and potentially associated node sets. Concrete use cases include checking equality or ordering of properties, retrieving their raw data, and determining which nodes have a specific property.",
      "description_length": 455,
      "index": 963,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "WorkerPool.PoolModel",
      "library": "rocq-runtime.stm",
      "description": "This module manages the spawning and handling of worker processes with specific priority levels. It provides a `spawn` function to create new workers using command-line arguments, returning associated communication channels. The `manager` function coordinates worker lifecycle and interaction within a control panel setup, using process and extra configuration data.",
      "description_length": 366,
      "index": 964,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vcs.Make",
      "library": "rocq-runtime.stm",
      "description": "This system manages version-controlled data using a DAG-based model, supporting branching, merging with conflict resolution, committing changes, and history rewriting. It builds on a directed acyclic graph structure with typed edges and node metadata, enabling efficient commit history modeling, branch management via a dedicated branch type, and garbage collection for storage optimization. You can create and manipulate branches, inspect and validate node properties, perform set operations on nodes, and traverse commit histories in ordered sequences. The system supports collaborative development workflows, structural queries, and scalable history management with automated cleanup.",
      "description_length": 687,
      "index": 965,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dag.S",
      "library": "rocq-runtime.stm",
      "description": "This module implements a directed acyclic graph (DAG) structure with typed nodes and edges. It supports operations such as adding and removing edges and nodes, attaching and retrieving metadata to nodes, and managing node properties. Concrete use cases include representing dependency graphs, processing topological relationships, and tracking metadata in a structured graph format.",
      "description_length": 382,
      "index": 966,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Dag.S-Property",
      "library": "rocq-runtime.stm",
      "description": "This module implements operations for comparing, converting to string, and extracting data from property values associated with nodes in a directed acyclic graph (DAG). It works with property values parameterized by a data type `'d` and provides access to the set of nodes that have a given property. Concrete use cases include tracking metadata such as labels or annotations across DAG nodes, enabling equality checks, and facilitating debugging through string representations.",
      "description_length": 478,
      "index": 967,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Vcs.S",
      "library": "rocq-runtime.stm",
      "description": "This module offers operations for branch management (creation, deletion, merging, and resetting), commit manipulation (amending history and merging), and metadata tracking, all structured around a directed acyclic graph (DAG) representing versioned states. It works with DAG nodes to model commit relationships, supporting property annotations, garbage collection of unreachable nodes, and reachability queries. These capabilities enable workflows like collaborative development with branching histories, storage optimization by pruning obsolete commits, and dependency analysis in versioned data.",
      "description_length": 597,
      "index": 968,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vcs.S-Dag",
      "library": "rocq-runtime.stm",
      "description": "This module implements a directed acyclic graph (DAG) structure with typed edges and node metadata. It supports operations to add and remove edges and nodes, associate and retrieve metadata with nodes, and attach properties to nodes. Concrete use cases include modeling version control commit histories, dependency resolution, and hierarchical data relationships.",
      "description_length": 363,
      "index": 969,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Stm.AsyncOpts",
      "library": "rocq-runtime.stm",
      "description": "Handles configuration of asynchronous proof processing, including worker management, caching strategies, and error resilience settings. Operates on proof states and tactic execution within a transactional state machine. Used to control parallelization and resource allocation during proof checking.",
      "description_length": 298,
      "index": 970,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vcs.S-Dag-NodeSet",
      "library": "rocq-runtime.stm",
      "description": "This module provides a suite of immutable set operations for managing collections of directed acyclic graph (DAG) nodes, supporting standard manipulations like union, intersection, and difference alongside ordered traversal and element selection. It enables transformation through filtering, mapping, and partitioning with guarantees of monotonic predicate handling, while facilitating bulk updates via sequence-based conversions to and from ordered iterables. Typical applications include dependency resolution, version history analysis, and hierarchical data synchronization where DAG node relationships require precise set-theoretic reasoning.",
      "description_length": 646,
      "index": 971,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AsyncTaskQueue.Task",
      "library": "rocq-runtime.stm",
      "description": "This module defines the interface for handling asynchronous task processing between a master and worker processes. It includes operations to generate requests from tasks, match tasks based on worker status, process responses, and handle errors or cancellations. The module works with abstract types for tasks, requests, responses, and worker status, enabling concrete implementations to define how tasks are processed and how workers respond. Use cases include distributing computations across worker processes, managing task lifecycle based on worker state, and handling feedback and errors during distributed execution.",
      "description_length": 621,
      "index": 972,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Partac.TacTask",
      "library": "rocq-runtime.stm",
      "description": "This module defines task and worker interaction logic for a distributed system. It handles task assignment, status tracking, and communication between master and worker processes using typed requests and responses. Concrete use cases include marshaling task data, filtering valid tasks for workers, processing results, and broadcasting feedback.",
      "description_length": 345,
      "index": 973,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vcs.Kind",
      "library": "rocq-runtime.stm",
      "description": "Represents a version control system branch, specifically providing a value for the default branch. Works with branch types in version control systems. Used to identify or compare the main development line in repositories.",
      "description_length": 221,
      "index": 974,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vcs.S-Branch",
      "library": "rocq-runtime.stm",
      "description": "This module defines operations for creating and comparing version control system branch identifiers. It supports string-based branch names with case-sensitive equality and ordering, and provides a predefined `master` branch. Typical use cases include tracking branch identities in Git-like systems and comparing branch names during merge or checkout operations.",
      "description_length": 361,
      "index": 975,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dag.Make",
      "library": "rocq-runtime.stm",
      "description": "This module combines a directed acyclic graph (DAG) structure with typed nodes and edges with set-based operations and property inspection capabilities. It allows adding and removing nodes and edges, attaching metadata, and managing node properties, while its child modules support set manipulations like union and map, and property data access and conversion. You can represent build dependencies, validate graph properties, and traverse node sets efficiently using ordered, immutable sets. The integration of graph and set operations enables modeling and processing complex hierarchical relationships with strong typing and structural guarantees.",
      "description_length": 648,
      "index": 976,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm.ProofTask",
      "library": "rocq-runtime.stm",
      "description": "This module defines operations for managing proof tasks within a state-transaction-machine system. It includes functions for generating worker requests based on task and worker status, matching tasks to workers, processing responses, and handling task lifecycle events such as cancellation or expiration. It works with proof tasks, worker statuses, and responses in a distributed proving environment where tasks are assigned to workers and results are collected and processed.",
      "description_length": 476,
      "index": 977,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AsyncTaskQueue.MakeQueue",
      "library": "rocq-runtime.stm",
      "description": "This module implements a task queue system with dynamic worker management, supporting task scheduling, cancellation, and prioritization. It operates on a generic task type `T.task` and maintains a queue of pending tasks along with a pool of workers. Concrete use cases include managing asynchronous proof processing tasks in an IDE or handling prioritized job execution in a distributed build system.",
      "description_length": 400,
      "index": 978,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AsyncTaskQueue.MakeWorker",
      "library": "rocq-runtime.stm",
      "description": "Implements a server task dispatcher for handling asynchronous tasks. Initializes standard output and runs the main event loop for task processing. Designed for use in a Coq server environment to manage execution flow during interactive sessions.",
      "description_length": 245,
      "index": 979,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm.DynBlockData",
      "library": "rocq-runtime.stm",
      "description": "This module manages dynamic type tags and their associated values, enabling type-safe operations across heterogeneous data through tagging, comparison, and lookup. It supports creating and comparing tags, injecting and projecting values with type safety, and maintaining type-indexed maps for dynamic state tracking. The module facilitates transactional workflows by allowing type-preserving transformations, filtering, and iteration over dynamically typed entries. Use it to handle tagged transactions, track runtime components with varying types, or transform dynamic state maps during transitions.",
      "description_length": 600,
      "index": 980,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Stm.QueryTask",
      "library": "rocq-runtime.stm",
      "description": "This module defines operations for managing task execution between a master and worker processes. It includes functions to generate requests based on worker status, match tasks to workers, process responses, and handle errors or cancellations. It works with task, competence, worker_status, request, and response types, enabling concrete use cases like distributed task scheduling, worker lifecycle management, and feedback propagation.",
      "description_length": 436,
      "index": 981,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WorkerPool.Make",
      "library": "rocq-runtime.stm",
      "description": "This module implements a worker pool management system for parallel task execution. It provides operations to create a pool of workers with specified size and priority, cancel individual or all workers, and check pool status. The module works with a model-specific extra data type and handles worker communication via threads and channels. Use it to manage background tasks in a concurrent environment, such as processing jobs with dynamic priorities or handling multi-threaded I/O operations.",
      "description_length": 493,
      "index": 982,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dag.S-NodeSet",
      "library": "rocq-runtime.stm",
      "description": "This module provides a comprehensive set of operations for managing collections of node elements, including standard set operations (union, intersection, difference), element queries (membership, cardinality, extremal values), and transformations (mapping, filtering, partitioning). It works with node sets and ordered sequences, supporting use cases like dependency tracking, group membership validation, and ordered traversal of node groups, while offering safe and unsafe variants for error handling.",
      "description_length": 503,
      "index": 983,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "WorkerPool",
      "library": "rocq-runtime.stm",
      "description": "This module manages concurrent task execution through a fixed pool of worker threads, allowing tasks to be submitted, results retrieved, and workers controlled. It supports parallelizing I/O or CPU-bound operations, such as batch data processing or network requests, using a priority-based system to manage worker creation and communication. Child modules extend this by enabling worker spawning via command-line arguments with dedicated channels, and by providing dynamic priority handling and cancellation of workers within a thread-based execution model. Key data types include worker configurations, communication channels, and task results, with operations like `spawn`, `submit`, `cancel`, and `manager` coordinating execution and lifecycle.",
      "description_length": 747,
      "index": 984,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Partac",
      "library": "rocq-runtime.stm",
      "description": "This module orchestrates parallel execution by spawning worker processes and distributing tasks defined in `TacTask`, enabling concurrent proof search and theorem proving. It manages task assignment, tracks worker status, and facilitates communication through typed requests and responses between master and worker processes. Key operations include marshaling task data, filtering valid tasks, processing results, and broadcasting feedback to coordinate distributed workloads. Example use cases include splitting a large proof search into concurrent jobs or aggregating results from parallel theorem proving tasks.",
      "description_length": 614,
      "index": 985,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dag",
      "library": "rocq-runtime.stm",
      "description": "This module provides a directed acyclic graph (DAG) structure with typed nodes and edges, supporting operations to add and remove nodes and edges, attach and query metadata, and enforce acyclicity. It enables topological sorting, dependency resolution, and property tracking, with concrete applications in task scheduling and build systems. Submodules extend the core functionality with set-based operations, property manipulation, and data conversion, allowing efficient node set management and structured metadata handling. You can, for example, track labeled dependencies, compute union or intersection of node sets, and validate graph properties using typed, immutable structures.",
      "description_length": 684,
      "index": 986,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vcs",
      "library": "rocq-runtime.stm",
      "description": "This module provides core abstractions for version control operations, enabling tracking changes, managing branches, and handling commits through a DAG-based model. It works with repositories, commits, diffs, and branch types, offering operations for branching, merging, history rewriting, and metadata tracking, while supporting property annotations, node set operations, and garbage collection. You can model commit histories, perform set-theoretic analysis on DAG nodes, compare branch identifiers, and manage versioned data with precise control over node relationships and reachability. Concrete use cases include implementing custom VCS backends, analyzing dependencies, and building tools for code review, repository visualization, and collaborative development workflows.",
      "description_length": 778,
      "index": 987,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ProofBlockDelimiter",
      "library": "rocq-runtime.stm",
      "description": "This module manages proof block boundaries and goal dependencies during interactive proof construction. It provides functions to determine if a goal is isolated, traverse document nodes to detect block closures, and handle dynamic block data for bullets and units. Key use cases include checking if focusing on a goal affects others and correctly delimiting proof blocks in the document structure.",
      "description_length": 397,
      "index": 988,
      "embedding_norm": 1.0
    },
    {
      "module_path": "TQueue",
      "library": "rocq-runtime.stm",
      "description": "This module implements a thread-safe queue with support for blocking operations, dynamic ordering, and synchronization primitives. It allows pushing and popping elements, waiting for specific queue states, and managing multiple consumers with optional filtering and cleanup. Concrete use cases include coordinating concurrent tasks, implementing work-stealing schedulers, and managing asynchronous event queues.",
      "description_length": 411,
      "index": 989,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AsyncTaskQueue",
      "library": "rocq-runtime.stm",
      "description": "This module coordinates asynchronous task execution across worker processes by managing a queue of tasks with cancellation support and status tracking. It defines core operations for task creation, scheduling, and lifecycle management, working with abstract types for tasks, workers, and responses, and supports dynamic worker pools and prioritization. Concrete implementations handle use cases like distributed proof generation and IDE-based task processing, while child modules provide interfaces for task-worker communication, dynamic queue management, and integration with Coq server environments. Key data types include tasks, worker statuses, and responses, with operations to enqueue, cancel, prioritize, and process tasks based on worker availability and feedback.",
      "description_length": 772,
      "index": 990,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Spawned",
      "library": "rocq-runtime.stm",
      "description": "Handles inter-process communication channels with anonymous pipes and TCP sockets. Initializes and retrieves input/output channels for thread-safe communication, using socket addresses and port numbers. Used to coordinate distributed processes by uniquely identifying and connecting them through predefined channels.",
      "description_length": 316,
      "index": 991,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Stmargs",
      "library": "rocq-runtime.stm",
      "description": "Handles parsing of command-line arguments related to STM (Software Transactional Memory) options. It processes input arguments to extract STM configuration and returns the remaining arguments for further processing. Useful in applications that require fine-grained control over STM behavior through command-line flags.",
      "description_length": 318,
      "index": 992,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stm",
      "library": "rocq-runtime.stm",
      "description": "This module orchestrates state transitions and transactional workflows in a Coq-based environment, coordinating document evolution, proof retrieval, and block management with support for asynchronous processing and metadata handling. It integrates configuration for parallel proof checking, task scheduling between master and worker processes, dynamic type tagging for heterogeneous state tracking, and lifecycle management of proof and computation tasks. Core data includes state identifiers, proof blocks, worker statuses, tagged values, and task-response pairs, with operations for transactional updates, task assignment, type-safe value injection, and proof state recovery. Use it to implement collaborative editors with live proof feedback, fault-tolerant proof checking pipelines, or distributed Coq task runners with dynamic load balancing and typed state transformations.",
      "description_length": 879,
      "index": 993,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rocqshim",
      "library": "rocq-runtime.rocqshim",
      "description": "This module manages worker executables and process initialization. It provides `init` to set up the environment, `get_worker_path` to locate worker binaries, and `exec_or_create_process` to handle cross-platform process execution reliably. It works with worker configurations and command-line options, primarily used in scenarios where external tools need to be spawned with precise control over their execution context.",
      "description_length": 420,
      "index": 994,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Perf",
      "library": "rocq-runtime.perf",
      "description": "Tracks CPU instruction counts with initialization, reading, and cleanup operations. Uses a global counter state to measure executed instructions between initialization and reset. Enables performance analysis by quantifying code execution at a low level.",
      "description_length": 253,
      "index": 995,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_byte_config",
      "library": "byte_config",
      "description": "This module provides functions for handling silent evaluation in a top-level loop and managing exit behavior with a success status. It works with standard formatting and unit functions. Concrete use cases include suppressing output during script execution and ensuring clean termination in compilation environments.",
      "description_length": 315,
      "index": 996,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Boot.Env.Path",
      "library": "rocq-runtime.boot",
      "description": "This module represents and manipulates filesystem paths within Rocq's runtime environment. It supports constructing relative paths, checking file existence, and converting paths to their string representation. It is used to locate and validate Rocq's standard directories and support files during environment initialization.",
      "description_length": 324,
      "index": 997,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Boot.Usage",
      "library": "rocq-runtime.boot",
      "description": "This module provides functions to print version information and usage instructions for executables. It defines a `specific_usage` type to structure executable-specific arguments and options, and prints combined generic and specific usage details to a given output channel. Concrete use cases include displaying version numbers in human-readable or machine-readable formats and generating tailored usage messages for command-line tools.",
      "description_length": 435,
      "index": 998,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Boot.Path",
      "library": "rocq-runtime.boot",
      "description": "This module provides operations to construct and manipulate file paths. It supports creating relative paths, checking if a file exists, and converting paths to their string representation. It works with the `t` type, which represents a file path, and is used for tasks like navigating directory structures or validating file presence.",
      "description_length": 334,
      "index": 999,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Boot.Env",
      "library": "rocq-runtime.boot",
      "description": "The environment API manages Rocq's runtime configuration, handling initialization and access to standard directories such as the stdlib, plugins, and contributions. It uses a core environment type `t` and path structures to resolve locations for tools, native compilation resources, and runtime metadata. The API supports operations like setting and retrieving library paths, checking file existence, and constructing valid paths relative to the runtime environment. Specific tasks include locating `theories/Init/Prelude.vo`, handling `ROCQLIB` and `ROCQRUNTIMELIB` resolution, and ensuring correct setup for applications needing stable runtime access.",
      "description_length": 653,
      "index": 1000,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Boot.Util",
      "library": "rocq-runtime.boot",
      "description": "This module handles environment variable retrieval with fallback and deprecation warnings, and provides a function to check file paths with a custom resolution strategy. It works with strings for environment keys and paths, and supports conditional logic for configuration discovery. Concrete use cases include reading ROCQ/COQ-prefixed environment variables with deprecation notices and resolving file paths based on a directory hierarchy.",
      "description_length": 440,
      "index": 1001,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Boot",
      "library": "rocq-runtime.boot",
      "description": "This module provides utilities for initializing and configuring executables, managing file paths, and resolving runtime environments. It centers around types like `specific_usage` for command-line interface descriptions, `t` for file paths, and environment configurations that support operations such as version display, path validation, and library resolution. You can generate usage messages, construct and check file paths, and locate runtime resources like `theories/Init/Prelude.vo` or resolve `ROCQLIB` paths. Specific tasks include printing machine-readable versions, validating file existence, and handling deprecated environment variables with fallback strategies.",
      "description_length": 673,
      "index": 1002,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Autorewrite.RewRule",
      "library": "rocq-runtime.tactics",
      "description": "This module defines and manipulates rewriting rules used by the autorewrite tactic. It provides access to the lemma, direction, and tactic associated with each rule. These rules are applied to terms during automated rewriting, enabling transformations based on equational logic in proof scripts.",
      "description_length": 295,
      "index": 1003,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Btermdn.Make",
      "library": "rocq-runtime.tactics",
      "description": "This module creates discrimination nets for efficiently matching terms against registered patterns, supporting operations to add, remove, and look up actions associated with patterns. It works with terms and patterns in a constrained environment, handling existential variables and transparency states. Concrete use cases include tactic selection based on term structure in proof automation.",
      "description_length": 391,
      "index": 1004,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Redexpr.Intern",
      "library": "rocq-runtime.tactics",
      "description": "Interns raw reduction expressions into typed red expressions using a context environment. It translates untyped red expressions into a form suitable for evaluation, producing structures that represent reduction rules or expressions parameterized over indices. This supports concrete tasks like compiling reduction strategies for terms in a proof context.",
      "description_length": 354,
      "index": 1005,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hints.FullHint",
      "library": "rocq-runtime.tactics",
      "description": "This module defines a hint type with operations to retrieve properties like priority, pattern, database, and name. It supports applying hints during proof construction using the `run` function, which executes a tactic based on the hint's contents. Concrete use cases include guiding automated proof search and structuring hint application in Coq's proof engine.",
      "description_length": 361,
      "index": 1006,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tactics.Internal",
      "library": "rocq-runtime.tactics",
      "description": "This module implements core tactic operations for proof manipulation, including name handling, pattern decomposition, and hypothesis clearing. It works with identifiers, introduction patterns, environments, and proof contexts. Concrete uses include checking name uniqueness in intro patterns, clearing hypotheses with optional wildcards, and decomposing complex intro patterns into simpler steps for tactic execution.",
      "description_length": 417,
      "index": 1007,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dn.Make",
      "library": "rocq-runtime.tactics",
      "description": "This module implements a structured table for associating decomposable tree-like objects with values, supporting insertion, removal, and lookup based on prefix decompositions. It works with arbitrary tree structures through user-provided decomposition functions and stores associated values of type `Z.t`. Concrete use cases include building decision trees, trie-like structures, or rule-based systems where hierarchical data needs to be efficiently queried and modified based on structural patterns.",
      "description_length": 500,
      "index": 1008,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tactics.Simple",
      "library": "rocq-runtime.tactics",
      "description": "This module provides basic proof manipulation tactics such as introducing hypotheses, applying lemmas, performing elimination, and case analysis on terms. It operates on proof goals represented as `unit Proofview.tactic`, working directly with identifiers (`Names.Id.t`) and constructed terms (`EConstr.constr`). These tactics are used to build and manipulate Coq proofs in a simplified manner, suitable for scripting or beginner-level proof automation.",
      "description_length": 453,
      "index": 1009,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ind_tables.Locmap",
      "library": "rocq-runtime.tactics",
      "description": "This module maps inductive types to their associated locations using a structured table. It supports creating and querying location information for both individual and mutual inductive schemes. Concrete use cases include tracking source code positions for inductive definitions during scheme generation or error reporting.",
      "description_length": 322,
      "index": 1010,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rewrite.Internal",
      "library": "rocq-runtime.tactics",
      "description": "This module implements internal operations for constructing and manipulating term signatures and morphisms during rewriting. It provides functions to build and transform signatures using environments, evar_maps, and constr expressions, working directly with EConstr and Constrexpr types. It is used in the implementation of generalized rewriting tactics, particularly for handling morphism constraints and term instantiation.",
      "description_length": 425,
      "index": 1011,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Redexpr.Interp",
      "library": "rocq-runtime.tactics",
      "description": "Interprets reduction expressions in environments with support for evaluating terms, handling evars, and processing red-exprs. Works with constr, evref, pat, and evar_map data types. Used to implement reduction strategies like HNF or CBV in Coq's evaluation pipeline.",
      "description_length": 266,
      "index": 1012,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Class_tactics.Search",
      "library": "rocq-runtime.tactics",
      "description": "This module provides a tactic for automated resolution of typeclass constraints using hint databases, supporting modes, transparency settings, and customizable search strategies. It operates on typeclass goals, applying hints with backtracking and depth control to find solutions, and handles dependencies and stuck goals. Concrete use cases include resolving implicit arguments and discharging proof obligations in typeclass-based developments.",
      "description_length": 445,
      "index": 1013,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hints.Hint_db",
      "library": "rocq-runtime.tactics",
      "description": "This module manages a database of proof hints, enabling operations to query hints based on pattern matching, reference association, and eauto/auto resolution strategies. It supports filtering hints by section variables, transparent state, and mode constraints, and allows modification through addition or removal of hints and modes. Concrete use cases include guiding automated proof search in Coq by retrieving applicable lemmas or tactics based on the current goal structure.",
      "description_length": 477,
      "index": 1014,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eauto",
      "library": "rocq-runtime.tactics",
      "description": "This module provides tactics for automated proof search and term unfolding in a theorem proving context. It includes functions for exact matching, eauto-style proof search with customizable depth and hint databases, and unfolding definitions in goals or hypotheses. These tactics operate on constrained terms and hint databases, targeting specific clauses or locations in the proof context.",
      "description_length": 390,
      "index": 1015,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Contradiction",
      "library": "rocq-runtime.tactics",
      "description": "This module implements tactics for handling contradictions in proof terms. It provides `absurd` to derive a contradiction from an impossible equality, and `contradiction` to close a goal by finding a contradiction in the context. These tactics operate on proof terms and are used when proving goals that involve refuting inconsistent assumptions.",
      "description_length": 346,
      "index": 1016,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Auto",
      "library": "rocq-runtime.tactics",
      "description": "This module implements automated proof search tactics, including unification-based resolution and pattern matching on conclusions. It operates on proof goals, hint databases, and constructor patterns, using precompiled clauses and configurable search depth. Concrete use cases include automatically solving goals using registered hints, applying unification with specific clauses, and performing heuristic proof search with customizable databases and debug options.",
      "description_length": 465,
      "index": 1017,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ind_tables",
      "library": "rocq-runtime.tactics",
      "description": "This module coordinates the registration, declaration, and on-demand generation of inductive scheme builders, handling both mutual and individual scheme kinds. It supports key operations such as defining schemes for inductive types and mutual blocks, tracking dependencies, and caching generated constants representing schemes. A companion submodule maintains structured tables mapping inductive types to their source locations, enabling precise querying and error reporting during scheme generation. Example uses include automating induction principle generation for inductive families or retrieving case-analysis schemes based on mutual inductive definitions.",
      "description_length": 661,
      "index": 1018,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tacticals",
      "library": "rocq-runtime.tactics",
      "description": "The module provides operations to sequence, branch, and manage error handling for tactics, working with proof states, evar maps, and intro patterns. These combinators enable constructing complex proof strategies with structured control flow, hypothesis manipulation, and delayed execution, particularly useful for handling interactive theorem proving tasks with dynamic goal structures and existential variables.",
      "description_length": 412,
      "index": 1019,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Equality",
      "library": "rocq-runtime.tactics",
      "description": "This module offers tactics for equality manipulation, including directional rewriting (e.g., left-to-right or right-to-left), term substitution, hypothesis injection, and equality destruction. These operate on Coq terms (`EConstr.constr`), hypotheses (`Names.Id.t`), and clauses (`Locus.clause`), utilizing bindings and flags to control behavior. They are employed to apply equalities in specific directions, derive new equalities through hypothesis injection, simplify proof goals by eliminating contradictions or redundancies, and manage term substitutions across logical contexts.",
      "description_length": 583,
      "index": 1020,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tactics",
      "library": "rocq-runtime.tactics",
      "description": "This module provides foundational tactics for manipulating proof goals, environments, and Coq terms, enabling operations like lemma application, induction, case analysis, and equality reasoning. It includes submodules that handle core proof manipulation tasks such as hypothesis management, pattern decomposition, and goal transformation using tactics like introduction, elimination, and term application. Key data types include proof goals (`unit Proofview.tactic`), identifiers (`Names.Id.t`), and internal terms (`EConstr.constr`), with operations for reduction, evar resolution, and context refinement. Examples include applying a lemma to a goal, decomposing an introduction pattern, or clearing hypotheses while preserving proof state integrity.",
      "description_length": 751,
      "index": 1021,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Redops",
      "library": "rocq-runtime.tactics",
      "description": "This module handles reduction flags and transformations for generalized reduction expressions. It provides operations to create and manipulate reduction flags, as well as mapping functions to transform components of reduction expression generators. It is used in contexts like processing lambda calculus terms with customizable reduction strategies.",
      "description_length": 349,
      "index": 1022,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Induction",
      "library": "rocq-runtime.tactics",
      "description": "This module implements elimination schemes for inductive types, providing structured case analysis and induction tactics. It operates on inductive data structures by generating elimination principles based on the shape of the type and its constructors. Concrete use cases include proof-by-cases with `destruct` and structural induction with `induction`, directly manipulating goals involving inductive types like natural numbers, lists, or trees.",
      "description_length": 446,
      "index": 1023,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Generalize",
      "library": "rocq-runtime.tactics",
      "description": "This module implements tactics for generalizing terms and hypotheses in proof goals. It operates on constructions, named contexts, and loci with occurrences, enabling manipulation of variables, dependencies, and term structures. Concrete use cases include reverting hypotheses, abstracting over terms, and selectively generalizing subterms while preserving dependencies.",
      "description_length": 370,
      "index": 1024,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dn",
      "library": "rocq-runtime.tactics",
      "description": "This module organizes hierarchical data into a structured table that maps decomposable tree-like structures to values, enabling efficient insertion, removal, and lookup based on prefix patterns. It relies on user-defined decomposition functions to navigate arbitrary tree forms and stores values of type `Z.t`. You can use it to build decision trees, trie-like hierarchies, or rule engines where structural queries drive data manipulation. For example, you might associate XML nodes with metadata or route network requests through a hierarchical rule set.",
      "description_length": 555,
      "index": 1025,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eqdecide",
      "library": "rocq-runtime.tactics",
      "description": "This module implements tactics for comparing terms and deciding equality goals in Coq's proof engine. It operates on `EConstr.t` values, which represent terms in an extended constructor form. The `compare` function checks equality between two terms, while `decideEqualityGoal` attempts to resolve an equality goal using available evidence.",
      "description_length": 339,
      "index": 1026,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hipattern",
      "library": "rocq-runtime.tactics",
      "description": "This module provides second-order pattern matching operations that analyze and decompose Coq terms with binding structures, focusing on logical and inductive type analysis. It works with `EConstr.constr` terms, environments, and evar_maps to detect properties like conjunctions, disjunctions, equalities, and negations in a name-agnostic way, even for user-defined types. Specific use cases include proof automation tasks that require recognizing logical forms (e.g., identifying implications to false, decomposing sigma types) and type-level reasoning without relying on predefined type names.",
      "description_length": 594,
      "index": 1027,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elimschemes",
      "library": "rocq-runtime.tactics",
      "description": "This module implements induction and recursion schemes for generating elimination principles. It operates on inductive type definitions, producing schemes that guide proof and program construction. Concrete use cases include automating the generation of induction principles for new inductive types and supporting the implementation of recursive functions with verified termination.",
      "description_length": 382,
      "index": 1028,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Btermdn",
      "library": "rocq-runtime.tactics",
      "description": "This module implements discrimination nets with bounded depth to efficiently match terms against registered patterns, using a shared prefix tree to optimize lookups based on rigid constants, variables, and existential variables. It supports operations to add, remove, and retrieve actions\u2014such as tactics\u2014based on pattern prefixes, enabling fast dispatch in proof automation and term rewriting. Submodules extend this functionality to handle constrained environments and dynamic updates to pattern registries. Example uses include tactic selection in proof assistants and efficient rule application in rewriting systems.",
      "description_length": 620,
      "index": 1029,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Abstract",
      "library": "rocq-runtime.tactics",
      "description": "This module provides tactics for abstracting terms during proof construction, including caching results of tactic applications and declaring abstracted definitions. It operates on Coq's internal proof terms, using data types like `EConstr.constr`, `Proofview.tactic`, and `Evd.evar_map`. Concrete use cases include optimizing repeated proof steps by abstracting common subproofs and managing evar substitutions during tactic execution.",
      "description_length": 435,
      "index": 1030,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Eqschemes",
      "library": "rocq-runtime.tactics",
      "description": "This module defines scheme kinds for constructing equality-based inductive types, including left-to-right and right-to-left rewriting schemes, symmetry schemes, and congruence schemes. It operates on equality inductive types, supporting dependent and non-dependent versions of transformations. These schemes are used to generate induction principles and proof automation tactics specific to equality reasoning.",
      "description_length": 410,
      "index": 1031,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Elim",
      "library": "rocq-runtime.tactics",
      "description": "This module provides tactics for performing case analysis and decomposition of inductive types. It operates on Coq's proof terms and contexts, using inductive definitions, constructors, and patterns to break down logical goals. Functions like `case_tac` enable structured case analysis, while `h_decompose`, `h_decompose_or`, and `h_decompose_and` split compound propositions into simpler subgoals during proof construction.",
      "description_length": 424,
      "index": 1032,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Autorewrite",
      "library": "rocq-runtime.tactics",
      "description": "This module implements automated rewriting tactics that operate on Coq's internal terms, using configurable rule sets and hint databases to drive equational reasoning. It supports defining, adding, and applying rewriting rules with control over matching and side-condition solving, enabling targeted transformations of proof goals. The rule management submodule allows inspection and manipulation of individual rules, including their associated lemmas, directions, and tactics, making it possible to build custom rewriting strategies. For example, users can define a rule set for simplifying arithmetic expressions or selectively rewrite subterms in a proof while ensuring correctness through generated side conditions.",
      "description_length": 719,
      "index": 1033,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stdarg",
      "library": "rocq-runtime.tactics",
      "description": "This module supports parsing, semantic resolution, and uniform handling of syntactic constructs in Coq, such as identifiers, global references, hypotheses, and Coq terms. It operates on primitive types like booleans, integers, and strings, alongside structured forms like located identifiers and resolved global references, enabling consistent argument interpretation across tactics and commands. Specific use cases include processing tactic arguments that require contextual resolution of terms, hypotheses, or numeric values during proof scripting or command execution.",
      "description_length": 571,
      "index": 1034,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cbn",
      "library": "rocq-runtime.tactics",
      "description": "This module implements weak-head and full normalization variants of the cbn (call-by-name normal) reduction strategy for Coq's kernel-level terms. It operates on `EConstr.constr` values, using reduction flags, environments, and evar maps to control and track the reduction process. It is used during typechecking and proof normalization to simplify terms according to Coq's definitional equality.",
      "description_length": 396,
      "index": 1035,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Class_tactics",
      "library": "rocq-runtime.tactics",
      "description": "This module implements automated typeclass resolution with customizable search strategies and debugging options. It provides tactics for solving goals using depth- or breadth-first search, hint databases, and transparency settings, operating on typeclass constraints with backtracking and dependency handling. Main data types include goals and hint databases, with operations for solver registration, search control, and instance resolution. Examples include resolving implicit arguments, discharging proof obligations, and customizing search behavior through hints and modes.",
      "description_length": 576,
      "index": 1036,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Evar_tactics",
      "library": "rocq-runtime.tactics",
      "description": "This module provides tactics for instantiating existential variables and introducing local definitions during proof construction. It operates on proof goals by manipulating hypotheses and evars, using identifiers, names, and constrained terms. Concrete use cases include refining incomplete proof terms by assigning values to existential variables or creating new hypotheses from computed expressions.",
      "description_length": 401,
      "index": 1037,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hints",
      "library": "rocq-runtime.tactics",
      "description": "This component orchestrates hint management for proof automation by integrating hint databases with logical decomposition and mode parsing. It centers on data types like `Hint_db`, glob references, and hint terms, offering operations to decompose goals, adjust transparency, and control resolution behavior through locality and mode settings. The core module coordinates global hint strategies, while submodules handle hint retrieval by priority or pattern and maintain dynamic databases that support eauto/auto tactics. Examples include optimizing proof search by filtering hints based on section variables or applying stored lemmas during tactic execution using structured hint runs.",
      "description_length": 685,
      "index": 1038,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppred",
      "library": "rocq-runtime.tactics",
      "description": "This module provides functions for pretty-printing reduction-related constructs, such as red flags, occurrences, and reduction expressions. It operates on data types like `Genredexpr.glob_red_flag`, `Genredexpr.red_expr_gen`, and `Locus.occurrences_gen`, typically used in the context of Coq's reduction mechanisms. Concrete use cases include formatting reduction strategies and occurrence annotations for display or debugging in proof assistants.",
      "description_length": 447,
      "index": 1039,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EClause",
      "library": "rocq-runtime.tactics",
      "description": "This module creates and manipulates clauses built from evars, generating holes for each quantified variable in a type. It provides functions to construct clauses by replacing variables with evars, solve those holes using bindings, and validate the resulting terms. Concrete use cases include supporting tactic-based proof refinement by managing incomplete terms and resolving evar instantiations during type checking.",
      "description_length": 417,
      "index": 1040,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genredexpr",
      "library": "rocq-runtime.tactics",
      "description": "This module processes reduction expressions in both raw and globally resolved forms, supporting operations like normalization and head reduction. It works with types such as `r_trm`, `r_pat`, `r_cst` for parsed expressions and `g_trm`, `g_pat`, `g_cst` for globally interned terms and patterns. It is used to represent and manipulate reducible expressions during tactic execution and proof processing.",
      "description_length": 401,
      "index": 1041,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rewrite",
      "library": "rocq-runtime.tactics",
      "description": "This module orchestrates rewrite strategies for term manipulation in Coq's proof system, combining unary, binary, and n-ary operations with support for reflexivity, symmetry, and transitivity. It coordinates with internal modules that handle signature construction and morphism transformations, using EConstr and Constrexpr to manage constraints and term instantiation during rewriting. Key operations include building equivalence chains, simplifying terms under custom strategies, and applying setoid transitivity in dependent contexts. Together, these capabilities enable precise, automated proof transformations backed by Coq's logical foundations.",
      "description_length": 651,
      "index": 1042,
      "embedding_norm": 1.0
    },
    {
      "module_path": "DeclareScheme",
      "library": "rocq-runtime.tactics",
      "description": "This module manages the registration and lookup of inductive scheme constants. It associates inductive types with their corresponding scheme constants, supporting operations to declare, retrieve, and list all registered schemes. It is used to track generated induction principles and related constructs for inductive types.",
      "description_length": 323,
      "index": 1043,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Redexpr",
      "library": "rocq-runtime.tactics",
      "description": "This module evaluates reduction expressions and manages their interpretation in different environments, supporting operations like `eval_red_expr` and `reduction_of_red_expr_val` for applying reductions and extracting reduction functions. It works with core data types such as `red_expr`, `red_expr_val`, and occurrence structures, enabling fine-grained control over normalization and reduction strategies. The first child module compiles raw red expressions into typed forms using a context, supporting tasks like strategy compilation in proof environments, while the second interprets these expressions within evaluation contexts involving terms, evars, and patterns. Together, they enable defining custom reductions, expanding constants, substituting kernel names, and implementing strategies like HNF or CBV in Coq's evaluation flow.",
      "description_length": 837,
      "index": 1044,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Inv",
      "library": "rocq-runtime.tactics",
      "description": "This module implements inversion tactics for proof manipulation, handling hypothesis elimination and case analysis. It works with proof terms, quantified hypotheses, and optional constructor constraints. Concrete use cases include structured inversion on inductive types, selective hypothesis clearing, and pattern-based introduction of derived goals during proof construction.",
      "description_length": 377,
      "index": 1045,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Rtauto_plugin.Proof_search",
      "library": "rtauto_plugin",
      "description": "This module implements a proof search algorithm for intuitionistic propositional logic. It manipulates logical formulas composed of atoms, implications, conjunctions, disjunctions, and falsity, and constructs proofs using natural deduction rules. The core operations include state initialization, proof projection, branching for backtracking search, and success checking, with concrete use cases in automated theorem proving and logic-based verification tasks.",
      "description_length": 460,
      "index": 1046,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rtauto_plugin.Refl_tauto",
      "library": "rtauto_plugin",
      "description": "This module implements a reflexive tautology solver for Coq's proof engine. It provides functions to convert Coq terms into logical formulas and manage atomic propositions during proof search. The `rtauto_tac` tactic applies propositional reasoning to automatically discharge goals using a combination of hypothesis analysis and formula normalization.",
      "description_length": 351,
      "index": 1047,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rtauto_plugin",
      "library": "rtauto_plugin",
      "description": "This module combines automated theorem proving techniques for intuitionistic propositional logic with Coq's proof engine. It supports logical formula manipulation using atoms, implications, conjunctions, disjunctions, and falsity, and performs proof search through state initialization, branching, and success checking. The module integrates with Coq via a reflexive tactic that normalizes formulas and discharges goals using hypothesis analysis. Example use cases include verifying logical equivalences and automatically proving propositional theorems within Coq.",
      "description_length": 564,
      "index": 1048,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vernac.State",
      "library": "rocq-runtime.toplevel",
      "description": "This module manages the state of vernacular parsing, tracking the document, proof context, and timing information. It provides functions to update and retrieve the current parsing state, including handling proof mode transitions and output timing. Concrete use cases include maintaining context during interactive proof development and logging execution times for commands.",
      "description_length": 373,
      "index": 1049,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqloop",
      "library": "rocq-runtime.toplevel",
      "description": "Handles the interactive read-evaluate-print loop for executing Coq commands. It maintains input buffers and state, processes user input, and feeds feedback during command execution. Useful for running Coq scripts interactively or in batch mode, managing OCaml toplevel state transitions, and handling command-line options during execution.",
      "description_length": 339,
      "index": 1050,
      "embedding_norm": 1.0
    },
    {
      "module_path": "G_toplevel",
      "library": "rocq-runtime.toplevel",
      "description": "This module defines a variant type for top-level commands in a proof system, including navigation, quitting, and goal-display operations. It provides parsers and entry points for handling these commands, specifically working with proof modes and goal identifiers. Concrete use cases include implementing command-line interactions for proof assistants, such as stepping back in a proof, displaying current goals, or showing proof differences.",
      "description_length": 441,
      "index": 1051,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common_compile",
      "library": "rocq-runtime.toplevel",
      "description": "This module handles file path manipulations, existence checks, and error signaling during compilation tasks. It provides functions for ensuring file extensions, constructing target paths, safely removing extensions, and verifying proof completion. Concrete use cases include managing source-to-target file conversions, enforcing file presence with specific extensions, and halting compilation on proof-related errors.",
      "description_length": 417,
      "index": 1052,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ccompile",
      "library": "rocq-runtime.toplevel",
      "description": "This module compiles Coq source files into bytecode or native code, using options and arguments passed through Coqargs, Stm.AsyncOpts, and Coqcargs. It processes a list of injection commands to customize the compilation process. Concrete use cases include building Coq projects, generating standalone executables, and integrating Coq code into larger applications.",
      "description_length": 364,
      "index": 1053,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Colors",
      "library": "rocq-runtime.toplevel",
      "description": "This module manages color initialization and output styling for terminal or Emacs environments. It defines operations to set color mode (`init_color`), parse color options from command-line arguments (`parse_extra_colors`), and apply style tags based on the selected color mode (`print_style_tags`). It works with a polymorphic variant type representing color modes and string lists for argument parsing.",
      "description_length": 404,
      "index": 1054,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Load",
      "library": "rocq-runtime.toplevel",
      "description": "This module loads initialization vernaculars from the Coq configuration file using command-line options and an initial state. It processes Coq's initialization script to set up the environment with user-defined settings and commands. Useful for initializing Coq sessions with custom configurations during startup.",
      "description_length": 313,
      "index": 1055,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Memtrace_init",
      "library": "rocq-runtime.toplevel",
      "description": "Initializes memory tracing for the application, setting up internal structures to track allocations and deallocations. Works directly with the runtime's memory management system to capture trace data. Useful for profiling memory usage patterns and identifying leaks during performance analysis.",
      "description_length": 294,
      "index": 1056,
      "embedding_norm": 1.0
    },
    {
      "module_path": "WorkerLoop",
      "library": "rocq-runtime.toplevel",
      "description": "Starts a worker process that initializes with a setup function, repeatedly runs a main loop function, and handles command-line arguments. It operates on functions with no arguments or return values, along with string lists for argument parsing. This module is used to implement long-running background workers that process tasks in a loop, such as job queues or event listeners.",
      "description_length": 378,
      "index": 1057,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqc",
      "library": "rocq-runtime.toplevel",
      "description": "Handles command-line arguments and invokes the Coq compiler. It processes a list of file paths to compile Coq source files into bytecode or native code. Useful for batch compilation and integration with build systems.",
      "description_length": 217,
      "index": 1058,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vernac",
      "library": "rocq-runtime.toplevel",
      "description": "This module processes Coq vernacular commands and loads script files while maintaining a precise interpreter state through functions like `process_expr` and `load_vernac`. It manages parsing state, proof context, and timing information, enabling interactive theorem proving sessions and script-based development with strict error handling. Submodule functionality supports tracking document state, proof mode transitions, and performance logging, allowing tools to maintain context and measure command execution times. Example uses include building Coq-based proof assistants, automated script runners, and interactive development environments with real-time feedback.",
      "description_length": 668,
      "index": 1059,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqcargs",
      "library": "rocq-runtime.toplevel",
      "description": "This module defines configuration options for controlling the compilation process, including modes like building `.vo`, `.vos`, or `.vok` files, output naming, and whether to echo commands or output context. It works with strings, booleans, and custom types like `glob_output` to configure compilation behavior. Concrete use cases include setting up command-line arguments for compiling Coq files with specific output formats and verbosity settings.",
      "description_length": 449,
      "index": 1060,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqrc",
      "library": "rocq-runtime.toplevel",
      "description": "Loads a configuration file into the given proof state, updating it with the commands from the file. Works with the `Vernac.State.t` type, representing the state of the Coq interpreter. Useful for initializing or restoring a proof environment from a script file during interactive theorem proving sessions.",
      "description_length": 305,
      "index": 1061,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coqtop",
      "library": "rocq-runtime.toplevel",
      "description": "This module defines a custom toplevel for Coq, providing operations to initialize and start a Coq session with specific configurations such as command-line arguments, load paths, and resource files. It works with data types like `custom_toplevel`, `toplevel_options`, and `query` to control execution modes (interactive, batch, query) and handle debugging actions via LTAC hooks. Concrete use cases include launching a Coq interpreter with custom initialization, querying module UIDs, and managing debug responses during proof scripting.",
      "description_length": 537,
      "index": 1062,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ring_plugin.Ring",
      "library": "ring_plugin",
      "description": "This module provides tactics and utilities for working with ring and field theories in Coq. It supports operations like adding and printing ring and field structures, as well as lookup and protection tactics for managing proof contexts. Concrete use cases include defining and manipulating algebraic structures such as polynomial rings and quotient fields within Coq proofs.",
      "description_length": 374,
      "index": 1063,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ring_plugin.G_ring",
      "library": "ring_plugin",
      "description": "This module defines and manipulates ring and field structures in Coq's syntax tree. It provides typed entries and witnesses for ring_mod, field_mod, and their list variants, enabling the representation of algebraic structures within Coq's vernacular. These are used to implement and reason about algebraic theories directly in Coq scripts.",
      "description_length": 339,
      "index": 1064,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ring_plugin.Ring_ast",
      "library": "ring_plugin",
      "description": "This module defines data structures and operations for representing ring and field tactic specifications in a Coq plugin. It includes types for constant tactic expressions and records containing metadata, carriers, required properties, and associated tactics for rings and fields. It is used to configure and execute automated reasoning procedures over algebraic structures in proof scripts.",
      "description_length": 391,
      "index": 1065,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ring_plugin",
      "library": "ring_plugin",
      "description": "This module enables the definition, manipulation, and automated reasoning of ring and field structures within Coq. It provides core data types such as ring_mod, field_mod, and their list variants, along with operations to register, look up, and protect these structures in proof contexts. The module supports concrete tasks like implementing polynomial rings, quotient fields, and configuring tactics for automated algebraic reasoning in Coq scripts.",
      "description_length": 450,
      "index": 1066,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_core_plugin.Polynom.Make",
      "library": "nsatz_core_plugin",
      "description": "This module provides polynomial arithmetic operations including addition, multiplication, division, greatest common divisor computation, and symbolic differentiation, alongside normalization and hashing for efficient term caching. It operates on recursively defined polynomials parameterized by integer variables and coefficients from an external type, supporting symbolic algebra tasks like equation solving and algebraic simplification in computational mathematics or formal verification contexts.",
      "description_length": 499,
      "index": 1067,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_core_plugin.Ideal.Monomial",
      "library": "nsatz_core_plugin",
      "description": "This module represents monomials as integer arrays, providing functions to create and inspect them. It works with arrays of integers to encode monomial structures. Concrete use cases include manipulating algebraic terms in polynomial ideals.",
      "description_length": 241,
      "index": 1068,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_core_plugin.Polynom.S",
      "library": "nsatz_core_plugin",
      "description": "This module provides polynomial arithmetic, normalization, and analysis operations for recursive polynomials with integer coefficients, supporting addition, multiplication, differentiation, GCD computation, and variable manipulation. It works with a recursive polynomial type indexed by integer variables, offering utilities for hashing, printing, and content extraction, while handling operations like pseudo-division and monomial expansion. Designed for symbolic computation tasks, it enables algebraic simplification and polynomial manipulation in formal verification or symbolic mathematics contexts.",
      "description_length": 604,
      "index": 1069,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nsatz_core_plugin.Ideal.Make",
      "library": "nsatz_core_plugin",
      "description": "This module implements polynomial arithmetic and ideal membership computations using a coefficient type from module P. It provides operations for constructing and manipulating multivariate polynomials, including addition, multiplication, exponentiation, and equality testing, along with generating certificates for ideal membership. Concrete use cases include symbolic computation in algebraic geometry and formal verification of polynomial identities.",
      "description_length": 452,
      "index": 1070,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nsatz_core_plugin.Polynom.Coef",
      "library": "nsatz_core_plugin",
      "description": "This module defines arithmetic operations and comparisons for a coefficient type, including addition, multiplication, division, exponentiation, and GCD. It supports numeric manipulation and hashing of coefficients, converting between rational numbers and the internal representation. Concrete use cases include polynomial coefficient handling, symbolic computation, and number-theoretic algorithms.",
      "description_length": 398,
      "index": 1071,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_core_plugin.Polynom",
      "library": "nsatz_core_plugin",
      "description": "This module manipulates polynomials over an abstract coefficient domain, representing them as term lists and supporting operations like addition, multiplication, and normalization. It integrates arithmetic, differentiation, GCD computation, and variable manipulation for recursive polynomials indexed by integer variables, enabling symbolic algebra tasks such as equation solving and simplification. Submodules refine coefficient handling with numeric operations, hashing, and conversions, while others extend polynomial analysis with division, monomial expansion, and efficient term caching. Example uses include symbolic differentiation, algebraic simplification, and GCD-based polynomial reduction in formal verification or computational mathematics.",
      "description_length": 753,
      "index": 1072,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nsatz_core_plugin.Utile",
      "library": "nsatz_core_plugin",
      "description": "This module provides low-level debugging and logging functions for printing values and diagnostic messages during program execution. It works directly with strings and generic values through polymorphic printing functions. Concrete use cases include tracing function outputs, logging intermediate states, and displaying debug information in interactive environments.",
      "description_length": 366,
      "index": 1073,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_core_plugin.Ideal",
      "library": "nsatz_core_plugin",
      "description": "This module provides tools for working with polynomial ideals over rings, combining monomial manipulation, polynomial arithmetic, and ideal membership testing. It represents monomials as integer arrays and supports operations like addition, multiplication, and exponentiation on multivariate polynomials, using a coefficient type from an external module. Users can construct Gr\u00f6bner bases, verify polynomial identities, and solve algebraic systems symbolically. It enables concrete tasks such as automated theorem proving in ring theory and symbolic computation in algebraic geometry.",
      "description_length": 584,
      "index": 1074,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nsatz_core_plugin.Nsatz",
      "library": "nsatz_core_plugin",
      "description": "This module provides the `nsatz_compute` tactic, which performs computational checks for algebraic reasoning in proofs. It operates on Coq's `Constr.t` type, representing terms in the proof context. A concrete use case is verifying equalities in polynomial expressions during interactive theorem proving.",
      "description_length": 304,
      "index": 1075,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nsatz_core_plugin",
      "library": "nsatz_core_plugin",
      "description": "This module combines symbolic polynomial manipulation, debugging utilities, ideal theory operations, and proof automation for algebraic reasoning. It supports polynomials over abstract coefficients with operations like addition, multiplication, GCD, and Gr\u00f6bner basis construction, while offering low-level logging and a tactic for verifying polynomial equalities in Coq. Examples include symbolic differentiation, ideal membership testing, and automated verification of algebraic identities during proof development.",
      "description_length": 517,
      "index": 1076,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vm_printers",
      "library": "rocq-runtime.dev",
      "description": "This module provides functions to print various internal data structures used in a virtual machine, such as reloc_info, sorts, id_key, zipper, stack, atom, kind, vblock, varray, and values. Each function is tailored to a specific type, enabling direct inspection of structured data during execution or debugging. Concrete use cases include logging machine state, tracing evaluation steps, and displaying intermediate results in a readable format.",
      "description_length": 446,
      "index": 1077,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Top_printers",
      "library": "rocq-runtime.dev",
      "description": "This module specializes in converting complex OCaml and Coq internal data structures\u2014such as identifiers, proof terms, constraints, universes, and environments\u2014into human-readable representations through pretty-printing and direct output operations. It works extensively with kernel-level types like `Constr.t`, `Evar.t`, `Id.Map.t`, and `Genarg.generic_argument`, as well as logical constructs including metavariables, substitutions, and tactic expressions. These utilities are primarily used in interactive proof development environments to inspect proof states, debug type-checking processes, and visualize abstract syntax trees or logical terms during formal verification workflows.",
      "description_length": 686,
      "index": 1078,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coq_checklib.Analyze.Input",
      "library": "rocq-runtime.checklib",
      "description": "This module defines an abstract type `t` representing input sources that support reading raw bytes and integers. It provides two operations: `input_byte` reads a single byte as an integer, and `input_binary_int` reads a 31-bit signed integer in big-endian format. It is used for low-level parsing of binary data, such as deserializing input streams or decoding binary file formats.",
      "description_length": 381,
      "index": 1079,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Analyze.LargeArray",
      "library": "rocq-runtime.checklib",
      "description": "This module implements an array-like data structure that supports creating, accessing, and modifying elements with lengths exceeding 2^22 on 32-bit systems. It provides operations for initializing arrays with a given size and value, retrieving elements by index, and updating elements in place. This structure is particularly useful for handling very large datasets that would otherwise exceed the standard array size limit.",
      "description_length": 424,
      "index": 1080,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Analyze.Make",
      "library": "rocq-runtime.checklib",
      "description": "This module parses a marshalled input structure into a reified memory representation and extracts an entry point. It operates on an input type defined by the parameter module M and returns a tuple containing analysis data and a large array of objects. A concrete use case is loading and preparing serialized Coq proof data for further analysis.",
      "description_length": 344,
      "index": 1081,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Analyze.S",
      "library": "rocq-runtime.checklib",
      "description": "This module parses a marshalled input structure into a reified memory representation and an entry point. It operates on raw input data, producing a tuple containing analysis data and a large array of objects. Use this module to load and prepare serialized Coq memory dumps for further analysis or processing.",
      "description_length": 308,
      "index": 1082,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Validate",
      "library": "rocq-runtime.checklib",
      "description": "Performs validation of a given value against analysis data and a collection of analyzed objects. Works with `value` and `Analyze.data` types, alongside a large array structure for efficient object storage. Useful for verifying correctness of evaluated expressions in a proof-checking context.",
      "description_length": 292,
      "index": 1083,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.CheckFlags",
      "library": "rocq-runtime.checklib",
      "description": "Sets typing flags in the environment, excluding flags ignored by the checker. Operates on `Declarations.typing_flags` and `Environ.env` types. Used to configure type-checking behavior in the Coq proof assistant.",
      "description_length": 211,
      "index": 1084,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Coq_checklib.Values",
      "library": "rocq-runtime.checklib",
      "description": "This module defines a `value` type representing structured data used for validation and symbolic computation, along with operations to construct and compare values. Functions like `v_tuple`, `v_sum`, and `v_annot` build complex values with specific shapes, while `equal` and `kind` inspect their structure and equality. It supports concrete use cases such as modeling Coq expressions, validating term structures, and handling recursive or opaque data definitions.",
      "description_length": 463,
      "index": 1085,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.CheckInductive",
      "library": "rocq-runtime.checklib",
      "description": "This module validates inductive type definitions within a given environment, ensuring they adhere to logical consistency and structural rules. It processes mutual inductive definitions, verifying constructors and their types against the environment. Used during the compilation of inductive data types in Coq to ensure correctness before further processing.",
      "description_length": 357,
      "index": 1086,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Mod_checking",
      "library": "rocq-runtime.checklib",
      "description": "This module sets an accessor for opaque proofs and validates modules within a specific environment, working with opaque proof terms and module structures. It handles dependency tracking and module body verification. Concrete use cases include checking module correctness during compilation and managing opaque proof references in a proof assistant context.",
      "description_length": 356,
      "index": 1087,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Safe_checking",
      "library": "rocq-runtime.checklib",
      "description": "Performs safe and unsafe imports of compiled libraries into a typing environment, updating the environment and dependency tracking structures. It operates on typing environments, compiled libraries, and disk-based VM libraries, using module dependency graphs and digest information. Used during Coq's proof checking to load and validate external libraries while maintaining consistency and trust levels.",
      "description_length": 403,
      "index": 1088,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Analyze",
      "library": "rocq-runtime.checklib",
      "description": "This module processes serialized data into structured values, supporting complex forms like integers, atoms, and structured objects through parsing functions such as `parse_channel` and `parse_string`. It integrates low-level input handling, large array manipulation, and memory reification for deserializing and analyzing complex data like Coq proofs and memory dumps. Key data types include input sources for byte-level parsing, large arrays for handling oversized datasets, and reified memory representations with entry points. You can use it to load binary data streams, process large serialized structures, and reconstruct and analyze dumped memory contents.",
      "description_length": 663,
      "index": 1089,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.CheckLibrary",
      "library": "rocq-runtime.checklib",
      "description": "This module manages Coq library paths and rechecking operations. It supports adding load paths that map physical directories to logical namespaces and rechecks libraries while handling dependencies with options to skip, admit, or fully check specific files. It works with Coq's safe environment, tracking dependencies and module paths during rechecking.",
      "description_length": 353,
      "index": 1090,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Coqchk_main",
      "library": "rocq-runtime.checklib",
      "description": "This module defines the `main` function that serves as the entry point for executing the Coq checker. It initializes and runs the core validation process for Coq proof terms. Use this module to start the checker in a standalone context, such as from a command-line interface.",
      "description_length": 275,
      "index": 1091,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib.Check_stat",
      "library": "rocq-runtime.checklib",
      "description": "Tracks and outputs statistical information about Coq proof environments and context usage. It provides global flags to enable memory statistics and context output, and a function to compute and display statistics from a given environment and name map. Useful for analyzing proof context size and structure during Coq development.",
      "description_length": 329,
      "index": 1092,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coq_checklib",
      "library": "rocq-runtime.checklib",
      "description": "This module suite provides validation, type-checking, and data processing capabilities for Coq proof terms and environments. It centers around the `value` type for structured data modeling, supports inductive type verification, opaque proof handling, and module validation, and includes mechanisms for importing and serializing complex data. You can use it to verify Coq expressions, load and check external libraries, parse binary proof data, and analyze type-correctness in compiled definitions. Key operations include value construction with `v_tuple` and `v_sum`, environment configuration with typing flags, and structured data parsing from channels or strings.",
      "description_length": 666,
      "index": 1093,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tuto2_plugin.G_tuto2",
      "library": "tuto2_plugin",
      "description": "This module defines a custom argument type and entry point for parsing and processing a specific custom type in the context of Coq's plugin system. It integrates directly with Coq's parsing and proof engine to support vernacular commands and tactic definitions. The `wit_custom` value handles argument witnessing, while `custom` provides the entry point for parsing custom values.",
      "description_length": 380,
      "index": 1094,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto2_plugin.Persistent_counter",
      "library": "tuto2_plugin",
      "description": "Tracks and manages a persistent integer counter across program runs. It provides `increment` to increase the counter by one and `value` to retrieve the current count. Useful for scenarios like tracking application launches or event occurrences.",
      "description_length": 244,
      "index": 1095,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto2_plugin.Counter",
      "library": "tuto2_plugin",
      "description": "Tracks and modifies a counter value with `increment` to increase the count and `value` to retrieve the current count. Uses an internal mutable state to maintain the counter. Useful for scenarios requiring a simple, persistent count across function calls, such as tracking events or iterations.",
      "description_length": 293,
      "index": 1096,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto2_plugin.Custom",
      "library": "tuto2_plugin",
      "description": "Defines a custom sum type with two variants, `Foo` and `Bar`. Directly represents simple enumerated states or flags in the application. Useful for modeling binary choices or status indicators in domain logic.",
      "description_length": 208,
      "index": 1097,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto2_plugin",
      "library": "tuto2_plugin",
      "description": "This module provides functionality for defining custom Coq plugin arguments, tracking persistent integer counters, and representing binary states. It includes a custom argument type for Coq's plugin system with parsing and witnessing capabilities, two counter implementations\u2014one persistent across runs and one with mutable state\u2014and a sum type for modeling binary choices. You can define custom Coq commands, track application events, and represent flags like `Foo` or `Bar` in domain logic. For example, you can parse custom values in Coq, increment a counter on each program run, or use the `Foo` variant to signal a specific state.",
      "description_length": 635,
      "index": 1098,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tuto3_plugin.Tuto_tactic",
      "library": "tuto3_plugin",
      "description": "This module defines specific tactics for manipulating lambda expressions and packing them into a structured form. It operates on Coq's `EConstr.t` and `Evd.evar_map` types, extracting and transforming lambda-bound variables and their bodies. A concrete use case is automating the refactoring of lambda expressions during proof development.",
      "description_length": 339,
      "index": 1099,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto3_plugin.Construction_game",
      "library": "tuto3_plugin",
      "description": "This module implements functions for constructing and manipulating proof terms in a goal-directed manner. It provides operations for generating identity terms with unassigned existential variables, demonstrating lambda applications in specific sort contexts, and working with type classes and canonical structures through concrete examples. These functions are used to illustrate and test term construction patterns in interactive theorem proving scenarios.",
      "description_length": 457,
      "index": 1100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto3_plugin",
      "library": "tuto3_plugin",
      "description": "This module provides tools for working with lambda expressions and proof terms in Coq's tactic system. It includes operations to extract and transform lambda-bound variables and bodies, as well as functions to generate identity terms with existential variables and manipulate type classes. You can use it to automate refactoring of lambda expressions or construct proof terms interactively. For example, it enables transforming a lambda expression into a structured form or building a proof term with unassigned evars in a specific context.",
      "description_length": 540,
      "index": 1101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Btauto_plugin.Refl_btauto.Btauto",
      "library": "btauto_plugin",
      "description": "This module implements a reflexive tactic for solving equations in a specific algebraic structure, typically used in proof assistants to automate equality reasoning. It operates on terms representing algebraic expressions and applies normalization techniques to determine equivalence. A concrete use case is automating proofs of associativity, commutativity, and other equational properties in a given theory.",
      "description_length": 409,
      "index": 1102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Btauto_plugin.Refl_btauto",
      "library": "btauto_plugin",
      "description": "This module provides a reflexive tactic for automating equality proofs in algebraic structures by normalizing and comparing terms. It supports operations like associativity, commutativity, and other equational reasoning tasks on algebraic expressions. The core data types include representations of terms and equations, with operations to apply normalization rules and check equivalence. For example, it can automatically prove that two expressions built from associative and commutative operators are equal by reducing them to a canonical form.",
      "description_length": 545,
      "index": 1103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Btauto_plugin",
      "library": "btauto_plugin",
      "description": "This module implements a reflexive tactic for automating equality proofs in algebraic structures by normalizing terms according to rules like associativity and commutativity. It provides data types for representing algebraic terms and equations, along with operations to apply normalization and check equivalence. For instance, it can automatically verify that two expressions using associative and commutative operators are equivalent by reducing both to a canonical form and comparing the results.",
      "description_length": 499,
      "index": 1104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto0_plugin.G_tuto0",
      "library": "tuto0_plugin",
      "description": "This module defines a warning category and a function to issue a specific warning with an optional location. It works with the `CWarnings` module's category type and the `Loc.t` location type. It is used to trigger tutorial-specific warnings during compilation or analysis tasks.",
      "description_length": 279,
      "index": 1105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto0_plugin.Tuto0_main",
      "library": "tuto0_plugin",
      "description": "Contains a single value `message` holding a string, used to store or retrieve a specific textual payload. Works directly with string data types. Serves as a simple container for a shared message in applications requiring a single point of string access or configuration.",
      "description_length": 270,
      "index": 1106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto0_plugin",
      "library": "tuto0_plugin",
      "description": "This module provides functionality for issuing tutorial-specific warnings and managing a shared string message. It includes a warning category and a function to trigger warnings with optional locations, along with a mutable string value for centralized message handling. You can use it to emit custom warnings during analysis or compilation and to store or retrieve a global string configuration. For example, it can signal deprecated constructs with precise source locations or maintain a dynamically updated status message.",
      "description_length": 525,
      "index": 1107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Clenv.Internal",
      "library": "rocq-runtime.proofs",
      "description": "Handles legacy operations for refining and manipulating open terms in the proof engine. Works with deprecated clausenv structures representing incomplete proof terms. Used internally for backward compatibility with older proof scripts relying on term hole resolution.",
      "description_length": 267,
      "index": 1108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Refine",
      "library": "rocq-runtime.proofs",
      "description": "This module implements the core refine tactic for filling proof holes in interactive theorem proving. It provides functions to apply partial proof terms, handle unification constraints, and manage subgoals derived from incomplete terms. Key operations include `refine`, `refine_with_principal`, and `solve_constraints`, which directly manipulate evar_maps and proof goals during tactic execution.",
      "description_length": 396,
      "index": 1109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tactypes",
      "library": "rocq-runtime.proofs",
      "description": "This module defines core tactic-related types used in Coq's proof engine, including introduction patterns, delayed open constructions, and naming expressions. It supports operations for hypothesis manipulation, pattern matching, and tactic composition in proof scripts. These types are essential for implementing and composing tactics that handle variable introduction, case analysis, and term instantiation.",
      "description_length": 408,
      "index": 1110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tacmach",
      "library": "rocq-runtime.proofs",
      "description": "This module provides operations for inspecting and transforming proof goals, including hypothesis management, term normalization, and type-checking within Coq's tactic system. It primarily works with `Proofview.Goal.t` structures to manipulate typing environments and convert goals into human-readable representations. Specific use cases include pretty-printing proof states for user feedback and dynamically adjusting contexts during tactic execution.",
      "description_length": 452,
      "index": 1111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Clenv",
      "library": "rocq-runtime.proofs",
      "description": "This module manages environments for open terms with metavariables, supporting operations like instantiation, unification, and binding of existential variables. It provides direct access to term manipulation in Coq's proof engine, allowing tasks such as posing dependent evars and tracking dependencies. The child module extends these capabilities with legacy refinement operations, enabling backward-compatible handling of incomplete proof terms and term hole resolution. Together, they support debugging via pretty-printing and are primarily used in older proof scripts for proof refinement and tactic development.",
      "description_length": 616,
      "index": 1112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proof",
      "library": "rocq-runtime.proofs",
      "description": "This module supports operations for structured proof state management, including goal focusing, tactic execution, and proof data extraction, while tracking evar_maps, goal hierarchies, and context environments. It manipulates proof terms through tactic application, existential variable resolution, and context-aware transformations using types like `Proof.t`, `Environ.env`, and `Proofview.tactic`. Designed for interactive theorem proving, it enables use cases such as stepwise goal refinement, context-sensitive proof validation, and automated subgoal shelving/unshelving during tactic composition.",
      "description_length": 601,
      "index": 1113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goal_select",
      "library": "rocq-runtime.proofs",
      "description": "This module defines goal selection strategies for proof navigation, supporting operations like selecting a specific goal by index, a range of goals, or all goals. It provides functions to print goal selectors, retrieve a default selector, and apply a selected goal to a tactic. Concrete use cases include directing proof automation to focus on particular subgoals during interactive theorem proving.",
      "description_length": 399,
      "index": 1114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Proof_bullet",
      "library": "rocq-runtime.proofs",
      "description": "This module defines bullet behaviors for proof structuring, supporting operations to focus and defocus proof goals using bullets like dashes, stars, and pluses. It manipulates proof states through registered behavior callbacks, enabling Coq users to customize bullet handling via commands like Set Bullet Behavior. Concrete use cases include guiding proof flow in interactive theorem proving and structuring proof scripts with visual indicators.",
      "description_length": 445,
      "index": 1115,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Miscprint",
      "library": "rocq-runtime.proofs",
      "description": "This module handles the pretty-printing of Coq tactic expressions, specifically for patterns used in introduction and binding contexts. It provides functions to convert structures like `intro_pattern_expr`, `or_and_intro_pattern_expr`, and `bindings` into human-readable `Pp.t` output. These operations are essential for displaying tactic arguments in proof scripts or error messages.",
      "description_length": 384,
      "index": 1116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Logic",
      "library": "rocq-runtime.proofs",
      "description": "This module implements a legacy proof engine for managing hypotheses and type checking in a logical context. It provides operations for introducing, converting, and moving hypotheses within a named context, ensuring proper scoping and type convertibility. Key functions handle errors like unresolved bindings or invalid hypothesis moves, and manipulate data structures such as `EConstr.named_declaration`, `Environ.named_context_val`, and `refiner_error`.",
      "description_length": 455,
      "index": 1117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssrmatching_plugin.Ssrmatching.Internal",
      "library": "ssrmatching_plugin",
      "description": "This module handles the construction, transformation, and printing of pattern-matching terms used in the SSReflect tactic language. It provides functions for substituting, globbing, and interpreting both raw and constrained patterns, along with utilities to build and manipulate pattern expressions from Coq's AST. Concrete use cases include processing match patterns during tactic execution and preparing terms for unification in proof scripts.",
      "description_length": 445,
      "index": 1118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssrmatching_plugin.G_ssrmatching",
      "library": "ssrmatching_plugin",
      "description": "This module defines parsing entries and argument types for pattern matching constructs used in proof scripting. It supports concrete syntax forms like `(f _)`, `(X in t)`, and `(t as X in t)` for both constrained and unconstrained patterns. These are used to specify match targets and bindings in tactics that manipulate proof terms and goals.",
      "description_length": 343,
      "index": 1119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssrmatching_plugin.Ssrmatching",
      "library": "ssrmatching_plugin",
      "description": "This module provides core facilities for parsing, evaluating, and transforming structured patterns in Coq's Ltac2, working directly with term representations like `EConstr.t`, environments, and evar maps. It supports directional matching, occurrence-based transformations, and advanced unification through pattern types such as `cpattern` and `rpattern`, enabling precise term inspection and stateful closures in proof automation. The child module extends this by handling pattern construction, substitution, and AST manipulation, allowing tactics to process and prepare terms for unification or rewriting. Together, they power SSReflect's custom matching and transformation capabilities, used in match expressions, tactic scripting, and term manipulation workflows.",
      "description_length": 766,
      "index": 1120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ssrmatching_plugin",
      "library": "ssrmatching_plugin",
      "description": "This module implements pattern matching infrastructure for proof scripting in Coq, handling both syntactic parsing and semantic evaluation of patterns in tactics. It introduces core data types like `cpattern` and `rpattern` to represent constrained and unconstrained patterns, along with operations for directional matching, substitution, and term transformation. Users can write patterns such as `(f _)`, `(X in t)`, and `(t as X in t)` to bind variables, restrict matches, and manipulate proof terms during automation. These capabilities enable precise goal and hypothesis manipulation, supporting advanced rewriting and structured proof search.",
      "description_length": 647,
      "index": 1121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printer.ContextObjectMap.Monad",
      "library": "rocq-runtime.printing",
      "description": "This module provides monadic traversal and transformation operations over a map structure that binds keys to values. It supports operations like `fold`, `mapi`, `fold_left`, and `fold_right`, which allow mapping functions to be applied across key-value pairs, producing results within a monadic context. It is used for processing context objects during term printing, where each key represents a context identifier and the associated value must be transformed or inspected in sequence.",
      "description_length": 485,
      "index": 1122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printer.ContextObjectMap.Smart",
      "library": "rocq-runtime.printing",
      "description": "This module provides optimized mapping operations that preserve sharing in context object maps, specifically through the `map` and `mapi` functions. It works with `'a Printer.ContextObjectMap.t`, a structure representing mappings from context objects to values. It is useful when transforming context-bound data while maintaining identity across shared nodes, such as when rewriting or analyzing terms in a context-sensitive manner.",
      "description_length": 432,
      "index": 1123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printer.ContextObjectSet.List",
      "library": "rocq-runtime.printing",
      "description": "This module operates on lists of context object sets, providing functions to combine and manipulate these sets. It supports operations like taking the union of multiple sets to form a single set. A typical use case involves aggregating context information from different sources into a unified set for analysis or transformation tasks.",
      "description_length": 335,
      "index": 1124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printer.ContextObjectMap",
      "library": "rocq-runtime.printing",
      "description": "This module implements ordered maps keyed by `Printer.context_object`, enabling functional updates and ordered traversal while supporting context-sensitive transformations through folds and maps. It provides core operations like insertion, deletion, and ordered iteration, along with submodules that extend functionality to monadic traversals and sharing-preserving transformations. The monadic submodule allows sequencing effects across key-value pairs, useful for term printing where each binding must be processed in sequence, while the optimized mapping submodule ensures efficient transformations that preserve structural identity. Together, these capabilities support structured manipulation of hierarchical context data, such as proof state annotations or term attributes, with precise control over ordering and sharing.",
      "description_length": 827,
      "index": 1125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Printer.ContextObjectSet",
      "library": "rocq-runtime.printing",
      "description": "This module manages collections of `Printer.context_object` elements, offering standard set operations like membership testing, insertion, deletion, and algebraic transformations such as union, intersection, and difference. It supports direct manipulation of sets through `Printer.ContextObjectSet.t` values, with utilities for converting sequences to sets, checking cardinality, and applying iterative transformations. The child module extends this functionality to operate on lists of sets, enabling aggregation and combination of multiple sets\u2014such as merging context data from disparate sources into a single unified set. Specific uses include deduplicating context objects, computing overlaps between tactic-generated sets, and building composite context views for analysis.",
      "description_length": 779,
      "index": 1126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printer.Debug",
      "library": "rocq-runtime.printing",
      "description": "This module provides a function `pr_goal` that converts a proof goal into a printable format using the `Pp.t` type. It is designed for debugging purposes, allowing developers to inspect the structure of proof goals during tactic development or proof exploration. The function directly supports the visualization of complex proof state data in a human-readable form.",
      "description_length": 365,
      "index": 1127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Genprint",
      "library": "rocq-runtime.printing",
      "description": "This module handles the registration and definition of generic printers for Coq's argument types, supporting pretty-printing at raw, glob, and top levels. It works with environments, evar maps, and custom levels to produce formatted output for terms and commands. Concrete use cases include printing proof terms, tactic arguments, and vernacular command parameters in a customizable way.",
      "description_length": 387,
      "index": 1128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Printer",
      "library": "rocq-runtime.printing",
      "description": "This module transforms Coq terms, contexts, and proof structures into human-readable formats using environments and evar maps, supporting operations like compact/expansive formatting, context diffing, and goal-specific rendering. It provides data types such as `Constr.constr`, inductive types, and existential variables, along with ordered maps and sets for structured context manipulation, enabling precise control over ordering and sharing during transformations. Submodules support monadic traversals for sequential processing of context bindings, optimized set operations for merging and analyzing context data, and direct goal visualization via `pr_goal`. Example uses include proof state visualization in coqtop, error diagnostics with context diffs, and tactic development with structured term annotations.",
      "description_length": 814,
      "index": 1129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppextend",
      "library": "rocq-runtime.printing",
      "description": "This module defines data types and functions for controlling the layout of pretty-printed output, including box and break commands that dictate formatting behavior. It works with structures like `ppbox`, `ppcut`, and `unparsing` to specify how terms and notations should be rendered, particularly in the context of Coq's notation system. It is used to customize the display of complex expressions, ensuring proper indentation, line breaks, and grouping during pretty-printing.",
      "description_length": 476,
      "index": 1130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppconstr",
      "library": "rocq-runtime.printing",
      "description": "This module formats Coq's abstract syntax trees, focusing on expressions, coercions, and structural components like binders and sorts, using contextual information from environments and existential variable maps. It employs combinator-based strategies to adjust spacing, separators, and precedence-aware rendering, enabling precise control over output appearance. Typical applications include generating human-readable terms in proof scripts, pretty-printing goals, or exporting expressions with customizable layouts for tools like IDEs or documentation generators.",
      "description_length": 565,
      "index": 1131,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Proof_diffs",
      "library": "rocq-runtime.printing",
      "description": "This module implements functionality for comparing proof states, including goals and hypotheses, and generating human-readable diffs with optional color output. It works with proof terms, environments, and evar_maps to compute differences in conclusions and hypotheses between versions of a proof. Concrete use cases include displaying incremental proof changes in an interactive theorem prover interface and logging proof modifications for debugging or auditing purposes.",
      "description_length": 472,
      "index": 1132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pputils",
      "library": "rocq-runtime.printing",
      "description": "This module provides functions for pretty-printing structured data such as located values, AST nodes, identifiers, and generic arguments, primarily used in Coq's proof and term manipulation. It handles data types like `Loc.located`, `CAst.t`, `lident`, `lname`, and variants like `or_var` and `or_by_notation`, along with comment extraction and formatting. Concrete use cases include displaying parsed terms with source locations, printing expressions with surrounding comments, and rendering generic arguments in both raw and global levels.",
      "description_length": 541,
      "index": 1133,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Derive_plugin.Derive",
      "library": "derive_plugin",
      "description": "Starts a proof to derive a value for a function `f` such that a given lemma holds, returning a proof object. It takes attributes, binders, a constraint expression, and the function identifier, supporting definitions by proof in a context extended with a fresh variable. Useful for interactively defining functions alongside correctness proofs within Coq's vernacular system.",
      "description_length": 374,
      "index": 1134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Derive_plugin",
      "library": "derive_plugin",
      "description": "This module enables interactive function definition alongside correctness proofs by starting a proof obligation for a given lemma. It supports definitions in an extended context with fresh variables, taking attributes, binders, a constraint, and a function identifier to generate a proof object. For example, users can define a function `f` while proving it satisfies a specific property, integrating the proof directly into the function's definition process.",
      "description_length": 459,
      "index": 1135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zify_plugin.Zify.PropUnOp",
      "library": "zify_plugin",
      "description": "This module maps propositional operators to their logical equivalents during tactic execution. It works with hint locality specifications and qualified identifiers to register and print transformation rules. Use it to extend or inspect logical operator mappings in proof automation.",
      "description_length": 282,
      "index": 1136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.BinOpSpec",
      "library": "zify_plugin",
      "description": "This module maps binary operator notations to their corresponding hint locality and qualified identifiers, enabling customizable printing and resolution of operators. It works with hint locality values and qualified identifiers to register and display operator specifications. A typical use case involves extending the pretty-printer or interpreter with user-defined binary operators tied to specific scopes or localities.",
      "description_length": 422,
      "index": 1137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zify_plugin.Zify.BinRel",
      "library": "zify_plugin",
      "description": "This module maps binary relations to their corresponding logical equivalences in the context of proving goals involving integer arithmetic. It provides operations to register hints for local or global use and to print registered binary relations. Use cases include enhancing automated tactic behavior by adding custom relation equivalences for Zify-based reductions.",
      "description_length": 366,
      "index": 1138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.UnOpSpec",
      "library": "zify_plugin",
      "description": "This module registers unary operation specifications for hints and provides a command to print registered operations. It works with hint localities and qualified identifiers. A typical use case is extending the hint database with custom unary operations and inspecting the registered entries.",
      "description_length": 292,
      "index": 1139,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zify_plugin.Zify.S",
      "library": "zify_plugin",
      "description": "This module registers hint localities for identifiers and prints registered hints. It operates on hint localities and qualified identifiers. Use it to manage and display hints in a proof context.",
      "description_length": 195,
      "index": 1140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.CstOp",
      "library": "zify_plugin",
      "description": "Registers and prints constants used in hint databases. Works with hint localities and qualified identifiers. Useful for managing and inspecting registered hints in proof automation.",
      "description_length": 181,
      "index": 1141,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zify_plugin.Zify.BinOp",
      "library": "zify_plugin",
      "description": "Registers binary operator hints for proof automation and prints registered binary operator information. Works with hint locality settings and qualified identifiers. Useful for extending automated tactic behavior with custom binary operations during proof search.",
      "description_length": 262,
      "index": 1142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.InjTable",
      "library": "zify_plugin",
      "description": "Maintains a table of injectivity hints for identifiers, allowing registration of hints with specified locality and qualified identifiers. Provides operations to register new entries and print the current table contents. Useful for managing and inspecting injectivity information during proof automation or hint propagation tasks.",
      "description_length": 329,
      "index": 1143,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zify_plugin.Zify.UnOp",
      "library": "zify_plugin",
      "description": "This module maps external unification hints to internal representations and provides commands to register these hints with specific locality settings. It operates on hint locality specifications and qualified identifiers, enabling precise control over hint application during unification. Use cases include extending unification behavior with domain-specific rules and managing hint visibility across modules.",
      "description_length": 409,
      "index": 1144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.Saturate",
      "library": "zify_plugin",
      "description": "Registers and prints hint locality information for qualified identifiers. Works with hint localities and library names. Useful for managing and inspecting hint registration in proof automation.",
      "description_length": 193,
      "index": 1145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Zify_plugin.Zify.PropBinOp",
      "library": "zify_plugin",
      "description": "This module registers propositional binary operators for use in proof automation and provides a command to display registered operators. It works with logical operator identifiers and hint locality settings. Useful for extending tactics with custom logical connectives and inspecting available operators.",
      "description_length": 304,
      "index": 1146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zify_plugin.Zify",
      "library": "zify_plugin",
      "description": "This module orchestrates the transformation and saturation of logical expressions through a suite of hint-driven tactics and operator mappings. It centralizes operations for managing injectivity tables, unification hints, and operator/constant registrations, while submodules handle specific mappings for binary operators, relations, and propositional logic constructs. Users can register custom unary and binary operations with locality settings, extend injectivity and unification hint tables, and control how operators are resolved and printed across scopes. Example tasks include automating logical equivalences for arithmetic goals, specializing operators during proof search, and enriching hint databases with domain-specific rules tied to identifiers.",
      "description_length": 758,
      "index": 1147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Zify_plugin",
      "library": "zify_plugin",
      "description": "The module transforms and saturates logical expressions using hint-driven tactics and operator mappings. It supports registering unary and binary operations, managing injectivity and unification hints, and controlling operator resolution and printing. Specific tasks include automating arithmetic goal solving, specializing operators during proofs, and extending hint databases with custom rules. No functionality is available from the second module.",
      "description_length": 450,
      "index": 1148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Globnames.ExtRefMap.Smart",
      "library": "rocq-runtime.library",
      "description": "This module provides optimized versions of `map` and `mapi` that attempt to preserve structural sharing when transforming values in a map. It works with `Globnames.ExtRefMap.t`, a map structure keyed by extended references. Use it when applying functions to map values while minimizing unnecessary duplication of shared map nodes.",
      "description_length": 330,
      "index": 1149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Summary.Dyn.Map",
      "library": "rocq-runtime.library",
      "description": "This module implements a type-safe heterogeneous map where keys are type tags and values are parameterized by their corresponding tag type. It supports operations like adding, removing, and modifying key-value pairs, as well as iterating, folding, and filtering over stored values. Concrete use cases include managing collections of typed summary data where dynamic access and transformation of specific typed entries are required.",
      "description_length": 431,
      "index": 1150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libobject.Dyn.Easy",
      "library": "rocq-runtime.library",
      "description": "This module provides functions to create and manipulate dynamically typed values with runtime type information, enabling type-safe injection and projection of values into a common dynamic type. It works with abstract data types represented as `Libobject.Dyn.t` and type-specific tags that track the original type. Concrete use cases include handling heterogeneous collections of persistent objects and implementing generic serialization or dispatch mechanisms where type information must be preserved and checked at runtime.",
      "description_length": 524,
      "index": 1151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Summary.Dyn.HMap",
      "library": "rocq-runtime.library",
      "description": "This module transforms or selects entries in a heterogeneous map based on per-type functions. It applies a map operation to convert values from one type to another or filters entries using type-specific predicates. Concrete use cases include type-preserving transformation of summary data or selecting subsets of entries matching specific type constraints.",
      "description_length": 356,
      "index": 1152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libobject.Dyn.HMap",
      "library": "rocq-runtime.library",
      "description": "This module transforms and filters heterogeneous maps of persistent objects using provided `map` and `filter` functions. It operates on `Libobject.Dyn.Map(V1).t` values, applying per-tag transformations or predicates to selectively retain or modify entries. Concrete use cases include adapting object caches during module loading or pruning objects based on visibility rules during module closing.",
      "description_length": 397,
      "index": 1153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libobject.Dyn.Map",
      "library": "rocq-runtime.library",
      "description": "This module implements a type-safe heterogeneous map where keys are associated with values parameterized by their type. It supports operations like adding, removing, and modifying key-value pairs, as well as iterating, folding, and filtering over stored values. Concrete use cases include managing collections of dynamically typed but type-safe configuration settings or plugin-specific data.",
      "description_length": 392,
      "index": 1154,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Globnames.ExtRefMap.Monad",
      "library": "rocq-runtime.library",
      "description": "This module provides monadic variants of map and fold operations over `Globnames.ExtRefMap`. It allows folding over key-value pairs with monadic effects and mapping values into a monadic context, producing a new map. Useful for accumulating state or handling effectful computations while transforming or reducing maps.",
      "description_length": 318,
      "index": 1155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Summary.Dyn.Easy",
      "library": "rocq-runtime.library",
      "description": "This module simplifies working with dynamically typed summaries by providing functions to create injective and projective conversions between values and a common dynamic type. It supports operations like `inj` for wrapping typed values into a uniform dynamic representation and `prj` for safely extracting them using type-specific tags. Concrete use cases include handling heterogeneous data in a type-safe way, such as storing and retrieving values of different types in a shared summary structure.",
      "description_length": 499,
      "index": 1156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nametab.UserName",
      "library": "rocq-runtime.library",
      "description": "This module manages mappings between user names and internal object references, supporting operations to register, resolve, and manipulate qualified identifiers. It works with types such as `full_user_name`, `qualid`, and `object_reference`, providing functions like `push` to bind names to objects, `locate` to resolve references from names, and `full_name` to expand qualified names. Concrete use cases include name resolution during compilation, tracking global definitions, and ensuring unambiguous references in interactive proof sessions.",
      "description_length": 544,
      "index": 1157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nametab.Make",
      "library": "rocq-runtime.library",
      "description": "This module implements a symbol table for mapping user names to internal objects, supporting operations like registration, lookup, and resolution of qualified identifiers. It works with user names, qualified identifiers, and internal object references, enabling precise name resolution in contexts like Coq's global environment. Concrete use cases include tracking constants, inductives, and modules during compilation or interactive proof sessions, ensuring correct name-to-object associations.",
      "description_length": 495,
      "index": 1158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libobject.Dyn",
      "library": "rocq-runtime.library",
      "description": "This module enables dynamic typing with type-safe casting through a GADT that pairs type tags with values, supporting creation, comparison, and inspection of tagged data. It works with heterogeneous collections, allowing type-preserving operations such as serialization, dispatch, and cache adaptation through its submodules. The first submodule handles dynamic value injection and projection, the second filters and transforms maps of persistent objects by type, and the third implements type-safe heterogeneous maps for managing typed key-value settings. Examples include safely storing and retrieving mixed-type configurations, transforming object caches during module loading, and pruning data based on runtime type checks.",
      "description_length": 727,
      "index": 1159,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nametab.GlobDirRef",
      "library": "rocq-runtime.library",
      "description": "This module defines a type `t` representing globally referenced directory structures, including open modules, module types, and sections. It provides equality checking via `equal` to compare these directory references. Concrete use cases include managing and comparing namespace hierarchies during the resolution of qualified identifiers in Coq's global environment.",
      "description_length": 366,
      "index": 1160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libobject.ExportObj",
      "library": "rocq-runtime.library",
      "description": "This module handles the export of persistent objects during module loading and opening, managing their visibility in the Nametab based on module structure and import depth. It works with objects that have caching, loading, opening, and substitution behaviors, particularly tracking them through module paths and visibility filters. Concrete use cases include controlling the visibility of definitions when modules are imported or required, ensuring correct scoping and name resolution.",
      "description_length": 485,
      "index": 1161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lib.Synterp",
      "library": "rocq-runtime.library",
      "description": "This module manages the trace and backtracking of operations within a structured context, supporting the opening and closing of sections, modules, and module types. It works with identifiers, nodes, and summaries to track state changes and discharge items, enabling precise control over nested structures. Concrete use cases include managing the lifecycle of Coq sections and modules while preserving consistency during undo operations or exports.",
      "description_length": 447,
      "index": 1162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nametab.EqualityType",
      "library": "rocq-runtime.library",
      "description": "This module defines an equality operation for a type `t` used in name resolution tables. It supports comparing name table entries for structural equivalence, ensuring consistent handling of qualified identifiers and internal object references. Concrete use cases include checking equality of global references and resolving ambiguous names during module loading or symbol lookup.",
      "description_length": 379,
      "index": 1163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Globnames.ExtRefSet",
      "library": "rocq-runtime.library",
      "description": "This module implements standard set operations for `Globnames.extended_global_reference` elements, including membership testing, insertion, deletion, union, intersection, and difference. It supports querying via cardinality, element listing, and arbitrary selection, using a set-based structure optimized for efficient manipulation of global reference collections. Designed for tasks like dependency tracking, symbol resolution, or static analysis in programming tools where global references require structured set-theoretic operations.",
      "description_length": 537,
      "index": 1164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goptions.OptionMap",
      "library": "rocq-runtime.library",
      "description": "The module implements a specialized map structure for managing hierarchical key-value associations, where keys are string lists (`option_name`) and values represent configurable options or tables. It supports operations for precise key-based updates, ordered traversal, and safe value extraction, while enabling dynamic configuration through vernacular commands like `Set`, `Unset`, `Add`, and `Print`. This structure is particularly suited for synchronizing document state with user-defined settings and maintaining extensible, scoped configuration parameters in a proof assistant context.",
      "description_length": 590,
      "index": 1165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Goptions.MakeStringTable",
      "library": "rocq-runtime.library",
      "description": "This module provides operations to manage a set of strings associated with a table key, including adding, removing, and testing membership of elements. It works with string values and is used to implement vernacular commands for manipulating named tables of strings. Concrete use cases include maintaining sets of identifiers or configuration entries that can be modified and queried through Coq's command interface.",
      "description_length": 416,
      "index": 1166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Summary.Stage",
      "library": "rocq-runtime.library",
      "description": "This module defines a sum type with two variants, `Synterp` and `Interp`, representing distinct stages in a system that undergoes backtracking. It includes an `equal` function to compare values of this type for equality. This module is used to track and manage transitions between syntactic and semantic processing stages during system execution.",
      "description_length": 346,
      "index": 1167,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Goptions.MakeRefTable",
      "library": "rocq-runtime.library",
      "description": "This module provides operations to manage a set of active elements of type `A.t`, supporting queries for the current set, checking if an element is active, and setting the activation state of elements. It works with sets of elements defined by the `A.Set.t` type and individual elements of type `A.t`. Concrete use cases include tracking enabled features or active entries in a system where elements can be dynamically activated or deactivated via commands like `Add`, `Remove`, or `Set`.",
      "description_length": 488,
      "index": 1168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Summary.FrozenStage",
      "library": "rocq-runtime.library",
      "description": "This module manages snapshots of table states with operations to freeze, unfreeze, and transform summaries. It works with the `frozen` type, representing a consistent snapshot, and interacts with dynamically typed summary tags. Use cases include capturing system state for checkpointing, restoring state from a snapshot, and preparing summaries for serialization.",
      "description_length": 363,
      "index": 1169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Summary.Interp",
      "library": "rocq-runtime.library",
      "description": "This module manages summaries by allowing them to be frozen, modified, and unfrozen. It supports operations to extract, update, and remove typed values from frozen summaries using dynamic tags. It is used to capture and manipulate structured summary data at runtime, particularly in scenarios requiring persistence or selective updates of summary information.",
      "description_length": 359,
      "index": 1170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lib.Interp",
      "library": "rocq-runtime.library",
      "description": "This module manages a trace of operations and supports backtracking, with functions to open and close sections, add entries, and manipulate modules and module types. It works with data types like `summary`, `frozen`, and `discharged_item`, along with identifiers and paths for modules. Concrete use cases include tracking state changes during proof development, managing modular structures, and enabling undo operations in interactive theorem proving sessions.",
      "description_length": 460,
      "index": 1171,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nametab.Modules",
      "library": "rocq-runtime.library",
      "description": "This module manages the registration and resolution of qualified names for internal objects, supporting operations like `push` to associate names with references, `locate` to resolve qualified identifiers, and `full_name` to expand them. It works with data types such as `full_user_name`, `qualid`, and `object_reference`, including path types like `DirPath.t`. Use cases include name resolution during compilation, tracking global definitions, and ensuring consistent name visibility across modules.",
      "description_length": 500,
      "index": 1172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Globnames.ExtRefOrdered",
      "library": "rocq-runtime.library",
      "description": "This module defines an ordered type for extended global references, enabling comparison, equality checks, and hashing. It supports operations necessary for using these references as keys in ordered collections like maps and sets. Concrete use cases include managing globally unique identifiers in environments where reference ordering and identity are required, such as symbol tables or dependency tracking systems.",
      "description_length": 415,
      "index": 1173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Summary.Synterp",
      "library": "rocq-runtime.library",
      "description": "This module manages snapshots of registered table states, providing operations to freeze, unfreeze, and manipulate these snapshots. It works with the `frozen` type, which represents a snapshot, and interacts with dynamically typed summary data via `Summary.Dyn.tag`. Use cases include capturing system state for checkpointing, restoring state from a snapshot, and extracting specific summary data from frozen states.",
      "description_length": 416,
      "index": 1174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Summary.Dyn",
      "library": "rocq-runtime.library",
      "description": "This module enables type-safe dynamic projections through unique type tags, supporting operations like `eq`, `create`, and `name` for managing and resolving typed values. Its heterogeneous map submodule stores and manipulates type-tagged values, allowing dynamic access, transformation, and traversal of typed entries. A transformation submodule applies type-specific functions to convert or filter map entries, enabling type-preserving data manipulation. Helper functions for injective and projective conversions facilitate wrapping and unwrapping typed values in a shared dynamic structure, supporting use cases like type-driven serialization and heterogeneous data management.",
      "description_length": 679,
      "index": 1175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Globnames.ExtRefMap",
      "library": "rocq-runtime.library",
      "description": "This module organizes structured data using extended global references as keys, enabling precise manipulation of hierarchical identifiers and conflict resolution during integration. It supports core operations like insertion, deletion, union, and symmetric difference, while submodules optimize value transformations with structural sharing and enable monadic folds and maps for effectful computations. You can merge maps with custom conflict handlers, filter ranges of keys, traverse relationships in symbolic data, or transform values without duplicating shared structure. Use cases include formal verification, symbolic computation, and managing complex, overlapping identifier hierarchies.",
      "description_length": 693,
      "index": 1176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goptions.RefConvertArg",
      "library": "rocq-runtime.library",
      "description": "This module defines operations for encoding, substituting, and printing a custom type `t` associated with a globally registered option key. It provides validation, discharge handling, and localized message generation for option values tied to Coq's vernacular commands. It is used to manage structured option values within Coq's configuration system, ensuring proper synchronization with the document and support for modular transformations.",
      "description_length": 441,
      "index": 1177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lib.StagedLibS",
      "library": "rocq-runtime.library",
      "description": "This module manages staged operations within a library, supporting the creation and closure of sections, modules, and module types while tracking their summaries and object prefixes. It provides functions to add entries, find opening nodes, and manipulate the library state through freezing, unfreezing, and initialization. Concrete use cases include structuring proof development by organizing definitions into sections and managing module boundaries with precise control over exports and object declarations.",
      "description_length": 510,
      "index": 1178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Nametab.NAMETREE",
      "library": "rocq-runtime.library",
      "description": "This module manages mappings between user names and internal object references, supporting operations like registration, lookup, and resolution of qualified identifiers. It works with data types such as `elt`, `t` (the table type), and `user_name`, alongside `Libnames.qualid` for identifier resolution. Concrete use cases include registering named objects with visibility settings, locating objects from qualified names, and generating the shortest unambiguous qualifier for a given name within a context.",
      "description_length": 506,
      "index": 1179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Global",
      "library": "rocq-runtime.library",
      "description": "This module manages the global environment, supporting operations to add and query constants, inductive types, and modules while enforcing name validity and universe constraints. It operates on identifiers, module paths, and kernel names, facilitating tasks like section management, opaque proof handling, and library serialization. Use cases include configuring compilation backends, resolving names during type-checking, and maintaining persistent state across compilation sessions.",
      "description_length": 484,
      "index": 1180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Summary",
      "library": "rocq-runtime.library",
      "description": "This module coordinates reference management and stage-aware summaries through `ref` and `ref_tag`, enabling state persistence across syntactic and semantic processing stages. It integrates snapshot handling via `frozen` types and dynamic tags, supporting operations to freeze, unfreeze, and selectively update structured data. The stage sum type tracks processing phases, while the dynamic module ensures type-safe projections and transformations over heterogeneous summary data. Example uses include checkpointing interpreter state, restoring dynamic values across sessions, and serializing structured summaries with type-preserving conversions.",
      "description_length": 647,
      "index": 1181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Nametab",
      "library": "rocq-runtime.library",
      "description": "This module manages hierarchical name mappings for global objects, enabling registration of names with visibility controls, resolution of qualified identifiers to internal references, and handling of ambiguous or incomplete names. It operates on qualified identifiers (`qualid`), fully resolved paths (`full_path`, `DirPath.t`), and internal references like constants, modules, and universes, offering disambiguation, shortest unambiguous name generation, and bidirectional conversion between user-facing and kernel-level representations. Functions like `push` register name-object associations, `locate` resolves references from qualified names, and `full_name` expands partial names to fully qualified ones, supporting use cases such as name resolution during type-checking and managing module hierarchies. Submodules refine this functionality with symbol tables, directory structures, and equality checks on name mappings, ensuring precise and consistent name handling across the global environment.",
      "description_length": 1002,
      "index": 1182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libobject",
      "library": "rocq-runtime.library",
      "description": "This module manages the lifecycle of persistent, marshallable objects through core operations like caching, substitution, classification, and discharge, ensuring proper visibility in the Nametab during module loading, opening, and closure. It operates on module paths, substitutions, and open filters, supporting use cases such as module imports, functor applications, and opaque module handling, with serialization enabling persistence across sessions. A child module provides dynamic typing with type-safe casting using a GADT, enabling heterogeneous collections and type-preserving operations like serialization and cache adaptation, while another governs the export and visibility of objects in the Nametab based on module structure and import depth. Together, they allow tasks like managing mixed-type configurations, controlling name visibility on module load, and transforming object caches during module opening.",
      "description_length": 920,
      "index": 1183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Goptions",
      "library": "rocq-runtime.library",
      "description": "This module organizes hierarchical configuration data through string-list keys, enabling typed options and tables with automated command generation such as `Set`, `Add`, and `Print`. It supports boolean, integer, and string-based values directly, while submodules extend functionality to custom types, scoped activation sets, and document-aware value handling. Tables manage sets of strings or user-defined elements with membership operations, and the system synchronizes all changes with the document state. Examples include tracking active proof features, maintaining named sets of identifiers, and defining structured options with custom printing and validation.",
      "description_length": 665,
      "index": 1184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libnames",
      "library": "rocq-runtime.library",
      "description": "This module provides tools for working with Coq's hierarchical naming system, handling structured identifiers and module paths through types like `DirPath.t`, `full_path`, and `qualid`. It supports operations such as path concatenation, prefix/suffix manipulation, equality checks, and conversions between string and structured forms, enabling tasks like module hierarchy management and identifier resolution. Submodules extend this functionality with specialized utilities for path normalization, scoped lookups, and root prefix handling, integrating seamlessly with Coq's development structure during compilation and interactive sessions. Example uses include resolving qualified names during proof scripting, restructuring module paths during imports, and normalizing identifiers for consistent scope resolution.",
      "description_length": 815,
      "index": 1185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Rocqlib",
      "library": "rocq-runtime.library",
      "description": "This module binds string names to global references and provides operations to register, retrieve, and check these mappings. It works with `Names.GlobRef.t` values, supporting lookups, existence checks, and listing all registered pairs. Specific use cases include resolving named constants like `\"core.eq.type\"` to their actual references, and building structured data for equality and sigma types using registered components.",
      "description_length": 426,
      "index": 1186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Globnames",
      "library": "rocq-runtime.library",
      "description": "This module classifies and deconstructs global references into variables, constants, inductive types, and constructors, while supporting substitution and extended references through abbreviations and inductive-level identifiers. It enables operations like reference transformation during type checking and proof construction, with support for set-based manipulation, ordered comparisons, and keyed data organization through its submodules. The set module handles membership and aggregation over global references, the ordered module provides comparison and hashing for maps and sets, and the map module enables structured key-based data manipulation with conflict resolution and efficient transformations. Examples include tracking dependencies in Coq's type checker, resolving symbolic identifiers in proof scripts, and merging hierarchical environments with custom conflict handling during module linking.",
      "description_length": 907,
      "index": 1187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Locality",
      "library": "rocq-runtime.library",
      "description": "This module manages locality settings for definitions, controlling whether they are discharged, globally exported, or kept local within sections or modules. It provides functions to create and enforce locality policies, such as `make_locality`, `enforce_locality`, and `check_locality_nodischarge`, which determine visibility and scope in different contexts. Use cases include configuring the scope of definitions in interactive proofs, managing module-local declarations, and ensuring proper export behavior in libraries.",
      "description_length": 522,
      "index": 1188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Coqlib",
      "library": "rocq-runtime.library",
      "description": "This module provides utilities for registering and resolving global Coq references (e.g., constants, inductives) by name, along with mechanisms to lazily construct standard type and term references like sigma types and equality primitives. It operates on data structures such as `Names.GlobRef.t` and `Names.inductive`, supporting library management and foundational type infrastructure. Specific applications include deferred initialization of equality-related constants (e.g., `eq`, `refl`) via delayed computation patterns, now replaced by Rocqlib in modern contexts.",
      "description_length": 570,
      "index": 1189,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lib",
      "library": "rocq-runtime.library",
      "description": "This module coordinates the tracking and reversal of operations within Coq's library system, managing hierarchical namespaces and compilation contexts through low-level bookkeeping. It operates on path and reference types like `ModPath`, `DirPath`, and `GlobRef`, while handling section-specific data, object classifications, and projection discharge. Submodules support structured context management through section and module lifecycle control, using summaries, identifiers, and discharge mechanisms to track and revert state changes. Examples include organizing proof development with nested sections, maintaining consistent module exports, and enabling undo operations during interactive theorem proving.",
      "description_length": 708,
      "index": 1190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Library_info",
      "library": "rocq-runtime.library",
      "description": "This module handles warnings related to library information during compilation. It provides a function to emit warnings when library paths or metadata are inconsistent or deprecated. The module works with directory paths and warning configurations to ensure correct handling of library dependencies.",
      "description_length": 299,
      "index": 1191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cc_core_plugin.Ccalgo.ATerm",
      "library": "cc_core_plugin",
      "description": "This module defines a term representation with operations to construct and deconstruct terms, including symbols, products, applications, and constructors. It works with Coq's `Constr.constr`, `Sorts.t`, and environment types, providing direct term manipulation. Concrete use cases include building and analyzing terms during proof search or tactic execution.",
      "description_length": 358,
      "index": 1192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cc_core_plugin.Ccproof",
      "library": "cc_core_plugin",
      "description": "This module defines a type `rule` representing inference rules for constructing equality proofs, including axioms, reflexivity, symmetry, transitivity, congruence, and injection. It supports operations over terms and proof structures used in the context of a proof assistant's kernel, particularly for handling inductive types and equality reasoning. The `build_proof` function generates a proof object based on a given goal and environment, used during proof search or tactic execution.",
      "description_length": 487,
      "index": 1193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cc_core_plugin.Ccalgo",
      "library": "cc_core_plugin",
      "description": "The module implements a congruence closure algorithm for term equivalence reasoning, centered on term forests, disequality propagation, and path joining. It directly supports operations on terms, patterns, axioms, and solver states, enabling precise equality constraint management and explanation generation in theorem proving. The term module provides concrete representations and manipulation primitives for Coq terms, including symbols, applications, and constructors, used to build and analyze terms during proof search. Together, these components facilitate automated reasoning tasks such as equality checking and structural analysis within Coq's plugin system.",
      "description_length": 666,
      "index": 1194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cc_core_plugin.Cctac",
      "library": "cc_core_plugin",
      "description": "This module provides tactics for proving equalities using congruence and functional extensionality. It operates on Coq's internal term representation (`EConstr.constr`) and supports reasoning about equalities in proof scripts. Concrete use cases include automating equality proofs for complex expressions and simplifying equivalence reasoning in formal verification tasks.",
      "description_length": 372,
      "index": 1195,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cc_core_plugin",
      "library": "cc_core_plugin",
      "description": "This module enables automated equality reasoning and proof construction in Coq through inference rules, congruence closure, and term manipulation. It defines core data types like `rule` and `constr`, supporting operations such as `build_proof`, term comparison, and disequality propagation. Users can automate proofs involving reflexivity, symmetry, transitivity, and congruence, particularly for complex expressions over inductive types. Example use cases include proving term equalities during tactic execution and generating explanations for equivalence derivations.",
      "description_length": 569,
      "index": 1196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_plugin.G_ground",
      "library": "firstorder_plugin",
      "description": "This module defines a generalized argument type and entry point for invoking first-order logic tactics with specified hypotheses and loci. It handles qualified identifiers and globally resolved terms, supporting tactic application in proof contexts. Concrete use cases include integrating custom first-order reasoning steps in Coq proofs by specifying relevant lemmas and variables.",
      "description_length": 382,
      "index": 1197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Firstorder_plugin",
      "library": "firstorder_plugin",
      "description": "This module enables the integration of first-order logic tactics into proof workflows by providing a structured interface for specifying hypotheses, lemmas, and variables. It centers around a generalized argument type that supports qualified identifiers and global term resolution, facilitating precise tactic application within proof contexts. Developers can use it to define custom reasoning steps that interact with Coq's proof engine, such as applying a specific lemma to a given set of variables or transforming proof goals using first-order logic principles. Example usage includes automating repetitive proof patterns or extending proof scripts with domain-specific logical inferences.",
      "description_length": 692,
      "index": 1198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map.Make.Monad",
      "library": "rocq-runtime.lib",
      "description": "This module provides monadic traversal and transformation operations for key-value maps, including `fold`, `mapi`, `fold_left`, and `fold_right`, which allow effectful computations over map elements. It works specifically with map-like structures where values are processed with monadic actions provided by the parameter module `M`. Concrete use cases include accumulating results with error handling, state threading, or asynchronous computations while iterating over key-value pairs.",
      "description_length": 485,
      "index": 1199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Array.Fun1.Smart",
      "library": "rocq-runtime.lib",
      "description": "This module provides optimized versions of array operations that avoid closure allocation by taking an additional argument to be applied across elements. It works with arrays and functions that take a shared environment parameter alongside each element. Use this when performance is critical and you want to eliminate closure overhead in array transformations.",
      "description_length": 360,
      "index": 1200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map.Make.Smart",
      "library": "rocq-runtime.lib",
      "description": "This module provides optimized `map` and `mapi` functions for key-value maps that attempt to preserve structural sharing during transformations. It works specifically with map data structures where keys are of a fixed type and values can be modified in place. These functions are useful when efficiently updating large maps while minimizing memory allocation, such as in incremental data processing or persistent data structure implementations.",
      "description_length": 444,
      "index": 1201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Set.Make.List",
      "library": "rocq-runtime.lib",
      "description": "This module implements set operations for lists, providing functions like `union` to combine multiple sets into one. It works with lists as representations of sets, ensuring elements are unique. Useful for merging configuration options or aggregating distinct values from multiple list sources.",
      "description_length": 294,
      "index": 1202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.List.MonoS",
      "library": "rocq-runtime.lib",
      "description": "This module provides operations for working with lists of elements, including equality checks, membership tests, association lookups, and removal of associated elements. It handles homogeneous lists and pairs where elements share the same type. Use this module for tasks like checking if an item exists in a list, finding associated values in key-value pairs, or removing entries by key from association lists.",
      "description_length": 410,
      "index": 1203,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Set.ExtS-List",
      "library": "rocq-runtime.lib",
      "description": "This module extends standard set operations with specialized functions for handling lists of sets, including efficient union computation. It operates on lists of set types, enabling aggregation and combination of elements across multiple sets. Useful for scenarios like merging configuration options, consolidating permissions, or combining results from parallel computations.",
      "description_length": 376,
      "index": 1204,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Map.ExtS-Monad",
      "library": "rocq-runtime.lib",
      "description": "This module provides monadic traversal and transformation operations for key-value maps, including `fold`, `mapi`, `fold_left`, and `fold_right`, all of which sequence computations using the `M` monad. It works specifically with map-like structures where values are associated with keys and supports operations that accumulate results or build new maps through monadic steps. Concrete use cases include transforming map values with effectful computations, aggregating map data while handling side effects, and building new maps from existing ones using key-aware logic.",
      "description_length": 569,
      "index": 1205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Map.Make",
      "library": "rocq-runtime.lib",
      "description": "This module offers a comprehensive set of operations for working with immutable maps, enabling functional manipulation of key-value pairs through insertion, deletion, and updates, along with traversal and set-like transformations such as union and symmetric difference. It supports direct operations like conversion to lists or sets and integrates two specialized submodules: one for monadic traversal and transformation, allowing effectful computations such as error handling or state threading over map elements, and another for optimized, sharing-preserving `map` and `mapi` functions that minimize memory use during large-scale or incremental updates. Example uses include managing application configuration through pure transformations, performing stateful aggregations with monadic effects, or efficiently updating persistent data structures while preserving performance.",
      "description_length": 877,
      "index": 1206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Set.Hashcons",
      "library": "rocq-runtime.lib",
      "description": "This module implements hash-consing for sets using a customizable hash and comparison function. It provides operations to generate a hash-consing table, apply hash-consing to a set, and retrieve statistics on the table's usage. The module works with sets built from an ordered type module and a hash function module. Use this module to ensure canonical representations of sets for efficient equality checks and memory usage in symbolic computation or data deduplication scenarios.",
      "description_length": 480,
      "index": 1207,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map.UExtS-Set",
      "library": "rocq-runtime.lib",
      "description": "This module provides operations for constructing and manipulating sets of keys, including membership checks, insertion, deletion, union, intersection, and difference, alongside querying capabilities like cardinality, element enumeration, and arbitrary element selection. It works with a domain-specific set structure (`Set.t`) where elements (`elt`) correspond to keys, enabling use cases such as managing key domains in mappings, performing set algebra, or traversing key collections efficiently.",
      "description_length": 497,
      "index": 1208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Set.OrderedType",
      "library": "rocq-runtime.lib",
      "description": "This module defines a type `t` and a comparison function `compare` for use with ordered sets. It supports creating sets where elements are compared using a custom total ordering. Concrete use cases include managing sets of custom data types like integers, strings, or compound keys where a specific sort order is required.",
      "description_length": 322,
      "index": 1209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Map.MonadS",
      "library": "rocq-runtime.lib",
      "description": "This module provides monadic operations for working with key-value maps, specifically supporting binding and return operations. It enables chaining transformations on map values using `>>=` to sequence computations that produce new maps. Concrete use cases include building complex map manipulations from simpler functions, such as aggregating values or transforming keys and values in a pipeline.",
      "description_length": 397,
      "index": 1210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Array.Smart",
      "library": "rocq-runtime.lib",
      "description": "This module optimizes array transformations by avoiding unnecessary copies when the result would be identical to the input. It provides specialized versions of `map`, `map_i`, `map2`, `fold_left_map`, and `fold_left2_map` that return the original array when the function leaves elements unchanged. These functions are useful when applying transformations that may be no-ops in certain cases, improving performance in scenarios like conditional array updates or identity-preserving filters.",
      "description_length": 489,
      "index": 1211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map.UExtS-Monad",
      "library": "rocq-runtime.lib",
      "description": "This module provides monadic folding and mapping operations over key-value pairs in a map structure. It works with maps that bind keys to values and supports operations where functions return monadic values. Use it to perform effectful traversals or transformations of maps, such as accumulating results in a state monad or handling optional or error-prone computations during iteration.",
      "description_length": 387,
      "index": 1212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Set.Make",
      "library": "rocq-runtime.lib",
      "description": "This module implements ordered set operations for elements with a defined comparison, supporting membership checks, insertion, deletion, and set algebra like union, intersection, and difference. It handles sets, sequences, and lists, offering conversions and ordered traversal, filtering, and subset checks. The child module extends this with list-based set operations, such as merging configuration options or aggregating distinct values from multiple lists. Together, they enable efficient manipulation of unique, ordered collections drawn from various data sources.",
      "description_length": 568,
      "index": 1213,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Map.ExtS-Set",
      "library": "rocq-runtime.lib",
      "description": "This module offers core set operations including membership checks, element insertion/removal, union, intersection, and difference calculations, alongside utilities for querying cardinality, extremum values, and converting sequences to sets. It manipulates `Set.t` structures and sequences of uniform element types, enabling efficient set algebra and traversal. Typical applications include managing unique element collections, performing data filtering via set operations, and bridging sequential data with set semantics for deduplication or aggregation tasks.",
      "description_length": 561,
      "index": 1214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map.ExtS",
      "library": "rocq-runtime.lib",
      "description": "This module provides operations for manipulating ordered maps through key-value transformations, structural merging, and ordered traversal, including set-like domain operations and monadic folds. It works with parameterized map structures supporting key-based access, domain manipulation, and comparison, while integrating smart constructors and applicative combinators. Typical use cases involve aggregating heterogeneous data, enforcing key ordering constraints, or performing conditional map updates with merged semantic domains.",
      "description_length": 532,
      "index": 1215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map.ExtS-Smart",
      "library": "rocq-runtime.lib",
      "description": "This module provides optimized mapping operations for key-value pairs in a data structure, specifically preserving sharing during transformations. It works with associative data types like maps or dictionaries, where keys are paired with values. Use this when efficiently updating structured data like configuration settings, environment variables, or relation tables without unnecessary duplication.",
      "description_length": 400,
      "index": 1216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map.UExtS-Smart",
      "library": "rocq-runtime.lib",
      "description": "This module provides optimized `map` and `mapi` functions for key-value maps that attempt to preserve structural sharing during transformations. It works specifically with map data structures where keys are of type `key` and values are of a uniform type `'a`. These functions are useful when efficiently updating large maps while minimizing memory allocation, such as in incremental data processing or persistent data structure implementations.",
      "description_length": 444,
      "index": 1217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.List.Smart",
      "library": "rocq-runtime.lib",
      "description": "This module provides optimized list transformation functions that maximize physical sharing between input and output lists when elements are unchanged. It supports `map`, `fold_left_map`, and `fold_right_map`, all of which return lists that physically share suffixes with the input when possible. These functions are useful in performance-sensitive contexts where preserving list identity reduces memory usage, such as incremental updates in data structures or efficient list diffing.",
      "description_length": 484,
      "index": 1218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Set.ExtS",
      "library": "rocq-runtime.lib",
      "description": "This module provides polymorphic set operations for creation, transformation, and querying, including algebraic operations (union, intersection), membership tests, element retrieval (with safe/unsafe variants), and conversions between sets, lists, and sequences. It works with a polymorphic set type `t` containing elements of type `elt`, supporting both strict and lazy evaluation through iterative functions like `fold` and `iter`. Typical use cases include data deduplication pipelines, set-theoretic computations, and scenarios requiring efficient containment checks over dynamic collections.",
      "description_length": 596,
      "index": 1219,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Map.OrderedType",
      "library": "rocq-runtime.lib",
      "description": "This module defines a comparable key type for maps, requiring a total ordering via the `compare` function. It supports efficient map operations like insertion, lookup, and traversal using ordered keys. Concrete use cases include building dictionaries with custom key types such as integers, strings, or tuples.",
      "description_length": 310,
      "index": 1220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map.UExtS",
      "library": "rocq-runtime.lib",
      "description": "This module provides operations for managing associative maps with polymorphic values indexed by a specific key type, supporting insertion, deletion, lookup, traversal, and advanced transformations like symmetric difference folding and performance-optimized merging. It enables safe and unsafe key access, domain extraction, and bidirectional conversion with key-value lists, while submodules enhance functionality for set-based bindings and monadic compositions. These capabilities are particularly useful for tasks requiring precise key-value manipulation, such as configuration management, dynamic state tracking, or data processing pipelines.",
      "description_length": 646,
      "index": 1221,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Array.Fun1",
      "library": "rocq-runtime.lib",
      "description": "This module extends standard array operations with higher-order functions that accept an additional environment argument, eliminating closure creation during element-wise processing. It includes core operations like `map`, `iter`, and `iter2`, which pass a shared context directly to the function operand, enabling efficient transformations with explicit state or configuration. The child module offers optimized variants of these operations, further improving performance by avoiding heap-allocated closures in critical loops. For example, you can use `map` to apply a function to each array element along with a shared parameter, or `iter2` to traverse two arrays in tandem while maintaining a common environment.",
      "description_length": 715,
      "index": 1222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Set.HashedType",
      "library": "rocq-runtime.lib",
      "description": "This module defines a hashed type interface with equality and hashing operations for elements of type `t`. It is used to create hash tables or sets where elements must be uniquely identified and efficiently compared. Concrete use cases include implementing custom key types for hash-based collections, such as using complex data structures as keys in a hash table.",
      "description_length": 364,
      "index": 1223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Spawn.Async",
      "library": "rocq-runtime.lib",
      "description": "This module manages asynchronous process execution and monitoring. It provides functions to spawn processes with custom environment settings, attach callbacks for handling output and conditions, and control processes using operations like kill, wait, and status checks. It works with strings, string arrays, and custom types for processes, callbacks, and handles, supporting use cases like running background tasks, scripting integrations, and event-driven process management.",
      "description_length": 476,
      "index": 1224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Aux_file.M",
      "library": "rocq-runtime.lib",
      "description": "This module implements a map structure with string keys and polymorphic values, maintaining keys in total order. It provides operations for ordered traversal, safe key lookups with optional results, merging and splitting maps, and converting between sequences and lists with guaranteed ordering. This facilitates use cases such as sorted key-value aggregation, incremental map construction from sequences, and deterministic processing of bindings in ascending or descending key order.",
      "description_length": 484,
      "index": 1225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AcyclicGraph.Make",
      "library": "rocq-runtime.lib",
      "description": "This module provides operations to construct and analyze directed acyclic graphs representing strict partial orders, including adding elements with optional ranking, enforcing equality/inequality constraints (`eq`, `leq`, `lt`), and diagnosing constraint conflicts. It operates on abstract `Point.t` values organized in a graph structure that supports traversal of relationships and inspection of domain properties. Typical applications include dependency resolution systems, task scheduling with precedence constraints, and formal verification tools requiring explicit representation of hierarchical or ordered relationships.",
      "description_length": 626,
      "index": 1226,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Union",
      "library": "rocq-runtime.lib",
      "description": "This module provides operations to transform, compare, and accumulate values contained in a union type. It supports mapping functions over either branch of a disjoint union, checking structural equality, and folding values into an accumulator based on the branch. These operations are useful when handling sum types where each variant holds a single value, such as parsing results or tagged data representations.",
      "description_length": 412,
      "index": 1227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Array",
      "library": "rocq-runtime.lib",
      "description": "This module provides low-level array manipulation with direct access to elements, slices, and in-place operations, supporting both flat and 2D arrays. It enables transformations like mapping, folding, and filtering, with index-aware logic and efficient mutation, ideal for data processing tasks that require precise control over array structure and content. The first child module optimizes transformations by reusing the original array when the result is unchanged, offering efficient `map` and `fold` variants that avoid unnecessary copies during conditional updates or identity-preserving operations. The second child module enhances performance by allowing element-wise functions to take an additional environment argument directly, eliminating closure allocations and enabling stateful, parameterized array processing without heap-allocated closures.",
      "description_length": 855,
      "index": 1228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NewProfile.Counters",
      "library": "rocq-runtime.lib",
      "description": "This module defines a data type `t` representing a collection of numeric counters. It supports operations to retrieve the current counter values, reset them to zero, add or subtract counter values, and format them for display. Concrete use cases include tracking and reporting performance metrics or usage statistics within a system.",
      "description_length": 333,
      "index": 1229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Spawn.Sync",
      "library": "rocq-runtime.lib",
      "description": "This module manages the synchronous spawning and control of external processes. It provides functions to start processes with custom environments, capture their input/output channels, and manipulate running processes via operations like killing, waiting, and checking status. Concrete use cases include executing shell commands with precise I/O handling and monitoring or terminating long-running subprocesses.",
      "description_length": 410,
      "index": 1230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Compare",
      "library": "rocq-runtime.lib",
      "description": "This module provides a structured way to define and chain comparison operations using a list of tuples containing comparison functions and their arguments. It works with polymorphic types `'a` and supports building complex comparisons by sequentially evaluating individual comparison functions. Concrete use cases include implementing custom ordering logic for composite data types or multi-field structures where comparisons must be performed in a specific priority order.",
      "description_length": 473,
      "index": 1231,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Deprecation.Version",
      "library": "rocq-runtime.lib",
      "description": "This module defines specific warning categories corresponding to different software version thresholds, such as v8_3, v8_5, and so on up to v9_0. Each value represents a distinct version boundary used to classify deprecation warnings. It is used to manage and trigger version-specific deprecation notices within a codebase during transitions across these version markers.",
      "description_length": 371,
      "index": 1232,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Stateid.Self",
      "library": "rocq-runtime.lib",
      "description": "This module defines a type `t` as an alias for `Stateid.t` and provides a `compare` function that establishes a total ordering between values of this type. It is used to compare state identifiers in contexts like sorting or building ordered collections. A concrete use case is ensuring consistent ordering of state IDs in data structures such as sets or maps.",
      "description_length": 359,
      "index": 1233,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AcyclicGraph.Point-Map-Monad",
      "library": "rocq-runtime.lib",
      "description": "This module implements monadic fold and map operations over map structures, where keys and values are processed within a monadic context. It works with standard OCaml maps (`Map.t`) and supports transformations and accumulations that involve effectful computations. Concrete use cases include building transformed maps with side-effect tracking or aggregating values through effectful traversal.",
      "description_length": 395,
      "index": 1234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AcyclicGraph.Point-Map",
      "library": "rocq-runtime.lib",
      "description": "This module type provides associative map operations for managing polymorphic key-value pairs where keys are derived from acyclic graphs representing strict orderings. It works with maps (`'a Map.t`) that enforce key-based ordering constraints, supporting creation, transformation, filtering, and structural comparison of mappings while enabling advanced operations like range filtering, symmetric difference folding, and dependency-aware binding. These capabilities are particularly useful for modeling hierarchical relationships, dependency resolution, or scenarios requiring ordered key traversal in domains like program analysis or topological data processing.",
      "description_length": 664,
      "index": 1235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AcyclicGraph.Point",
      "library": "rocq-runtime.lib",
      "description": "This module represents points in a directed acyclic graph modeling strict partial orders. It defines the core operations for comparing and printing graph nodes, supporting construction and traversal of hierarchical data structures. It is used to implement dependency tracking and topological sorting over discrete elements.",
      "description_length": 323,
      "index": 1236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Map",
      "library": "rocq-runtime.lib",
      "description": "This module extends OCaml's standard map implementation with advanced operations for transforming, combining, and querying key-value pairs using monadic and set-theoretic approaches. It supports ordered keys with custom comparison, immutable map manipulations, and optimized transformations that preserve structural sharing, enabling efficient updates and aggregations. Key operations include monadic folds and mappings that sequence effectful computations, set-like domain manipulations for key management, and specialized merging strategies that handle conflicts and combinations of values. Example uses include managing application state with ordered key domains, performing effectful traversals over map contents, and optimizing memory usage during large-scale map transformations.",
      "description_length": 785,
      "index": 1237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AcyclicGraph.Point-Set",
      "library": "rocq-runtime.lib",
      "description": "This module provides a functional set abstraction for managing collections of comparable elements, supporting creation, union, intersection, and predicate-based transformations. It operates on immutable sets of elements with efficient membership checks and structural comparisons, using a type that ensures consistency with equality constraints. Typical applications include tracking node relationships in directed acyclic graphs and implementing algorithms that require set-theoretic operations over ordered elements.",
      "description_length": 518,
      "index": 1238,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "NewProfile.MiniJson",
      "library": "rocq-runtime.lib",
      "description": "This module defines a minimal JSON-like data structure with support for integers, strings, associative lists, and nested lists. It provides a `pr` function to pretty-print values in a structured, human-readable format. Use this module to serialize and display lightweight JSON data, such as configuration snippets or simple data interchange formats.",
      "description_length": 349,
      "index": 1239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Stateid.Set",
      "library": "rocq-runtime.lib",
      "description": "This module provides operations for managing ordered collections of `Stateid.t` values, supporting standard set operations like union, intersection, and difference, as well as transformations such as mapping, filtering, and folding over elements in a defined order. It works with immutable sets structured via `Stateid.Self.compare`, enabling efficient membership checks, subset comparisons, and conversions to or from lists and sequences. These capabilities are particularly useful for tasks requiring ordered set manipulation, such as tracking hierarchical state identifiers or processing sequences with strict ordering constraints.",
      "description_length": 634,
      "index": 1240,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Aux_file.H",
      "library": "rocq-runtime.lib",
      "description": "The module implements a persistent ordered map structure with keys as integer pairs, supporting efficient insertion, deletion, merging, and ordered traversal operations. It provides functions for ordered iteration (ascending/descending), filtering, and bulk conversion to/from sequences, along with key-based queries and transformations that maintain immutability. This structure is well-suited for sparse grid representations, memoization with coordinate keys, or scenarios requiring ordered key-value associations with functional update semantics.",
      "description_length": 549,
      "index": 1241,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CAst.Smart",
      "library": "rocq-runtime.lib",
      "description": "Performs a recursive transformation on all elements within a `CAst.t` structure, applying the given function to each node. Works directly with the `CAst.t` type, which represents a generic abstract syntax tree. Useful for modifying AST nodes during code analysis or transformation passes in compilers or interpreters.",
      "description_length": 317,
      "index": 1242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util.Empty",
      "library": "rocq-runtime.lib",
      "description": "This module defines a single abstract type `t` that has no inhabitants, representing an impossible or unreachable value. It provides the `abort` function, which takes a value of this empty type and returns any desired type, effectively signaling that the function can never be called with a valid argument. This is useful for expressing functions that should never be invoked, such as handling impossible branches in pattern matching or modeling unreachable code paths in type-safe APIs.",
      "description_length": 487,
      "index": 1243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pp_diff.StringDiff",
      "library": "rocq-runtime.lib",
      "description": "Computes differences between two strings using the Rocq lexer to split text into tokens, then applies the Myers algorithm to compute the diff. It highlights changes by adding specific tags to the resulting Pp.t structure, distinguishing added, removed, and modified spans across multiple strings. Works directly on arrays of string elements, producing tagged output suitable for display in environments supporting styled text rendering.",
      "description_length": 436,
      "index": 1244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AcyclicGraph.Point-Map-Smart",
      "library": "rocq-runtime.lib",
      "description": "This module provides optimized mapping operations for directed acyclic graphs represented as strict orders, where nodes are associated with values. It supports transformations that preserve structural sharing to improve memory efficiency during updates. Use it when efficiently modifying node values in a DAG while minimizing redundant allocations.",
      "description_length": 348,
      "index": 1245,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Spawn.Control",
      "library": "rocq-runtime.lib",
      "description": "This module manages the lifecycle and monitoring of external processes. It provides operations to terminate a process, wait for its completion, retrieve its PID and unique identifier, and check if it is still running. It works with process handles to enable direct interaction with system-level processes.",
      "description_length": 305,
      "index": 1246,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.Set",
      "library": "rocq-runtime.lib",
      "description": "This module implements efficient set operations using balanced trees and customizable ordering or hashing, supporting core functions like membership testing, insertion, deletion, and set algebra. It provides data types for ordered and hashed sets, with operations that enable aggregation across multiple sets, hash-consing for memory efficiency, and custom comparison logic for unique element management. Examples include merging configuration options, consolidating permissions, deduplicating data streams, and managing symbolic representations with canonical forms. Submodules extend functionality to list-based set aggregation, hash-based element handling, and ordered traversal, enabling efficient manipulation of distinct, structured collections from diverse sources.",
      "description_length": 772,
      "index": 1247,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Util.List",
      "library": "rocq-runtime.lib",
      "description": "This module provides core operations for list manipulation, including equality checks, membership tests, and association list lookups, while its submodules enhance performance through optimized transformations that preserve physical list structure. Key data types include standard lists and key-value pairs, with operations like `mem`, `assoc`, and `remove_assoc` for direct access and modification. The submodule introduces sharing-preserving variants of `map` and fold-based transformations, enabling efficient memory use in scenarios like incremental data processing or structural diffing. Together, they support tasks ranging from basic list queries to high-performance list evolution with minimal allocation.",
      "description_length": 713,
      "index": 1248,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Spawn.MainLoopModel",
      "library": "rocq-runtime.lib",
      "description": "This module manages asynchronous event loops with file descriptor monitoring. It provides functions to create and manage watches on asynchronous channels, trigger callbacks on specified conditions, and read data from channels. Concrete use cases include handling I/O events from sockets or files in non-blocking applications.",
      "description_length": 325,
      "index": 1249,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pp_diff",
      "library": "rocq-runtime.lib",
      "description": "This module computes differences between two pretty-printed structures by tokenizing their string representations using the Rocq lexer and applying the Myers diff algorithm. It highlights changes using four specific tags for additions, removals, and background styling, with support for multi-string spans via start and end markers. The core functionality includes tokenization, diff computation, and tag insertion, allowing users to visualize differences in structured text such as Coq scripts or formatted logs. A helper routine shortens diff spans for more concise output, and a fallback handles unlexable input by diffing raw strings directly.",
      "description_length": 647,
      "index": 1250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Feedback",
      "library": "rocq-runtime.lib",
      "description": "Handles feedback messages and status updates for user interfaces, supporting levels like debug, info, warning, and error. Works with structured feedback types including messages, worker status, file dependencies, and custom XML content, tied to document and route IDs. Used to send targeted feedback to IDEs or consoles, attach quick fixes to warnings, and manage asynchronous processing status in interactive environments.",
      "description_length": 423,
      "index": 1251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Quickfix",
      "library": "rocq-runtime.lib",
      "description": "This module defines a data structure for representing quick fixes associated with errors, including their location and a printable message. It provides functions to create, access, and format quick fixes, along with mechanisms to register and retrieve quick fix generators based on exceptions. It is used to produce actionable error corrections in error reporting tools and interactive development environments.",
      "description_length": 411,
      "index": 1252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Spawn",
      "library": "rocq-runtime.lib",
      "description": "This module provides core types and utilities for managing asynchronous processes and inter-process communication, including a request type for signaling and a protocol version constant. It enables coordinating distributed tasks, handling process lifecycle events, and implementing custom communication protocols. The module supports spawning and controlling processes asynchronously or synchronously, capturing I/O, attaching callbacks, and monitoring file descriptors. Specific operations include running background tasks, scripting integrations, executing shell commands with precise I/O handling, and managing event loops for non-blocking I/O.",
      "description_length": 647,
      "index": 1253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Xml_datatype",
      "library": "rocq-runtime.lib",
      "description": "This module defines a polymorphic type `xml` for representing XML-like data with attributes and nested elements. It provides functions for constructing, traversing, and manipulating XML trees, including operations to add or retrieve attributes, map over nodes, and fold across element hierarchies. Concrete use cases include building XML documents programmatically, parsing and transforming XML data, and serializing structured data to XML format.",
      "description_length": 447,
      "index": 1254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Control",
      "library": "rocq-runtime.lib",
      "description": "This module manages global execution control for interrupting and timing out computations. It provides functions to enable thread delays, check for interrupts, and run functions with timeouts, returning results or `None` if the timeout elapses. It works with functions of arbitrary types, boolean references for control flags, and signal handlers for atomic execution around `SIGALRM`. Use this module to safely interrupt long-running tasks, enforce computation deadlines, or coordinate asynchronous termination signals in interactive systems.",
      "description_length": 543,
      "index": 1255,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flags",
      "library": "rocq-runtime.lib",
      "description": "This module manages system-wide configuration through mutable global state, offering operations to access, modify, and temporarily override boolean, numeric, and list-based settings during execution. It works with low-level data structures like `Stdlib.ref` to store flags controlling debugging modes, warning levels, asynchronous proof handling, and output behavior, while supporting scoped dynamic binding for temporary state changes. Specific use cases include enabling verbose logging, toggling test mode, adjusting inlining thresholds, and isolating configuration changes within specific computation scopes without persistent side effects.",
      "description_length": 644,
      "index": 1256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CDebug",
      "library": "rocq-runtime.lib",
      "description": "This module implements a conditional logging system with named debug components. It allows creating debug printers tied to flags that control output visibility, using a custom syntax to activate or deactivate components. Functions manipulate flags directly or parse string expressions to selectively enable logging across different parts of a program.",
      "description_length": 351,
      "index": 1257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Envars",
      "library": "rocq-runtime.lib",
      "description": "This module retrieves and processes environment variables and system paths needed for Rocq's configuration and execution. It handles variable expansion, home directory resolution, and XDG-compliant configuration and data directories. Concrete use cases include locating Coq binaries, resolving user-specific paths, and printing runtime configuration details.",
      "description_length": 358,
      "index": 1258,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Loc",
      "library": "rocq-runtime.lib",
      "description": "This module handles source code locations with precision, tracking file context, line numbers, and character positions. It supports operations to create, merge, shift, and compare locations, along with embedding locations into values and handling exceptions with location metadata. It is used to manage and propagate source positions through parsing, type checking, and error reporting in compilers or interpreters.",
      "description_length": 415,
      "index": 1259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CErrors",
      "library": "rocq-runtime.lib",
      "description": "This module handles error creation, classification, and printing through functions like `anomaly`, `user_err`, and `print`. It works with exceptions, particularly `Exninfo.iexn`, and supports filtering critical errors via `noncritical`. Concrete use cases include raising user-facing errors with location metadata and converting exceptions into results with `to_result`.",
      "description_length": 370,
      "index": 1260,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Stateid",
      "library": "rocq-runtime.lib",
      "description": "This module manages state identifiers with operations for comparison, string conversion, and validity checks, while its child modules extend its capabilities to support ordered collections and set manipulations. The core type `t` represents state identifiers, with operations to create fresh IDs, compare order, and validate transitions, enabling use cases like tracking document states or managing stateful computations. The child modules provide a `compare` function for total ordering and structures for immutable sets, supporting union, intersection, and ordered transformations such as mapping and folding. These features allow efficient handling of hierarchical states and ordered sequences, with direct applications in maintaining and manipulating structured state data.",
      "description_length": 777,
      "index": 1261,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "ObjFile",
      "library": "rocq-runtime.lib",
      "description": "This module implements low-level serialization and deserialization of typed segments in an object file format. It supports reading and writing structured data through handles, with functions to marshal and retrieve segments by identifier, and to manage file-level input/output state. Concrete use cases include storing and loading compiled OCaml objects, caching structured data to disk, and implementing custom binary formats with segment-based layouts.",
      "description_length": 454,
      "index": 1262,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pp",
      "library": "rocq-runtime.lib",
      "description": "This module offers operations to construct and manipulate structured documents (`Pp.t`) using text, spacing, line breaks, and semantic tags, with layout controls like indentation, alignment, and horizontal/vertical boxing. It handles basic values (numbers, strings) and structured data (lists, arrays, optional values) through customizable separators and formatting, supporting transformations like flattening nested structures, extracting string representations, or debugging via tree visualization. Use cases include generating human-readable logs, pretty-printing complex data with adaptive layouts, and embedding annotations for documentation or diff tracking.",
      "description_length": 664,
      "index": 1263,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "System",
      "library": "rocq-runtime.lib",
      "description": "This module provides file system navigation and manipulation, binary data serialization, and performance analysis capabilities. It operates on Unix paths, directories, files, channels, time values, and instruction counters, supporting tasks like path resolution, file metadata checks, duration measurement, and instruction count profiling. Key use cases include build system path management, binary format handling, and code execution performance characterization through marshaling and instrumentation.",
      "description_length": 503,
      "index": 1264,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "DAst",
      "library": "rocq-runtime.lib",
      "description": "This module wraps AST nodes with lazy evaluation capabilities, allowing delayed computation and location tracking. It provides operations to create, force, and map over lazily evaluated values, while preserving source location information. Used primarily for handling global constraints in a parsed form, where deferred evaluation and precise location metadata are critical.",
      "description_length": 374,
      "index": 1265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Aux_file",
      "library": "rocq-runtime.lib",
      "description": "This module manages auxiliary files for key-value data storage during program execution, supporting load, update, and query operations with optional source tracking, and integrates ordered map structures for efficient, deterministic manipulation of string-keyed and integer-pair-keyed data. The main data types include ordered maps with polymorphic values and persistent maps with integer-pair keys, offering operations like ordered traversal, safe lookups, merging, and sequence conversion. You can use it to log intermediate results, persist contextual data during analysis, or represent sparse grids with efficient key-based queries. The combination of file-level persistence and in-memory ordered maps enables structured handling of dynamic and static key-value associations in a unified workflow.",
      "description_length": 801,
      "index": 1266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Instr",
      "library": "rocq-runtime.lib",
      "description": "This module provides a function `read_counter` to retrieve the current value of a global instruction counter, returning either the count as an `Int64.t` or an error message. It is designed for measuring the relative number of instructions executed between two points in a program. Use this module to profile code performance by capturing instruction counts before and after a target operation and computing the difference.",
      "description_length": 422,
      "index": 1267,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hook",
      "library": "rocq-runtime.lib",
      "description": "This module implements runtime-initialized hooks with single assignment semantics. It provides operations to create, retrieve, and set typed values through `make`, `get`, and `set`. Useful for late binding of configuration values or dependency injection where initialization must occur once and only once.",
      "description_length": 305,
      "index": 1268,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CWarnings",
      "library": "rocq-runtime.lib",
      "description": "This module provides a system for defining and managing warnings with customizable categories, statuses, and message formats, supporting global and temporary control over warning behavior through flags and quickfixes. It introduces core types such as warning identifiers, category tags, and state configurations, allowing operations like enabling, disabling, or elevating warnings to errors, along with structured message formatting. Submodules extend this functionality by offering predefined warning categories, utilities for scoped warning suppression, and integration with error-reporting pipelines. Example uses include configuring compiler diagnostics to treat certain warnings as errors, temporarily silencing known issues during specific phases, or customizing warning output for user-facing tools.",
      "description_length": 806,
      "index": 1269,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CoqProject_file",
      "library": "rocq-runtime.lib",
      "description": "This module handles parsing and managing Coq project configurations from both command-line arguments and project files. It works with structured data types like `arg_source`, `meta_file`, and `project`, which track the origin of configuration values and manage file paths with source information. Concrete use cases include reading and validating `.coqproject` files, extracting command-line arguments, locating project files in a directory hierarchy, and filtering or transforming file lists based on suffixes or source.",
      "description_length": 521,
      "index": 1270,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "CAst",
      "library": "rocq-runtime.lib",
      "description": "This module wraps values with optional location information, enabling transformations and comparisons that preserve or utilize source positions. It provides core operations to construct, map, and extract values with location context, along with a recursive transformation function that applies a given function to every node in a `CAst.t` structure. The main data type `CAst.t` represents a generic abstract syntax tree, where each node may carry location metadata. You can use it to build ASTs with source tracking, modify nodes during analysis or compilation passes, or compare values while respecting their original positions in the source code.",
      "description_length": 648,
      "index": 1271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UserWarn",
      "library": "rocq-runtime.lib",
      "description": "This module defines and manages user-triggered warnings, including deprecation notices, with support for attaching notes and categories. It works with structured warning types that include optional locations and customizable warning messages. Concrete use cases include emitting warnings during code parsing or evaluation when deprecated features or user-defined warning conditions are encountered.",
      "description_length": 398,
      "index": 1272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Deprecation",
      "library": "rocq-runtime.lib",
      "description": "This module manages deprecation metadata and warnings for software objects, supporting version-based classification and qualified name handling. It allows creating and manipulating deprecation entries with version thresholds and custom notes, and emits warnings when deprecated objects are accessed. The child module introduces version-specific warning categories like v8_3 and v8_5, enabling precise control over deprecation notices during software version transitions. For example, a definition can be marked as deprecated starting in version 8.3, with a warning emitted only when the code is compiled in a version past that threshold.",
      "description_length": 637,
      "index": 1273,
      "embedding_norm": 1.0
    },
    {
      "module_path": "NewProfile",
      "library": "rocq-runtime.lib",
      "description": "This module profiles OCaml code execution by measuring time and invocation counts for named operations, aggregating data into structured JSON reports via the `MiniJson` submodule. It tracks performance metrics using the `Counters` module, which provides numeric counters with operations to increment, retrieve, reset, and format values. With `Counters`, you can monitor usage statistics or low-level performance data, while `MiniJson` serializes and pretty-prints that data for readable output. Use this combination to analyze function performance, generate structured profiling logs, and display metrics in a lightweight, portable format.",
      "description_length": 639,
      "index": 1274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AcyclicGraph",
      "library": "rocq-runtime.lib",
      "description": "This module represents directed acyclic graphs (DAGs) that model strict partial orders, allowing the addition of constraints like less-than, less-than-or-equal, and equality between nodes while ensuring acyclicity. It supports operations for dependency resolution, topological sorting, and constraint enforcement over abstract `Point.t` values, with utilities for traversal, comparison, and structural analysis. Child modules extend this foundation with monadic map transformations, ordered key-value maps, efficient node value updates preserving structural sharing, and set-theoretic operations for managing node collections. Specific applications include task scheduling with precedence constraints, hierarchical configuration systems, and formal verification tools requiring precise dependency tracking.",
      "description_length": 806,
      "index": 1275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Util",
      "library": "rocq-runtime.lib",
      "description": "This module offers a comprehensive toolkit for data manipulation across fundamental types like strings, lists, arrays, and custom sum types. It provides direct utilities for equality, transformation, and comparison, while its submodules enable advanced operations such as memory-efficient list mapping, stateful array processing, and structured comparisons over composite data. Users can perform tasks like parsing tagged data with union types, optimizing map and fold operations on arrays, defining custom sort logic through comparison chains, and managing unreachable code paths through an empty type. The combination of low-level access and high-level abstractions supports efficient, expressive data handling across diverse application domains.",
      "description_length": 748,
      "index": 1276,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto1_plugin.Simple_print",
      "library": "tuto1_plugin",
      "description": "This module provides a function `simple_body_access` that retrieves the body of a global reference using an indirect accessor. It operates on data types `Global.indirect_accessor` and `Names.GlobRef.t`, returning an `EConstr.constr`. A concrete use case is extracting the definition body of a constant or variable for inspection or transformation in proof automation.",
      "description_length": 367,
      "index": 1277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto1_plugin.Inspector",
      "library": "tuto1_plugin",
      "description": "Prints values in a formatted way using a provided pretty-printing function, a conversion function, and a string header. Works with any data type through polymorphic printing functions. Useful for debugging by displaying intermediate values with custom formatting and contextual labels.",
      "description_length": 285,
      "index": 1278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto1_plugin.Simple_check",
      "library": "tuto1_plugin",
      "description": "This module implements two functions, `simple_check1` and `simple_check2`, which perform type checking and constraint resolution on Coq terms represented as `EConstr.constr`. They operate within the context of an environment (`Environ.env`) and an existential variable map (`Evd.evar_map`), returning updated constraint states alongside normalized terms. These functions are used during tactic execution to validate and refine incomplete proof terms.",
      "description_length": 450,
      "index": 1279,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Tuto1_plugin.Simple_declare",
      "library": "tuto1_plugin",
      "description": "This module handles the declaration of definitions in a Coq-like environment, providing a function to register a new definition with a given name, type, and value. It works with identifiers, existential variable maps, and global references, supporting both polymorphic and monomorphic declarations. A concrete use case is defining new constants during proof scripting or tactic development.",
      "description_length": 390,
      "index": 1280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Tuto1_plugin",
      "library": "tuto1_plugin",
      "description": "This module provides utilities for accessing and inspecting definitions, performing type checks on Coq terms, and declaring new definitions within a proof context. It centers around data types like `EConstr.constr`, `Environ.env`, and `Evd.evar_map`, with operations to retrieve definition bodies, format values for debugging, and validate terms during tactic execution. For example, you can extract and transform the body of a constant, print intermediate values with custom formatting, or register a new definition with a given name and type.",
      "description_length": 544,
      "index": 1281,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 1320,
    "meaningful_modules": 1282,
    "filtered_empty_modules": 38,
    "retention_rate": 0.9712121212121212
  },
  "statistics": {
    "max_description_length": 1002,
    "min_description_length": 106,
    "avg_description_length": 490.1107644305772,
    "embedding_file_size_mb": 4.656938552856445
  }
}