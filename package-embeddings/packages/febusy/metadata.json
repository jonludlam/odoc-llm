{
  "package": "febusy",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 16,
  "creation_timestamp": "2025-08-14T23:21:33.789297",
  "modules": [
    {
      "module_path": "Febusy.Edsl.File.List",
      "library": "febusy",
      "description": "This module constructs DAG nodes representing lists of files, using `make` to create artifacts with custom actions that produce file lists, and `return` to directly insert static file lists into the DAG. It operates on file lists as `[> `File of string ] list` values, integrating them into dependency graphs where each file path represents an artifact. Concrete use cases include defining dynamic file collections generated by build rules, such as compiling multiple source files into a list of object files.",
      "description_length": 509,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Febusy.Build.Database",
      "library": "febusy",
      "description": "This module implements a simple in-memory database for storing and retrieving key-value pairs, specifically strings. It provides mutable storage for two lists: one for caching string pairs and another for tracking string hashes. This can be used to manage build artifacts and their dependencies in a build system, where fast lookups and updates are required.",
      "description_length": 358,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Febusy.Edsl.Make_unix",
      "library": "febusy",
      "description": "Executes a build DAG in a Unix-like environment, handling dependencies and actions sequentially. Works with artifacts represented as nodes in a directed acyclic graph, where each artifact is tied to a specification and a representative value. Useful for implementing custom build systems that compile, link, or process files based on dynamic dependencies, such as generating configuration files or compiling source code on demand.",
      "description_length": 430,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Febusy.Edsl.System",
      "library": "febusy",
      "description": "This module provides functions for interacting with the file system and executing shell commands. It handles operations like reading/writing files, running commands with optional input redirection, and retrieving environment information such as the home directory. These functions are used to implement build actions that require direct OS interaction, like generating configuration files or invoking external tools.",
      "description_length": 416,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Febusy.Build.Artifact",
      "library": "febusy",
      "description": "This module handles serialization, deserialization, hashing, and string representation of artifact values. It operates on typed artifacts parameterized by two types, supporting conversion between in-memory values and string representations. Concrete use cases include persisting build outputs, generating content hashes, and reconstructing values from stored strings.",
      "description_length": 367,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Febusy.Edsl.File",
      "library": "febusy",
      "description": "This module provides functions to create and manipulate file artifacts within a dependency graph, supporting dynamic generation and static insertion of individual files or lists of files. It works with file paths as `string` values and file lists as `[> `File of string ] list` structures, integrating them into the DAG as buildable artifacts. Concrete use cases include defining source files, generated configuration files, or output artifacts like compiled binaries in a build system pipeline.",
      "description_length": 495,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Febusy.Build.State",
      "library": "febusy",
      "description": "This module manages the state of a build process, tracking artifacts, dependencies, and build metadata. It supports operations to push build statuses onto a stack, save and load state to disk, log messages, and check dependency hashes. Concrete use cases include resuming interrupted builds, tracking build depth for cycle detection, and caching build results based on artifact hashes.",
      "description_length": 385,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Febusy.Build.DAG",
      "library": "febusy",
      "description": "This module represents a directed acyclic graph (DAG) for composing build actions and artifacts. It supports operations like binding sequential actions, joining parallel computations, and ensuring artifact dependencies through explicit action constraints. It is used to define build pipelines where artifacts are produced through dependent or concurrent steps.",
      "description_length": 360,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Febusy.Edsl.String_value",
      "library": "febusy",
      "description": "The module defines a string artifact with a specification type that includes an `id`. It provides the `create` function to construct artifacts from string values. This supports building DAG nodes representing string-based build outputs, such as configuration files or generated text, directly within the DSL.",
      "description_length": 308,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Febusy.Common.Error",
      "library": "febusy",
      "description": "This module defines a custom error type that represents errors as strings or wrapped exceptions with context. It provides functions to construct and format these errors, catch exceptions into result types, and convert errors to strings. It is used to handle and propagate errors in computations that require detailed diagnostic messages or exception tracking.",
      "description_length": 359,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Febusy.Build.Action",
      "library": "febusy",
      "description": "This module defines a GADT for representing actions that produce values, specifically supporting OCaml function actions. It provides operations to execute these actions and convert them to string representations. Concrete use cases include modeling build steps with deferred execution and serializing actions for logging or debugging.",
      "description_length": 334,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Febusy.Meta",
      "library": "febusy",
      "description": "Stores and provides access to build-time metadata such as version strings. Works with basic data types like strings to expose information generated during the build process. Useful for embedding version numbers or other static build details directly into applications or libraries.",
      "description_length": 281,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Febusy.Build",
      "library": "febusy",
      "description": "This module coordinates build processes by combining artifacts, actions, and dependency graphs. It provides functions to execute build pipelines, check build statuses, and manage artifact caching and dependencies. Concrete use cases include running build steps with dependency resolution, resuming builds from saved state, and ensuring correct artifact production based on hash validation.",
      "description_length": 389,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Febusy.Edsl",
      "library": "febusy",
      "description": "This module provides a monadic DSL for constructing dynamic dependency graphs (DAGs) of build artifacts, where each node represents a buildable item tied to an action. It supports operations like `return`, `>>=`, and `=<>=` to sequence and combine artifacts, and integrates file and string-based artifacts for concrete build tasks like generating config files or compiling code. Key data types include `'artifact DAG.t` for the graph structure and `('spec, 'repr) Artifact.t` for individual build items, with specific use cases in defining build pipelines that involve file manipulation, shell commands, and value serialization.",
      "description_length": 628,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Febusy.Common",
      "library": "febusy",
      "description": "This module provides functions for formatted output to various destinations, including channels, buffers, and strings, with support for conditional printing and continuation-based handling. It works with standard output channels, extensible buffers, and custom error types. Concrete use cases include logging to files or standard streams, building dynamic strings efficiently, and integrating error diagnostics with formatted message handling.",
      "description_length": 443,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Febusy",
      "library": "febusy",
      "description": "This module coordinates build pipelines using dependency graphs and artifact management, supporting operations like build execution, status tracking, and cache control. It works with artifact representations, action specifications, and dependency metadata to enable use cases such as incremental builds, build resumption, and hash-validated output generation.",
      "description_length": 359,
      "index": 15,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 16,
    "meaningful_modules": 16,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 628,
    "min_description_length": 281,
    "avg_description_length": 401.3125,
    "embedding_file_size_mb": 0.2322540283203125
  }
}