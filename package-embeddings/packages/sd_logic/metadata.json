{
  "package": "sd_logic",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 14,
  "creation_timestamp": "2025-08-14T23:23:44.366612",
  "modules": [
    {
      "module_path": "Sd_logic.Sd_lang.Let_syntax.Let_syntax.Open_on_rhs",
      "library": "sd_logic",
      "description": "This module provides functions to construct and manipulate temporal logic expressions involving state variables and their past values. It supports operations like returning a value in a logic context, referencing state variables, accessing historical values, and capturing the full state history. These functions are used to define complex temporal properties over state transitions in formal verification tasks.",
      "description_length": 412,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic.Sd_lang.Let_syntax.Let_syntax",
      "library": "sd_logic",
      "description": "This module provides functions to build and combine temporal logic expressions over state variables. It supports operations like returning a value in a logic context, mapping over existing expressions, and pairing expressions to capture state transitions. These are used to specify and verify temporal properties of stateful systems by composing logical assertions about current and past states.",
      "description_length": 395,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic.Sd.Packed",
      "library": "sd_logic",
      "description": "This module defines a packed type `t` that wraps values of any type `'a` wrapped in an `sd_t` structure, enabling heterogeneous storage and comparison. It provides operations to create instances, convert to strings, compare, hash, and check equality of these packed values. Concrete use cases include managing polymorphic symbolic data representations where type-erased values need to be stored uniformly and compared or hashed based on their underlying structure.",
      "description_length": 464,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic.Sd_lang.Let_syntax",
      "library": "sd_logic",
      "description": "This module provides functions for constructing and manipulating temporal logic expressions over state variables. It supports operations such as embedding values into logic contexts, mapping over expressions, and pairing expressions to model state transitions. These capabilities enable precise specification and verification of temporal properties in stateful systems, such as invariants and event sequences across time steps.",
      "description_length": 427,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic.Sd.Id",
      "library": "sd_logic",
      "description": "This module defines a type `t` representing unique identifiers with functions for comparison, serialization, and deserialization. It supports working with S-expressions through `t_of_sexp` and `sexp_of_t`, and provides a comparator for ordering. Concrete use cases include managing and comparing identifiers in data structures like sets and maps.",
      "description_length": 346,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic.Sd_lang.Applicative_infix",
      "library": "sd_logic",
      "description": "This module defines infix operators for applicative functor operations over the `Sd_logic.Sd_lang.t` type. It supports function application within contexts using `<*>`, value sequencing with `<*` and `*>`, and mapped transformations with `>>|`. These operations enable composing effectful computations that maintain logical structure, such as combining parser results or chaining conditional logic evaluations.",
      "description_length": 410,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic.Seq_model",
      "library": "sd_logic",
      "description": "Models sequential logic circuits with a type `t` representing the circuit state and `safety` indicating execution constraints. It supports creating circuits from node lists, advancing simulation steps with `tick`, and running simulations for a duration or number of ticks. Used to simulate digital circuit behavior over time, handling safe or unsafe node evaluations.",
      "description_length": 367,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic.Rs",
      "library": "sd_logic",
      "description": "This module implements a map-like structure for efficiently storing and manipulating key-value pairs where keys are of type `Sd_logic.Sd.t` or `Sd_logic.Sd.Packed.t`. It supports operations such as insertion, lookup, deletion, and set-based filtering, all with logarithmic time complexity for individual operations and linear or combined complexity for bulk operations. It is used to manage dynamic robot state data, enabling selective updates, queries, and synchronization based on specific state descriptors.",
      "description_length": 510,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic.Sd_node",
      "library": "sd_logic",
      "description": "Represents a node in a safety-directed computation graph, containing logic for robot state transitions and a set of safety directives. It supports creating nodes with custom logic and safety constraints, and executing them with varying safety levels against a robot state history to produce a transformed state. Used to model and enforce safety behaviors in robotic control systems.",
      "description_length": 382,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic.Sd",
      "library": "sd_logic",
      "description": "This module creates and manipulates typed symbolic identifiers with comparison, hashing, and S-expression serialization. It works with polymorphic wrapped values and supports concrete use cases such as tracking and comparing structured identifiers in symbolic data systems. The packed submodule enables heterogeneous storage and comparison of these identifiers, useful for managing type-erased symbolic representations in sets and maps.",
      "description_length": 436,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic.Sd_lang",
      "library": "sd_logic",
      "description": "This module implements applicative functor operations for composing and evaluating logical expressions with state dependencies. It provides functions like `map`, `both`, and `apply` to combine values within a context, along with infix operators for sequencing and transforming computations. Concrete use cases include building temporal logic formulas over state variables and evaluating these expressions against specific system states.",
      "description_length": 436,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic.Robot_state",
      "library": "sd_logic",
      "description": "This module implements a map-like structure for managing robot state data indexed by `Sd` keys, supporting efficient insertion, lookup, and deletion operations. It provides functions like `set`, `find`, and `remove` for individual key-value pairs, along with batch operations such as `use` and `trim_to` for managing subsets of state data. Use cases include tracking sensor values, configuration settings, or runtime variables associated with specific robot components identified by `Sd` or `Sd.Packed` keys.",
      "description_length": 508,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic.Robot_state_history",
      "library": "sd_logic",
      "description": "This module provides operations for managing a bounded history of robot states, supporting efficient addition of new states, retrieval of current and past values by SD identifiers, and presence checks for specific SDs. It operates on a list-based structure where each entry represents a robot state, with O(n) time complexity for length operations. This structure is useful in scenarios requiring temporal analysis of robot behavior, such as simulation playback, anomaly detection, or decision-making systems relying on historical state data.",
      "description_length": 542,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sd_logic",
      "library": "sd_logic",
      "description": "This module provides core abstractions for symbolic identifiers and state logic in robotic systems. It includes map-like structures for managing robot state data indexed by typed identifiers, supports efficient insertion, lookup, and filtering operations, and enables temporal analysis through bounded state history tracking. Concrete use cases include tracking sensor values over time, evaluating logical expressions against robot states, and modeling safety-directed computation graphs for control systems.",
      "description_length": 508,
      "index": 13,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 16,
    "meaningful_modules": 14,
    "filtered_empty_modules": 2,
    "retention_rate": 0.875
  },
  "statistics": {
    "max_description_length": 542,
    "min_description_length": 346,
    "avg_description_length": 438.7857142857143,
    "embedding_file_size_mb": 0.20329761505126953
  }
}