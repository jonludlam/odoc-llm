{
  "package": "datalog",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 78,
  "creation_timestamp": "2025-08-15T16:34:09.345126",
  "modules": [
    {
      "module_path": "Datalog_caml_interface.Logic.T.Tbl",
      "library": "datalog.caml_interface",
      "description": "This component implements a hash table with keys of type `Datalog_caml_interface.Logic.T.t` and polymorphic values, supporting imperative operations like insertion, lookup, iteration, and size tracking. It includes functions for bulk modification and construction from sequences of key-value pairs (`Stdlib.Seq.t`), enabling efficient data ingestion workflows and transformations between tabular and sequential representations. Use cases include dynamic dataset management and processing logic terms paired with arbitrary metadata in Datalog engines.",
      "description_length": 550,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Logic.BuiltinFun",
      "library": "datalog.caml_interface",
      "description": "This module manages built-in functions for evaluating terms in a logic system. It provides operations to create and manipulate a map of functions, associate constants with their corresponding evaluation functions, and check or perform evaluations. Use cases include extending the logic system with custom term evaluation rules and executing built-in operations during term processing.",
      "description_length": 384,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Logic.T",
      "library": "datalog.caml_interface",
      "description": "This module represents logical terms in a Datalog engine, supporting construction and inspection of variables, constants, and function applications. It provides operations for checking term properties like groundness, extracting variables, comparing and hashing terms, and pretty-printing. Use cases include term manipulation in Datalog rule processing, query evaluation, and transformation pipelines.",
      "description_length": 401,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Logic.TVariantTbl",
      "library": "datalog.caml_interface",
      "description": "This module implements a hash table structure with keys of type `T.t` and polymorphic values, supporting imperative operations like insertion, deletion, lookup, and in-place modifications. It includes bulk processing capabilities for iteration, folding, filtering, and converting entries to sequences, alongside utilities to build or update tables from sequential key-value data. Such functionality is suited for dynamic data aggregation or transformation workflows where bulk updates from sequences are required.",
      "description_length": 513,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_caml_interface.Logic.Index",
      "library": "datalog.caml_interface",
      "description": "This module implements an index for efficient retrieval of data associated with logic terms, supporting operations like adding, removing, and querying term-data bindings. It works with logic terms and substitutions, enabling concrete use cases such as rule indexing and query resolution in logic programming. Key functionality includes generalization and unification-based lookups, which are used to find relevant clauses during theorem proving or logic inference tasks.",
      "description_length": 470,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Logic.C",
      "library": "datalog.caml_interface",
      "description": "This module represents logical clauses in a Datalog program, supporting operations to construct clauses and facts, compare and hash them, and access components like the head symbol and maximum variable index. It works with terms and literals from the `Logic` module to define rules and facts in a Datalog knowledge base. Concrete use cases include building and manipulating Datalog rules for program analysis and logic-based reasoning tasks.",
      "description_length": 441,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Logic.Lit",
      "library": "datalog.caml_interface",
      "description": "This module represents logical literals in a Datalog-like language, supporting positive, negative, and aggregate literals. It provides constructors for creating and manipulating literals, including functions to apply transformations, compare, and serialize them. Use cases include building and processing logical expressions with aggregation constraints in program analysis or logic programming tasks.",
      "description_length": 401,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Logic.Rewriting",
      "library": "datalog.caml_interface",
      "description": "This module implements a term rewriting system for logic expressions, supporting rule-based transformations. It works with terms represented by `Datalog_caml_interface.Logic.T.t` and maintains a collection of rewrite rules of type `rule`, which are pairs of terms representing left-hand and right-hand sides. Use it to normalize logic expressions recursively or apply rewriting at the root level only, enabling tasks like formula simplification or equivalence checking under defined rewrite rules.",
      "description_length": 497,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Logic.CVariantTbl",
      "library": "datalog.caml_interface",
      "description": "This module implements a hash table for imperative manipulation of key-value associations where keys are logic terms (`C.t`) and values are polymorphic. It supports efficient bulk operations like sequence-based initialization and in-place filtering, alongside standard imperative modifications and queries. The structure is particularly suited for scenarios requiring dynamic updates or bulk data processing, such as compiling logic rules into mutable state or aggregating results from sequential computations.",
      "description_length": 510,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Logic.Subst",
      "library": "datalog.caml_interface",
      "description": "This module implements substitution management for logic variables in a Datalog interpreter. It supports operations to bind and dereference variables within a specific scope, rename variables to avoid capture, and apply substitutions to terms, literals, and clauses while ensuring variable uniqueness. It is used during query evaluation and rule instantiation to manage variable scoping and substitution.",
      "description_length": 404,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Logic.Const",
      "library": "datalog.caml_interface",
      "description": "This module defines operations for working with constant values in a Datalog context. It provides equality checking, hashing, string conversion, and a special query symbol for representing logical constants. The primary data type is `t`, which encapsulates constant values used in Datalog clauses and terms.",
      "description_length": 307,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_caml_interface.Rel3",
      "library": "datalog.caml_interface",
      "description": "This module implements a ternary relation abstraction with named keys, supporting operations to create, query, and manipulate relations using a logic database. It works with tuples of three arbitrary types and provides functions to add data from lists or predicates, retrieve matching tuples, and format relations as strings. Concrete use cases include representing and querying structured logical facts with three attributes, such as relationships between entities in a deductive database.",
      "description_length": 490,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Rel2",
      "library": "datalog.caml_interface",
      "description": "This module implements binary relations for use in a Datalog database, supporting operations like creating relations, adding axioms, and enforcing logical properties such as transitivity, reflexivity, and symmetry. It works with typed pairs `'a * 'b` and integrates with a database to define and query logical facts. Concrete use cases include defining hierarchical relationships, enforcing ordering constraints, and encoding predicate logic rules with user-defined functions.",
      "description_length": 476,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Univ",
      "library": "datalog.caml_interface",
      "description": "This module implements a type-safe universe of values with dynamic typing capabilities. It allows creating typed keys to pack and unpack values of arbitrary types, ensuring type safety through key-specific operations like `pack`, `unpack`, and `compatible`. Common use cases include embedding domain-specific languages with heterogeneous data storage, implementing generic memoization, and handling runtime type-checked data exchanges.",
      "description_length": 435,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Logic",
      "library": "datalog.caml_interface",
      "description": "This module implements a logic programming engine with operations for unification, alpha equivalence, and constrained query evaluation over logic databases. It manipulates terms, literals, and clauses while maintaining term-value mappings and built-in functions to support rule-based reasoning and constraint solving. Key functionality includes binding variables through literal constraints and rewriting terms via substitution, enabling applications like deductive database queries and symbolic computation.",
      "description_length": 508,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.RelList",
      "library": "datalog.caml_interface",
      "description": "This module implements a relation list structure that maps logic terms to typed lists of values. It supports creating named relations with optional keys, retrieving value lists by logic term, and constructing logic terms from value lists. It is used to represent and manipulate logical relations with associated data in a type-safe manner.",
      "description_length": 339,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Rel1",
      "library": "datalog.caml_interface",
      "description": "This module implements a representation for unary relations in a Datalog-like logic system. It provides operations to create, query, and manipulate relations using terms and logic databases, supporting tasks like subset assertions, function-based relation definition, and batch axiom addition. Concrete uses include encoding domain-specific facts and rules over structured data terms.",
      "description_length": 384,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_caml_interface.Parse",
      "library": "datalog.caml_interface",
      "description": "This module parses Datalog terms, literals, and clauses from various input sources like strings, files, and channels. It converts abstract syntax trees into internal data representations and supports loading parsed clauses directly into a database. Concrete use cases include reading Datalog programs from text files, parsing individual clauses for evaluation, and initializing a logic database from string-encoded rules.",
      "description_length": 421,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_caml_interface",
      "library": "datalog.caml_interface",
      "description": "This module bridges Datalog and OCaml by enabling typed constant embedding, logic database operations, and relation management. It supports universal constants, logic terms, and unary, binary, and ternary relations, along with parsing and built-in function integration. Concrete use cases include defining and querying structured logical facts, enforcing relational properties like transitivity, and parsing Datalog rules from text into executable logic databases.",
      "description_length": 464,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Default.T.Tbl",
      "library": "datalog.top_down",
      "description": "This module offers imperative hash table operations for key-value pairs with a specialized key type, supporting creation, modification, and querying through standard methods like `add`, `find`, and `fold`, as well as sequence-driven bulk operations such as `add_seq` and `of_seq`. It works with hash tables and sequences, enabling efficient data ingestion from sequential sources and in-place transformations with functions like `filter_map_inplace`. Typical use cases include building or updating tables from large datasets, iterative processing with dynamic key-value binding, and scenarios requiring fine-grained control over hash table state.",
      "description_length": 646,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Make.T.Tbl",
      "library": "datalog.top_down",
      "description": "This module manages key-value stores with `T.t` keys and polymorphic values, offering creation, mutation, traversal, and conversion to sequences alongside statistics tracking. It emphasizes batch operations through `Stdlib.Seq.t`, enabling bulk inserts, replacements, and table initialization from sequences. Such capabilities are ideal for bulk data ingestion, transactional updates, or building tables from streaming data sources.",
      "description_length": 432,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_top_down.Default.C.Tbl",
      "library": "datalog.top_down",
      "description": "This module implements hash table operations for keys of type `Datalog_top_down.Default.C.t`, supporting in-place modifications like insertion and deletion, as well as functional queries via iteration, folding, and sequence conversion. It provides bulk operations to add or replace key-value pairs from `Stdlib.Seq` sequences of tuples and convert between hash tables and such sequences. These capabilities are useful for efficiently managing dynamic key-value mappings or transforming data between structured formats and sequential processing pipelines.",
      "description_length": 554,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Make.C.Tbl",
      "library": "datalog.top_down",
      "description": "This module provides imperative hash table operations for managing key-value pairs with keys of type `C.t`, supporting efficient insertion, deletion, lookup, and traversal. It includes bulk manipulation functions to process sequences of key-value pairs, enabling use cases like batch updates or initializing tables from streamed data. The design emphasizes seamless integration with `C.t`-keyed tables in functor-generated contexts, offering optimized variants for handling optional and multi-result queries.",
      "description_length": 508,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Make.DB",
      "library": "datalog.top_down",
      "description": "This module provides operations to manage a Datalog knowledge base, supporting unification-based query evaluation, clause resolution with substitution, and interpreter registration for constant terms. It operates on a database structure (`DB.t`) containing facts, clauses, and interpreters, enabling top-down reasoning by matching goals against clause heads while optionally applying occur checks during unification. Typical use cases include logic programming systems and rule-based inference engines where deductive reasoning over relational data is required.",
      "description_length": 561,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_top_down.Make.CVariantTbl",
      "library": "datalog.top_down",
      "description": "This module implements a specialized hash table for variant-keyed data, supporting imperative operations like insertion, lookup, iteration, and in-place transformations over key-value pairs where keys conform to `C.t` and values are polymorphic. It emphasizes bulk manipulation through sequence-driven workflows, enabling efficient construction, replacement, or merging of entries from sequential data sources. Typical applications include processing dynamically typed variant mappings or staging batch updates to variant-indexed datasets.",
      "description_length": 539,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Default.BuiltinFun",
      "library": "datalog.top_down",
      "description": "This module manages built-in functions for evaluating terms in a Datalog interpreter. It provides operations to register functions for specific constants, check if a constant is associated with a built-in function, and evaluate terms using those functions. The core data structures are terms (`T.t`) and constants (`Const.t`), organized through a map that associates constants with their corresponding evaluation functions. Use cases include implementing and applying built-in operations like arithmetic, comparison, or string manipulation directly within Datalog rules.",
      "description_length": 570,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Make.Subst",
      "library": "datalog.top_down",
      "description": "This module implements substitution management for logic variables in a top-down Datalog interpreter. It supports binding variables to terms with scope tracking, dereferencing variables through chains of bindings, and safe renaming of variables to avoid capture during substitution. Key operations include `bind`, `deref`, and `eval`, which are used to manipulate and apply substitutions to terms, literals, and clauses during query evaluation.",
      "description_length": 444,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_top_down.Default.Subst",
      "library": "datalog.top_down",
      "description": "This module implements substitution management for logic variables in a Datalog interpreter. It supports operations like binding variables to terms, dereferencing variables through chains of substitutions, and renaming variables to ensure uniqueness. Substitutions are applied to terms, literals, and clauses during query evaluation to manage variable scoping and avoid capture.",
      "description_length": 378,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_top_down.Default.Const",
      "library": "datalog.top_down",
      "description": "This module defines operations for working with constant values in a Datalog top-down evaluation context. It provides equality checking, hashing, and conversion to and from strings for constants, supporting efficient comparison and representation. A special query symbol is used internally to represent an unmatched value, distinct from any user-defined constant.",
      "description_length": 363,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Default.C",
      "library": "datalog.top_down",
      "description": "This module represents logical clauses in a Datalog program, consisting of a head term and a list of body literals. It supports constructing clauses and facts, comparing clauses for equality, hashing, extracting symbol information, mapping over terms, and string formatting. Use cases include defining Datalog rules and facts, manipulating logical expressions, and preparing clauses for storage or output.",
      "description_length": 405,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Make.TVariantTbl",
      "library": "datalog.top_down",
      "description": "This module implements imperative hash table operations for key-value pairs with keys of type `T.t` and values stored in a typed variant structure, supporting insertion, lookup, deletion, in-place filtering, and folding. It enables batch manipulation through sequence conversions (`add_seq`, `replace_seq`, `of_seq`) and handles optional values, making it suitable for scenarios requiring efficient key-based data aggregation with presence-sensitive values and statistical analysis.",
      "description_length": 482,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Make.BuiltinFun",
      "library": "datalog.top_down",
      "description": "This module implements a map for storing and managing built-in functions that evaluate terms in a Datalog engine. It supports operations to add, check, and apply built-in functions to terms, where each function is associated with a constant and may transform a term into another or return `None` if evaluation fails. The module is used to define and execute primitive operations such as arithmetic, comparison, or string manipulation directly on Datalog terms during evaluation.",
      "description_length": 478,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Make.Lit",
      "library": "datalog.top_down",
      "description": "This module represents logical literals, including positive, negative, and aggregated literals, using a parameterized type `T.t`. It provides constructors to build literals, operations to compare and transform them, and utilities to convert literals to strings or output them to channels. Use cases include representing clauses in a logic engine, processing symbolic expressions, and supporting transformations in a rule-based system.",
      "description_length": 434,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_top_down.Default.Index",
      "library": "datalog.top_down",
      "description": "This module implements a mutable index structure for efficient retrieval of data associated with terms in a Datalog engine. It supports operations to add, remove, and query term-data bindings, with specialized functions for finding generalizations and unifying terms. Use cases include accelerating rule evaluation and managing scoped term substitutions during logic program execution.",
      "description_length": 385,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Default.DB",
      "library": "datalog.top_down",
      "description": "This module offers operations for constructing and manipulating Datalog databases, including adding facts and clauses, registering interpreters and built-in functions, and evaluating terms through unification. It works with Datalog terms, clauses, constants, and substitutions to support logic programming tasks like rule-based inference and symbolic computation. The functionality is designed for top-down query evaluation, where goals are matched against clause heads using substitutions and interpreter callbacks to derive results.",
      "description_length": 534,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Make.T",
      "library": "datalog.top_down",
      "description": "This module defines a term language with variables, constants, and function applications, supporting construction, inspection, and comparison of terms. It operates on the `t` type, representing terms as either variables (integers), constants, or applied functions with arguments. Concrete use cases include symbolic manipulation in logic programming, term rewriting systems, and implementing interpreters or compilers for domain-specific languages.",
      "description_length": 448,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Make.Rewriting",
      "library": "datalog.top_down",
      "description": "This module implements a term rewriting system that applies a set of rules to normalize terms either at the root level or recursively. It operates on terms of type `T.t` and maintains a collection of rewrite rules, each consisting of a pair of terms representing a transformation. Use cases include symbolic simplification, query optimization, and rule-based term manipulation where transformations must be applied in a controlled, top-down manner.",
      "description_length": 448,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Make.C",
      "library": "datalog.top_down",
      "description": "This module defines and manipulates logical clauses composed of a head term and a list of body literals. It supports constructing clauses and facts, comparing and hashing clauses, extracting symbols and variable counts, and applying term transformations. Use cases include implementing logic programming engines, analyzing or transforming Datalog rules, and managing logical assertions with structured bodies.",
      "description_length": 409,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Default.Rewriting",
      "library": "datalog.top_down",
      "description": "This module implements a term rewriting system for normalized Datalog expressions, supporting rule-based transformations. It allows adding and managing rewrite rules that operate on terms, with operations to normalize terms recursively or rewrite only their root. Use cases include simplifying logical expressions, optimizing query representations, and enforcing canonical forms during top-down evaluation.",
      "description_length": 406,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_top_down.Make.Index",
      "library": "datalog.top_down",
      "description": "This module implements an index structure for efficient term-based data retrieval and manipulation, supporting operations like adding, removing, and querying term-to-data bindings. It works with terms of type `T.t` and arbitrary data values of type `Data.t,` enabling indexed lookups based on term generalizations or unification. Concrete use cases include rule-based systems and logic programming engines where fast access to relevant data based on term structure is critical.",
      "description_length": 477,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Default.T",
      "library": "datalog.top_down",
      "description": "This module defines a term language for representing logical expressions with variables, constants, and function applications. It provides constructors and predicates for building and inspecting terms, along with operations for extracting variables, checking groundness, and comparing or hashing terms. Key use cases include implementing logic programming engines, symbolic manipulation, and term-based analysis or transformation passes.",
      "description_length": 437,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Default.Lit",
      "library": "datalog.top_down",
      "description": "This module represents logical literals in a Datalog engine, supporting positive, negative, and aggregate literals. It provides constructors for creating and manipulating literals, including functions to apply transformations, compare, and serialize them. Use cases include representing atoms in Datalog rules, evaluating logic programs, and handling aggregation operations during query processing.",
      "description_length": 398,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.MakeParse",
      "library": "datalog.top_down",
      "description": "This module parses Datalog clauses and terms from various input sources, converting them into internal representations using context mappings. It processes AST nodes from a concrete syntax tree into typed terms, literals, and clauses, supporting direct string and file parsing for easy integration with external specifications. Concrete use cases include loading Datalog programs from files, validating and converting user-provided strings into clauses for runtime evaluation, and building term dictionaries from named contexts.",
      "description_length": 528,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Make",
      "library": "datalog.top_down",
      "description": "This module implements a logic programming engine centered on symbolic manipulation of terms, literals, and clauses to support rule-based reasoning. It provides operations for unification, alpha equivalence checking, constrained query evaluation (`ask_lits`), and database-driven inference over structured data like terms (`T.t`), substitutions (`Subst.t`), and Datalog clauses (`C.t`). Key use cases include building knowledge bases with custom constraints, executing bound-variable logic queries, and managing rule expansions in systems requiring term rewriting or indexed fact retrieval.",
      "description_length": 590,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Parser",
      "library": "datalog.top_down",
      "description": "This module parses Datalog expressions into abstract syntax trees using a set of token types representing logical and arithmetic constructs. It includes functions to parse individual terms, literals, clauses, and entire files, handling input elements like variables, constants, operators, and logical connectives. It is used to convert tokenized Datalog source code into structured data for evaluation in a top-down interpreter.",
      "description_length": 428,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Default",
      "library": "datalog.top_down",
      "description": "This module implements logic programming operations for term manipulation, rule application, and query evaluation using structured representations like constants, literals, clauses, and substitutions. It provides utilities for unification, alpha equivalence checks, and database management with support for built-in functions and interpreters. Key use cases include parsing Datalog syntax into logical expressions, symbolic computation over structured data, and managing variable contexts during rule evaluation.",
      "description_length": 512,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.AST",
      "library": "datalog.top_down",
      "description": "This module defines the abstract syntax tree (AST) for terms, literals, clauses, and files used in a top-down Datalog implementation. It includes operations for representing logical expressions with variables, function applications, integers, and aggregates, along with error handling utilities for parsing and processing input. Concrete use cases include constructing and manipulating Datalog queries with negation, aggregation, and rule-based logic.",
      "description_length": 451,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down.Lexer",
      "library": "datalog.top_down",
      "description": "This module provides functions for lexical analysis, converting input text into tokens for parsing. It handles lexing of Datalog programs, including error reporting and location tracking. Concrete use cases include reading Datalog expressions from a file or interactive input and converting them into a structured token stream for the parser.",
      "description_length": 342,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_top_down",
      "library": "datalog.top_down",
      "description": "This module implements top-down evaluation of Datalog queries with support for non-stratified negation, using symbolic term manipulation and rule expansion. It works with logical terms, literals, clauses, and substitutions to perform constrained query evaluation and database inference. Concrete use cases include executing logic programs with negation and aggregation, building rule-based knowledge bases, and evaluating bound-variable queries over structured data.",
      "description_length": 466,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog.BottomUp.Make.Query",
      "library": "datalog",
      "description": "This module evaluates Datalog queries using a bottom-up approach, supporting operations like `ask` to construct logical queries over a database of atoms, and `iter`, `to_list`, and `cardinal` to process and inspect query results. It works with atoms, literals, and terms, organizing them into arrays to represent logical variables and constraints. Use it to express and solve constraint-based problems such as dependency analysis, access control policies, or static program analysis where logical inference over structured data is required.",
      "description_length": 540,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog.BottomUp.Univ",
      "library": "datalog",
      "description": "This module provides operations to embed, pack, and unpack values of arbitrary types into a universal type `t`, ensuring type-safe retrieval using the same embedding. It supports working with heterogeneous data in a type-agnostic container, primarily used when extending explanations with user-defined types. Concrete use cases include storing and retrieving values of different types in a shared context, such as during the execution of a Datalog engine.",
      "description_length": 455,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog.BottomUp.Hashcons",
      "library": "datalog",
      "description": "This module implements hash-consing for symbols using a user-defined equality and hashing function. It ensures that structurally equal symbols are represented by the same physical object, improving memory efficiency and enabling fast equality checks. It is useful when managing a large number of symbols where canonicalization is important, such as in symbolic computation or compiler internal representations.",
      "description_length": 410,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog.Default.StringSymbol",
      "library": "datalog",
      "description": "This module implements a symbol type for string-based identifiers with equality, hashing, and string conversion operations. It wraps string values into a distinct type to ensure consistent handling in contexts like logic variable representation or term indexing. The module is used to manage unique symbols in Datalog expressions, ensuring correct comparison and efficient lookup.",
      "description_length": 380,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog.Default.Query",
      "library": "datalog",
      "description": "This module evaluates logical queries against a database, producing lazy sets of variable instantiations that satisfy given constraints. It supports operations to execute queries with optional negation, iterate over results, and convert results to lists or count elements. Use it to extract structured data from a Datalog database by defining variables and constraints as literals.",
      "description_length": 381,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog.BottomUp.Make",
      "library": "datalog",
      "description": "This module specializes in constructing and manipulating typed logical expressions, managing a database of clauses with explanations, and performing bottom-up inference through fact matching and binding extraction. It operates on atoms, literals, clauses, and terms composed of variables and constants, supporting custom atom types beyond strings for domain-specific modeling. Typical applications include deductive databases, rule-based systems, or static analysis tools where atoms represent program states, type constraints, or dependency graphs requiring forward-chaining inference.",
      "description_length": 586,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog.Version",
      "library": "datalog",
      "description": "Contains the version number of the Datalog library as a string. This module provides direct access to the version identifier for runtime checks or logging. Useful for ensuring compatibility or reporting the library version in diagnostic output.",
      "description_length": 244,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog.BottomUp",
      "library": "datalog",
      "description": "Implements bottom-up evaluation of Datalog programs by computing the fixpoint of a database of facts and Horn clauses. It processes logical atoms, literals, and rules, deriving new facts through iterative application of deduction rules until no new information can be inferred. This module is used to execute Datalog programs that model relationships and constraints in domains like program analysis, knowledge representation, and relational data processing.",
      "description_length": 458,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog.AST",
      "library": "datalog",
      "description": "This module defines the abstract syntax tree for Datalog programs, centered around clauses composed of predicates and terms. It provides operations for constructing and manipulating Datalog rules and facts, including functions to create atoms, literals, and variables. Concrete use cases include parsing Datalog input into structured clauses and analyzing or transforming logic programs.",
      "description_length": 387,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog.Parser",
      "library": "datalog",
      "description": "This module defines a set of parsing functions for converting token streams into Datalog abstract syntax structures. It operates on lexbuf inputs using a custom token type that includes parentheses, keywords, literals, and identifiers. It directly constructs AST elements such as literals, clauses, and queries, suitable for processing Datalog programs and queries from textual input.",
      "description_length": 384,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog.Default",
      "library": "datalog",
      "description": "This module provides operations for constructing and manipulating logical entities such as terms (variables and constants), literals (predicates with arguments), and clauses (rules with premises and conclusions), along with equality, hashing, and ground-check utilities. It supports database management through safety validation, clause manipulation, and query processing features like literal matching, variable binding extraction, and derivation tracing. Typical use cases include converting parsed queries into normalized forms for evaluation, validating logical rule safety, and enabling incremental database updates via subscription hooks.",
      "description_length": 644,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog.Lexer",
      "library": "datalog",
      "description": "This module handles lexical analysis for parsing Datalog input. It provides functions to convert raw input into tokens, report lexing errors with context, and retrieve position information from the input stream. It operates on Lexing.lexbuf structures and produces tokens consumed by the Datalog parser.",
      "description_length": 303,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog",
      "library": "datalog",
      "description": "This module implements a Datalog interpreter with components for parsing, evaluating, and manipulating logic programs. It works with terms, literals, clauses, and facts to model relational logic, supporting use cases like static analysis, knowledge graphs, and rule-based systems. Key operations include parsing Datalog source into an AST, evaluating rules via bottom-up fixpoint computation, and managing logical entities with equality, hashing, and query processing.",
      "description_length": 468,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_unix.Default.TD.T.Tbl",
      "library": "datalog.unix",
      "description": "This module offers imperative hash table operations for key-value storage, including insertion, deletion, lookup, and bulk updates, using a custom key type optimized for efficient equality checks. It supports sequence-driven batch processing and transformations through folding and filtering, enabling scalable manipulation of dynamic datasets. Practical applications include managing transient relational data during rule evaluation or maintaining indexed collections for rapid query resolution in data-intensive workflows.",
      "description_length": 524,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_unix.Default.TD.C.Tbl",
      "library": "datalog.unix",
      "description": "This module provides imperative hash table operations for key-value associations where keys are of type `Datalog_unix.Default.TD.C.t` and values are arbitrary. It supports insertion, deletion, lookup, iteration, in-place filtering, and batch manipulation via sequences, including bulk additions, replacements, and table construction from key-value pairs. These capabilities are particularly useful for managing dynamic datasets requiring efficient lookups, incremental updates, or bulk initialization from structured data streams.",
      "description_length": 530,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_unix.Default.TD.Rewriting",
      "library": "datalog.unix",
      "description": "This module implements a term rewriting system for normalized Datalog terms, supporting rule-based transformations. It provides operations to add and apply rewriting rules, perform recursive normalization, and manage rewriting contexts. Use it to simplify or transform logical expressions in Datalog programs using user-defined rewrite rules.",
      "description_length": 342,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_unix.Default.TD.Lit",
      "library": "datalog.unix",
      "description": "This module represents logical literals in a Datalog context, supporting positive, negative, and aggregated forms. It provides constructors for creating literals, operations for equality and hashing, and transformations over terms. Use cases include building and manipulating Datalog clauses with precise term handling for logic evaluation.",
      "description_length": 340,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_unix.Default.TD.BuiltinFun",
      "library": "datalog.unix",
      "description": "This module manages a collection of built-in functions for evaluating terms in a Datalog interpreter. It provides operations to create and populate a function map, associate constants with their corresponding evaluation functions, and check or perform evaluation of terms using those built-in functions. Concrete use cases include defining arithmetic operations, comparison logic, or custom term transformations directly executable during Datalog rule processing.",
      "description_length": 463,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_unix.Default.TD.Subst",
      "library": "datalog.unix",
      "description": "This module implements substitutions for logic variables in a Datalog term representation, supporting operations to bind variables to terms, dereference bound variables, and rename variables to ensure uniqueness. It works with terms, literals, and clauses from the `TD` module, using scopes to manage variable visibility. Key use cases include applying substitutions during unification, generating fresh variable names during clause evaluation, and printing substitution contents for debugging.",
      "description_length": 494,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_unix.Default.TD.CVariantTbl",
      "library": "datalog.unix",
      "description": "This module implements imperative hash table operations for key-value pairs where keys are of type `Datalog_unix.Default.TD.C.t` and values are polymorphic. It supports standard operations like insertion, deletion, iteration, folding, and sequence conversion, along with batch processing functions to construct or update tables from sequences of key-value tuples. These capabilities are particularly useful in scenarios requiring efficient bulk data manipulation, such as ingesting or transforming dynamic datasets with structured keys.",
      "description_length": 536,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_unix.Default.TD.C",
      "library": "datalog.unix",
      "description": "This module represents logical clauses in a Datalog program, consisting of a head term and a list of body literals. It supports constructing clauses and facts, comparing and hashing clauses, extracting symbol information, mapping over terms, and converting clauses to string representations. It is used for defining and manipulating Datalog rules and facts in memory, particularly during program analysis or transformation tasks.",
      "description_length": 429,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_unix.Default.TD.Index",
      "library": "datalog.unix",
      "description": "This module implements a term-indexed data structure that supports efficient insertion, deletion, and retrieval of bindings between terms and arbitrary data. It provides operations for exact matches, generalization queries, and unification queries, enabling advanced term-based lookups commonly used in logic programming and theorem proving. The index is mutable and allows deep copying, iteration over bindings, and precise size tracking.",
      "description_length": 439,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_unix.Default.TD.DB",
      "library": "datalog.unix",
      "description": "This module enables creating and managing a Datalog database with operations for adding facts, clauses, and interpreters, evaluating terms, and handling built-in functions. It works with Datalog terms, substitutions, and scoped databases to support unification-based queries that retrieve clauses matching a goal under variable bindings. Specific use cases include rule-based reasoning, logical inference, and extending evaluation logic through interpreters for domain-specific constraints.",
      "description_length": 490,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_unix.Default.TD.T",
      "library": "datalog.unix",
      "description": "This module defines a term algebra for representing symbolic expressions with variables, constants, and function applications. It provides constructors, predicates, and utilities for term manipulation, including variable inspection, hashing, equality checks, and string formatting. Concrete use cases include building and analyzing logical expressions in a Datalog engine, where terms represent atoms or expressions in rules and queries.",
      "description_length": 437,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_unix.Default.TD.TVariantTbl",
      "library": "datalog.unix",
      "description": "This module implements a hash table with keys of type `Datalog_unix.Default.TD.T.t` and polymorphic values, supporting imperative operations like insertion, lookup, iteration, and folding. It also includes utilities for bulk initialization and updates via sequences of key-value pairs, enabling efficient construction and modification of tables from sequential data sources. The design emphasizes handling variant-based keys with dynamic values in scenarios requiring batch processing or transformation.",
      "description_length": 503,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_unix.Default.TD",
      "library": "datalog.unix",
      "description": "This module provides unification, matching, and alpha equivalence checks for terms and clauses in a Datalog engine. It operates on terms, literals, and clauses with support for variable substitution and scoping, enabling logic operations like rule application and query resolution. Concrete use cases include solving logical constraints, performing term rewriting, and managing variable bindings during Datalog program evaluation.",
      "description_length": 430,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_unix.Make",
      "library": "datalog.unix",
      "description": "Implements a system for registering event handlers that react to changes in a Datalog database. It operates on `TD.DB.t`, a typed database structure, and provides `setup_handlers` to bind logic that executes when specific database events occur. This module is useful for building reactive systems where database updates must trigger side effects like cache invalidation or notification streams.",
      "description_length": 394,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Datalog_unix.Default",
      "library": "datalog.unix",
      "description": "This module implements unification, matching, and alpha equivalence checks for terms and clauses in a Datalog engine. It works with terms, literals, and clauses, supporting variable substitution and scoping. It is used for logic operations such as rule application, query resolution, solving logical constraints, and managing variable bindings during Datalog program evaluation.",
      "description_length": 378,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Datalog_unix",
      "library": "datalog.unix",
      "description": "Implements event-driven logic for reacting to database changes using typed Datalog structures, with functions to register handlers that execute on specific database events. It operates on `TD.DB.t` to enable real-time side effects like cache invalidation or streaming notifications in response to data updates. The `Default` submodule provides core logic operations for term unification, clause matching, and variable binding used during rule evaluation and query solving.",
      "description_length": 472,
      "index": 77,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 82,
    "meaningful_modules": 78,
    "filtered_empty_modules": 4,
    "retention_rate": 0.9512195121951219
  },
  "statistics": {
    "max_description_length": 646,
    "min_description_length": 244,
    "avg_description_length": 452.4230769230769,
    "embedding_file_size_mb": 1.130873680114746
  }
}