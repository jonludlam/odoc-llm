{
  "package": "mirage",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 74,
  "creation_timestamp": "2025-07-15T23:18:21.390061",
  "modules": [
    {
      "module_path": "Functoria.Lib.Make",
      "library": "mirage.functoria",
      "description": "This module provides the `register` function to define and configure applications by specifying jobs and optional initialization tasks. It operates on job implementations and source settings, enabling concrete use cases like setting up custom application entry points with dependency injection. The function supports configuring source locations and initialization logic for building modular, configurable systems.",
      "description_length": 414,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Tool.S",
      "library": "mirage.functoria",
      "description": "This module defines the interface for CLI tools that assemble and compile functor implementations. It specifies operations to declare tool metadata, load dependency packages, and construct job implementations from a list of functor components. It is used to generate executable commands that build and execute functor-based configurations.",
      "description_length": 339,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Package.Set",
      "library": "mirage.functoria",
      "description": "This module provides operations for creating and manipulating sets of opam packages, including union, conversion to and from lists, and an empty set. It works with the `Functoria.Package.t` type as the element of the set. Concrete use cases include managing collections of dependencies or required packages in a build system or package manager context.",
      "description_length": 352,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Lib.S",
      "library": "mirage.functoria",
      "description": "This module defines the interface for custom application builders, specifying values and functions needed to configure and generate a project. It includes operations for setting up build-time metadata, package dependencies, and entry points, as well as generating dune project stanzas and target-specific names. Concrete use cases include defining a custom DSL for MirageOS unikernels or configuring a library with specific build flags and d",
      "description_length": 441,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Runtime_arg.Set",
      "library": "mirage.functoria",
      "description": "The module provides set operations for managing collections of command-line argument descriptors, supporting union, intersection, difference, and element-wise transformations while preserving ordering constraints. It works with sets of elements, offering functions to convert between lists/sequences, filter, map, and query membership or structural properties. This structure is useful for composing runtime argument configurations, validating argument sets, or generating ordered representations for user-facing output.",
      "description_length": 520,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Action.Syntax",
      "library": "mirage.functoria",
      "description": "This module provides monadic and applicative syntax for composing actions that support sequencing and value transformation. It works with values of type `'a Functoria.Action.t`, enabling operations like `let*` for flat-mapping and `let+` for mapping within action chains. Concrete use cases include building complex action pipelines with dependency handling, such as file system operations or command executions, while preserving the ability to perform dry runs.",
      "description_length": 462,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Tool.Make",
      "library": "mirage.functoria",
      "description": "This module provides functions to run a configuration builder for CLI tools, parsing command-line arguments and generating code. It handles the execution flow for assembling functors based on provided configurations. Use it to build and compile functor-based systems from the command line or with custom argument arrays.",
      "description_length": 320,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Functoria.Key.Set",
      "library": "mirage.functoria",
      "description": "This module provides standard set operations\u2014union, intersection, difference, membership checks, and transformations via mapping or filtering\u2014alongside utilities for ordered traversal and conversion to or from lists and sequences. It operates on sets of configuration keys, maintaining element uniqueness and a consistent internal order while supporting functional purity and performance. Typical applications include managing collections of command-line arguments, combining configuration sets, or extracting ordered subsets for deterministic processing.",
      "description_length": 555,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Impl.Tbl",
      "library": "mirage.functoria",
      "description": "This module implements a mutable hash table for efficient key-value storage and manipulation, supporting operations like insertion, lookup, iteration, and in-place updates using keys of type `Functoria.Impl.abstract`. It works with sequences of key-value pairs for bulk modifications or table initialization, enabling use cases such as dynamic configuration management or transient data processing where fast access and incremental updates are critical. The ability to fold over entries and filter bindings also supports analytical workflows over structured data.",
      "description_length": 563,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Device.Graph",
      "library": "mirage.functoria",
      "description": "This module represents a directed acyclic graph of devices, where each node contains a device implementation, its dependencies, and command-line arguments. It provides operations to traverse the graph in topological order and generate valid OCaml variable and module names for each node. Use this module to manage and resolve device configurations with interdependencies in a type-safe manner.",
      "description_length": 393,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Key.Arg",
      "library": "mirage.functoria",
      "description": "This module provides functions to define typed command-line arguments with cross-stage persistence, supporting optional, required, and flag arguments. It works with standard OCaml types like `string`, `int`, `bool`, and lists, enabling configuration values to be passed between stages of a multi-stage program. Concrete use cases include defining persistent configuration options for command-line tools that generate code or configure behavior across different execution stages.",
      "description_length": 478,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Action.List",
      "library": "mirage.functoria",
      "description": "Implements list traversal and transformation operations within the Action context, handling effects like file system interactions with dry-run support. Works directly with lists of values wrapped in the Action monad, enabling sequential execution of effectful operations. Useful for processing collections of system resources such as files or configuration entries where each element requires IO with Bos.",
      "description_length": 405,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Action.Infix",
      "library": "mirage.functoria",
      "description": "This module provides infix operators for sequencing and transforming actions in a monadic context. It works with values of type `'a Functoria.Action.t`, enabling chaining of operations with `>>=` and mapping results with `>|=`. Concrete use cases include composing file system operations with logging and handling side effects while supporting dry-run execution.",
      "description_length": 362,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Functoria.Package",
      "library": "mirage.functoria",
      "description": "This module represents and manipulates opam packages, enabling the specification of dependencies with version constraints, sublibraries, and build-time flags. It provides core operations to construct, modify, and query package metadata such as name, scope, libraries, and version bounds, while its child module handles sets of packages for managing collections of dependencies. You can define MirageOS unikernel dependencies, generate opam files with precise requirements, and perform set operations like union and conversion to lists. The main data types include `t` for individual packages and a set type for collections, supporting use cases in build systems and package management.",
      "description_length": 685,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Dune",
      "library": "mirage.functoria",
      "description": "This module constructs and manipulates Dune configuration files using typed stanzas. It supports creating stanzas with formatted strings, building minimal Dune files for project configuration, and rendering them to string representations. Concrete use cases include generating `dune`, `dune-project`, and `dune-workspace` files required to compile a MirageOS configuration.",
      "description_length": 373,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Impl",
      "library": "mirage.functoria",
      "description": "This module provides typed module representations with erased types, functors, and device-based constructions, enabling operations like functor application (`$`), conditional selection (`if_`), and pattern matching (`match_`) over module values. It includes a mutable hash table implementation for efficient key-value storage and manipulation, using keys of type `Functoria.Impl.abstract` with support for insertion, lookup, iteration, and bulk updates via sequences. The module supports building and evaluating abstract syntax trees, managing dynamic configurations, and generating build artifacts based on runtime keys and context. Together, these features facilitate complex module transformations, device graph construction, and structured data analysis workflows.",
      "description_length": 768,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.DSL",
      "library": "mirage.functoria",
      "description": "This module provides combinators to define and compose modular, configurable applications using a domain-specific language (DSL). It works with types representing module implementations, runtime arguments, package dependencies, and configuration keys, enabling precise control over application assembly. Concrete use cases include building MirageOS unikernels with customizable backends, handling command-line arguments for configuration, and managing package dependencies during compilation.",
      "description_length": 492,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Functoria.Install",
      "library": "mirage.functoria",
      "description": "This module manages installation rules for binaries and configuration files, providing operations to create, combine, and output these rules. It works with file paths and contexts to define how files are installed, supporting concrete use cases like generating `.install` files, `opam` installation instructions, and `dune` promotion rules. Key functions include defining binary and config file mappings, merging installation sets, and printing installation logic for different build systems.",
      "description_length": 492,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Tool",
      "library": "mirage.functoria",
      "description": "This module enables the creation of command-line tools that assemble and compile functor-based systems, combining version constraint validation with CLI configuration parsing and execution. It provides data types for version constraints and functor components, along with operations to declare tool metadata, load dependencies, and generate executable configurations. The core functor builds command-line interfaces that process arguments and produce compiled functor implementations. Example usage includes generating a CLI command that validates package versions, assembles functor components, and compiles the resulting system into an executable.",
      "description_length": 649,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Functoria.Info",
      "library": "mirage.functoria",
      "description": "This module manages metadata and configuration for an application, including access to the configuration file, project and application names, output settings, dependencies, and command-line arguments. It provides functions to retrieve and modify configuration values, generate opam files, and parse runtime keys and arguments. Use it to construct and customize application contexts during build or configuration phases.",
      "description_length": 419,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Action",
      "library": "mirage.functoria",
      "description": "This module provides a monadic framework for building and composing actions that manipulate the file system, manage environment variables, and execute shell commands with support for dry-run simulation. It centers around the `'a t` type, representing abstract actions that capture state transitions and side effects, and includes operations for sequencing, mapping, and transforming these actions using both prefix syntax (`let*`, `let+`) and infix operators (`>>=`, `>|=`). The associated modules extend this functionality by enabling list-based processing of effectful operations, applicative composition, and fluent chaining of actions, making it possible to model complex workflows like build systems or deployment scripts with safe, testable execution. Examples include conditionally copying files based on environment variables, logging command outputs, or processing lists of configuration files with simulated I/O.",
      "description_length": 922,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Functoria.Opam",
      "library": "mirage.functoria",
      "description": "This module constructs and manipulates opam package descriptions, handling configuration, build, and installation commands. It works with file paths, package dependencies, and repository pins to define how a package is built and installed. Concrete use cases include generating opam files with custom build instructions, specifying dependency constraints, and setting up package pinning for development.",
      "description_length": 403,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Functoria.Type",
      "library": "mirage.functoria",
      "description": "This module represents module signatures and functor types, enabling the construction and manipulation of first-class module type descriptions. It provides operations to create module type values, build functor types with `@->`, check if a type is a functor, and pretty-print types. It is used to model module signatures like `job`, `argv`, and `info` for building functor-based applications and configurations.",
      "description_length": 411,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Engine",
      "library": "mirage.functoria",
      "description": "This module processes abstract implementation graphs to generate build configurations, runtime arguments, and installation files. It provides functions to extract keys, packages, and runtime dependencies, and to generate Dune stanzas, configuration files, and connection code. It supports concrete use cases like compiling MirageOS unikernels by resolving dependencies and generating the necessary build artifacts and hooks.",
      "description_length": 424,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Device",
      "library": "mirage.functoria",
      "description": "This module manages configurable components with runtime state, enabling dynamic setup through command-line arguments or compile-time configuration. It provides a core type for devices and a dependency graph structure to represent and resolve interdependencies between components. The graph module supports topological traversal and OCaml name generation, allowing safe and structured configuration of complex systems. Use it to build applications that integrate optional modules, handle command-line arguments, and manage dependencies at both compile and runtime.",
      "description_length": 564,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Context",
      "library": "mirage.functoria",
      "description": "This module implements a type-safe key-value store where keys are dynamically created with unique names and values can be of arbitrary types. It supports operations to add, query, and merge key-value pairs, as well as check for key presence and generate a dump of the current state. It is useful for managing configuration or runtime state where heterogeneous data needs to be stored and retrieved by symbolic keys, such as in dynamic environments or plugin systems.",
      "description_length": 466,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Functoria.Lib",
      "library": "mirage.functoria",
      "description": "This module provides a standard interface for building configurable application components, centered around the `Make` functor that generates libraries from configuration files. It integrates with submodules to enable defining applications through job implementations and initialization tasks, supporting dependency injection and modular system design. The interface for custom builders allows specifying build metadata, package dependencies, and dune project generation, enabling use cases like MirageOS unikernel DSLs or configuration-driven library builds. Key data types include job definitions, source settings, and build stanzas, with operations to register applications, configure sources, and generate project files.",
      "description_length": 724,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Key",
      "library": "mirage.functoria",
      "description": "This module enables the definition and manipulation of typed configuration keys with support for applicative composition, conditional logic, and dependency tracking across execution contexts. It provides core operations for working with individual keys and values, including default resolution, context-aware evaluation, and command-line argument parsing, while integrating with submodules for set-based key management and multi-stage argument persistence. The set submodule offers standard functional set operations with ordered traversal and transformations, ideal for managing collections of keys in deterministic workflows. The argument submodule extends this functionality by enabling typed command-line interface definitions with support for optional, required, and flag arguments across program stages.",
      "description_length": 809,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Cli",
      "library": "mirage.functoria",
      "description": "This module handles command-line parsing and evaluation for Functoria applications, supporting operations like extracting output paths, evaluating subcommands, and configuring terminal settings. It works with data types such as `args`, `action`, and `query_kind`, which represent command-line arguments, executable actions, and query types like `Dune` or `Opam`. Concrete use cases include parsing global arguments, extracting `--output` or `--eval` flags, and defining command-line interfaces for configuration, building, and project description workflows.",
      "description_length": 557,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Runtime_arg",
      "library": "mirage.functoria",
      "description": "This module defines runtime command-line arguments with support for positional metadata, package association, and type-erased values, enabling the creation of structured command-line interfaces. It provides the `arg` type for handling strings, integers, and custom types, along with a set module for composing and transforming collections of argument descriptors while preserving ordering. The set module supports union, intersection, difference, and element-wise transformations, making it suitable for validating or generating ordered argument configurations. Use this module to build command-line parsers for Functoria-based applications and to link arguments to specific opam packages.",
      "description_length": 689,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria",
      "library": "mirage.functoria",
      "description": "This module enables the construction and configuration of functor-based systems with rich support for dependency management, code generation, and command-line interaction. It provides core data types such as module signatures, functors, and typed configuration keys, along with operations to compose, conditionally select, and evaluate them. You can define MirageOS unikernels with customizable backends, generate Dune and opam files, manage package dependencies with version constraints, and build command-line interfaces that parse and validate runtime arguments. Submodules handle filesystem actions, installation rules, and key-value configuration stores, allowing workflows like conditional file copying, structured configuration, and dynamic dependency resolution.",
      "description_length": 770,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Target.Xen.Substitutions",
      "library": "mirage.devices",
      "description": "This module processes substitution variables for Xen device configurations, supporting lookups and default value generation. It operates on a list of key-value pairs where keys are variants like `Name`, `Kernel`, `Memory`, or device-specific types like `Block` and `Network`. It is used to resolve configuration placeholders when generating Xen domain configuration files.",
      "description_length": 372,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Target.TARGET",
      "library": "mirage.devices",
      "description": "This module defines operations for managing Mirage targets, which group multiple backends. It provides functions to cast modes to valid backends, generate Dune build rules, configure targets, and retrieve required packages and installation files. It works with data types like `t`, `Info.t`, `Dune.stanza`, and `Install.t`, supporting use cases such as unikernel build configuration and context setup.",
      "description_length": 401,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Target.Unix",
      "library": "mirage.devices",
      "description": "This module defines types and operations for handling Unix-like target environments, specifically distinguishing between generic Unix and macOS. It provides functions for configuration, package retrieval, context naming, and Dune stanza generation tailored to Unix targets. Use cases include building and installing applications on Unix systems with platform-specific settings.",
      "description_length": 377,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Runtime_arg.V6",
      "library": "mirage.devices",
      "description": "This module defines command-line arguments for configuring IPv6 networking in Mirage applications. It provides functions to specify an IPv6 network prefix, a default gateway address, and whether to accept router advertisements. These arguments are used to customize network stack behavior at runtime for unikernels deploying IPv6 connectivity.",
      "description_length": 343,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Runtime_arg.V4",
      "library": "mirage.devices",
      "description": "This module defines runtime arguments for configuring IPv4 networks and gateways in MirageOS applications. It provides functions to specify an IPv4 network prefix and an optional default gateway address. These arguments are used to set up network interfaces with specific IP configurations when launching unikernels.",
      "description_length": 316,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Target.Solo5",
      "library": "mirage.devices",
      "description": "This module provides configuration and build automation for Solo5-based unikernels, offering operations to select platform-specific packages, generate manifests, and construct Dune build stanzas tailored to targets like Virtio, Xen, and Spt. It processes device metadata stored in `Info.t` records to produce deployment-ready configurations and build instructions, enabling MirageOS unikernels to be compiled and installed with target-specific optimizations. The functionality supports use cases such as cross-platform unikernel development and automated generation of installation artifacts for cloud or virtualized environments.",
      "description_length": 630,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Devices.Target.Xen",
      "library": "mirage.devices",
      "description": "This module manages Xen device configuration by detecting bridges and formatting configuration files, while its child module processes substitution variables for dynamic configuration. Key data types include variant keys like `Name`, `Kernel`, and device-specific types such as `Block` and `Network`, used to resolve placeholders during configuration generation. Operations allow appending formatted text to a formatter, substituting values, and configuring domains using external files. Examples include generating `.xl` files with dynamic values and setting up virtual machine network bridges using resolved configuration data.",
      "description_length": 629,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Devices.Random",
      "library": "mirage.devices",
      "description": "This module defines implementations for a random number generator job, including a null implementation and a default system-based implementation. It works with the `random` type, which represents a job for generating random numbers. Concrete use cases include providing a source of randomness for cryptographic operations or seeding other components in a system.",
      "description_length": 362,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Http",
      "library": "mirage.devices",
      "description": "This module implements HTTP clients and servers using different backends. It supports creating HTTP servers with `cohttp_server` or `httpaf_server` from a conduit, and clients with `cohttp_client` from a resolver and conduit or `paf_client` from TCP and a mimic. It also provides `paf_server` for ALPN-based servers with runtime port configuration.",
      "description_length": 348,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Sleep",
      "library": "mirage.devices",
      "description": "Implements sleep operations as job functors for use in MirageOS applications. Provides `default_sleep` to create a standard sleep job and `no_sleep` to disable sleep behavior. Useful for controlling execution timing in unikernels without relying on OS-level delays.",
      "description_length": 265,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Syslog",
      "library": "mirage.devices",
      "description": "This module implements syslog message transmission over UDP, TCP, and TLS transports, using IPv4 and IPv6 stacks. It provides structured logging capabilities to remote syslog servers, supporting plaintext and encrypted channels. Use cases include remote logging from embedded devices, secure log aggregation, and network monitoring setups.",
      "description_length": 339,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Dns",
      "library": "mirage.devices",
      "description": "This module provides a DNS client implementation that supports asynchronous resolution of domain names using a configurable list of nameservers, with optional caching and timeout settings. It works with network stacks and integrates with happy eyeballs for IPv4/IPv6 dual-stack resolution. Concrete use cases include bootstrapping network applications that require DNS lookups, such as HTTP clients or secure socket layers, in environments where custom DNS configuration is needed.",
      "description_length": 481,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Argv",
      "library": "mirage.devices",
      "description": "Handles command-line argument parsing and configuration through predefined implementations. Works with `Functoria.argv` to provide ready-to-use argument vectors. Use `default_argv` to capture standard command-line inputs or `no_argv` to explicitly disable argument handling in contexts where none are expected.",
      "description_length": 310,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Conduit",
      "library": "mirage.devices",
      "description": "This module defines a `conduit` type representing network transport configurations and provides functions to construct and manipulate them. It includes `conduit_direct` for creating conduits over a network stack with optional TLS support. Use cases include setting up secure or insecure network connections for client-server communication.",
      "description_length": 339,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Icmp",
      "library": "mirage.devices",
      "description": "This module implements ICMPv4 protocol handling, providing a type `icmpv4` for representing ICMPv4 packets. It includes functions for creating and processing ICMPv4 messages, such as echo requests and replies, over IPv4. A concrete use case is enabling ping functionality in networked applications by sending and receiving ICMPv4 echo packets.",
      "description_length": 343,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Block",
      "library": "mirage.devices",
      "description": "This module provides functions to create and manipulate block devices, including operations for initializing block devices from files, ramdisks, or XenStore IDs, and converting block devices into key-value stores (read-only or read-write). It supports data types such as `block` for representing block device implementations and `block_t` for tracking block device metadata. Concrete use cases include mounting tar archives or FAT filesystems from block devices, analyzing block device contents with the `docteur` function, and encrypting block devices using CCM mode with optional nonce lengths.",
      "description_length": 596,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Happy_eyeballs",
      "library": "mirage.devices",
      "description": "This module implements a happy eyeballs connection manager that selects between IPv4 and IPv6 addresses to optimize connection latency. It provides configurable timeouts for DNS resolution, connection attempts, and address family fallback, along with a timer-driven retry mechanism. Concrete use cases include improving client connection reliability in dual-stack networks and reducing perceived latency during service discovery.",
      "description_length": 429,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Qubesdb",
      "library": "mirage.devices",
      "description": "This module models a QubesDB device, providing a typed representation and default implementation for interacting with QubesDB in a unikernel context. It defines a concrete type for QubesDB instances and a package dependency required for integration. Use this module when building unikernels that need to communicate with QubesDB for configuration or inter-VM data exchange.",
      "description_length": 373,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Arp",
      "library": "mirage.devices",
      "description": "Implements ARPv4 for resolving IPv4 addresses over Ethernet. Provides `arpv4` as a type and implementation for handling ARP requests and responses. Used to enable network communication by mapping IP addresses to Ethernet MAC addresses in low-level networking stacks.",
      "description_length": 266,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Reporter",
      "library": "mirage.devices",
      "description": "This module defines a type `reporter` representing a logging job and provides implementations for creating default and null log reporters. It works with the `Functoria` module's `job` and `impl` types, along with `Logs.level` for setting log verbosity. Concrete use cases include configuring logging behavior in a MirageOS application, such as setting up a default logger with a specific log level or disabling logging entirely using `no_reporter`.",
      "description_length": 448,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Devices.Ip",
      "library": "mirage.devices",
      "description": "This component provides functionality for constructing and configuring TCP/IP implementations that support IPv4, IPv6, and dual-stack protocols, using Ethernet interfaces, ARP tables, and runtime configuration mechanisms like DHCP or QubesDB. It also determines appropriate library dependencies for MirageOS targets by resolving implementation choices based on sublibrary lists and platform-specific requirements, enabling unikernel builds with tailored networking stacks. Use cases include dynamic IP configuration in virtualized environments, static network setup for embedded systems, and compiling MirageOS applications with target-optimized dependencies.",
      "description_length": 659,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Ptime",
      "library": "mirage.devices",
      "description": "This module defines a type `ptime` representing time-related jobs and provides implementations for handling time in different contexts. It includes functions to create a default time implementation, a mock time implementation for testing, and a null implementation that disables time functionality. These are used to manage system time dependencies in applications requiring precise control over time sources.",
      "description_length": 409,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Devices.Mimic",
      "library": "mirage.devices",
      "description": "This module provides a `mimic` type and a `mimic_happy_eyeballs` function that constructs a mimic device using a network stack, a happy eyeballs implementation, and a DNS client. It enables transparent proxying or traffic redirection by simulating network behavior. Use cases include testing network applications under realistic connection conditions or implementing redirection-based middleboxes.",
      "description_length": 397,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Runtime_arg",
      "library": "mirage.devices",
      "description": "This module configures network and system parameters for Mirage unikernels through command-line arguments, supporting typed values like IP addresses, log levels, and cryptographic settings. It organizes arguments into documented groups with defaults, enabling runtime customization of TLS authentication, syslog endpoints, HTTP headers, and network interfaces. Child modules extend this functionality with specific support for IPv6 networks, including prefix, gateway, and router advertisement settings, and for IPv4 networks, handling prefix and gateway configuration. Together, they provide a structured way to define and launch unikernels with tailored network stacks for IPv4 and IPv6 deployments.",
      "description_length": 701,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Devices.Resolver",
      "library": "mirage.devices",
      "description": "This module implements DNS resolution logic using either a provided list of nameservers or the system's default resolver. It works with network stacks supporting IPv4 and IPv6 to perform domain name lookups. Use it to configure DNS resolution in networked applications or system services requiring hostname resolution.",
      "description_length": 318,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Ethernet",
      "library": "mirage.devices",
      "description": "Implements Ethernet device abstractions for network communication. Provides `ethernet` as a type and configuration value for defining Ethernet interfaces, and `ethif` to create an Ethernet interface from a network implementation. Use to configure and manage physical or virtual Ethernet devices in a MirageOS unikernel.",
      "description_length": 319,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Devices.Udp",
      "library": "mirage.devices",
      "description": "This module implements UDP networking over IPv4 and IPv6, supporting operations to create UDP sockets with configurable IP versions, bind addresses, and runtime configuration parameters. It works with IP addresses represented as `Ipaddr.V4.t` and `Ipaddr.V6.t`, and abstracts UDP instances through the `udp` type. Concrete use cases include setting up dual-stack UDP sockets, binding to specific IP prefixes, and configuring network stacks with direct or socket-based UDP implementations.",
      "description_length": 488,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Kv",
      "library": "mirage.devices",
      "description": "This module implements key-value stores for both read-only and read-write access, supporting operations like `direct_kv_ro`, `crunch`, and `generic_kv_ro` for immutable data, and `direct_kv_rw`, `mem_kv_rw` for mutable storage. It works with string keys and abstract value types through the `Functoria.DSL.impl` interface. Concrete use cases include embedding static file systems via `crunch` or configuring memory-backed stores with `mem_kv_rw`.",
      "description_length": 446,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Devices.Key",
      "library": "mirage.devices",
      "description": "This module enables defining and manipulating command-line configuration keys and values for Mirage OS applications. It supports key creation, value mapping, conditional logic, dependency tracking, and context management, working with types representing platform targets (Unix, Xen, Solo5), storage configurations, block devices, and network stacks. These operations facilitate parsing command-line arguments, resolving configuration dependencies, applying default values, and generating platform-specific setup code.",
      "description_length": 517,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Devices.Git",
      "library": "mirage.devices",
      "description": "This module implements Git client configurations for interacting with Git repositories over various transport protocols. It provides functions to create and combine Git clients using TCP, SSH, or HTTP(S), supporting authentication and custom headers. Use this to integrate Git-based workflows into applications that require secure, networked repository access.",
      "description_length": 360,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Stack",
      "library": "mirage.devices",
      "description": "This module implements a network stack supporting both IPv4 and IPv6, offering functions to construct stacks with customizable TCP, ARP, Ethernet, and IP configurations. It provides direct, keyed, socket-based, and static initialization methods, allowing precise control over networking interfaces and protocols. Use cases include setting up custom network environments for virtual devices, configuring dual-stack networking, and managing low-level communication layers in system-level applications.",
      "description_length": 499,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Libvirt",
      "library": "mirage.devices",
      "description": "This module handles device configuration for virtualized environments using Libvirt. It provides functions to generate configuration files, set up main devices, and configure Virtio devices, all based on a given device name. The operations return actions suitable for integration with Functoria's configuration system.",
      "description_length": 318,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Misc",
      "library": "mirage.devices",
      "description": "This module determines the execution context by checking if the program is running in a terminal, retrieves the target mode from configuration info, and provides a function to raise formatted error messages with exit codes. It works with boolean values, string formatting, and the `Functoria.Info.t` configuration type. Concrete use cases include initializing environment-specific behavior and handling fatal errors during setup.",
      "description_length": 429,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Network",
      "library": "mirage.devices",
      "description": "This module manages network device configurations through concrete implementations like `netif` and `default_network`, which construct network interfaces with optional grouping. It works with the abstract `network` type, representing network devices, and maintains a global list of all networks in `all_networks`. Use this module to define and reference network interfaces in virtualized or containerized environments, such as setting up tap devices or connecting to specific network backends.",
      "description_length": 493,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Mtime",
      "library": "mirage.devices",
      "description": "This module provides implementations of a time measurement job type, including default, null, and mock variants. It works with the `mtime` type, which represents a time-related computation or value within the Functoria framework. Concrete use cases include simulating or providing real-time measurements in MirageOS applications, such as tracking execution duration or mocking time for testing.",
      "description_length": 394,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices.Target",
      "library": "mirage.devices",
      "description": "This module selects and configures target platforms such as Unix, Xen, or Solo5 based on the provided mode, generating Dune stanzas, managing build contexts, and determining package dependencies. It defines the core data type `t` and works with `Info.t`, `Dune.stanza`, and `Install.t` to support operations like backend casting, configuration setup, and installation rule generation. Submodules handle Unix-like environments with platform-specific settings, configure Solo5-based unikernels with manifest generation and device metadata processing, and manage Xen device configuration using substitution variables and domain setup. Examples include building MirageOS unikernels for Virtio or Xen targets, generating `.xl` files with dynamic values, and installing applications on Unix or macOS with tailored build rules.",
      "description_length": 820,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Devices.Tcp",
      "library": "mirage.devices",
      "description": "This module implements TCP networking abstractions for IPv4 and IPv6, providing typed constructors for TCP sockets with configurable IP versions, address families, and network groups. It supports concrete operations like `direct_tcp` for IP-to-TCP binding and `socket_tcpv4v6` for creating dual-stack TCP sockets with optional IPv4 and IPv6 addresses. Use cases include setting up secure network servers, handling client connections, and configuring IP-specific runtime parameters in MirageOS unikernels.",
      "description_length": 504,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Devices",
      "library": "mirage.devices",
      "description": "This collection of modules provides a comprehensive framework for building networked and system-level applications, particularly in MirageOS and unikernel environments. Core data types include `random`, `conduit`, `icmpv4`, `block`, `udp`, `tcp`, `dns`, `syslog`, `argv`, `ptime`, `mtime`, `network`, and `reporter`, each modeling fundamental system components like randomness sources, network transports, block devices, time sources, and logging facilities. Operations span network communication (HTTP, DNS, ICMP, TCP, UDP, syslog), device management (block, Ethernet, ARP), time and sleep control, command-line configuration, and structured logging. Examples include setting up dual-stack TCP servers with TLS, generating cryptographically secure random numbers, mounting block devices as filesystems, configuring DNS clients with happy eyeballs, and building unikernels with custom network stacks and runtime parameters.",
      "description_length": 923,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mirage.Project",
      "library": "mirage",
      "description": "Handles project configuration and build generation for MirageOS unikernels. It processes project metadata to produce Dune build stanzas and executes setup tasks during configuration. Works directly with `Info.t` to generate `Dune.stanza list` and `unit Action.t` values. Used to define build rules and initialization steps specific to Mirage projects.",
      "description_length": 351,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mirage.Key",
      "library": "mirage",
      "description": "This module provides functions to define and manipulate configuration keys using command-line arguments, applicative transformations, conditional logic, and dependency tracking. It operates on `context`, `key`, and `value` types, enabling use cases like system target configuration (Unix/Xen/Solo5), storage (KV stores), networking (DHCP, net devices), and block device management, with support for context-sensitive evaluation and declarative configuration workflows.",
      "description_length": 468,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mirage.Runtime_arg",
      "library": "mirage",
      "description": "This module provides operations for defining and managing typed command-line configuration keys in MirageOS applications, utilizing `Runtime_arg.t` and related types. It supports network interfaces, DNS settings, connection timeouts, SSH/TLS authentication, HTTP headers, syslog destinations, and log thresholds, offering features like documentation, default values, and grouped argument organization to configure network services and logging in unikernels with optional, serializable parameters.",
      "description_length": 496,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mirage.Tool",
      "library": "mirage",
      "description": "Implements command-line interface logic for managing MirageOS unikernels, including subcommands for building, running, and inspecting configurations. Operates on configuration files and command-line arguments to orchestrate unikernel workflows. Used directly by developers to compile and deploy MirageOS applications from the terminal.",
      "description_length": 335,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mirage",
      "library": "mirage",
      "description": "This module orchestrates MirageOS unikernel configuration and deployment by bridging project metadata with build generation, command-line interface handling, and runtime configuration. It processes `Info.t` into Dune build stanzas, defines configuration keys over `context` and `value` types for targets like networking and storage, and exposes CLI subcommands for building and inspecting unikernels. Examples include generating DHCP-enabled network stacks, configuring TLS parameters via runtime arguments, and setting up KV stores with conditional dependencies. Submodules handle low-level key parsing, typed CLI flags, and setup actions, enabling declarative, context-aware unikernel definitions.",
      "description_length": 699,
      "index": 73,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 74,
    "meaningful_modules": 74,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 923,
    "min_description_length": 265,
    "avg_description_length": 480.14864864864865,
    "embedding_file_size_mb": 0.26923179626464844
  }
}