{
  "package": "flow_parser",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 230,
  "creation_timestamp": "2025-06-18T16:59:23.566969",
  "modules": [
    {
      "module_path": "Flow_ast.Pattern.Array.Element",
      "description": "Generates human-readable representations of structured data by formatting a pair of values, where the first is a metadata type and the second is a recursive structure. Provides pretty-printing and string conversion for both the main type and its recursive variant. Used to serialize complex nested data for logging or debugging purposes.",
      "description_length": 337,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Pattern.Object.Property",
      "description": "Generates human-readable representations of key-value structures using formatter functions for custom types. Operates on nested tuples and recursive types parameterized by metadata and value types. Formats and displays structured data for logging and debugging purposes.",
      "description_length": 270,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Tuple.LabeledElement",
      "description": "Formats labeled elements with custom pretty-printing and string representation, using separate formatters for metadata and content. Operates on a tuple type containing metadata and content of arbitrary types. Used to generate human-readable output for structured data with distinct metadata and payload components.",
      "description_length": 314,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.Tuple.SpreadElement",
      "description": "Formats and converts values representing a spread element, where one part is a metadata type ('M) and the other is a data type ('T). It supports pretty-printing to a formatter and generating string representations based on custom formatters for each component. Used to serialize structured data with associated metadata in a readable format.",
      "description_length": 341,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Typeof.Target",
      "description": "Provides pretty-printing and string representation functions for structured data, supporting both simple and qualified types. Works with polymorphic types parameterized by module and type identifiers, including nested qualified structures. Used to generate human-readable output for debugging or logging complex data hierarchies.",
      "description_length": 329,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Component.Param",
      "description": "Generates human-readable representations of nested data structures by combining custom pretty-printers for base and nested types. Operates on tuples and recursive types parameterized by two type variables, enabling structured output for complex data. Used to format configuration objects with embedded metadata and dynamic values.",
      "description_length": 330,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Component.RestParam",
      "description": "Formats and converts structured data between a base type and a nested recursive type, using custom pretty-printing and string representation functions. It operates on tuples containing a marker type and a recursive structure, enabling detailed output formatting. Used to serialize complex nested data for logging or debugging purposes.",
      "description_length": 335,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.Component.Params",
      "description": "Formats and converts parameterized data structures by generating pretty-printers and string representations for nested tuples. It handles composite types composed of a metadata element and a recursive structure, enabling detailed inspection of hierarchical data. Used to serialize complex configurations or structured data for logging or debugging.",
      "description_length": 348,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Object.Property",
      "description": "Generates human-readable representations of structured data by formatting a metadata type and a value type. Formats values using provided pretty-printing or string conversion functions for metadata and target types. Handles nested structures through recursive type definitions that link metadata to value components.",
      "description_length": 316,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Object.SpreadProperty",
      "description": "Generates pretty-printed and string representations of nested data structures composed of a base type 'M and a recursive variant 'T. Operates on tuples and recursive records structured as ('M, 'T) t. Used to visualize configuration schemas and serialized data formats with custom formatting rules.",
      "description_length": 297,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Object.Indexer",
      "description": "Provides pretty-printing and string representation functions for tagged tuples, supporting custom formatting for both the tag and value components. Operates on polymorphic types 'M and 'T, handling nested structures through recursive tuple definitions. Used to generate human-readable output for structured data in logging or debugging contexts.",
      "description_length": 345,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Object.MappedType",
      "description": "Provides pretty-printing and string representation for tagged union types, including optional flags and nested structures. Works with custom types like `optional_flag` and parameterized types `('M, 'T) t` and `('M, 'T) t'`. Used to generate human-readable output for serialized data formats and debugging logs.",
      "description_length": 310,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Object.CallProperty",
      "description": "Formats and converts structured data types representing method-call properties, including nested structures. Operates on tuple-based types with metadata and recursive subtypes. Generates human-readable string representations and pretty-printed outputs for debugging or logging.",
      "description_length": 277,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Object.InternalSlot",
      "description": "Formats and displays values of a nested type structure consisting of a pair where the second element is a recursive variant. Supports pretty-printing to a formatter and converting to a string using custom pretty-printers for the type parameters. Handles both the base type and its recursive variant with distinct output functions.",
      "description_length": 330,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.Function.Param",
      "description": "Generates human-readable representations of nested data structures using custom pretty-printing and string conversion functions. It operates on tuples containing a metadata type and a recursive structure type, supporting deep serialization of complex hierarchies. Used to format configuration trees and structured logs with consistent output formatting.",
      "description_length": 353,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.Function.RestParam",
      "description": "Formats and converts structured data between a base type and a nested recursive type, using custom pretty-printing and string representation functions. It operates on tuples containing a marker type and a recursive structure, enabling detailed output customization. Used to serialize complex nested configurations with explicit control over formatting rules.",
      "description_length": 358,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.Function.ThisParam",
      "description": "Generates human-readable representations of structured data by combining custom pretty-printers for two distinct types, 'M and 'T. Supports formatted output for both recursive and non-recursive variants of the same data structure. Used to serialize complex nested records with explicit control over formatting and type-specific rendering.",
      "description_length": 338,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Function.Params",
      "description": "Generates human-readable representations of structured data by formatting a value and its metadata. Operates on tuples containing a metadata type and a recursive structure. Used to produce debug outputs or serialized forms for logging and inspection.",
      "description_length": 250,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.Generic.Identifier",
      "description": "Generates formatted string representations of identifiers with module and type information using custom pretty-printing functions. Handles nested structures like qualified identifiers that include module and type annotations. Supports both standard and extended qualified formats for detailed output in debugging or serialization contexts.",
      "description_length": 339,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.ComponentDeclaration.RestParam",
      "description": "Formats and converts structured data types representing REST parameters, supporting both recursive and non-recursive representations. It generates human-readable output using custom pretty-printing functions for message and transport types. The module enables serialization of parameter hierarchies into strings for logging or debugging purposes.",
      "description_length": 346,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.ComponentDeclaration.Param",
      "description": "Provides pretty-printing and string representation functions for parameterized types, including nested structures and named parameters. Operates on tuple-based recursive types and parameter names, using formatter functions for custom output formatting. Used to generate human-readable representations of complex parameter configurations in parsing or serialization contexts.",
      "description_length": 374,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Statement.ComponentDeclaration.Params",
      "description": "Formats and converts parameterized data structures into human-readable strings, using custom pretty-printers for base and recursive components. Operates on nested tuple-based structures that combine a metadata type with a recursive tree type. Used to generate debug representations and serialized outputs for structured configuration data.",
      "description_length": 339,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Try.CatchClause",
      "description": "Formats and displays error messages with associated values, using custom pretty-printers for message and value types. Operates on tuple structures containing a message and a nested error type. Used to generate human-readable representations of error states in logging or debugging contexts.",
      "description_length": 290,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.ExportNamedDeclaration.ExportSpecifier",
      "description": "Generates pretty-printed and string representations of module and type pairs, supporting nested structures. Operates on tuples containing a module identifier and a recursive type structure. Used to serialize or display complex type annotations in code generation tools.",
      "description_length": 269,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.ExportNamedDeclaration.ExportBatchSpecifier",
      "description": "Produces human-readable representations of tuples containing a module identifier and an optional type identifier, using custom pretty-printing and string conversion functions. Operates on polymorphic tuples where the first element is a module type and the second is an optional type identifier. Used to generate debug output or serialized formats for module-type pairs in code generation workflows.",
      "description_length": 398,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.VariableDeclaration.Declarator",
      "description": "Formats and converts structured data between custom representations, using provided pretty-printing and string conversion functions for each component. Operates on nested tuples and recursive types that pair a metadata element with a tagged structure. Used to generate human-readable output from complex data models in parsing or serialization workflows.",
      "description_length": 354,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Switch.Case",
      "description": "Formats and converts structured data between a base type and a tagged variant, using custom pretty-printing functions for each component. It operates on tuples containing a marker and a recursive tagged structure, supporting both direct and recursive representations. Used to generate human-readable outputs and debug representations of nested data models.",
      "description_length": 356,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Statement.EnumDeclaration.DefaultedMember",
      "description": "Provides pretty-printing and string representation functions for a nested tuple structure where each element is paired with a recursive continuation. Operates on types 'M t and 'M t', which represent a value and a possibly empty tail. Used to generate human-readable output for hierarchical data like parsed syntax trees or structured configurations.",
      "description_length": 350,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.EnumDeclaration.InitializedMember",
      "description": "Formats and displays tuples containing an initial value and a recursively defined structure, using custom pretty-printing and string conversion functions for each component. Operates on nested types where the first component is an initial value and the second is a recursive structure. Used to generate human-readable representations of complex, layered data during debugging or logging.",
      "description_length": 387,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.EnumDeclaration.BooleanBody",
      "description": "Provides pretty-printing and string representation for boolean expressions using a custom type 'M t. Operates on structured boolean data with support for formatting and conversion to strings. Used to generate human-readable output for logical expressions in parsing or debugging contexts.",
      "description_length": 288,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.EnumDeclaration.NumberBody",
      "description": "Formats a value of type 'M t using a provided printer function, outputting to a formatter. Converts a value of type 'M t into a string representation using a specified formatting function. Designed for custom type serialization and debugging with explicit control over output format.",
      "description_length": 283,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Statement.EnumDeclaration.StringBody",
      "description": "Provides pretty-printing and string representation for structured data, with specialized formatting for member fields. Operates on a type parameterized by model and member types, supporting nested structure rendering. Used to generate human-readable output for complex data models in logging and debugging contexts.",
      "description_length": 315,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Statement.EnumDeclaration.SymbolBody",
      "description": "Produces a formatted string representation of a symbol body using a provided printer function, and generates a human-readable string from a symbol body instance. Works with the polymorphic type 'M t, which encapsulates symbol body data. Used to serialize symbol information for logging or debugging purposes.",
      "description_length": 308,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.EnumDeclaration.BigIntBody",
      "description": "Formats and converts arbitrary-precision integer values between internal representations and string or formatter outputs. Operates on a parameterized type representing big integers, supporting custom formatting logic. Used to generate human-readable outputs or integrate with systems requiring formatted numeric data.",
      "description_length": 317,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.If.Alternate",
      "description": "Generates pretty-printed and string representations for nested data structures composed of a base type 'M and a recursive variant 'T. It handles tuples paired with recursive records that alternate between two type parameters. Used to serialize complex tree-like structures with custom formatting for debugging or logging.",
      "description_length": 321,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.TemplateLiteral.Element",
      "description": "Provides pretty-printing and string representation functions for custom data structures, including nested types and polymorphic variants. Works with value records, polymorphic type constructors 'M t, and their associated t' representations. Used to generate human-readable output for debugging or logging complex data hierarchies.",
      "description_length": 330,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.Object.Property",
      "description": "Provides pretty-printing and string representation functions for key-value structures, where keys are annotated with metadata and values are recursively structured. Operates on polymorphic types ('M, 'T) key, ('M, 'T) t, and ('M, 'T) t', enabling formatted output for nested data. Used to generate human-readable representations of configuration maps and hierarchical data models.",
      "description_length": 380,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.Object.SpreadProperty",
      "description": "Generates pretty-printed and string representations of nested data structures composed of a base type 'M and a recursive variant 'T. Processes tuples pairing 'M with a recursive structure 'T, supporting custom formatting for each component. Used to serialize complex, layered data models with explicit control over output formatting.",
      "description_length": 333,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Expression.CallTypeArg.Implicit",
      "description": "Generates human-readable representations of structured data by combining a metadata formatter with a type-specific formatter. Operates on tuples of type 'T and nested metadata structures 'M t'. Used to produce debug output for complex data models with embedded metadata.",
      "description_length": 270,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Class.Implements.Interface",
      "description": "Generates human-readable representations of structured data by formatting values with custom pretty-printers for two nested types. It handles tuples containing a metadata element and a recursive structure, along with their variants. Used to serialize complex data models for logging or debugging purposes.",
      "description_length": 305,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.JSX.Identifier",
      "description": "Formats and converts identifier representations using custom pretty-printing and string conversion functions. Operates on tuples of type ('M, 'T) t and nested type 'M t', which encapsulate identifier metadata and token data. Used to generate human-readable outputs for parsed code elements in compiler or parser tools.",
      "description_length": 318,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.JSX.NamespacedName",
      "description": "Formats and converts namespaced identifiers consisting of a module part and a type part into human-readable strings. Operates on nested tuple structures representing hierarchical name components. Used to generate debug representations and string outputs for namespaced type definitions.",
      "description_length": 286,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.JSX.ExpressionContainer",
      "description": "Provides pretty-printing and string representation for abstract syntax tree nodes, supporting custom pretty-printers for metadata and type information. Operates on polymorphic types representing expressions and their contexts, allowing structured output formatting. Used to generate human-readable representations of parsed code elements during analysis or debugging.",
      "description_length": 367,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.JSX.Text",
      "description": "Formats text content for pretty printing and converts it to a string representation. Works with a structured text type containing content and metadata. Used to generate human-readable output from parsed text data.",
      "description_length": 213,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.JSX.Attribute",
      "description": "Provides pretty-printing and string representation functions for attribute structures, including names, values, and nested types. Works with polymorphic tuples and recursive type definitions involving metadata ('M) and type information ('T). Used to generate human-readable output for attributes in parsing or serialization contexts.",
      "description_length": 333,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.JSX.SpreadAttribute",
      "description": "Generates pretty-printed and string representations of nested attribute structures by applying custom formatters for base and nested values. Operates on tuple-based recursive types that combine a marker and a nested attribute structure. Used to serialize complex attribute hierarchies in code generation or debugging contexts.",
      "description_length": 326,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.JSX.MemberExpression",
      "description": "Generates human-readable representations of member expressions and their components using formatter functions for custom output formatting. Operates on nested types representing object properties and member access structures. Used to serialize complex data models for debugging or logging purposes.",
      "description_length": 298,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.JSX.Opening",
      "description": "Generates pretty-printed and string representations for structured data types using custom formatters for base and nested elements. Operates on recursive types representing attributes and nodes, such as syntax tree elements or annotated data. Used to format and serialize complex hierarchical structures with customizable output for debugging or logging.",
      "description_length": 354,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.JSX.Closing",
      "description": "Formats and converts structured data types representing a hierarchical closure, where each node contains a value and a nested structure. It supports pretty-printing to a formatter and generating string representations for both recursive and non-recursive variants of the structure. Used to serialize complex tree-like data for logging or debugging purposes.",
      "description_length": 357,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.JSX.SpreadChild",
      "description": "Formats and displays values of a polymorphic variant type that combines two distinct types, 'M and 'T, using custom pretty-printing functions. It generates string representations by applying separate formatting functions to each variant. Used to serialize structured data for logging or user-facing output.",
      "description_length": 306,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Pattern.RestElement",
      "description": "Generates human-readable representations of structured data by formatting a metadata value and a nested tree structure. Processes tuples containing metadata and recursive tree nodes, supporting pretty-printing and string serialization. Used to visualize configuration hierarchies or parsed document structures with annotated nodes.",
      "description_length": 331,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Pattern.Object",
      "description": "Provides formatted output for complex data structures by recursively applying custom formatting rules to nested tuples and metadata-parameterized types. Supports operations such as serialization and debug printing through user-defined formatter functions. Examples include displaying tree structures with labeled nodes or logging hierarchical configuration data. Enables precise control over how data is presented in logs or interactive environments.",
      "description_length": 450,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Pattern.Array",
      "description": "formats structured data by pairing metadata with recursive elements, enabling detailed visualization of nested constructs. It defines a custom type for metadata and a recursive variant, along with functions to convert these into readable strings. Operations include pretty-printing, string serialization, and recursive traversal of data hierarchies. For example, it can display a tree structure with node labels and child relationships in a human-readable format.",
      "description_length": 463,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Pattern.Identifier",
      "description": "Produces a formatted string representation of a type-safe identifier by combining custom pretty-printers for its metadata and type components. Operates on the polymorphic variant type ('M, 'T) t, allowing distinct rendering for different metadata and type pairs. Used to generate human-readable outputs for identifiers in domain-specific languages or code generation tools.",
      "description_length": 373,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Conditional",
      "description": "Formats and converts values of a conditional type that holds either a 'M or a 'T, using provided pretty-printing and string conversion functions. Operates on a polymorphic variant type with two distinct branches. Used to generate human-readable representations or string outputs for conditional data in logging or serialization contexts.",
      "description_length": 337,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.Infer",
      "description": "Formats a structured data type using provided pretty-printing functions for its components, and generates a string representation from it. It operates on a tuple type that pairs two distinct data types, M and T. This is used to produce human-readable output for custom data structures in code generation scenarios.",
      "description_length": 314,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Function",
      "description": "Combines custom pretty-printing and serialization logic to generate human-readable representations of structured data, operating on tuples of metadata and recursive types. Supports deep formatting of nested configurations, logs, and records, with control over output structure and type-specific rendering. Examples include formatting configuration trees, serializing debug logs, and generating consistent output for complex data hierarchies. Enables detailed customization of how data is presented, including recursive and non-recursive variants.",
      "description_length": 546,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Component",
      "description": "Provides structured formatting and conversion between nested data types, including tuples with metadata and recursive elements, using custom pretty-printers and string representations. Main data types include parameterized tuples, recursive structures, and composite types with metadata. It enables serialization of complex configurations, logging of hierarchical data, and generation of human-readable outputs for debugging. Examples include formatting configuration objects with embedded metadata and converting nested data for traceability in system logs.",
      "description_length": 558,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Generic",
      "description": "Produces formatted string representations of identifiers, incorporating module and type information through custom pretty-printing. Supports nested and qualified identifiers, offering flexibility in output styles for debugging or data serialization. Key data types include identifiers, modules, and type annotations, with operations for formatting and parsing. Examples include generating human-readable debug logs or serializing complex type structures into strings.",
      "description_length": 467,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.IndexedAccess",
      "description": "Provides pretty-printing and string representation for indexed access structures using custom formatters for member and target types. Operates on tuples of the form ('M, 'T) t, where 'M and 'T are distinct type parameters. Used to generate human-readable output for data structures that track indexed relationships, such as database schemas or hierarchical data models.",
      "description_length": 369,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.OptionalIndexedAccess",
      "description": "Formats and converts values of a tuple type containing a map and a list, using custom pretty-printing and string representation functions for each component. Accepts a map type 'M' and a list type 'T' to generate human-readable output. Used to serialize structured data for logging or debugging with precise control over formatting.",
      "description_length": 332,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Object",
      "description": "Generates human-readable representations of nested data structures using metadata and value types, with support for tuples, records, and tagged unions. Handles recursive and polymorphic types, allowing custom formatting for tags, values, and optional flags. Examples include visualizing configuration schemas, serializing method-call properties, and producing debug logs with structured output. Operates on types like ('M, 'T) t, ('M, 'T) t', and nested variants with distinct formatting rules for base and recursive components.",
      "description_length": 528,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Interface",
      "description": "Formats a value using a custom printer function for a message type and a target type, then generates a string representation. Works with a tuple type that pairs a message and a target. Used to produce human-readable output for protocol buffers during debugging or logging.",
      "description_length": 272,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Nullable",
      "description": "Produces a string representation of a value with optional presence, using custom pretty-printers for the missing and present cases. Accepts formatter functions to define output formats for both states. Used to generate human-readable logs or error messages where values may be absent.",
      "description_length": 284,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.Typeof",
      "description": "Generates human-readable representations of structured data, including polymorphic and nested qualified types. Supports operations like pretty-printing, string conversion, and type inspection. Can display complex data hierarchies in debug logs or user interfaces. Examples include formatting type annotations, serializing nested module structures, and rendering polymorphic variants with context.",
      "description_length": 396,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Keyof",
      "description": "Produces a pretty-printing function and a string representation for a type that maps keys of type 'M to values of type 'T. Operates on tuples representing key-value mappings, enabling custom formatting and string conversion. Used to generate human-readable output for structured data with explicit key-value associations.",
      "description_length": 321,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.Renders",
      "description": "Provides pretty-printing and string representation functions for variant types and a tagged union structure. Operates on a variant type and a parameterized tagged type ('M, 'T) t, supporting custom formatting for each tag. Used to generate human-readable output for serialized data structures with distinct metadata and tag components.",
      "description_length": 335,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.ReadOnly",
      "description": "Formats values of a tuple type with a custom printer and string representation, using provided formatting functions for each component. Operates on pairs where the first element is a module type and the second is a type, typically used for structured data inspection. Enables detailed output for debugging or logging specific data configurations.",
      "description_length": 346,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Tuple",
      "description": "Encapsulates structured data with metadata and content, offering pretty-printing and string conversion through customizable formatters for each component. Supports operations on tuples containing distinct metadata and data types, enabling readable serialization and representation of complex values. Can format labeled elements and spread elements, allowing precise control over how metadata and payload are displayed. Examples include generating debug outputs, logging structured information, and exporting data with explicit metadata tags.",
      "description_length": 541,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.Array",
      "description": "Provides functions to format and convert arrays of mixed and typed elements into human-readable strings. Operates on a polymorphic array type that combines two distinct element types. Used to generate debug representations or display structured data in logs or user interfaces.",
      "description_length": 277,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Union",
      "description": "Produces a string representation of a variant type with two distinct constructors, using custom pretty-printing functions for each. Operates on a polymorphic variant type with two type parameters, 'M and 'T, representing different branches. Used to generate human-readable output for logging or debugging purposes where distinct formatting for each branch is required.",
      "description_length": 368,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Intersection",
      "description": "Produces a string representation of a structured data type by combining custom pretty-printers for two distinct components. Accepts formatter functions for each component type and applies them to generate a formatted output. Used to display complex composite data in a readable format during debugging or logging.",
      "description_length": 313,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.TypeParam",
      "description": "Provides pretty-printing and string representation functions for type-bound structures, including a nested type `('M, 'T) t` and its recursive variant `('M, 'T) t'`. Operates on tuples and recursive records that encode type parameters and their constraints. Used to generate human-readable output for type annotations in code generation tools.",
      "description_length": 343,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.TypeParams",
      "description": "Formats and converts type parameters with custom pretty-printing and string representation. Operates on nested type structures involving metadata and type information. Used to generate human-readable output for complex type annotations in code generation tools.",
      "description_length": 261,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.TypeArgs",
      "description": "Formats and converts structured data types representing a metadata-value pair and nested recursive structures, using custom pretty-printing and string representation functions. It handles tuples containing a metadata type and a recursively defined structure, enabling detailed output formatting for complex hierarchical data. Used to generate human-readable representations of nested data models in serialization or debugging contexts.",
      "description_length": 435,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type.Predicate",
      "description": "Generates human-readable representations of structured predicate data by formatting a metadata type 'M and a term type 'T. Provides pretty-printing and string serialization for nested predicate structures and their kinds. Used to visualize logical conditions in type-checking or debugging contexts.",
      "description_length": 298,
      "index": 75,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Type.TypeGuard",
      "description": "Generates human-readable representations of type-checked values by combining custom pretty-printers for a base type and a target type. Operates on tuples containing a marker type and a recursive structure, along with a nested variant type that holds additional type information. Used to serialize or debug complex type-safe data structures with explicit type annotations.",
      "description_length": 371,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Block",
      "description": "Formats and converts values of a composite type containing elements of type 'M and 'T into human-readable strings using provided pretty-printing functions. Accepts custom formatting rules for each component and generates output suitable for logging or user interfaces. Used to serialize structured data with distinct metadata and content fields.",
      "description_length": 345,
      "index": 77,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Statement.If",
      "description": "Provides custom serialization and pretty-printing for nested data structures involving a base type and a recursive variant, supporting tuples and alternating record types. Key data types include the base type 'M and recursive variant 'T, with operations for converting structures to formatted strings and debug outputs. It enables detailed inspection of complex tree-like hierarchies by generating readable representations. For example, it can transform a deeply nested record with alternating types into a structured string showing each level's content.",
      "description_length": 554,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Labeled",
      "description": "Formats labeled values by combining a formatter for the label and a formatter for the value, producing a string representation. Works with tuples of labeled values and their corresponding label types. Used to generate human-readable output for data structures with named fields in logging or debugging contexts.",
      "description_length": 311,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Break",
      "description": "Provides pretty-printing and string representation functions for a type parameterized by 'M. Operates on a record type 'M t containing a single field of type 'M. Used to generate human-readable output for debugging or logging purposes.",
      "description_length": 235,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Continue",
      "description": "Provides pretty-printing and string conversion for values of type 'M t using a custom formatter. Operates on a polymorphic variant type 'M t that encapsulates continuation-based state. Used to generate human-readable representations during debugging or logging of continuation-passing style computations.",
      "description_length": 304,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Debugger",
      "description": "Provides pretty-printing and string representation functions for custom data types, using a formatter and a type-specific printer. Works with polymorphic types wrapped in a container, enabling structured output for debugging. Used to visualize complex data during runtime inspection and error tracing.",
      "description_length": 301,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.With",
      "description": "Formats values of a tagged union type by combining custom pretty-printing functions for each variant, using a formatter to produce output. Works with a polymorphic variant type that associates a tag with a value. Used to generate human-readable representations of structured data during debugging or logging.",
      "description_length": 308,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.TypeAlias",
      "description": "Provides pretty-printing and string conversion for a type alias that wraps two distinct types, 'M and 'T. Accepts formatter functions for each type and applies them to instances of the alias. Used to generate human-readable representations of mixed-type values in logging or debugging contexts.",
      "description_length": 294,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.OpaqueType",
      "description": "Formats values of a polymorphic variant type using custom pretty-printing functions for its constructors and values, and generates string representations by combining these. It operates on tuples of type ('M, 'T) t, where 'M represents constructor metadata and 'T represents the actual values. Used to serialize complex data structures with custom formatting rules for debugging or logging.",
      "description_length": 390,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Switch",
      "description": "Converts structured data between a base type and a tagged variant, using custom pretty-printing functions to format tuples containing a marker and a recursive tagged structure. Supports both direct and recursive representations, enabling clear visualization of nested data models. Examples include generating debug outputs for complex data hierarchies and transforming internal representations into human-readable formats. Operations include conversion, pretty-printing, and recursive traversal of tagged structures.",
      "description_length": 516,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Return",
      "description": "Formats error messages and values using provided pretty-printing functions, supporting custom representations for both error and value types. Works with a tuple type that pairs an error type and a value type. Used to generate human-readable strings for debugging or logging purposes.",
      "description_length": 283,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Throw",
      "description": "Formats error messages and trace information using custom pretty-printing functions for two distinct types, M and T. Accepts a formatter and a value of type ('M, 'T) t to generate a string representation suitable for logging or debugging. Designed for structured error reporting in applications requiring detailed diagnostic output.",
      "description_length": 332,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Statement.Try",
      "description": "Provides structured error reporting by combining message and value types through custom pretty-printers, operating on tuples that encapsulate error states. Supports rendering detailed error information for debugging or logging by formatting nested error types. Allows developers to generate clear, contextual error representations from complex data structures. Example uses include displaying stack traces or highlighting specific failure points in program execution.",
      "description_length": 467,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.VariableDeclaration",
      "description": "Handles structured data transformation through custom formatting and string conversion, supporting nested tuples and recursive types with metadata. Key data types include tagged structures and metadata-paired elements, with operations for pretty-printing and serialization. Examples include converting abstract syntax trees to readable strings or transforming configuration data for logging. Enables precise control over data representation in parsing and output generation workflows.",
      "description_length": 484,
      "index": 90,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Statement.While",
      "description": "Formats a structured value with custom pretty-printing for two distinct components, using provided formatting functions for each. Operates on a tuple type containing two distinct data elements, often used for representing state transitions or labeled data. Generates a string representation suitable for debugging or logging specific composite structures.",
      "description_length": 355,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.DoWhile",
      "description": "Formats a structured value using custom pretty-printing functions for its components and generates a string representation from it. It operates on a tuple type containing two distinct elements, typically used for modeling state transitions or labeled data. This is applied in scenarios requiring precise control over output formatting, such as generating debug logs or serialized representations.",
      "description_length": 396,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.For",
      "description": "Generates formatted output and string representations for structured data types using custom pretty-printers for member and tag components. Processes tagged tuples and initialization records with explicit formatting functions for each field. Enables precise control over the textual representation of complex data during debugging or logging.",
      "description_length": 342,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.ForIn",
      "description": "Generates formatted output for a sum type with two variants, supporting custom pretty-printing and string representation. It handles types parameterized by two type variables, where one represents a \"marker\" and the other a \"tag.\" Used to serialize and display structured data with distinct left and right branches in a controlled format.",
      "description_length": 338,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.ForOf",
      "description": "Provides pretty-printing and string representation for a type parameterized by two type variables, supporting both full values and left-embedded variants. Operates on structured data with distinct 'M' and 'T components, enabling formatted output for debugging or logging. Used to generate human-readable representations of complex data during development or error reporting.",
      "description_length": 374,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.EnumDeclaration",
      "description": "Generates human-readable representations of complex, nested data structures using custom pretty-printing and string conversion functions. Operates on parameterized types like 'M t, supporting recursive, boolean, and structured data, with specialized handling for symbols, integers, and member fields. Examples include formatting parsed syntax trees, debugging logical expressions, and serializing symbol bodies. Provides explicit control over output format through printer functions and supports hierarchical data rendering.",
      "description_length": 524,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Statement.ComponentDeclaration",
      "description": "Handles structured data conversion and pretty-printing for parameterized, nested, and recursive types. Operates on tuple-based recursive structures, metadata, and named parameters, generating human-readable outputs for logging, debugging, and serialization. Supports custom formatting of message, transport, and configuration data, including nested metadata and recursive tree types. Examples include serializing parameter hierarchies into strings, generating debug representations of complex configurations, and producing readable outputs for parsing or transport layers.",
      "description_length": 572,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Interface",
      "description": "Provides pretty-printing and string conversion for a type that pairs a message type and a transport type. Operates on the polymorphic variant type ('M, 'T) t, enabling custom formatting and representation. Used to generate human-readable output for protocol messages and their associated transport layers.",
      "description_length": 305,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.DeclareClass",
      "description": "Produces a string representation of a class structure by formatting its members and traits using custom pretty-printing functions. Operates on a polymorphic tuple type that pairs member and trait definitions. Used to generate human-readable class summaries for debugging or logging purposes.",
      "description_length": 291,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.DeclareComponent",
      "description": "Produces a pretty-printing function and a string representation for a type that combines two distinct components, 'M and 'T. It operates on tuples structured as ('M, 'T) t, enabling custom formatting for mixed-type records. Used to generate human-readable outputs for domain-specific data models in code generation tools.",
      "description_length": 321,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.DeclareVariable",
      "description": "Formats a value with custom pretty-printing for two distinct types, using provided formatting functions for each. Operates on a tuple type that pairs two distinct data types, M and T. Used to generate human-readable representations of structured data during debugging or logging.",
      "description_length": 279,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.DeclareFunction",
      "description": "Produces a string representation of a type with two parameters by combining custom pretty-printing functions for each parameter. Accepts formatter-based functions to format each type and applies them to instances of the parameterized type. Used to generate human-readable output for complex data structures in code generation or debugging contexts.",
      "description_length": 348,
      "index": 102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Statement.DeclareModule",
      "description": "Provides pretty-printing and string representation functions for type-safe identifiers and values, using custom formatters for associated metadata and type tags. Operates on polymorphic variants with embedded metadata and type information. Used to generate human-readable output for debug logging and serialization contexts.",
      "description_length": 324,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.DeclareModuleExports",
      "description": "Provides pretty-printing and string representation for a tuple type containing two distinct values, using custom formatting functions for each component. Operates on polymorphic tuples where each element has its own type-specific rendering logic. Used to generate human-readable output for structured data in code generation or debugging contexts.",
      "description_length": 347,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.DeclareNamespace",
      "description": "Formats and displays values of a named tuple type, combining a module and a type representation. It operates on polymorphic tuples where the first component represents a module and the second a type. Used to generate human-readable output for custom type representations in code generation tools.",
      "description_length": 296,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.ExportNamedDeclaration",
      "description": "Generates human-readable and serialized representations of module-type pairs, handling both nested structures and optional type identifiers. Processes tuples where the first element is a module identifier and the second is either a recursive type or an optional type. Supports code generation tasks by enabling debug output, serialization, and display of complex type annotations. Examples include formatting module signatures for documentation or converting type structures into string literals for configuration files.",
      "description_length": 520,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.ExportDefaultDeclaration",
      "description": "Generates pretty-printed representations of module and type declarations using custom formatters. Processes abstract syntax tree nodes representing module and type structures. Outputs formatted strings for debugging or code generation tasks.",
      "description_length": 241,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.DeclareExportDeclaration",
      "description": "Generates human-readable representations of module and type declarations using custom pretty-printing and string conversion functions. Operates on polymorphic tuples representing module-type pairs and their associated declarations. Used to format AST nodes for debugging or code generation outputs.",
      "description_length": 298,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Statement.ImportDeclaration",
      "description": "Formats and converts import declarations and their components, including import kinds, specifiers, and identifiers, using custom pretty-printing and string representation functions. Works with polymorphic types representing module and type information in a structured import syntax. Used to generate human-readable representations of ES6-style import statements during code analysis or transformation.",
      "description_length": 401,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Expression",
      "description": "Produces a formatted string representation of a typed expression structure using custom pretty-printing functions for metadata and type information. Operates on a polymorphic variant type that pairs metadata and type annotations. Used to generate human-readable output for debugging or logging purposes in a compiler or interpreter context.",
      "description_length": 340,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Statement.Empty",
      "description": "Produces a formatted string representation of a value using a provided printer function, and provides a pretty-printing function for the same type. Works with a parameterized type that wraps a value of type 'M. Used to generate human-readable output for custom data structures in debugging or logging contexts.",
      "description_length": 310,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.CallTypeArg",
      "description": "Combines metadata and type-specific formatting to create human-readable outputs from structured data, handling tuples of type 'T and nested metadata 'M t'. Supports custom formatting rules for different data types and metadata layers. Allows developers to generate detailed debug information for complex data models. Example: converting a nested record with embedded metadata into a readable string representation.",
      "description_length": 414,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.CallTypeArgs",
      "description": "Formats and converts structured data representing function call types, where each entry pairs a module type with a type expression. It supports pretty-printing to a formatter and string representation for both nested and non-nested variants of the type structure. Used to generate human-readable outputs for debugging or logging complex type annotations in OCaml tools.",
      "description_length": 369,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Expression.SpreadElement",
      "description": "Provides pretty-printing and string representation functions for a nested structure composed of a base type 'M and a recursive variant 'T. Operates on a tuple type pairing 'M with a recursive variant type that may contain additional elements. Used to generate human-readable output for complex data hierarchies in serialization or debugging contexts.",
      "description_length": 350,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.Array",
      "description": "Provides pretty-printing and string representation for array elements and arrays themselves, using custom formatters for embedded metadata and values. Operates on typed arrays with associated metadata and element types. Used to generate human-readable output for debugging or logging structured array data.",
      "description_length": 306,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.TemplateLiteral",
      "description": "Generates human-readable representations of complex data structures, supporting nested types, polymorphic variants, and value records. Offers functions to convert polymorphic type constructors 'M t and their t' forms into readable strings. Enables debugging and logging by formatting intricate data hierarchies clearly. Examples include printing a nested record with variant fields or converting a polymorphic list into a structured string.",
      "description_length": 440,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.TaggedTemplate",
      "description": "Provides pretty-printing and string conversion for tagged template structures using custom formatters for metadata and template parts. Operates on a polymorphic tuple type representing a template with associated metadata. Used to generate human-readable output or serialize templates with structured data.",
      "description_length": 305,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.Object",
      "description": "Produces human-readable representations of nested, metadata-rich key-value structures and layered data models using polymorphic types. Supports formatted output for tuples of metadata and recursive elements, enabling precise control over how complex data is displayed. Can generate structured strings for configuration maps, hierarchical models, and nested variant types. Examples include rendering JSON-like structures with annotations or serializing tree-based data with custom formatting rules.",
      "description_length": 497,
      "index": 118,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Expression.Sequence",
      "description": "Provides pretty-printing and string representation for a structured data type with two parameters, 'M and 'T, using formatter functions. Works with a custom type ('M, 'T) t that encapsulates a pair of values. Used to generate human-readable output for debugging or logging specific data models and their associated tags.",
      "description_length": 320,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.Unary",
      "description": "Produces human-readable representations of operator values and structured data types. Handles formatting and string conversion for custom types using provided pretty-printers and show functions. Used to generate debug outputs and serialized representations in parsing or logging workflows.",
      "description_length": 289,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.Binary",
      "description": "Formats and converts operator values for human-readable output using custom pretty-printing and string representation functions. Works with the `operator` type and a generic tuple type `('M, 'T) t` that pairs two distinct data types. Used to generate debug logs and serialized representations of structured data in parsing or serialization workflows.",
      "description_length": 350,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Expression.Assignment",
      "description": "Produces human-readable representations of operator values and structured data types. Handles formatting and string conversion for custom types using provided pretty-printing and show functions. Supports complex data structures with nested type parameters, enabling detailed output for specific domain models.",
      "description_length": 309,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.Update",
      "description": "Formats and converts operator values for human-readable output using custom pretty-printers and string representations. Operates on a polymorphic type representing updates with metadata and target values. Used to generate debug logs and serialized representations in a type-safe manner.",
      "description_length": 286,
      "index": 123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Expression.Logical",
      "description": "Provides pretty-printing and string representation for logical operators and structured data, using custom formatters for flexible output. Works with a polymorphic type representing logical expressions and an operator type for symbolic operations. Used to generate human-readable formats for debugging or logging logical structures in a typed system.",
      "description_length": 350,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.Conditional",
      "description": "Formats and converts values of a conditional type that holds either a value of type 'M or 'T, using provided pretty-printing and string conversion functions. It supports custom formatting for each branch and generates human-readable representations. Used to display error or success states with distinct formatting rules.",
      "description_length": 321,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.ArgList",
      "description": "Generates pretty-printed and string representations of labeled argument lists, where each element has a metadata type 'M and a value type 'T. Processes recursive structures composed of tuples and tagged records, enabling structured output for debugging or logging. Supports custom formatting for metadata and value components during serialization.",
      "description_length": 347,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.New",
      "description": "Formats a value using custom pretty-printing functions for two distinct types, M and T, and generates a string representation from the formatted output. It operates on a polymorphic variant type ('M, 'T) t that encapsulates values of type M and T. This is used to produce human-readable debug output for composite data structures containing mixed types.",
      "description_length": 353,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.Call",
      "description": "Formats a structured value using custom pretty-printing functions for its components and returns a string representation. It operates on a tuple type containing two distinct elements, often used for representing method and target pairs in a typed interface. This is useful for generating human-readable logs or debug outputs with controlled formatting.",
      "description_length": 352,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.OptionalCall",
      "description": "Formats a value with two distinct representations, one for a mandatory component and one for an optional component, using provided pretty-printing functions. Operates on a tuple type that pairs a mandatory value with an optional value. Used to generate human-readable output for structured data where some fields may be absent.",
      "description_length": 327,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.Member",
      "description": "Generates pretty-printed and string representations for values with associated metadata and type information. Operates on polymorphic types parameterized by metadata ('M) and type tags ('T). Used to format domain-specific data structures for logging and debugging.",
      "description_length": 264,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.OptionalMember",
      "description": "Formats and converts values of a tagged union type representing optional members, where one variant holds a value of type 'M and the other is a placeholder of type 'T. It supports pretty-printing to a formatter and generating string representations based on custom formatters for each variant. Used to serialize or display structured data with optional fields in a controlled manner.",
      "description_length": 383,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.Yield",
      "description": "Formats a value with custom pretty-printing for two distinct types, using provided formatting functions for each. Operates on a tuple type that pairs two values of potentially different types. Used to generate human-readable representations of structured data during debugging or logging.",
      "description_length": 288,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.TypeCast",
      "description": "Formats a value using a custom pretty-printer and converts it to a string representation, supporting type-safe casting between two distinct types. Operates on a polymorphic variant type that encapsulates a value and its associated type information. Used to generate human-readable output and string representations during debugging or logging of typed data.",
      "description_length": 357,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.AsExpression",
      "description": "Produces a string representation of a typed expression by formatting its metadata and type information. Accepts custom pretty-printing functions for metadata and type, and operates on a structured type that pairs these elements. Used to generate human-readable output for abstract syntax tree nodes during code analysis or debugging.",
      "description_length": 333,
      "index": 134,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.AsConstExpression",
      "description": "Formats and converts values of a polymorphic variant type representing constant expressions, using provided pretty-printing and string conversion functions for its two type parameters. Works with a tuple-based structure that encapsulates two distinct type parameters, often used to represent metadata and type information. Used to generate human-readable representations of abstract syntax tree nodes during code generation or analysis.",
      "description_length": 436,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.TSSatisfies",
      "description": "Produces a string representation of a type-checked value by combining custom pretty-printers for two distinct types, M and T. Accepts formatter functions for each type and applies them to a structured value containing both. Used to generate human-readable output for complex data models in validation or debugging scenarios.",
      "description_length": 324,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Expression.MetaProperty",
      "description": "Provides pretty-printing and string representation functions for type-safe metadata structures. Operates on polymorphic type 'M t, which encapsulates structured metadata with type constraints. Used to generate human-readable output and string representations for custom metadata types in code generation workflows.",
      "description_length": 314,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Expression.This",
      "description": "Provides pretty-printing and string representation functions for type-safe data structures. Operates on polymorphic variants wrapped in a type constructor that encapsulates a value of type 'M. Used to generate human-readable output for custom data types in a type-safe manner.",
      "description_length": 276,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression.Super",
      "description": "Produces a formatted string representation of values using a custom printer function, and generates a human-readable string from a value using a specified formatting function. Works with parameterized type 'M t, which encapsulates structured data. Used to serialize complex data structures for logging or debugging purposes.",
      "description_length": 324,
      "index": 139,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Expression.Import",
      "description": "Formats a value using custom pretty-printing functions for two distinct types, producing a string representation. Operates on a tuple type that pairs two different data structures, enabling structured output generation. Used to generate human-readable logs or debug information from complex data models.",
      "description_length": 303,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Function.RestParam",
      "description": "Formats and converts structured data between a metadata type and a target type, using custom pretty-printing and string representation functions. Operates on nested tuple structures that pair metadata with recursive data nodes. Used to generate human-readable outputs for complex data models in serialization pipelines.",
      "description_length": 319,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Function.Param",
      "description": "Generates human-readable representations of structured data by formatting a value with a custom printer and a type-specific formatter. Operates on tuples containing a metadata value and a recursive structure, along with a nested type that holds additional configuration. Used to produce debug output or log structured information with controlled formatting.",
      "description_length": 357,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Function.ThisParam",
      "description": "Generates human-readable representations of nested data structures by combining custom pretty-printers for base and nested types. Accepts formatter functions for two type parameters and applies them to tuples and recursive variants. Produces formatted strings or outputs to a formatter for debugging or logging purposes.",
      "description_length": 320,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Function.Params",
      "description": "Formats and converts parameterized data structures into human-readable strings, using custom pretty-printers for base and recursive components. Operates on nested tuple types representing structured parameter sets. Used to generate debug outputs and serialized representations in parsing and configuration systems.",
      "description_length": 314,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Function.ReturnAnnot",
      "description": "Produces a string representation of a tagged value by combining a custom printer for the tag and a custom printer for the value. Operates on tuples of type ('M, 'T) t, where 'M and 'T are arbitrary types. Used to generate human-readable output for annotated data structures in code generation or debugging contexts.",
      "description_length": 315,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Class.Method",
      "description": "Provides pretty-printing and string representation functions for method signatures, handling both base and recursive components. Works with tuple structures representing method types and a discriminated union for kind annotations. Used to generate human-readable output for compiler or parser diagnostics.",
      "description_length": 305,
      "index": 146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Class.Property",
      "description": "Provides pretty-printing and string representation functions for structured data, supporting custom formatters for metadata and type-specific rendering. Operates on nested types representing values with associated metadata and recursive structures. Used to generate human-readable output for complex data models in serialization or debugging contexts.",
      "description_length": 351,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Class.PrivateField",
      "description": "Formats and converts values wrapped in a nested tuple structure containing a metadata element and a recursive field, supporting pretty-printing to a formatter and string representation. Operates on polymorphic types where the first component represents metadata and the second holds the actual value. Used to serialize and display structured data with embedded metadata in logging or output contexts.",
      "description_length": 400,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Class.Extends",
      "description": "Provides pretty-printing and string representation functions for nested data structures composed of a metadata type 'M and a content type 'T. Operates on recursive types ('M, 'T) t and ('M, 'T) t' that represent labeled, hierarchical data. Used to generate human-readable output for debug logging and data serialization scenarios.",
      "description_length": 330,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Class.Implements",
      "description": "Produces human-readable output by formatting nested data structures, including tuples with metadata and recursive elements, along with their variants. Key data types include metadata-encapsulated tuples and recursive variants, with operations for pretty-printing and serialization. It enables developers to inspect and log complex data models in a structured, readable format. For example, it can transform a nested list with metadata into a cleanly indented string for debugging.",
      "description_length": 480,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Class.Body",
      "description": "Generates formatted output for structured data using custom pretty-printers and string representations. Operates on nested type constructors ('M, 'T) t, ('M, 'T) t', and ('M, 'T) element, enabling detailed rendering of hierarchical content. Supports custom formatting for markup and text components in document-like structures.",
      "description_length": 327,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Class.Decorator",
      "description": "Generates formatted output and string representations for nested data structures by combining custom pretty-printers for base and decorated values. Operates on tuples containing a base value and a recursive structure, along with associated pretty-printing functions. Used to serialize complex hierarchical data with consistent formatting rules.",
      "description_length": 344,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsdoc.Param",
      "description": "Provides pretty-printing, string representation, and equality checks for structured data elements, including paths, metadata info, and optionality flags. Works with nested types such as lists of (path * info) pairs, individual path components, and metadata records. Used to serialize and compare configuration parameters in a parser or code generator.",
      "description_length": 351,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsdoc.Params",
      "description": "Formats, converts, and compares lists of string-param pairs using pretty-printing, string representation, and equality checks. Works with structured data representing configuration parameters. Used to serialize and validate parameter sets in CLI tools and configuration loaders.",
      "description_length": 278,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsdoc.Unrecognized_tags",
      "description": "Handles lists of tag-value pairs where each tag is a string and the value is an optional string. Provides pretty-printing, string representation, and equality checks for these structured data elements. Used to process and compare unrecognized XML or HTML tags during parsing workflows.",
      "description_length": 285,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Object_parser.Object",
      "description": "Handles expression parsing and analysis for assignment, conditional, and sequence operations, with support for numeric and big integer literals. Works with AST expressions, location data, and pattern covers to validate and construct syntactic elements. Used to process variable assignments, evaluate conditional expressions, and parse type arguments in function calls.",
      "description_length": 368,
      "index": 156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pattern_cover.Cover",
      "description": "This module specializes in parsing and constructing abstract syntax tree (AST) nodes for JavaScript/Flow code, handling elements like expressions, statements, class declarations, and JSX. It works with AST nodes, location metadata, and token types to manage syntactic structures, including type annotations and numeric literals. Use cases include code analysis, transformation, and syntax validation in tools processing complex JavaScript/Flow constructs.",
      "description_length": 455,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Statement_parser.Statement",
      "description": "Extracts and processes the key of an object property, including location and type information. Parses class declarations, expressions, and implements clauses, along with decorator lists, using environment state to track parsing context. Handles initializer expressions with error tracking for pattern matching.",
      "description_length": 310,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parse_error.PP",
      "description": "Provides error formatting for a custom type `t` by converting it to a string with an error message. Works with a domain-specific type representing parsed or processed data. Used to generate human-readable error outputs during validation or parsing steps.",
      "description_length": 254,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declaration_parser.Declaration",
      "description": "This module handles parsing and construction of abstract syntax tree (AST) nodes for JavaScript/Flow code, including programs, expressions, classes, and type annotations, while managing syntactic structures like JSX elements and numeric literals. It operates on parser environments, tokens, and AST elements, incorporating location tracking, error reporting, and support for optional parameters. Key use cases involve analyzing or transforming code structures, validating type annotations, and processing complex syntactic patterns in static analysis or code generation workflows.",
      "description_length": 580,
      "index": 160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parser_flow.Parse",
      "description": "This module handles parsing of syntactic elements in a JavaScript-like language, constructing abstract syntax trees (ASTs) with location tracking while managing parser environments and tokens. It specializes in processing expressions, class structures, type annotations, and numeric literals, with mechanisms for error reporting and optional parameter handling. Use cases include building structured representations of code for analysis or transformation, particularly in scenarios requiring precise syntactic and type information.",
      "description_length": 531,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parser_env.SSet",
      "description": "This module provides functional set operations for managing collections of unique string elements, including adding, removing, membership checks, and set unions, while preserving immutability by returning new instances. It supports querying cardinality, iterating over elements, and constructing sets from lists or arrays, enabling efficient data processing and transformation in functional workflows. These capabilities are particularly useful for tasks requiring deterministic set manipulations, such as filtering, aggregating, or analyzing string-based datasets.",
      "description_length": 565,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parser_env.Lex_mode",
      "description": "Provides conversion of lex mode values to debug strings. Works with a custom type representing different lexical processing states. Used to generate human-readable representations during debugging or logging.",
      "description_length": 208,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parser_env.Peek",
      "description": "This module provides indexed retrieval of parsing artifacts like tokens, locations, errors, and comments, along with lexical analysis functions to inspect character properties such as line terminators, identifiers, and implicit semicolons. It operates on an environment and positional indices to validate syntax and track parsing state. Use cases include real-time syntax checking, error reporting, and comment-aware token processing in compiler or linter workflows.",
      "description_length": 466,
      "index": 164,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parser_env.Eat",
      "description": "Processes lexical tokens and comments within a parsing environment, supporting mode switching and comment extraction. Operates on environment state, token types, and comment structures with precise control over lexical flow. Extracts specific comment lists and manages lexical modes during parsing tasks.",
      "description_length": 304,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parser_env.Expect",
      "description": "Provides functions to handle parsing errors, validate tokens, and check for identifiers within a given environment. Works with token data, location information, and parse error structures. Used to enforce syntax rules, report malformed input, and track expected token patterns during parsing.",
      "description_length": 292,
      "index": 166,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parser_env.Try",
      "description": "Provides operations to handle parsing with environment context, including a function to execute a parser and another to substitute a fallback value on failure. Works with environment values and a custom parse result type that encapsulates parsing outcomes. Used to safely chain parsing steps and provide default values when parsing fails.",
      "description_length": 338,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Syntax",
      "description": "Produces human-readable representations of syntax trees by formatting nodes with custom pretty-printing functions for different node types. Accepts formatter functions for two distinct node variants and applies them to a structured syntax tree. Used to generate debug output or source code representations from parsed syntax data.",
      "description_length": 330,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Identifier",
      "description": "Generates human-readable representations of structured data using custom pretty-printing and string conversion functions. Operates on tuples containing a type-specific value and a nested structure parameterized by 'M and 'T. Used to format and serialize domain-specific identifiers with custom formatting rules.",
      "description_length": 311,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.PrivateName",
      "description": "Generates pretty-printed and string representations of values with custom formatting functions. Operates on recursive data structures defined as a pair of a type parameter and a nested variant. Used to serialize complex nested data for logging or debugging purposes.",
      "description_length": 266,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.StringLiteral",
      "description": "Produces a pretty-printed string representation of a type with a custom formatting function, using a provided formatter. Operates on a polymorphic variant type 'M t that encapsulates string literals with metadata. Used to generate human-readable outputs for debugging or logging purposes in code generation tools.",
      "description_length": 313,
      "index": 171,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.NumberLiteral",
      "description": "Formats and converts numeric values into human-readable string representations using a custom formatter. Operates on a parameterized type 'M t that encapsulates numeric data. Used to generate consistent textual output for numbers in parsing and serialization workflows.",
      "description_length": 269,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.BigIntLiteral",
      "description": "Formats and converts arbitrarily large integer literals into string representations using a custom type that encapsulates the numeric value and its base. It supports operations for pretty-printing and string conversion, enabling precise handling of large integers in parsing or serialization workflows. Works with a parameterized type that stores the integer value and its representation details.",
      "description_length": 396,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.BooleanLiteral",
      "description": "Produces a string representation of boolean values using a custom formatter, and formats them for output. Works with a parameterized type representing boolean literals, allowing integration with different monadic contexts. Used to generate human-readable boolean outputs in code generation or logging scenarios.",
      "description_length": 311,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.RegExpLiteral",
      "description": "Generates string representations of regular expression patterns using a custom formatter. Operates on a parameterized type representing compiled regex patterns. Used to produce human-readable forms for debugging or logging purposes.",
      "description_length": 232,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.ModuleRefLiteral",
      "description": "Produces a pretty-printed representation of a module reference with associated type, using custom pretty-printing functions for each component. Accepts formatter functions for module and type parts, and outputs a formatted string. Designed for generating human-readable module and type annotations in code generation or debugging contexts.",
      "description_length": 339,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Variance",
      "description": "Provides pretty-printing and string representation functions for type structures involving a monadic context and nested variants. Operates on recursive types 'M t and kind, with specialized formatting for different layers of the structure. Used to generate human-readable outputs for complex type hierarchies in compiler or analysis tools.",
      "description_length": 339,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.ComputedKey",
      "description": "Generates human-readable representations of nested key structures by formatting a base type 'M and a recursive structure 'T. Provides pretty-printing and string conversion for both the top-level and recursive variants of the type. Used to serialize complex key hierarchies in debugging or logging contexts.",
      "description_length": 306,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Variable",
      "description": "Prints and converts kind values to strings using pretty-printing and string representation functions. Operates on the abstract type `kind` used to classify variables. Used to generate human-readable output for debugging or logging variable classifications.",
      "description_length": 256,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Type",
      "description": "Provides unified pretty-printing and string conversion for a range of structured data types, including polymorphic variants, tuples, maps, lists, and recursive structures. Main data types include variant branches, metadata-value pairs, key-value mappings, and nested configurations, with operations for custom formatting, string generation, and recursive rendering. Examples include formatting debug logs, serializing configuration trees, and generating human-readable outputs for type-safe data structures. Supports distinct formatting rules for each component, enabling precise control over output structure and type-specific representation.",
      "description_length": 643,
      "index": 180,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Statement",
      "description": "Combines multiple formatting and serialization capabilities for structured data, supporting composite, nested, and polymorphic types. Key data types include tuples, polymorphic variants, and parameterized records, with operations for pretty-printing, string conversion, and recursive traversal. It enables detailed output for debugging, logging, and code generation, such as formatting abstract syntax trees, serializing module-type pairs, or generating human-readable error messages. Examples include transforming nested records into structured strings, displaying continuation-passing style computations, and rendering labeled data with custom formatting rules.",
      "description_length": 663,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Expression",
      "description": "Combines metadata and structured data formatting into human-readable outputs, supporting nested types, polymorphic variants, and custom rules for diverse data models. Operates on tuple types pairing metadata with values, recursive structures, or tagged unions, enabling detailed string representations for debugging, logging, and serialization. Examples include formatting nested records, polymorphic lists, or tagged unions with distinct display rules. Provides functions to convert complex data hierarchies into readable strings using customizable pretty-printers.",
      "description_length": 566,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.JSX",
      "description": "Provides unified pretty-printing and string conversion for a range of structured data types, including identifiers, namespaced types, AST nodes, text content, attributes, and hierarchical closures. Operates on polymorphic tuples, nested types, and recursive structures, enabling customizable output for debugging, logging, and code generation. Examples include generating human-readable representations of parsed code elements, serializing complex attribute hierarchies, and formatting member expressions with custom formatters. Supports both recursive and non-recursive variants, as well as polymorphic variant types with distinct 'M and 'T components.",
      "description_length": 653,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Pattern",
      "description": "Combines metadata and recursive data structures into human-readable formats through custom pretty-printing and serialization. It defines types for metadata and nested elements, supporting operations like string conversion, debug output, and hierarchical traversal. Users can generate labeled tree visualizations, log structured data, or produce domain-specific identifier representations. Examples include displaying annotated configuration trees or rendering type-safe identifiers with custom formatting rules.",
      "description_length": 511,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Comment",
      "description": "Formats and displays comment data structures using pretty-printing and string conversion functions. Operates on types representing comments with metadata and their parsed forms. Used to generate human-readable representations of comments during code analysis or output formatting.",
      "description_length": 280,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast.Class",
      "description": "Offers unified pretty-printing and string representation for nested data structures, including metadata-encapsulated tuples, recursive variants, and hierarchical types. Key data types include tuples with metadata and content, recursive structures, and labeled data models, with operations for custom formatting, serialization, and debugging. It enables the transformation of complex, nested values\u2014such as method signatures, structured data, or document-like hierarchies\u2014into readable, indented strings. For example, it can format a recursive list with metadata into a clear, human-readable output for logging or diagnostics.",
      "description_length": 625,
      "index": 186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Function",
      "description": "Combines custom pretty-printing and formatting capabilities for structured data, handling nested tuples that pair metadata with recursive or parameterized data. Supports operations on types like ('M, 'T) t and nested tuple structures, enabling controlled string representation through configurable printers. Examples include generating debug logs, serializing complex models, and producing annotated output for code generation. Functions allow recursive formatting, configuration-based rendering, and conversion between metadata and target types.",
      "description_length": 546,
      "index": 187,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Flow_ast.Program",
      "description": "Generates human-readable representations of structured data by formatting a metadata value and a nested tree structure. Accepts custom pretty-printing and string conversion functions for metadata and tree nodes. Used to output debug information or serialize complex tree-based configurations in a readable format.",
      "description_length": 313,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsx_parser.JSX",
      "description": "This module handles parsing and construction of JavaScript/Flow syntax elements, including JSX elements, class declarations, and type annotations, while managing parser environments and AST nodes with location tracking. It processes numeric literals, big integers, and optional parameters, enabling precise error reporting and syntactic analysis. Use cases include building linters, transpilers, or IDE tools for React projects and type-aware code transformations.",
      "description_length": 464,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Estree_translator.Translate",
      "description": "Provides functions to process and transform location data, including filtering by inclusion of coordinates. Operates on custom record types representing geographic points and bounding boxes. Used to generate simplified geometry for map rendering or spatial queries.",
      "description_length": 265,
      "index": 190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Enum_parser.Enum",
      "description": "This module provides parsing and construction operations for JavaScript/Flow syntax, including programs, statements, expressions, and class structures, while handling type annotations and numeric literals. It works with parser environments, AST nodes, and token types to generate structured representations with location metadata. Specific use cases include analyzing code syntax, converting literal values, and managing complex type annotations in static analysis workflows.",
      "description_length": 475,
      "index": 191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Token_translator.Translate",
      "description": "Converts various values\u2014strings, booleans, objects, arrays, numbers, integers, and null\u2014into a unified type for serialization. Constructs regular expression patterns with location metadata for parsing or validation tasks. Used to build structured data representations for JSON-like outputs or configuration formats.",
      "description_length": 315,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast_utils.ExpressionSort",
      "description": "Processes and displays abstract syntax tree nodes with customizable formatting. Operates on a type representing parsed expressions, supporting pretty-printing and string conversion. Used to generate human-readable output for debugging or logging during compiler transformations.",
      "description_length": 278,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Type_parser.Type",
      "description": "This module specializes in parsing and constructing abstract syntax trees (ASTs) for JavaScript/Flow code, handling elements like programs, statements, expressions, classes, and JSX. It manipulates parser environments, AST nodes, and token types to represent syntax and type annotations accurately. Key use cases include building code analysis tools, transpilers, or linters that require precise handling of complex syntax and type information.",
      "description_length": 444,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Expression_parser.Expression",
      "description": "Handles conversion of parsed patterns into AST expressions and patterns, managing error accumulation and reversal. Operates on location-annotated AST nodes and error lists, supporting error tracking during parsing. Used to construct and validate flow control structures in code analysis pipelines.",
      "description_length": 297,
      "index": 195,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pattern_parser.Pattern",
      "description": "This module specializes in parsing and manipulating Abstract Syntax Tree (AST) nodes for JavaScript/Flow programs, handling constructs like expressions, statements, class declarations, and JSX elements while incorporating type annotations and decorators. It operates on AST types, token data, and parser environments, enabling tasks such as syntax validation, code transformation, and error handling during language processing. Specific use cases include analyzing numeric literals, managing complex expression patterns, and constructing accurate location-aware ASTs for code analysis tools.",
      "description_length": 591,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "flow_parser",
      "description": "Provides functions to parse and analyze JavaScript code structures, including abstract syntax trees and type annotations. Works with node-based representations of code and type information. Enables validation of type annotations and detection of type inconsistencies in JavaScript files.",
      "description_length": 287,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsdoc",
      "description": "Handles structured data representation and comparison across multiple domains, including paths, metadata, configuration parameters, and tag-value pairs. Provides pretty-printing, string conversion, and equality checks for nested types like lists of (path * info) pairs, string-param lists, and optional tag-value records. Enables serialization, validation, and comparison of configuration settings, parser metadata, and XML/HTML tag structures. Can be used to generate human-readable outputs, check parameter consistency, or track differences in parsed document elements.",
      "description_length": 571,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Enum_common",
      "description": "Provides comparison and string conversion for a type representing explicit type annotations. Operates on a custom type that encodes type information in a structured format. Used to generate consistent string representations and enforce ordering during code generation processes.",
      "description_length": 278,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Object_parser",
      "description": "Parses and analyzes expressions for assignments, conditions, and sequences, handling numeric and big integer literals. Processes AST expressions, location data, and pattern covers to validate and construct syntactic elements. Supports variable assignments, conditional evaluation, and type argument parsing in function calls. Examples include parsing a variable assignment like \"x = 42\" or evaluating a conditional expression with big integers.",
      "description_length": 444,
      "index": 200,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Pattern_cover",
      "description": "handles JavaScript/Flow AST construction and parsing, managing expressions, statements, class declarations, and JSX with precise location tracking and token handling. It supports type annotations, numeric literals, and syntactic validation through AST node manipulation. Operations include node creation, traversal, and modification for code analysis or transformation tasks. Examples include extracting type information from function parameters or rewriting class structures for static analysis.",
      "description_length": 496,
      "index": 201,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "File_key",
      "description": "Provides operations to format, compare, and manipulate file path representations, including checking suffixes, modifying extensions, and converting to strings or paths. Works with a custom type `t` representing file keys, supporting transformations and predicate checks. Used to validate file types, generate normalized paths, and perform string-based file operations.",
      "description_length": 368,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Statement_parser",
      "description": "Processes object property keys, class declarations, and expressions while maintaining context through environment state. Tracks location, type, and initializer information, supporting error handling during pattern matching. Enables precise extraction and analysis of structured code elements. Can parse and validate class implementations, including decorators and expressions.",
      "description_length": 376,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parser_common",
      "description": "Converts pattern covers into AST expressions and patterns using a parser environment, handling error accumulation and reversal. Operates on location-annotated AST nodes and error lists represented as linked lists. Used to construct and validate syntax trees during parsing, ensuring accurate error tracking and recovery.",
      "description_length": 320,
      "index": 204,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Js_id_unicode",
      "description": "Provides functions to check if a Unicode code point is a valid start or continuation character for an identifier. Operates on arrays of integer pairs representing Unicode code point ranges. Used to validate characters in JavaScript-like identifier naming conventions.",
      "description_length": 267,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Token",
      "description": "Compares tokens and related types for equality, including boolean, number, and bigint representations. Converts tokens to strings, extracts their values, and formats quoted versions of those values. Provides detailed explanations of tokens, optionally including articles.",
      "description_length": 271,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Translator_intf",
      "description": "Constructs values of type `t` from primitive types like strings, booleans, and numbers, as well as structured data such as objects and arrays. Generates regular expression patterns with location metadata for parsing or validation. Used to serialize configuration data or generate structured output for external systems.",
      "description_length": 319,
      "index": 207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lex_result",
      "description": "Returns the parsed token, location, associated comments, and any parsing errors encountered during lexing. Operates on a structured record containing a token, location, comments, and error list. Used to inspect the outcome of a lexical analysis step, including error diagnostics and comment tracking.",
      "description_length": 300,
      "index": 208,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Parse_error",
      "description": "Formats errors from a domain-specific type `t` into human-readable strings, enabling clear error communication during parsing or validation. Supports operations that map internal error states to descriptive messages. For example, it can transform a failed parse result into a message like \"unexpected token at line 10\". This allows developers to quickly diagnose issues in input data or processing pipelines.",
      "description_length": 408,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Declaration_parser",
      "description": "Parses and constructs AST nodes for JavaScript/Flow code, including programs, expressions, classes, and type annotations, while tracking locations and handling errors. It processes tokens and environments to build structured representations of code, supporting JSX, numeric literals, and optional parameters. Operations include analyzing code structures, validating type annotations, and transforming syntactic elements. Examples include extracting class definitions, inspecting type constraints, and generating intermediate representations for further processing.",
      "description_length": 564,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parser_flow",
      "description": "Handles parsing of JavaScript-like syntax, constructing abstract syntax trees with location tracking, and managing environments and tokens. Supports expressions, class structures, type annotations, and numeric literals, with error reporting and optional parameter handling. Enables structured code representation for analysis or transformation tasks. Examples include parsing type annotations for static analysis or extracting class definitions for code generation.",
      "description_length": 465,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lex_env",
      "description": "The module provides a foundational structure for managing lexical environments, offering basic constructs for symbol lookup and scope handling. It includes a `t` type representing environment states and operations like `lookup` and `add` for manipulating bindings. While minimal, it supports the creation of nested scopes and tracking of variable definitions. This setup enables simple implementations of name resolution in interpreters or compilers.",
      "description_length": 450,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "RelativeLoc",
      "description": "Converts between a custom location type and OCaml's built-in `Loc.t`, preserving file context when needed. Accepts a `Loc.t` to create an opaque representation and reconstructs a `Loc.t` with optional file key information. Used to track source positions across different file contexts in a compiler or linter.",
      "description_length": 309,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parser_env",
      "description": "manages parsing environments with set-based state tracking, lexical analysis, and error handling, enabling precise control over token processing, error reporting, and environment transitions. it includes immutable string sets for tracking unique elements, lex mode debugging, indexed access to parsing artifacts, and robust error validation. operations like set unions, token indexing, and error recovery support tasks such as syntax validation, comment extraction, and safe parser chaining. examples include tracking unique identifiers, generating debug logs for lexical states, and extracting comments during token processing.",
      "description_length": 628,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Js_id",
      "description": "Checks if a given integer represents a valid Unicode identifier code point. Operates on integer values corresponding to Unicode code points. Used to validate characters in identifiers within JavaScript-like syntax parsing.",
      "description_length": 222,
      "index": 215,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast",
      "description": "Produces human-readable representations of structured data through custom pretty-printing and string conversion functions, handling recursive, nested, and polymorphic types. Main data types include metadata-value pairs, polymorphic variants, tuples, and recursive structures, with operations for formatting, serialization, and debug output. Examples include generating source code from syntax trees, formatting module references, and serializing complex key hierarchies. Supports distinct formatting rules for each component, enabling precise control over output structure and type-specific representation.",
      "description_length": 606,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Jsx_parser",
      "description": "Parses and constructs JavaScript/Flow syntax, including JSX, classes, and type annotations, with support for numeric literals, big integers, and optional parameters. Tracks AST nodes with location data to enable precise error reporting and analysis. Supports building linters, transpilers, and IDE tools for React and type-aware transformations. Examples include extracting component structures, validating type annotations, and generating abstract syntax trees with detailed source mapping.",
      "description_length": 491,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_lexer",
      "description": "Processes JSX elements, regular expressions, and template literals by advancing the lexer state and returning parsed results. Handles identifier validation and token recognition using a custom lexing environment. Parses type-specific tokens and JSX syntax within a structured lexical analysis context.",
      "description_length": 301,
      "index": 218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Loc",
      "description": "This module handles operations like comparing, formatting, and manipulating positions and locations, including range checks, line-based intersections, and file source tracking. It works with position data structures and file keys to support tasks such as code analysis, parsing, or text editing, enabling precise control over cursor positioning and range extraction. Specific use cases involve analyzing source code regions or managing file offsets in structured data processing.",
      "description_length": 479,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Estree_translator",
      "description": "Provides functions to translate ESTree ASTs into OCaml data structures, including location tracking via the `include_locs` flag. Operates on ESTree nodes and source maps to preserve positional information. Used to generate typed OCaml representations for static analysis and code transformation pipelines.",
      "description_length": 305,
      "index": 220,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Enum_parser",
      "description": "parses and constructs JavaScript/Flow syntax elements such as programs, expressions, and classes, incorporating type annotations and numeric literals into structured ASTs with location data. It supports operations on parser environments, token types, and AST nodes, enabling tasks like syntax analysis and static type inspection. Users can extract and transform literal values, navigate class structures, and process complex type annotations. Examples include converting numeric literals to their OCaml equivalents and analyzing type constraints within codebases.",
      "description_length": 563,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Token_translator",
      "description": "Translates diverse data types into a standardized format suitable for serialization and structured output. Supports pattern generation for regex-based parsing, incorporating location information for precision. Operations include value conversion, pattern construction, and data representation building. Examples include converting a boolean to a serialized form, generating a regex with source positions, or constructing a JSON-like object from mixed input.",
      "description_length": 457,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Flow_ast_utils",
      "description": "Provides tools for manipulating and visualizing parsed expressions through customizable formatting options. It defines a type for representing abstract syntax tree nodes and includes operations for pretty-printing and converting these nodes to strings. Users can generate structured output for debugging or logging during compiler passes. For example, it can transform a complex expression into a formatted string that highlights its hierarchical structure.",
      "description_length": 457,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Type_parser",
      "description": "Parses and constructs ASTs for JavaScript/Flow, representing programs, statements, expressions, classes, and JSX with accurate syntax and type annotations. It manages parser environments, AST nodes, and token types to enable precise manipulation of code structures. Users can build analysis tools, transpilers, or linters that process complex syntax and type information. Examples include extracting type definitions, transforming AST nodes, or validating syntax correctness.",
      "description_length": 475,
      "index": 224,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Expression_parser",
      "description": "Converts parsed patterns into annotated AST expressions and patterns, tracking errors and enabling reversible operations. Processes location-annotated nodes and error lists to validate and construct flow control structures. Supports error accumulation and reversal during parsing, allowing precise error handling. Can generate valid ASTs from input patterns while maintaining location information and error state.",
      "description_length": 413,
      "index": 225,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Comment_attachment",
      "description": "Tracks leading and trailing comments associated with specific AST nodes. Operates on tuples containing a node identifier and a Flow_ast.Comment.t value. Used to annotate syntax elements with surrounding comments for precise source mapping or code analysis.",
      "description_length": 256,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Pattern_parser",
      "description": "Parses and manipulates AST nodes for JavaScript/Flow, supporting expressions, statements, classes, and JSX with type annotations and decorators. It processes AST types, tokens, and environments to enable syntax validation, code transformation, and error handling. Operations include analyzing numeric literals, managing expression patterns, and building location-aware ASTs. Examples include transforming function expressions, extracting type information, and validating JSX structure.",
      "description_length": 485,
      "index": 227,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Parse_error_utils",
      "description": "Converts a snake_case string to camelCase by capitalizing each word after the first and removing underscores. Operates on strings and is used to standardize error message formatting in parsed input. Enhances readability of error outputs by transforming identifiers into a more conventional style.",
      "description_length": 296,
      "index": 228,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Offset_utils",
      "description": "Provides functions to create and manipulate offset data, compute positions, and analyze text structure. Works with text positions, line lengths, and offset kinds to track character offsets. Used to determine byte offsets for specific positions in a string and detect multibyte characters.",
      "description_length": 288,
      "index": 229,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 238,
    "meaningful_modules": 230,
    "filtered_empty_modules": 8,
    "retention_rate": 0.9663865546218487
  },
  "statistics": {
    "max_description_length": 663,
    "min_description_length": 208,
    "avg_description_length": 363.0826086956522,
    "embedding_file_size_mb": 0.835993766784668
  }
}