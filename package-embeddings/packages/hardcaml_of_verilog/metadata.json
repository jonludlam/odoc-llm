{
  "package": "hardcaml_of_verilog",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 66,
  "creation_timestamp": "2025-07-15T23:17:38.220549",
  "modules": [
    {
      "module_path": "Hardcaml_port_verilog.Make",
      "library": "hardcaml_of_verilog.port",
      "description": "Implements a command-line tool for converting digital circuit designs written in Hardcaml to Verilog code. It takes a Hardcaml circuit description as input and generates synthesizable Verilog output, enabling hardware description in OCaml to be used in standard FPGA or ASIC toolchains. Useful for hardware engineers generating Verilog from OCaml-based simulation or synthesis tools.",
      "description_length": 383,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_port_verilog",
      "library": "hardcaml_of_verilog.port",
      "description": "This module converts Hardcaml circuit descriptions into synthesizable Verilog code, enabling seamless integration with FPGA and ASIC toolchains. It operates on digital circuit data structures defined in Hardcaml, transforming them into Verilog modules through a structured translation process. Engineers can use it to generate hardware implementations directly from OCaml-based design and simulation workflows. For example, a register file or ALU described in Hardcaml can be translated into Verilog for deployment on an FPGA.",
      "description_length": 526,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.O.Names_and_widths",
      "library": "hardcaml_of_verilog",
      "description": "Handles extraction and manipulation of port names and widths from Verilog modules. Works with lists of strings and integers to represent port names and their bit widths. Used to dynamically construct OCaml module interfaces with correct signal widths based on Verilog instantiation parameters.",
      "description_length": 293,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.I.Names_and_widths",
      "library": "hardcaml_of_verilog",
      "description": "Maps Verilog port names to their widths, providing access to lists of port names, widths, and associated tags. Works with tuples of strings and integers to represent port metadata. Used to dynamically construct OCaml module interfaces with correct signal widths for HardCaml simulations.",
      "description_length": 287,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.I.All",
      "library": "hardcaml_of_verilog",
      "description": "This module provides a function `all` that transforms a monadic interface into an interface of monadic values, effectively lifting the monad out of the interface structure. It operates on interfaces where each field is wrapped in a monad `M`, restructuring them into a monad containing a fully constructed interface. A concrete use case is aggregating multiple asynchronous signal generators into a single asynchronous interface, ensuring each signal is properly initialized before the interface is used.",
      "description_length": 504,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.I.Of_bits",
      "library": "hardcaml_of_verilog",
      "description": "This module provides operations to construct, validate, and manipulate hardware interfaces represented as bit vectors. It supports concrete tasks like packing and unpacking interfaces to and from bit vectors, multiplexing between interface values, concatenating interfaces, and selecting between one-hot or priority-encoded inputs. Functions like `of_int`, `assert_widths`, and `validate` enable creating constant interfaces and ensuring correct signal widths during simulation or synthesis flows.",
      "description_length": 497,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.O.Of_signal",
      "library": "hardcaml_of_verilog",
      "description": "This module provides operations for constructing and manipulating hardware signal interfaces, including structural transformations like concatenation, multiplexing, and register creation, alongside input/output handling with name customization. It operates on `O.Of_signal.t` and `Hardcaml.Signal.t` types, emphasizing dynamic width validation and safe signal connection. Specific use cases include dynamically adjusting interface configurations at runtime, automating signal naming conventions for hierarchical modules, and building parameterized hardware pipelines with validated bit-widths.",
      "description_length": 593,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.I.Of_signal",
      "library": "hardcaml_of_verilog",
      "description": "This module provides operations for constructing and transforming hardware interfaces using signal vectors, supporting tasks like constant assignment, signal composition, multiplexing, and register control. It works with signal interfaces (`I.Of_signal.t` and `I.Of_signal.comb I.t`) to enable structural manipulations, naming conventions, and runtime validation of interface widths. These capabilities are used to build dynamically configurable hardware descriptions that align with Verilog instantiations, ensuring correctness through explicit width checks and signal connectivity.",
      "description_length": 583,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Netname.V",
      "library": "hardcaml_of_verilog",
      "description": "Maps net names to their bit representations in a Yosys netlist. Provides functions to create, update, and query bit vectors associated with net identifiers. Used to track signal connections and bit widths during hardware compilation from Verilog to Hardcaml.",
      "description_length": 258,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_of_verilog",
      "description": "This module provides direct conversions between interface values and association lists indexed by field names. It operates on OCaml module interfaces (`O.t`) and string-keyed lists of values. Use it to dynamically construct interfaces from named field data or extract interface fields into a list for runtime processing.",
      "description_length": 320,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.O.Of_bits",
      "library": "hardcaml_of_verilog",
      "description": "This module provides functions to construct, manipulate, and validate bit-level hardware interfaces. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection logic (priority, one-hot). Concrete use cases include building configurable hardware blocks where interface signal widths are dynamically determined at instantiation.",
      "description_length": 388,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.I.Of_always",
      "library": "hardcaml_of_verilog",
      "description": "This module provides functions to construct and manipulate interface-bound signals within Hardcaml's `Always` blocks. It supports operations like assigning signals, creating registers and wires, and naming interface fields, all while preserving interface structure and parameterized widths. Concrete use cases include building synchronous logic with named interface fields and dynamically wiring interfaces with default signal values.",
      "description_length": 434,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Connection.V",
      "library": "hardcaml_of_verilog",
      "description": "Handles conversion between JSON and S-expression representations of bit-level connections in a Verilog netlist. Works with lists of bit identifiers to represent signal connections during hardware description translation. Used to interface between raw JSON parsing and structured netlist processing in Verilog-to-Hardcaml workflows.",
      "description_length": 331,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.O.All",
      "library": "hardcaml_of_verilog",
      "description": "This module provides a function `all` that transforms a Hardcaml interface containing monadic values into a monadic interface, effectively lifting the monad outside the interface structure. It operates on data types involving interfaces (`O.t`) and a monad `M`, restructuring how values are combined across these types. A concrete use case is aggregating multiple signal generators within a circuit description, where each signal is wrapped in a monadic context such as error handling or state tracking.",
      "description_length": 503,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Parameter.V",
      "library": "hardcaml_of_verilog",
      "description": "Handles conversion between JSON and S-expression representations for integer-or-string values in a Yosys netlist. Works directly with `Int_or_string.t` to support parameter values that may be either numeric or symbolic. Used during netlist parsing and serialization to ensure consistent handling of mixed-type parameters.",
      "description_length": 321,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.O.Make_comb",
      "library": "hardcaml_of_verilog",
      "description": "This module provides functions to manipulate and validate structured combinatorial interfaces, such as packing/unpacking to vectors, multiplexing, concatenation, and selection operations. It works with types representing combinatorial signals and their structured interfaces, ensuring correct bit-width handling. Concrete use cases include building and verifying complex signal routing logic, dynamically constructing test fixtures, and implementing configurable multiplexers or priority encoders.",
      "description_length": 497,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.O.Comb",
      "library": "hardcaml_of_verilog",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of bit vectors. It supports constant assignment, packing/unpacking, multiplexing, concatenation, and selection operations on interfaces with defined field widths. These functions enable building complex digital circuits by combining and transforming signal interfaces based on fixed-width bit representations.",
      "description_length": 404,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_of_verilog",
      "description": "Maps between interface fields and values using field names as keys. Works with Hardcaml interfaces and association lists of strings paired with values. Used to dynamically construct or extract interface components by name during module generation.",
      "description_length": 247,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Port.V",
      "library": "hardcaml_of_verilog",
      "description": "Handles parsing and serialization of port definitions in a Verilog netlist, specifically managing direction and bit-level connections. Works with JSON and S-expression formats for data interchange. Used to convert between raw JSON representations and structured port data during netlist processing.",
      "description_length": 298,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.I.Comb",
      "library": "hardcaml_of_verilog",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of integer-width fields. It supports constant initialization, packing/unpacking to bit vectors, multiplexing, concatenation, and selection operations with support for validity signals. These functions are used to build and verify hardware components with dynamic port widths, such as register files or control units.",
      "description_length": 411,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Module.V",
      "library": "hardcaml_of_verilog",
      "description": "This module directly maps the Verilog netlist module structure to OCaml, representing ports, cells, and netnames as lists of their respective types. It provides serialization and deserialization to and from JSON and S-expressions, enabling direct manipulation and inspection of raw netlist data. Use this module when working with low-level netlist representations, such as during debugging or transformation of Verilog modules into other formats.",
      "description_length": 446,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.O.Of_always",
      "library": "hardcaml_of_verilog",
      "description": "This module provides functions to construct and manipulate interface containers using the Always API in Hardcaml. It supports operations like assigning signals to variables, creating registers and wires with customizable initial values, and applying naming conventions to interface fields. These functions are used when defining hardware descriptions that require structured signal handling within always blocks.",
      "description_length": 412,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.I.Make_comb",
      "library": "hardcaml_of_verilog",
      "description": "This module provides functions to manipulate and validate fixed-width hardware interfaces, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection operations. It works with a combinator-based signal type and structured interface descriptions, ensuring correct port widths during validation. Concrete use cases include building and verifying hardware components like register files, control units, and data path elements with precise bit-level control.",
      "description_length": 487,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Cell.V",
      "library": "hardcaml_of_verilog",
      "description": "This module directly maps Verilog cell data from a Yosys JSON netlist into OCaml types, preserving low-level details like port directions, parameter values, and signal connections. It operates on raw JSON structures, converting them to and from a typed record representation that includes module names, connection lists, and integer flags such as `hide_name`. It is used to inspect or transform Verilog cell instances during netlist parsing, particularly when interfacing with synthesis tools like Yosys.",
      "description_length": 504,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Port_direction.V",
      "library": "hardcaml_of_verilog",
      "description": "Handles conversion between JSON and S-expression representations of port direction types in a Yosys netlist. Works directly with JSONAF and Sexp types to enable serialization and deserialization of direction data. Useful when parsing or generating netlist files that specify signal directions like input, output, or inout.",
      "description_length": 322,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.O",
      "library": "hardcaml_of_verilog",
      "description": "This module transforms and composes hardware interface descriptions with operations like mapping, zipping, and width-aware conversions, supporting combinational logic and bit-level signal manipulation. It works on structured interface data representing hardware ports with metadata, interacting with Verilog AST structures to reconstruct OCaml interfaces, adjust signal widths during instantiation, and build error-checked interface hierarchies. Child modules handle port extraction, signal interface construction, interface-to-alist conversions, bit-vector manipulations, monadic interface lifting, combinatorial interface validation, field-based interface transformations, and integration with Hardcaml's Always API. Examples include dynamically generating parameterized pipelines, validating signal widths across hierarchical modules, converting interfaces to bit vectors for synthesis, and lifting monadic signal generators into structured interfaces.",
      "description_length": 955,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Netname",
      "library": "hardcaml_of_verilog",
      "description": "This module represents signal identifiers and their bit-level values in a Yosys JSON netlist, enabling structured manipulation of net names and associated data during hardware compilation. It provides core operations to map, update, and query bit vectors linked to net identifiers, supporting tasks like signal connection tracking and bit-width analysis. With its submodules, it offers utilities to process and transform netlist signals, such as extracting bit ranges or merging multi-bit signals. Example uses include converting Verilog signals to Hardcaml representations and analyzing signal dependencies in synthesized circuits.",
      "description_length": 632,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Connection",
      "library": "hardcaml_of_verilog",
      "description": "This module manages connections between signals in a netlist by mapping signal names to values represented as strings or `V.t` types. It supports constructing and manipulating signal assignments during netlist processing, with operations for setting, retrieving, and transforming signal values. The child module facilitates conversion between JSON and S-expression representations of bit-level connections, using bit identifier lists to model signal relationships in Verilog-to-Hardcaml translation. Together, they enable structured processing of hardware descriptions by bridging raw data formats with typed signal manipulations.",
      "description_length": 630,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces.I",
      "library": "hardcaml_of_verilog",
      "description": "This module provides combinators for transforming and inspecting parameterized hardware interfaces, enabling operations like mapping, zipping, and conversion to structured formats such as bit vectors and lists. It supports manipulation of interfaces with named, width-annotated fields, allowing dynamic restructuring based on hardware parameters and direct translation of Verilog constructs into OCaml. Child modules enhance this functionality by enabling monadic interface lifting, bit vector manipulation, signal vector construction, and runtime validation of interface widths. Specific capabilities include packing/unpacking interfaces, multiplexing signals, dynamically wiring components, and constructing register blocks with named fields and precise bit-level control.",
      "description_length": 774,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Module",
      "library": "hardcaml_of_verilog",
      "description": "This module represents a Verilog module parsed into a raw JSON netlist format, using string identifiers to access structured data through its core functions and the `V` submodule. It provides operations to inspect and manipulate low-level components such as ports, cells, and netnames, which are represented as lists of their respective types. The module supports serialization and deserialization to JSON and S-expressions, enabling direct data transformation and debugging. Use it to translate, analyze, or convert Verilog netlists into alternative formats while maintaining access to detailed structural information.",
      "description_length": 619,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Assoc_list",
      "library": "hardcaml_of_verilog",
      "description": "Represents a list of named value pairs with efficient lookup and manipulation functions. Works with string keys and arbitrary values, supporting operations like adding, finding, and removing entries. Useful for mapping signal names to their corresponding values in a netlist during hardware description translation.",
      "description_length": 315,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Int_or_string",
      "library": "hardcaml_of_verilog",
      "description": "This module defines a variant type that represents either an integer or a string, primarily used for parsing and serializing JSON values in the context of a Verilog netlist. It includes functions to convert between this type and JSON or S-expressions, enabling straightforward integration with JSON-based netlist data. It serves as a low-level building block for handling attributes or identifiers that may be either numeric or string-based in the raw netlist representation.",
      "description_length": 475,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Parameter",
      "library": "hardcaml_of_verilog",
      "description": "This module manages parameter definitions in a Yosys netlist, offering direct access to parameter names and their evaluated values, which can be strings or values of the `V` module's types. It resolves constant and configuration parameters during netlist processing, ensuring accurate value extraction and type handling. The nested `V` module supports values that are either integers or strings, while conversion functions facilitate parsing and serializing these values between JSON and S-expressions. For example, it can extract a parameter's evaluated integer value or serialize a symbolic parameter to JSON for consistent netlist representation.",
      "description_length": 649,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Cell",
      "library": "hardcaml_of_verilog",
      "description": "This module represents individual cells within a Yosys netlist, storing each cell's name and associated value data. It works with string identifiers and structured cell values defined in the `V` submodule, which directly maps Verilog cell data from a Yosys JSON netlist into OCaml types, preserving low-level details like port directions, parameter values, and signal connections. The module supports operations such as extracting connection lists, modifying integer flags like `hide_name`, and converting between raw JSON structures and typed records. These capabilities enable inspection and transformation of Verilog cell instances during netlist parsing and synthesis tool integration.",
      "description_length": 689,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Direction",
      "library": "hardcaml_of_verilog",
      "description": "This module defines a polymorphic variant type with two constructors, `Input` and `Output`, representing signal directions in a hardware netlist. It includes functions for equality checking, JSON serialization and deserialization, and S-expression conversion. This type is used to distinguish between input and output ports when processing or analyzing netlist data structures derived from Yosys JSON output.",
      "description_length": 408,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Port",
      "library": "hardcaml_of_verilog",
      "description": "This module manages port definitions in a Yosys netlist, offering direct access to port names and their associated values through operations that map and manipulate port data during netlist parsing and transformation. It integrates string-based identifiers with the `V` module's value type to represent and modify port states. The child module specializes in parsing and serializing port definitions in Verilog netlists, handling direction and bit-level connections while supporting conversion between raw JSON and structured port data. Together, they enable tasks like extracting port metadata, transforming signal widths, and serializing port configurations to JSON or S-expressions for interchange.",
      "description_length": 701,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Port_direction",
      "library": "hardcaml_of_verilog",
      "description": "This module represents port directions in a Yosys netlist, supporting values such as input, output, and inout. It provides direct conversion to S-expressions for serialization and integrates with JSONAF for parsing and generating direction data in netlist files. The main operations include converting direction values to and from both S-expression and JSON formats. For example, it can parse a JSON input specifying `\"direction\": \"input\"` into an internal representation or serialize an output direction to an S-expression for further processing.",
      "description_length": 547,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist.Bit",
      "library": "hardcaml_of_verilog",
      "description": "This module represents individual bits in a Verilog netlist, with variants for constant values (Vdd, Gnd, X) and indexed signals. It provides comparison, JSON serialization/deserialization, and S-expression conversion for these bit values. Used to model and manipulate low-level signal representations during netlist parsing and transformation.",
      "description_length": 344,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Verilog_design.Defines",
      "library": "hardcaml_of_verilog",
      "description": "Handles parsing and serialization of Verilog `define directives. Works with lists of `Define.t` values, converting between S-expressions and in-memory representations. Useful for processing Verilog preprocessor definitions during synthesis or translation workflows.",
      "description_length": 265,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Netlist.Bus",
      "library": "hardcaml_of_verilog",
      "description": "This module represents buses in a Verilog netlist as lists of bits and provides comparison and serialization functions. It works with bus types composed of bit-level signals, enabling ordered comparisons and S-expression serialization. Concrete use cases include tracking and comparing signal buses during netlist analysis and transformation tasks.",
      "description_length": 348,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Verilog_design.Define",
      "library": "hardcaml_of_verilog",
      "description": "This module represents Verilog `define directives with operations to create, compare, and access named definitions and their values. It works with strings for names and a `Define_value` type for associated values, supporting parsing and serialization via S-expressions. Concrete use cases include managing preprocessor macros during Verilog-to-Hardcaml translation and enabling configuration-specific code generation.",
      "description_length": 417,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Verilog_design.Parameter",
      "library": "hardcaml_of_verilog",
      "description": "This module represents and manipulates Verilog parameters in Hardcaml designs. It provides functions to create parameters with names and values, access their components, and compare or serialize them. Use cases include defining configurable constants in hardware descriptions and exporting parameter values to strings or s-expressions for debugging or configuration purposes.",
      "description_length": 375,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Verilog_design.Parameters",
      "library": "hardcaml_of_verilog",
      "description": "This module manages a list of Verilog parameter definitions, supporting operations to serialize and deserialize them using S-expressions. It provides a function to replace parameters in one list with those from another, maintaining the order and structure. This is used when modifying or injecting parameter values during Verilog design processing.",
      "description_length": 348,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Netlist.Bus_names",
      "library": "hardcaml_of_verilog",
      "description": "Maps bus identifiers to their corresponding net names in a Verilog netlist. Provides functions to create and query bus name associations for netlist signals. Used to resolve signal names during netlist analysis or debugging tasks.",
      "description_length": 230,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Netlist.Parameter",
      "library": "hardcaml_of_verilog",
      "description": "Handles parameter definitions and evaluations within a Verilog netlist, providing functions to convert parameter values to S-expressions for serialization. Works directly with `Hardcaml.Parameter.t` types, extracting and representing their values in a format suitable for analysis or debugging. Useful for inspecting or exporting parameter configurations during netlist processing.",
      "description_length": 381,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.With_interface.Make",
      "library": "hardcaml_of_verilog",
      "description": "Converts a Verilog design into a Hardcaml circuit while preserving the input and output interfaces specified by the `I` and `O` modules. It provides the `create` function that takes a Verilog design and returns a function mapping input signals to output signals, enabling direct integration of Verilog components into Hardcaml workflows. This is useful when building FPGA or ASIC designs that combine Verilog IP blocks with Hardcaml-generated logic, such as wrapping a Verilog-based peripheral with Hardcaml control logic.",
      "description_length": 522,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Verilog_design.Define_value",
      "library": "hardcaml_of_verilog",
      "description": "Represents values used in Verilog `define directives, supporting string, integer, and no-argument forms. Converts values to and from S-expressions for serialization and comparison. Used to process and manipulate preprocessor definitions during Verilog parsing and transformation.",
      "description_length": 279,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Synthesize",
      "library": "hardcaml_of_verilog",
      "description": "This module synthesizes Verilog designs into JSON or Yosys netlist formats using specified optimization passes. It operates on Verilog design structures and generates output files or in-memory netlists suitable for further processing or simulation. Concrete use cases include converting Verilog RTL into a standardized netlist format for simulation or generating JSON representations for external tool integration.",
      "description_length": 414,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Verilog_design.Crunched",
      "library": "hardcaml_of_verilog",
      "description": "Reads a Verilog file and returns its contents as a string, or `None` if the file cannot be read. Works directly with file paths and raw string data. Useful for loading preprocessed Verilog source code into memory for further parsing or analysis.",
      "description_length": 245,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Netlist.Port",
      "library": "hardcaml_of_verilog",
      "description": "This module represents ports in a Verilog netlist, providing access to port names and associated values. It includes functions to retrieve port data, look up ports by name in a list, and convert port data to S-expressions. It is used to manipulate and inspect input/output ports during synthesis and conversion of Verilog designs to Hardcaml.",
      "description_length": 342,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert.Yosys_netlist",
      "library": "hardcaml_of_verilog",
      "description": "This module parses and manipulates raw Yosys JSON netlists, converting them into structured OCaml types for tasks like importing synthesis results into Hardcaml or analyzing circuit structure. It provides core data types for modules, ports, cells, signals, and parameters, with operations to inspect, modify, and serialize these components. Submodules handle bit-level signal representations, directional ports, parameter values, and cell connections, supporting transformations such as signal mapping, width analysis, and Verilog-to-Hardcaml translation. Examples include extracting port metadata, resolving parameter values, converting net identifiers to typed signals, and serializing modified netlists to JSON or S-expressions.",
      "description_length": 731,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Verilog_design.Embedded_files",
      "library": "hardcaml_of_verilog",
      "description": "Stores Verilog file contents as a list of filename-content pairs. Provides direct access to embedded Verilog source files through the `by_filename` value, which maps each file to its contents. Used to bundle and retrieve Verilog modules and testbenches within OCaml code for simulation or synthesis workflows.",
      "description_length": 309,
      "index": 51,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_of_verilog.Netlist.Module",
      "library": "hardcaml_of_verilog",
      "description": "This module represents a Verilog module in a synthesized netlist, containing inputs, outputs, cells, and bus names. It provides operations to access and manipulate module components, such as sanitizing instance names and converting module data to S-expressions. It is used to interface with HardCaml by converting Yosys-generated netlists into a structured format for further processing.",
      "description_length": 387,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Netlist.Bit",
      "library": "hardcaml_of_verilog",
      "description": "Represents individual bits in a Verilog netlist with values for power, ground, undefined, and indexed signals. Supports comparison, JSON, and S-expression serialization for persistence and debugging. Used to model and manipulate low-level digital signal states during netlist conversion and analysis.",
      "description_length": 300,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module.Rebuild_interfaces",
      "library": "hardcaml_of_verilog",
      "description": "This module rebuilds OCaml interfaces from Verilog designs, adjusting signal widths based on instantiation parameters and integrating with Hardcaml circuits through dynamic module construction. It provides structured interface data types with named, width-annotated fields and supports operations like mapping, zipping, bit-vector conversion, and monadic lifting for combinational logic and signal manipulation. Child modules enable port extraction, interface validation, field transformations, and integration with Hardcaml's Always API, allowing tasks like generating parameterized pipelines, validating hierarchical signal widths, and constructing register blocks. Examples include dynamically wiring components, packing interfaces for synthesis, and lifting signal generators into structured formats with bit-level precision.",
      "description_length": 829,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Verilog_design.Module",
      "library": "hardcaml_of_verilog",
      "description": "This module represents Verilog modules with structured metadata, including their hierarchy, parameters, and instantiation relationships. It supports creating, modifying, and traversing module structures, with operations to override properties like module name, path, and parameters. Concrete use cases include building and transforming Verilog design hierarchies for simulation or synthesis workflows.",
      "description_length": 401,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Netlist.Cell",
      "library": "hardcaml_of_verilog",
      "description": "This module represents individual cells within a synthesized Verilog netlist, capturing their module and instance names, parameters, and input/output ports. It works with data types like strings, lists, and structured port and parameter types to model cell connectivity and configuration. Concrete use cases include inspecting and transforming specific cell instances during netlist analysis or optimization tasks.",
      "description_length": 414,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Verilog_design",
      "library": "hardcaml_of_verilog",
      "description": "This module represents a Verilog design with support for parameters, preprocessor defines, and hierarchical modules. It provides operations to construct and manipulate designs, override top-level parameters, and map file paths for integration with external tools. Concrete use cases include reading and transforming Verilog code with parameterized modules, handling preprocessor directives, and interfacing with embedded or compiled Verilog sources. The module works with top-level data types like `module`, `parameter`, and `define`, and supports operations to modify, serialize, and traverse design elements. Submodules handle specific tasks such as parsing and serialization of `define directives, managing parameter lists, and storing embedded Verilog source files for simulation or synthesis workflows.",
      "description_length": 807,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Expert",
      "library": "hardcaml_of_verilog",
      "description": "This module provides tools for converting and manipulating Verilog designs through synthesis and netlist processing. It supports parsing Verilog into structured representations, applying optimizations, and emitting results in JSON or Yosys netlist formats, while also enabling detailed inspection and transformation of netlist elements such as ports, signals, and cells. Key operations include synthesis pass application, signal mapping, parameter resolution, and format conversion, allowing tasks like preparing RTL for simulation, integrating with external tools via JSON, or translating netlists into Hardcaml-compatible structures. Examples include converting a Verilog module into a typed signal representation, modifying cell connections in a synthesized netlist, or exporting a design to JSON for downstream analysis.",
      "description_length": 824,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_of_verilog.Verilog_circuit",
      "library": "hardcaml_of_verilog",
      "description": "Represents a Verilog design converted into a Hardcaml netlist, providing access to input and output ports as typed signals. It supports constructing a Hardcaml circuit from a netlist and generating a simulation function for the circuit. Used to integrate Verilog designs into Hardcaml simulations and toolchains.",
      "description_length": 312,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_of_verilog.Netlist",
      "library": "hardcaml_of_verilog",
      "description": "This module synthesizes Verilog designs into a structured netlist representation using Yosys, supporting lazy conversion of modules upon reference. It operates on core types like `t`, `Module.t`, and signal-level structures, enabling selective synthesis, error handling, and inspection of digital designs. Functionality spans low-level bit modeling, bus manipulation, parameter evaluation, port access, and cell representation, with support for serialization and name resolution. Specific use cases include converting Verilog to Hardcaml, analyzing signal paths, extracting module interfaces, and transforming cell instances during netlist optimization.",
      "description_length": 653,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.With_interface",
      "library": "hardcaml_of_verilog",
      "description": "This module bridges Verilog designs with Hardcaml by converting a Verilog circuit into a Hardcaml component that maintains the original input and output interfaces. It centers around the `create` function, which transforms a Verilog design into a function mapping input signals (`I`) to output signals (`O`), enabling seamless integration of Verilog IP into Hardcaml circuits. Main data types include `I` and `O`, representing input and output interfaces, and the resulting function type `Signal.t list -> Signal.t list`. Example usage includes wrapping a Verilog UART peripheral with Hardcaml control logic to build a complete communication subsystem.",
      "description_length": 652,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Pass",
      "library": "hardcaml_of_verilog",
      "description": "This module defines transformations applied during Verilog-to-Hardcaml conversion. It includes operations for procedural block processing, flattening, memory handling with optional mapping, optimization with mux-undef control, and cleanup. These passes configure translation behavior, enabling precise control over circuit elaboration and optimization for simulation or synthesis targets.",
      "description_length": 388,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Circuit_to_json",
      "library": "hardcaml_of_verilog",
      "description": "Converts a Hardcaml circuit into a Yosys netlist format, enabling visualization via netlistsvg. Works directly with `Hardcaml.Circuit.t` and produces a structured representation consumable by external rendering tools. Useful for generating visual diagrams of digital circuits from OCaml-based hardware designs.",
      "description_length": 310,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog.Ocaml_module",
      "library": "hardcaml_of_verilog",
      "description": "This module constructs OCaml modules from Verilog designs, dynamically adjusting interface widths based on instantiation parameters and integrating with Hardcaml circuits through runtime-loaded implementations. It provides structured interface types with named, width-annotated fields, supporting operations like mapping, zipping, bit-vector conversion, and monadic lifting for signal manipulation. Child modules enable port extraction, interface validation, field transformations, and integration with Hardcaml's Always API, allowing tasks like generating parameterized pipelines and constructing register blocks. Examples include dynamically wiring components, validating hierarchical signal widths, and lifting signal generators into structured formats with bit-level precision.",
      "description_length": 781,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_of_verilog",
      "library": "hardcaml_of_verilog",
      "description": "This module converts Verilog designs into Hardcaml circuits by synthesizing netlists, handling parameters, and mapping interfaces with typed signals. It supports parsing, transforming, and optimizing Verilog code through structured representations, enabling integration with simulation, synthesis, and visualization tools. Key data types include modules, parameters, signals, and interfaces (`I`, `O`), with operations for synthesis, signal mapping, and netlist inspection. Examples include wrapping a Verilog UART in Hardcaml logic, exporting circuits to JSON or Yosys netlist formats, and generating simulation functions from Verilog designs.",
      "description_length": 644,
      "index": 65,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 66,
    "meaningful_modules": 66,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 955,
    "min_description_length": 230,
    "avg_description_length": 468.1060606060606,
    "embedding_file_size_mb": 0.2401294708251953
  }
}