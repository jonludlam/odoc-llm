{
  "package": "lustre-v6",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 74,
  "creation_timestamp": "2025-08-18T18:35:39.373197",
  "modules": [
    {
      "module_path": "TopoSort.Make",
      "library": "lustre-v6",
      "description": "Implements topological sorting on directed acyclic graphs represented as elements and dependencies in a store structure. Provides cycle detection and ordering of elements such that all dependencies of an element appear before it. Useful for scheduling tasks with precedence constraints or resolving dependency chains in build systems.",
      "description_length": 334,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lic.TopoSortVarInfo",
      "library": "lustre-v6",
      "description": "This module implements topological sorting for variable information structures, specifically handling dependencies between `Lic.var_info` elements stored in a hash table. It provides cycle detection and sorting operations on lists of variable information, ensuring correct ordering based on dependencies. Use this when processing variable definitions with interdependencies, such as resolving variable declarations in a compiler or static analysis tool.",
      "description_length": 453,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc.SocMap",
      "library": "lustre-v6",
      "description": "This module provides key-value storage and manipulation operations for ordered maps with support for safe access patterns, value list aggregation, and set-like merging. It operates on maps with ordered keys and arbitrary value types, including list-valued maps, enabling functional transformations through iteration, filtering, and bidirectional conversion to sequences. Common use cases include generating structured code representations, maintaining sorted associative data, and processing bulk key-value operations with guaranteed ordering constraints.",
      "description_length": 555,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cHeap",
      "library": "lustre-v6",
      "description": "This module generates C code for heap-based operations, focusing on assignments, variable expressions, and step method prototypes. It works with `Soc.t` structures representing system-on-chip components and `Soc.var_expr` expressions for variables and values. Concrete uses include generating function calls for steps, variable assignments, and C typedefs for SoC components.",
      "description_length": 375,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lSplit",
      "library": "lustre-v6",
      "description": "Performs equation splitting on a node's expressions, breaking complex assignments into individual operator steps and handling tuple decompositions. It transforms each tuple assignment into multiple single-variable assignments, introducing temporary variables as needed. This module operates on program structures represented by `LicPrg.t`, modifying both the equations and the local environment during the transformation.",
      "description_length": 421,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AstPredef",
      "library": "lustre-v6",
      "description": "This module defines a comprehensive set of logical, arithmetic, and comparison operators used in an abstract syntax tree. It includes functions to convert operators to strings, check properties like infix status, and map between string representations and operator values. These operations support parsing, pretty-printing, and analysis of expressions involving predefined operators.",
      "description_length": 383,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SocVar",
      "library": "lustre-v6",
      "description": "This module transforms variable representations in structured data, expanding structs and arrays for external communication. It maps enums to integers and adjusts variable naming to match C-style access patterns, such as using \"S.f`3`\" for array elements inside structs. Key use cases include preparing data for C interfaces and post-processing substitutions in structured formats.",
      "description_length": 381,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lExpandMetaOp",
      "library": "lustre-v6",
      "description": "Performs expansion of meta operators like `red` and `map` in a program representation. It transforms high-level meta operations into lower-level constructs. Useful when compiling or interpreting programs that use meta-level abstractions directly.",
      "description_length": 246,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LicEvalClock",
      "library": "lustre-v6",
      "description": "Handles static evaluation of clock operators in clock expressions by applying substitutions and solving constraints. Works with clock identifiers, substitution environments, and predefined operators from the AST. Used to simplify and resolve clock expressions during type checking or constraint solving.",
      "description_length": 303,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6MainArgs",
      "library": "lustre-v6",
      "description": "This module defines data structures and functions for handling command-line arguments and global configuration options in a compiler or toolchain. It provides parsing of command-line arguments into a structured format, usage message generation, and management of global settings including modes for code generation, scheduling, and input/output handling. Concrete use cases include configuring compilation pipelines, controlling optimization behaviors, and managing input file processing with detailed options for code generation and analysis.",
      "description_length": 543,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cPredef",
      "library": "lustre-v6",
      "description": "This module generates C function calls from OCaml data structures and checks if a given function call is supported. It operates on `Soc.key` and `Soc.t` types, producing string representations of C function calls based on provided input and output parameters. It is used to bridge OCaml logic with C code generation, specifically for handling function call syntax and validation.",
      "description_length": 379,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SocPredef2cStack",
      "library": "lustre-v6",
      "description": "This module generates C code snippets for specific operations derived from a given `Soc` structure. It provides functions to retrieve predefined operations, iterators, conditional actions, and boolean reductions as C strings. Use this module when translating high-level Soc constructs into their corresponding low-level C implementations, particularly for code generation or compilation tasks.",
      "description_length": 393,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6parser",
      "library": "lustre-v6",
      "description": "This module defines a comprehensive set of lexical tokens used in parsing a domain-specific language, including keywords, operators, literals, and delimiters, all carrying positional information via `Lxm.t`. It provides a `program` function that parses a full program into an abstract syntax tree (`AstV6.t`) using a given lexer function. Concrete use cases include building compilers or interpreters for languages with complex syntax, such as modeling or configuration languages.",
      "description_length": 480,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cDep",
      "library": "lustre-v6",
      "description": "This module generates C code for various operations in the Soc language, handling assignments, step method prototypes, variable expressions, and control structures. It works with data types like `Soc.t`, `Soc.var_expr`, and `Soc.step_method` to produce low-level C implementations. Concrete use cases include translating Soc expressions into C variables, generating function calls for steps, and emitting C code for iterators, conditionals, and reductions.",
      "description_length": 456,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnifyType",
      "library": "lustre-v6",
      "description": "This module implements a specialized type unification algorithm for comparing and matching lists of types, particularly handling type variables and overloaded types constrained to `int` or `real`. It supports unification of two lists of types where at most one type variable (either `Any` or `Overload`) is present, returning whether the types are equal, can be unified with a specific type substitution, or are incompatible. Concrete use cases include type inference and checking during compilation of expressions involving overloaded arithmetic operators.",
      "description_length": 557,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lOptimIte",
      "library": "lustre-v6",
      "description": "Transforms conditional expressions into merged branches when neither branch contains memory operations. Works with program expressions represented in the `LicPrg.t` type. Useful for optimizing control flow in low-level intermediate representations where memory effects are absent.",
      "description_length": 280,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EvalType",
      "library": "lustre-v6",
      "description": "Performs static type evaluation for expressions, updating type fields in the expression tree. Works with `Lic.val_exp` and `Lic.type_` structures during type checking. Used to infer and annotate types in expressions during compilation.",
      "description_length": 235,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SocExecEvalPredef",
      "library": "lustre-v6",
      "description": "This module provides the `get` function, which retrieves a predefined operator interpreter based on a given `Soc.key` from a `SocExecValue.ctx` context. It operates on predefined operators within an evaluation context, specifically handling key-based lookup of interpreter functions. A concrete use case is resolving and executing built-in operators during the interpretation of a Soc-based language, where each operator is uniquely identified by a key.",
      "description_length": 453,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cExtern",
      "library": "lustre-v6",
      "description": "This module generates C code files and constants from a system-on-chip description. It operates on data types representing SoC configurations (`Soc.t`, `Soc.tbl`) and license programs (`LicPrg.t`), producing C declarations, getters, and related logic. Concrete use cases include automatically generating C headers and source files for hardware abstraction layers based on a given SoC model and licensing information.",
      "description_length": 416,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2yaml",
      "library": "lustre-v6",
      "description": "Converts a specific entry from a `Soc.tbl` table into a YAML-formatted string and writes it to a file. Works with `Soc.key` and `Soc.tbl` types, which represent keys and tables in the `Soc` module's data structure. Useful for exporting individual configuration or state entries to YAML files for external consumption or logging.",
      "description_length": 328,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LicTab",
      "library": "lustre-v6",
      "description": "This module implements a lazy compiler for transforming abstract syntax trees into a structured program representation. It maintains internal tables for incremental compilation of nodes and supports compiling individual nodes or entire programs. The result is converted into a functional data structure for further processing.",
      "description_length": 326,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lRemoveAlias",
      "library": "lustre-v6",
      "description": "Performs alias elimination on compiler-generated intermediate code, specifically removing redundant variable aliases introduced during lower-level translation passes. Operates on `LicPrg.t` structures, which represent program data in a format suitable for analysis and transformation. Useful for optimizing program representations before final code generation, especially in scenarios involving complex control flow or combinatorial logic.",
      "description_length": 439,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SocPredef2cHeap",
      "library": "lustre-v6",
      "description": "This module generates C code snippets for specific operations derived from a `Soc` structure. It handles predefined operations, iterators, conditional actions, and boolean reductions by translating them into their corresponding C implementations. Use this module when emitting low-level C code from a higher-level representation, particularly for constructs like maps, reductions, and control flow conditions.",
      "description_length": 409,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lic2soc",
      "library": "lustre-v6",
      "description": "Converts license program nodes into system-on-chip profiles by mapping variables and types between the license and system-on-chip domains. It processes `LicPrg.t` and `Lic.node_exp` structures to generate `Soc` variables and tables, using `Lic.type_` to determine corresponding data types. This module is used to translate license logic into system configurations for hardware integration.",
      "description_length": 389,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ast2lic",
      "library": "lustre-v6",
      "description": "This module translates abstract syntax tree (AST) elements into the intermediate representation (IR) used by the lic module. It provides functions to convert type expressions, variable clocks, node expressions, equations, and assertions from their AST forms into corresponding IR structures. These translations are used during compilation to transform parsed source code into a form suitable for further analysis and code generation.",
      "description_length": 433,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6Verbose",
      "library": "lustre-v6",
      "description": "This module controls verbose output levels and conditional logging flags. It provides functions to set and retrieve logging levels, enable or disable specific flags, and conditionally print messages or execute functions based on the current verbosity settings. Use cases include debugging applications by selectively enabling detailed logs for specific components or execution paths.",
      "description_length": 383,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cStack",
      "library": "lustre-v6",
      "description": "This module generates C code for heap-based interactions between components in a system-on-chip design. It provides functions to create assignments, step function prototypes, variable expressions, and inlined step calls, primarily working with `Soc.t`, `Soc.var_expr`, and related identifiers. Concrete use cases include emitting C code for data transfers, function calls, and type definitions during the code generation phase of a hardware-software co-design workflow.",
      "description_length": 469,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SocExecValue",
      "library": "lustre-v6",
      "description": "This module manages value substitutions and contexts for the Soc interpreter, handling operations like adding substitutions, retrieving values from variables, and substituting parameters and arguments. It works with paths, substitutions, and context records that track current paths and substitution sets. Concrete use cases include resolving variable expressions to values, managing enum selections, and converting between substitution formats during interpreter execution.",
      "description_length": 474,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cUtil",
      "library": "lustre-v6",
      "description": "This module converts data types and flow declarations to C code, handling type representations, licensing, and variable declarations. It operates on data structures like `Data.t`, `Lic.type_`, and `(string * Data.t)` pairs, generating C strings for switch statements, variable declarations, and annotated flows. Concrete uses include translating internal data models into C function bodies, mapping license types to C macros, and emitting switch-case logic based on input values.",
      "description_length": 479,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lExpandEnum",
      "library": "lustre-v6",
      "description": "Performs program expansion based on the target architecture. It transforms a `LicPrg.t` program into a new `LicPrg.t` program, expanding instructions for either integer (`I`) or byte array (`BA`) targets. Useful when compiling intermediate code to architecture-specific instruction sets.",
      "description_length": 287,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FilenameExtras",
      "library": "lustre-v6",
      "description": "Simplifies file paths by resolving components like `.` and `..`, normalizing slashes, and removing redundant elements. Works with string representations of file paths. Useful for canonicalizing user-provided paths before file operations or logging.",
      "description_length": 248,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LicEvalType",
      "library": "lustre-v6",
      "description": "This module defines type evaluation logic for predefined operators in type expressions. It includes functions to validate operator input types, enforce correct arity, and generate typed expression nodes. Key operations include `f` for type checking operator applications and `make_node_exp_eff` for constructing expression nodes with proper type and effect handling. It works directly with AST representations of types and expressions, making it essential for type inference and validation during compilation.",
      "description_length": 509,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LicMetaOp",
      "library": "lustre-v6",
      "description": "Handles construction of lic expressions for predefined Meta operators by extracting node and integer constants from static arguments and generating corresponding node expressions. Works with `Lic.node_key`, `Lic.node_exp`, and `Lxm.t` types. Used to produce lic representations for specific Meta operator instantiations during code generation.",
      "description_length": 343,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6version",
      "library": "lustre-v6",
      "description": "This module exposes version metadata including the tool name, version string, Git SHA, branch, and maintainer email. These values are typically used for logging, diagnostics, or reporting build-specific information. The module works directly with string values, each representing a distinct piece of version or build-time data.",
      "description_length": 327,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cIdent",
      "library": "lustre-v6",
      "description": "This module handles identifier manipulation and lookup for a system involving hierarchical keys and data types. It provides regular expressions for parsing identifiers, functions to convert various identifier formats to strings, and retrieves specific name components from keys. Use cases include transforming and extracting base, context, and system names from structured identifiers during data processing or serialization.",
      "description_length": 425,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AstV6",
      "library": "lustre-v6",
      "description": "This module represents the abstract syntax tree of Lustre V6 programs using hash tables. It defines core types like `t`, `packbody`, and `pack_or_model`, along with operations to construct and manipulate package bodies and extract source identifiers. Concrete use cases include parsing Lustre V6 source code into structured data, mapping identifiers to their definitions, and converting AST elements to string representations for debugging or serialization.",
      "description_length": 457,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2c",
      "library": "lustre-v6",
      "description": "Performs a validation check on a license program using provided main arguments, a cryptographic key, and a symbol table. Works with types `Lv6MainArgs.t`, `Soc.key`, `Soc.tbl`, and `LicPrg.t`. Useful for verifying license compliance in a system requiring cryptographic validation and symbol resolution.",
      "description_length": 302,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6Id",
      "library": "lustre-v6",
      "description": "This module provides utilities for managing structured identifiers, focusing on conversions between string representations and typed forms, construction and decomposition of hierarchical namespaced identifiers with optional package prefixes, and controlled serialization that preserves packaging context. It operates on identifiers (`t`), long-form identifiers (`long`), package-qualified references (`idref`), and clock identifiers (`clk`), enabling workflows like module system path resolution, structured name manipulation, and persistent storage of identifier hierarchies. Key use cases include implementing namespacing in modular systems, handling qualified references during compilation, and serializing/deserializing identifier graphs with package-aware formatting.",
      "description_length": 772,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "L2lCheckMemSafe",
      "library": "lustre-v6",
      "description": "This module performs safety and memory analysis on value expressions and node declarations. It checks whether expressions are safe and memoryless with respect to a given program context. Concrete use cases include validating that expressions do not introduce memory leaks or unsafe operations during program transformation or optimization.",
      "description_length": 339,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SortActions",
      "library": "lustre-v6",
      "description": "Performs a topological sort on a list of actions given their dependencies, returning a list of actions in execution order. It processes `Action.t` values and uses `ActionsDeps.t` to represent dependencies between actions. Validates that no dependency cycles exist, using `Lxm.t` to track and report errors during sorting.",
      "description_length": 321,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SocExecDbg",
      "library": "lustre-v6",
      "description": "This module implements step-by-step execution of a virtual machine, tracking context changes and handling debug events. It operates on a symbol table, a virtual machine state, and a debug event stream, producing updated context or modified debug events. Concrete use cases include single-stepping through assembly-like code during debugging sessions and injecting breakpoints into execution flow.",
      "description_length": 396,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lExpandArrays",
      "library": "lustre-v6",
      "description": "Performs array and structure expansion transformations on intermediate code, specifically handling nested data structures and array initializations. Operates on `LicPrg.t` programs, simplifying complex node representations to generate valid EC code. Used during code generation to flatten nested constructs into a form suitable for low-level emission.",
      "description_length": 351,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnifyClock",
      "library": "lustre-v6",
      "description": "This module implements clock unification logic with substitutions for clock variables and structural constraints. It operates on clock expressions and substitutions, which map identifiers to other identifiers or enforce relationships between clock structures. Functions unify and apply constraints to clocks, generate fresh clock variables, and transform constants into value expressions while maintaining clock consistency.",
      "description_length": 424,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "TopoSort",
      "library": "lustre-v6",
      "description": "Implements topological sorting on directed acyclic graphs using a store structure of elements and dependencies. Provides cycle detection and total ordering where each element follows its dependencies. Useful for scheduling tasks with precedence constraints or resolving dependency chains in build systems.",
      "description_length": 305,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6Run",
      "library": "lustre-v6",
      "description": "Creates an executable plugin from a list of command-line arguments, working with string arrays and plugin types. It directly constructs a plugin instance for debugging purposes. Useful for initializing and running plugins with specific command-line configurations.",
      "description_length": 264,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6lexer",
      "library": "lustre-v6",
      "description": "This module implements a lexer for parsing source code, handling lexical analysis with support for token recognition, error recovery, and comment processing. It works with lex buffers and token structures, including detailed handling of nested comments and keyword identification. Concrete use cases include reading and processing OCaml-like syntax, managing lexical states during parsing, and extracting token values with position tracking.",
      "description_length": 441,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lExpandNodes",
      "library": "lustre-v6",
      "description": "This module replaces node calls with their internal equations, introducing fresh variables for inputs, outputs, and intermediate values. It processes both node instantiations and assertions, transforming them into equivalent flat equations within the program. It is used to eliminate hierarchical node structure, enabling further analysis or compilation passes that require flattened code.",
      "description_length": 389,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FreshName",
      "library": "lustre-v6",
      "description": "This module generates fresh, non-clashing identifier names for use in program transformation and analysis tasks. It provides functions to create fresh node identifiers, local variable names, variable metadata, and array type names, all based on input parameters. These operations are essential during code generation and semantic analysis to ensure unique naming across different scopes and contexts.",
      "description_length": 400,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LicEvalConst",
      "library": "lustre-v6",
      "description": "This module evaluates predefined operators in constant expressions, handling type and arity errors. It works with constant values, static arguments, and operator definitions. Concrete use cases include validating and computing constant expressions during static analysis, such as checking arithmetic operations on literals or ensuring correct argument counts for built-in functions.",
      "description_length": 382,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cGenAssign",
      "library": "lustre-v6",
      "description": "Generates C assignment code for used data types from a list of SOC structures. Converts individual data types to their C string representations using `f`, and handles for-loop constructs with `f_forloop`. Used to automate C code generation for data type assignments in embedded systems.",
      "description_length": 286,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6util",
      "library": "lustre-v6",
      "description": "This module includes functions for string and float conversion, checking string suffixes, finding an element's position in a list, generating integer lists, and handling associations in key-value pairs. It works with basic types like strings, floats, integers, and lists of these types. Concrete uses include parsing numerical inputs, validating string formats, and manipulating list-based mappings.",
      "description_length": 399,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SocExec",
      "library": "lustre-v6",
      "description": "This module executes operations on a social contract table using a key and main arguments, stepping through contract logic with a specified method. It processes contract execution contexts, updating state based on provided inputs and contract rules. Concrete use cases include running contract functions and validating transitions in a blockchain environment.",
      "description_length": 359,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lCheckOutputs",
      "library": "lustre-v6",
      "description": "Performs static checks on node expressions and programs to ensure outputs and local variables are defined exactly once and inputs are not redefined. Works with `Lic.node_exp` and `LicPrg.t` data structures, which represent nodes and programs in an intermediate language. Validates correctness of variable assignments during compilation or analysis phases.",
      "description_length": 355,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lRmPoly",
      "library": "lustre-v6",
      "description": "Performs transformation on iterator nodes to eliminate overloading, primarily handling polymorphism in `if/then/else` expressions. Works directly with the `LicPrg.t` data structure, which represents program constructs. Useful for simplifying type resolution in programs by normalizing polymorphic control flow constructs.",
      "description_length": 321,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LicPrg",
      "library": "lustre-v6",
      "description": "This module manages the creation, transformation, and analysis of a structured representation of compiled programs, focusing on typed entities and their relationships. It operates on a hierarchical data structure (`LicPrg.t`) that encapsulates types, constants, and computational nodes, enabling operations like bulk modification, scoped iteration, and dependency-aware transformations. Key use cases include compiler pipeline stages such as type-driven optimization, symbol table maintenance, and generating unique identifiers for type-specific constructs during program assembly.",
      "description_length": 581,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Soc",
      "library": "lustre-v6",
      "description": "This module defines a data structure for representing low-level program components with precise structural and behavioral attributes, specifically designed for code generation and execution modeling. It supports operations like variable expression construction, atomic operation definition, and step method implementation, working with complex nested types such as `var_expr`, `gao`, and `step_method`. Concrete use cases include building and manipulating intermediate representations for synchronous systems, compiling to C code, and executing models through the interpreter.",
      "description_length": 576,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EvalClock",
      "library": "lustre-v6",
      "description": "Performs static clock evaluation for expressions and node calls, ensuring clock compatibility between arguments and parameters. It operates on value expressions, clock constraints, and substitution environments, producing a clock profile for further validation. Used during type checking to enforce correct clock synchronization in signal processing or reactive system implementations.",
      "description_length": 385,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "L2lNoWhenNot",
      "library": "lustre-v6",
      "description": "Transforms equations involving \"when not\" conditions into equivalent forms using auxiliary boolean variables. Works with equation sets and boolean expressions in a program representation. Enables compatibility with code generators that do not support \"when not\" syntax by rewriting such equations into standard \"when\" constructs.",
      "description_length": 329,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lxm",
      "library": "lustre-v6",
      "description": "This module handles lexeme creation and manipulation, providing functions to extract source code positions, associate pragmas, and modify lexeme properties. It works with lexemes (`t`), pragmas (`pragma`), and lexing buffers to support precise error reporting and source tracking during parsing. Concrete uses include attaching file and line information to tokens, retrieving detailed source positions for diagnostics, and embedding custom metadata via pragmas.",
      "description_length": 461,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "IdSolver",
      "library": "lustre-v6",
      "description": "This module manages identifier resolution in node environments using mappings from identifiers to constants, types, nodes, and variables. It supports operations to create and serialize local environments, and to look up type, node, constant, and variable information based on identifiers and context. Concrete use cases include resolving symbolic references during compilation and maintaining environment state during semantic analysis.",
      "description_length": 436,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Action",
      "library": "lustre-v6",
      "description": "This module defines an intermediate data structure representing clocked atomic operations with input and output variables. It provides operations to construct and convert these actions to string representations, primarily used during translation of expressions into lower-level guarded atomic operations. The module works with lists of variable expressions, clocks, and atomic operations to model timed data flow transformations.",
      "description_length": 429,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AstV6Dump",
      "library": "lustre-v6",
      "description": "This module provides functions to pretty-print various components of a version 6 abstract syntax tree, including package information, model details, and expressions. It operates on data types such as `AstV6.pack_info`, `AstV6.packbody`, `AstV6.t`, and `AstV6.model_info`, all tied to source location tracking. It is used to generate human-readable representations of parsed models and expressions for debugging or logging.",
      "description_length": 422,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lCheckCKeyWord",
      "library": "lustre-v6",
      "description": "Performs a check on the input program's identifiers to ensure none are C keywords. Works directly with the `LicPrg.t` data type, which represents the parsed program structure. Useful for validating identifier naming in C-like languages before further processing or compilation steps.",
      "description_length": 283,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dbg",
      "library": "lustre-v6",
      "description": "This module provides functions for printing and converting structured data to strings, primarily for debugging purposes. It works with data types such as `Lxm.t`, `AstCore.val_exp`, and `Lic.const`, offering direct inspection of their internal structures. Concrete use cases include logging intermediate values during evaluation, displaying expressions in error messages, and formatting constants for debugging output.",
      "description_length": 418,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cInstances",
      "library": "lustre-v6",
      "description": "This module processes lists of soc instances, each consisting of a unique identifier and a key, by converting them into arrays for efficient C-level iteration. It provides a `to_array` function that maps each instance to an index and returns an association list of keys to indices along with an indexing function. Use this when generating C code that requires array-based access to soc instances.",
      "description_length": 396,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6Misc",
      "library": "lustre-v6",
      "description": "Converts a `left` value wrapped in `srcflagged` into a `filtered_left` tuple, reordering its elements for explicit list traversal. Works with `filtered_left` type, which pairs variable info, a `Lxm.t` value, and a list of `filter` values. Useful for analyzing and transforming left-hand side expressions in a structured, ordered format.",
      "description_length": 336,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "L2lCheckLoops",
      "library": "lustre-v6",
      "description": "Performs dependency loop detection between equations in a program representation, ensuring correct evaluation order. Operates directly on the `LicPrg.t` data structure, which models equations and their dependencies. Useful in compilation pipelines where equation ordering is critical, such as during code generation or static analysis.",
      "description_length": 335,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SocNameC",
      "library": "lustre-v6",
      "description": "This module defines data structures for representing variables, nodes, and instances in a system-on-chip design, along with functions to extract and transform these elements from a Soc.t structure. It provides mappings between variable expressions and indices, and supports retrieval of input, output, and internal variables as well as node and instance configurations. Use cases include parsing and analyzing SoC components for simulation or code generation based on their structural and contextual properties.",
      "description_length": 511,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SortActionsExpe",
      "library": "lustre-v6",
      "description": "This module implements heuristic-based transformations for optimizing action scheduling code. It provides functions to split action lists based on dependencies, compare actions using clock and metadata, group actions into sequences, and optimize test structures by reducing redundant checks. These operations directly manipulate action lists and dependency graphs to improve execution efficiency in scenarios like conditional branching transformations.",
      "description_length": 452,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LicDump",
      "library": "lustre-v6",
      "description": "This module transforms compiler intermediate representations into textual formats for diagnostics, handling AST nodes, type variables, value expressions, and structural keys with configurable formatting. It operates on data structures like identifiers, clock expressions, and node definitions, using context-aware string conversion to support debugging and error reporting. The output is optimized for readability through line wrapping and verbosity controls, catering to scenarios like logging and interactive development tools.",
      "description_length": 529,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "L2lCheckKcgKeyWord",
      "library": "lustre-v6",
      "description": "Performs case-insensitive checks on program identifiers to ensure they do not conflict with KCG keywords. Works directly with `LicPrg.t` structures representing parsed programs. Validates identifier usage during program analysis to prevent keyword collisions.",
      "description_length": 259,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lWhenOnId",
      "library": "lustre-v6",
      "description": "Performs substitution of equations with conditional expressions by introducing intermediate variables for conditions. Transforms assignments guarded by `when` conditions into equivalent forms with explicit condition variables. Useful for translating high-level synchronous equations into lower-level intermediate code.",
      "description_length": 318,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AstRecognizePredef",
      "library": "lustre-v6",
      "description": "Replaces identifier references in the syntax tree with predefined constructors when they match known predefined items. Works directly with the `AstV6.t` data type, performing a recursive traversal to resolve and update nodes. Useful for transforming raw syntax trees into a normalized form where predefined entities are explicitly marked.",
      "description_length": 338,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6Compile",
      "library": "lustre-v6",
      "description": "Performs compilation of model and pack definitions into a structured program representation. Processes input files and node references to generate a unified program structure. Useful for transforming parsed source data into an executable form.",
      "description_length": 243,
      "index": 73,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 74,
    "meaningful_modules": 74,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 772,
    "min_description_length": 235,
    "avg_description_length": 394.7432432432432,
    "embedding_file_size_mb": 1.072601318359375
  }
}