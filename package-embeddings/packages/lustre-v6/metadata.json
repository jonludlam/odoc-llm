{
  "package": "lustre-v6",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 75,
  "creation_timestamp": "2025-07-15T23:16:27.827748",
  "modules": [
    {
      "module_path": "TopoSort.S",
      "library": "lustre-v6",
      "description": "Implements topological sorting on directed acyclic graphs represented as element lists and a store structure. Provides cycle detection and ordering computation operations. Useful for dependency resolution tasks such as scheduling or build system rule processing.",
      "description_length": 262,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc.SocMap",
      "library": "lustre-v6",
      "description": "The module provides associative map operations for key-value associations with polymorphic values, supporting modification, querying, and structural transformations over a key type tied to synchronous object components. It works with polymorphic maps, sequences, and lists, enabling safe access, iterative processing, and bidirectional conversions between these structures. This is particularly useful for constructing and manipulating hierarchical data representations, such as those used in code generation or symbolic computation workflows.",
      "description_length": 543,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lic.TopoSortVarInfo",
      "library": "lustre-v6",
      "description": "Implements topological sorting on a graph of variable dependencies represented as a hash table mapping nodes to their adjacent nodes. It supports cycle detection and produces a sorted list of elements in topological order. Useful for resolving dependencies between variables in a program analysis context.",
      "description_length": 305,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "TopoSort.Make",
      "library": "lustre-v6",
      "description": "Implements topological sorting on directed acyclic graphs represented as elements and dependencies in a store structure. Provides cycle detection and ordering of elements such that all dependencies of an element appear before it. Useful for scheduling tasks with precedence constraints or resolving dependency chains in build systems.",
      "description_length": 334,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "TopoSort.PartialOrder",
      "library": "lustre-v6",
      "description": "Implements a partial order relation over a set of elements, supporting dependency checks and removals. It maintains a store of elements and their dependencies, enabling operations to query and modify dependencies. Useful for managing directed acyclic graphs where elements must be processed in dependency order.",
      "description_length": 311,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lv6parser",
      "library": "lustre-v6",
      "description": "This module defines a comprehensive set of lexical tokens used in parsing a domain-specific language, including keywords, operators, literals, and structural symbols. It provides the `program` function that parses a full program from a lexing buffer using a token-producing function. It is used to construct abstract syntax trees from source code input according to the grammar of the Lv6 language.",
      "description_length": 398,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6Id",
      "library": "lustre-v6",
      "description": "This module provides tools for managing structured identifiers with hierarchical and package-aware contexts, supporting operations like bidirectional conversion between string representations and typed identifiers, qualified name manipulation with optional package prefixes, and constructing or parsing reference records that encapsulate contextual metadata. It works with types representing atomic identifiers (`t`), qualified sequences (`long`), package names (`pack_name`), reference records (`idref`), and clock identifiers (`clk`), enabling use cases such as module system name resolution, package-scoped reference tracking, and structured identifier serialization with configurable formatting rules.",
      "description_length": 705,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lWhenOnId",
      "library": "lustre-v6",
      "description": "Performs substitution of equations involving the `when` construct in a program, transforming them into equivalent forms with explicit condition variables. Works with program structures containing equations and conditions, specifically targeting expressions with the `when` operator and associated predicates. Useful for simplifying and normalizing guarded expressions in formal verification or program analysis tasks.",
      "description_length": 417,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lv6Misc",
      "library": "lustre-v6",
      "description": "Converts a `left` value from a reversed list representation into an explicit list structure, reordering elements into a standard traversal format. Processes `Lic.left` values flagged with source information, extracting variable details, XML markers, and filter lists. Useful for analyzing or transforming nested XML structures where element ordering affects interpretation.",
      "description_length": 373,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ast2lic",
      "library": "lustre-v6",
      "description": "This module translates abstract syntax trees into a lower intermediate representation, handling type and expression conversions, static argument evaluation, and compatibility checks between parameters and arguments. It operates on data types such as `type_exp`, `var_info`, `node_exp`, `eq_info`, and `val_exp` from both the `AstCore` and `Lic` modules. It is used to convert high-level node expressions and equations into their equivalent lower-level forms while ensuring static constraints are met.",
      "description_length": 500,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lExpandMetaOp",
      "library": "lustre-v6",
      "description": "Performs expansion of meta-level operators like `red` and `map` in a program representation. Operates on `LicPrg.t`, transforming expressions by replacing meta-operations with their lower-level equivalents. Useful for compiling high-level specifications into executable code by eliminating abstractions.",
      "description_length": 303,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lic2soc",
      "library": "lustre-v6",
      "description": "Converts license program nodes into system-on-chip configurations by mapping variables and types between the license and system-on-chip domains. It processes `LicPrg.t` and `Lic.node_key` inputs to generate `Soc.key` and `Soc.tbl` outputs, and translates license types into data types used in system configurations. This module is used to generate SoC profiles from license expressions, handling variable lists and type conversions directly.",
      "description_length": 441,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SocExecDbg",
      "library": "lustre-v6",
      "description": "This module implements step-by-step execution of a virtual machine, handling transitions between states using a symbol table and a context. It works with `Soc.tbl` for symbol resolution, `Soc.t` as the instruction sequence, and `SocExecValue.ctx` to track execution state. It is used to interpret low-level code in a debugger, where each step may produce or consume debug events through the `RdbgEvent.t` type.",
      "description_length": 410,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AstV6Dump",
      "library": "lustre-v6",
      "description": "This module provides functions to pretty-print various components of a version 6 abstract syntax tree, including package information, body, top-level structures, and model details, using OCaml's Format module. It operates on data types such as `pack_info`, `packbody`, `t`, and `model_info`, all tied to source-position tracking. Concrete use cases include generating human-readable output of parsed syntax trees for debugging, logging, or code generation workflows.",
      "description_length": 466,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Soc2cStack",
      "library": "lustre-v6",
      "description": "This module generates C code for heap-based interactions between system-on-chip components. It provides functions to create assignments, step function prototypes, and inlined step calls, working with types like `Soc.t`, `Soc.var_expr`, and `Soc.step_method`. Concrete use cases include emitting C code for variable assignments using `memcpy` or direct assignment, generating function prototypes for step methods, and producing C code for calling step functions between components.",
      "description_length": 480,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SocVar",
      "library": "lustre-v6",
      "description": "This module transforms variable representations in structured data, expanding records and arrays for external communication. It maps enumerated values to integers and adjusts variable naming conventions based on C-style access patterns. Key use cases include preparing data for C interfaces and normalizing substitutions in structured formats.",
      "description_length": 343,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "EvalClock",
      "library": "lustre-v6",
      "description": "Performs static clock evaluation for expressions and node calls, ensuring clock compatibility between arguments and parameters. It operates on value expressions, clock constraints, and substitution environments, producing clock profiles for further validation. Used during type checking to enforce correct clock behavior in node instantiations and expression evaluations.",
      "description_length": 371,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lCheckMemSafe",
      "library": "lustre-v6",
      "description": "This module performs safety and memory analysis on node declarations and value expressions. It checks whether expressions are safe and memoryless, ensuring they do not introduce side effects or depend on state. It operates on `LicPrg.t` programs and `Lic.val_exp` expressions, typically used during static analysis of reactive systems to enforce memory safety.",
      "description_length": 360,
      "index": 17,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LicMetaOp",
      "library": "lustre-v6",
      "description": "Handles extraction of node and constant values from static arguments and generates lic expressions for predefined Meta operators. Works with `Lxm.t`, `Lic.static_arg`, `Lic.node_key`, and `Lic.node_exp` types. Used to construct lic representations of Meta operator applications by processing static arguments and node keys.",
      "description_length": 323,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lCheckOutputs",
      "library": "lustre-v6",
      "description": "Performs static checks to ensure each output and local variable in a node is defined exactly once and prevents redefinition of inputs. Works with node expressions and program structures from the intermediate language. Validates correctness during compilation to catch definition errors early.",
      "description_length": 292,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "L2lRmPoly",
      "library": "lustre-v6",
      "description": "Transforms programs to eliminate polymorphism in node usages, specifically handling overloaded nodes and ensuring consistent type resolution. Works directly on `LicPrg.t` structures, modifying how polymorphic constructs like `if/then/else` are represented. Useful for preparing code before type aliasing to avoid complex or incorrect type names during subsequent processing stages.",
      "description_length": 381,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LicTab",
      "library": "lustre-v6",
      "description": "This module implements a lazy compiler for transforming abstract syntax trees into a structured program representation. It maintains internal tables that are incrementally updated by compiling individual nodes or all nodes at once. The resulting data structure is converted into an immutable map-based format for further processing.",
      "description_length": 332,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SocExecEvalPredef",
      "library": "lustre-v6",
      "description": "This module provides the `get` function, which retrieves a predefined operator interpreter based on a given `Soc.key` from a `SocExecValue.ctx` context. It works with `Soc.key` identifiers and `SocExecValue.ctx` contexts to locate and return the corresponding interpreter function. A typical use case involves looking up built-in operators during the evaluation phase of a program, ensuring that the correct interpreter is applied to a specific key within a defined context.",
      "description_length": 474,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc",
      "library": "lustre-v6",
      "description": "This module represents synchronous components with precise operational semantics, enabling the modeling of hardware-like behavior with variables, expressions, and atomic operations such as assignments and method calls. It supports structured data through records, arrays, indexing, and slicing, and is used for both C code generation and behavioral interpretation. The module includes a child module for polymorphic map operations, allowing safe key-based access, iteration, and conversion between maps, sequences, and lists, which is essential for constructing and transforming hierarchical data during code generation or symbolic computation. Examples include modeling clocked memory elements, generating C structs from records, and transforming component hierarchies into target-specific representations.",
      "description_length": 807,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6Verbose",
      "library": "lustre-v6",
      "description": "This module controls verbose output levels and flags, enabling conditional logging and execution based on set verbosity. It provides functions to set and retrieve verbosity levels, manage named flags, and print or execute actions only when the current level or flag matches. Use cases include debugging specific components, controlling log detail in long-running processes, and selectively enabling diagnostic output.",
      "description_length": 417,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LicEvalClock",
      "library": "lustre-v6",
      "description": "This module evaluates predefined operators in clock expressions using a substitution-based approach. It processes clock identifiers and constraints through a solver, producing resolved clock expressions and updated substitutions. It is used to enforce clock consistency during type checking of expressions involving time-based operators.",
      "description_length": 337,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "IdSolver",
      "library": "lustre-v6",
      "description": "This module manages identifier resolution in node environments using hashtables and global symbol tables. It provides functions to create and dump local environments, look up types, constants, nodes, and variables by identifier, and resolve expressions and variable info from keys. It is used to track and retrieve node-specific data during compilation or analysis of modular code structures.",
      "description_length": 392,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6Compile",
      "library": "lustre-v6",
      "description": "This module compiles a list of packs and models into a LicPrg.t program representation, using a specified main node. It processes source files into an AST and resolves references during compilation. Use it to build and link modular programs from parsed source files.",
      "description_length": 266,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lCheckCKeyWord",
      "library": "lustre-v6",
      "description": "Performs a check on the input program's identifiers to ensure none are C keywords. Works with the `LicPrg.t` data type, which represents the program structure. Useful for validating that generated or parsed code adheres to C naming restrictions.",
      "description_length": 245,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "AstV6",
      "library": "lustre-v6",
      "description": "This module represents the abstract syntax tree of Lustre V6 programs using hash tables to store constants, types, and nodes. It provides operations to construct and manipulate package bodies, rename packages, and extract source identifiers and string representations. Concrete use cases include parsing and processing Lustre V6 source code for compilation or analysis tasks.",
      "description_length": 375,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lOptimIte",
      "library": "lustre-v6",
      "description": "Transforms conditional expressions into merged expressions when neither branch uses memories. Works directly on program structures to optimize control flow. Useful for simplifying conditional logic in low-level code transformations.",
      "description_length": 232,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LicEvalType",
      "library": "lustre-v6",
      "description": "This module defines type evaluation logic for predefined operators in type expressions. It includes functions to validate operator arities and types, and to generate typed expression nodes based on operator semantics. It works with types like `Lic.type_`, `AstPredef.op`, and `Lic.node_exp`, and is used to enforce type correctness during static analysis of expressions involving built-in operators.",
      "description_length": 399,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lNoWhenNot",
      "library": "lustre-v6",
      "description": "Performs substitution of \"when not\" expressions in equations by introducing auxiliary boolean variables. Transforms equations where a variable is defined under a negated clock condition into equivalent forms using explicit boolean variables. Useful for preprocessing programs before code generation in systems that do not support \"when not\" constructs directly.",
      "description_length": 361,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cUtil",
      "library": "lustre-v6",
      "description": "This module converts data types and flow declarations to C code, handling type representations, licensing information, and variable scoping. It operates on data structures like `Data.t`, `Lic.type_`, and `(string * Data.t)` pairs, with support for generating C switch statements or conditional chains. Concrete use cases include translating internal data representations into C function declarations, variable definitions, and control structures for code generation pipelines.",
      "description_length": 476,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LicEvalConst",
      "library": "lustre-v6",
      "description": "This module evaluates predefined operators in constant expressions, handling type and arity errors. It works with constant values, static arguments, and predefined operations. Concrete use cases include validating and computing constants during static analysis of expressions.",
      "description_length": 276,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lv6Run",
      "library": "lustre-v6",
      "description": "Creates an RdbgPlugin instance from a string array, typically used to process command-line arguments for launching a debugging session. It directly handles array manipulation and plugin initialization. This function is essential for integrating custom debugging tools into the Rdbg environment via command-line interfaces.",
      "description_length": 322,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "L2lExpandNodes",
      "library": "lustre-v6",
      "description": "This module expands node instantiations by substituting node equations with equivalent local variable assignments, handling both regular and assert-style node calls. It works with node definitions containing inputs, outputs, and local variables, transforming them into equivalent expressions using fresh variables. Concrete use cases include inlining node logic during compilation to eliminate abstraction overhead and preparing code for further optimization passes.",
      "description_length": 466,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lv6MainArgs",
      "library": "lustre-v6",
      "description": "This module defines data structures and parsing logic for command-line arguments and global configuration options, including modes for enumeration handling, I/O transmission, and scheduling. It provides functions to parse command-line inputs into a structured form, display usage information, and create lexical buffers from file names. Concrete use cases include configuring compilation behavior, controlling code generation, and managing input/output processing during program execution.",
      "description_length": 489,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lxm",
      "library": "lustre-v6",
      "description": "This module handles lexeme creation, manipulation, and metadata extraction during lexical analysis. It provides functions to access the string content, source location (line, column range, file), and pragmas attached to lexemes, along with utilities to construct and modify them during parsing. Concrete use cases include tracking token positions for error reporting, attaching metadata to identifiers, and managing pragmas in the compiler frontend.",
      "description_length": 449,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lSplit",
      "library": "lustre-v6",
      "description": "Performs equation splitting on a node's expressions to ensure each equation contains only one operator, transforming complex assignments into simpler, single-operation equations. Works with tuples and local environments, introducing fresh variables as needed to maintain correctness during the transformation. Useful for simplifying intermediate representations in a compiler pipeline, enabling further optimizations or analysis that require normalized forms of equations.",
      "description_length": 472,
      "index": 39,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "EvalType",
      "library": "lustre-v6",
      "description": "Performs static type evaluation for expressions, updating type information in the abstract syntax tree. Works with value expressions and type lists, resolving type annotations during compilation. Used to ensure type correctness in language implementations by analyzing expression structures and their associated types.",
      "description_length": 318,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cGenAssign",
      "library": "lustre-v6",
      "description": "Generates C assignment code for used data types from a list of SOC structures. Converts individual data type definitions into their corresponding C string representations. Used to create both standard assignments and for-loop specific code based on the data type.",
      "description_length": 263,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Soc2c",
      "library": "lustre-v6",
      "description": "Performs a final validation step for a license generation process. Takes command-line arguments, a cryptographic key, a symbol table, and a program license structure to produce no output but likely updates internal state or verifies data integrity. Used in a licensing or authentication system where program-specific data must be validated against cryptographic keys and symbol tables.",
      "description_length": 385,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SocExecValue",
      "library": "lustre-v6",
      "description": "This module manages value substitutions and contexts for the Soc interpreter, handling operations like adding substitutions, retrieving values from variables, and substituting parameters with expressions. It works with paths, substitutions, and contexts to manipulate data values during interpretation. Concrete use cases include resolving variable expressions to concrete values, managing substitution lists during function calls, and extracting enum identifiers from structured data.",
      "description_length": 485,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnifyType",
      "library": "lustre-v6",
      "description": "This module implements a specialized type unification algorithm for comparing and matching two lists of types, supporting limited polymorphism through a single type variable (Any or Overload). It works with type representations defined in the `Lic` module, producing one of three outcomes: exact equality, unifiability with a single substitution, or failure. Concrete use cases include type inference in language compilers or static analysis tools where precise type matching with minimal polymorphism is required.",
      "description_length": 514,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SocNameC",
      "library": "lustre-v6",
      "description": "This module defines data structures for representing variables, nodes, and instances in a system, along with functions to extract and convert these structures from a `Soc.t` context. It provides operations to retrieve input, output, and variable lists with their associated metadata, and supports mapping variable expressions to indices. Concrete use cases include analyzing and transforming system components based on their structural and contextual properties.",
      "description_length": 462,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cInstances",
      "library": "lustre-v6",
      "description": "This module processes a list of SOC instances, each identified by a unique identifier and a key, to enable efficient C-level iteration. It provides the `to_array` function, which returns a list of SOC keys with their occurrence counts and a mapping function that determines the array position of each instance. This supports use cases like generating C arrays for fast lookup or processing SOC instances in a fixed order.",
      "description_length": 421,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AstPredef",
      "library": "lustre-v6",
      "description": "This module defines a comprehensive set of logical, arithmetic, and comparison operators used in an abstract syntax tree representation. It provides operations to convert operators to and from strings, classify operators as infix, and map them to identifier references and long identifiers. It is used to support parsing, pretty-printing, and semantic analysis of expressions in a domain-specific language embedded in OCaml.",
      "description_length": 424,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "FreshName",
      "library": "lustre-v6",
      "description": "This module generates fresh, unique identifier names for variables and types, ensuring no clashes with existing user-defined identifiers. It provides functions to create fresh local variable names, variable information records, array type names, and node identifiers based on a given key. Use this module during code generation or transformation phases to safely introduce new variables and types in a conflict-free manner.",
      "description_length": 423,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "L2lRemoveAlias",
      "library": "lustre-v6",
      "description": "Performs aggressive removal of redundant variable aliases in compiled intermediate representations. Operates on `LicPrg.t` structures, which represent program definitions and expressions. Useful after transformation passes that introduce temporary bindings, especially in optimizing compilers targeting lower-level forms.",
      "description_length": 321,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SocExec",
      "library": "lustre-v6",
      "description": "This module implements the core execution logic for processing a table of values using a step-based evaluation method. It operates on a table structure and a context, applying transformations based on a given key and execution arguments. It is used to drive stepwise computation in a context-aware environment, such as evaluating a sequence of operations over structured data.",
      "description_length": 376,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lv6util",
      "library": "lustre-v6",
      "description": "This module includes functions for string and float conversion, checking string suffixes, finding an element's position in a list, generating integer lists, and custom association list handling. It works primarily with basic types like strings, floats, integers, and lists, including association lists. Concrete uses include parsing numeric strings, validating file extensions, and managing indexed list operations.",
      "description_length": 415,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6lexer",
      "library": "lustre-v6",
      "description": "This module implements a lexer for parsing source code, handling lexical analysis with support for token recognition, error recovery, and comment processing. It works with lex buffers and token structures, including support for keyword lookup and string-to-token conversion. Concrete use cases include reading and processing tokens during parsing, managing nested comments, and retrieving token source representations.",
      "description_length": 418,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SortActions",
      "library": "lustre-v6",
      "description": "Performs a topological sort on a list of actions given their dependencies, returning a list of sorted actions in dependency order. It works with `Action.t`, `ActionsDeps.t`, and `Lxm.t` types, where dependencies are represented as a graph structure. This function is used to determine the correct execution order of dependent tasks or to detect circular dependencies in a build system or task scheduler.",
      "description_length": 403,
      "index": 53,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "L2lExpandEnum",
      "library": "lustre-v6",
      "description": "Performs enum expansion into different target forms, specifically integers (I) or bitarrays (BA). Works with `LicPrg.t` programs to transform enum-based logic into equivalent representations. Used to generate low-level code variants optimized for specific backends or execution contexts.",
      "description_length": 287,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cPredef",
      "library": "lustre-v6",
      "description": "This module generates C function calls from OCaml data structures and checks if a given function call is supported. It operates on `Soc.key` and `Soc.t` types, producing C code as string output. It is used to interface OCaml logic with C-based code generation, specifically handling function call translation and validation.",
      "description_length": 324,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "L2lExpandArrays",
      "library": "lustre-v6",
      "description": "Performs array and structure expansion transformations on intermediate code, specifically tailored for generating ec code. Operates on `LicPrg.t` data structures, which represent program constructs in a form suitable for code generation. Useful in lowering high-level array and struct representations into simpler, expanded forms that simplify subsequent code emission steps.",
      "description_length": 375,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "L2lCheckKcgKeyWord",
      "library": "lustre-v6",
      "description": "Performs a check on the input program to ensure no identifiers use KCG keywords. Works directly with the `LicPrg.t` data structure. Enforces naming constraints during program validation by raising an error if restricted keywords are found.",
      "description_length": 239,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "UnifyClock",
      "library": "lustre-v6",
      "description": "This module implements clock substitution and unification logic for handling polymorphic and bound clock variables during type checking. It provides operations to apply substitutions to clocks, merge clock constraints, and generate fresh clock variables, working with clock expressions and substitution environments. Concrete uses include checking clock compatibility in expressions like \"42 + x\" by unifying constants with variable clocks and managing alpha-equivalence in node parameter bindings.",
      "description_length": 498,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Action",
      "library": "lustre-v6",
      "description": "This module defines an intermediate data structure representing clocked atomic operations with input and output variables. It provides functions to convert these operations into string representations for debugging or messaging. It is used during the translation of expressions into Soc.gao by associating atomic operations with their respective clocks and variable expressions.",
      "description_length": 378,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Soc2cIdent",
      "library": "lustre-v6",
      "description": "This module handles identifier manipulation and conversion for a system involving keys and data types. It provides regular expressions for parsing, functions to convert identifiers to strings, and utilities to extract components from keys. Concrete use cases include formatting identifiers for output, parsing structured keys, and mapping data types to string representations.",
      "description_length": 376,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Soc2cExtern",
      "library": "lustre-v6",
      "description": "This module generates C code files and constants from a system-on-chip description. It works with data types representing SoC configurations, license programs, and string-based code templates. It is used to automate C code generation for hardware abstraction layers and peripheral drivers.",
      "description_length": 289,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "L2lCheckLoops",
      "library": "lustre-v6",
      "description": "Performs dependency loop detection between equations in a program representation where structs and arrays are expanded. Uses the same logic as the C code generation phase but operates independently to support analysis modes that do not generate C code. Directly consumes `LicPrg.t` structures and raises errors if cyclic dependencies are found.",
      "description_length": 344,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "AstRecognizePredef",
      "library": "lustre-v6",
      "description": "Replaces identifier references in the abstract syntax tree with predefined constructors by performing a recursive traversal. It resolves ambiguous identifier references during parsing by determining the correct long identifier form. This module is used to correctly bind identifier references to their predefined counterparts in the core AST representation.",
      "description_length": 357,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lv6version",
      "library": "lustre-v6",
      "description": "This module exposes version metadata as string values, including the tool name, version string, Git SHA, branch, and maintainer. It provides direct access to these constants without requiring any input parameters. This is useful for embedding build-time information into applications, such as displaying version details in a CLI or logging system.",
      "description_length": 347,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Soc2cDep",
      "library": "lustre-v6",
      "description": "This module generates C code for various operations in the Soc language, including assignments, step function prototypes, variable expressions, and control structures like iterators and conditionals. It works with data types such as `Soc.t`, `Soc.var_expr`, `Soc.step_method`, and `Soc.key` to produce low-level C representations tailored to different execution models like heap or stack-based code. Concrete use cases include translating Soc expressions into C variables, generating function calls for steps, and emitting C code for predefined operations, conditionals, and reductions.",
      "description_length": 586,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "TopoSort",
      "library": "lustre-v6",
      "description": "This module provides topological sorting for directed acyclic graphs using adjacency lists, with support for cycle detection and dependency resolution. It includes operations to compute linear orderings where each node precedes all its dependents, enabling tasks like scheduling and build system processing. Child modules extend this functionality by representing graphs through element lists and store structures, allowing dependency queries, modifications, and partial order relations. Specific uses include resolving module dependencies, processing ordered tasks, and maintaining acyclic graphs with dynamic dependencies.",
      "description_length": 624,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SortActionsExpe",
      "library": "lustre-v6",
      "description": "This module implements heuristics for reordering and grouping actions in a directed acyclic graph (DAG) to optimize test openings and reduce redundancy in conditional execution. It provides functions to split action lists based on dependencies, compare and sort actions, group actions for factorization, and optimize test structures by duplicating code where beneficial. Concrete use cases include transforming sequences of conditional actions into more compact and efficient forms while managing trade-offs between test count and code size.",
      "description_length": 541,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Soc2cHeap",
      "library": "lustre-v6",
      "description": "This module generates C code for heap-based operations, handling assignments, variable expressions, and step method prototypes. It works with `Soc.t` structures representing system-on-chip configurations and `Soc.var_expr` for variable expressions. Concrete uses include generating function calls for steps, inlining SOC definitions, and producing C typedefs and assignments.",
      "description_length": 375,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "SocPredef2cStack",
      "library": "lustre-v6",
      "description": "This module generates C code snippets for specific operations derived from a given `Soc` structure. It provides functions to retrieve predefined operations, iterators, conditional actions, and boolean reductions as strings. These functions are used to translate high-level constructs into low-level C implementations, particularly for code generation tasks in a compiler or transformation pipeline.",
      "description_length": 398,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Soc2yaml",
      "library": "lustre-v6",
      "description": "Converts a specific entry from a `Soc.tbl` table into a YAML-formatted string and writes it to a file. Works with `Soc.key` and `Soc.tbl` types to serialize network configuration data. Useful for exporting individual firewall rules or network policies to YAML for storage or sharing.",
      "description_length": 283,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "FilenameExtras",
      "library": "lustre-v6",
      "description": "Simplifies file paths by resolving `.` and `..` components and normalizing slashes. Works with string representations of file paths. Useful for canonicalizing user-provided paths before file operations or logging.",
      "description_length": 213,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "SocPredef2cHeap",
      "library": "lustre-v6",
      "description": "This module generates C code snippets for specific operations based on predefined keys and expressions. It works with data types from the Soc module, including keys, expressions, and variables. Use cases include translating high-level operations like iterators, conditionals, and reductions into low-level C implementations.",
      "description_length": 324,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Dbg",
      "library": "lustre-v6",
      "description": "This module provides functions for printing and converting structured data to strings, primarily for debugging purposes. It works with data types such as `Lxm.t`, `AstCore.val_exp`, and `Lic.const`, offering direct visualizations of their internal structures. Concrete use cases include logging intermediate values during evaluation, displaying expressions in error messages, and formatting constants for inspection.",
      "description_length": 416,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LicPrg",
      "library": "lustre-v6",
      "description": "The module implements a structured representation of a compiled Lustre program using map-based storage for types, constants, and nodes. It provides operations to manipulate this structure through element insertion, lookup, iteration, and file serialization, alongside utilities like `fresh_type_id` to generate globally unique type identifiers during compilation. This data structure serves post-compilation tasks such as resolving static order dependencies, handling overloading, and enabling subsequent transformation phases like macro expansion.",
      "description_length": 548,
      "index": 74,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 76,
    "meaningful_modules": 75,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9868421052631579
  },
  "statistics": {
    "max_description_length": 807,
    "min_description_length": 213,
    "avg_description_length": 395.4,
    "embedding_file_size_mb": 0.2728710174560547
  }
}