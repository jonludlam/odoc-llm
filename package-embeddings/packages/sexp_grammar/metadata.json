{
  "package": "sexp_grammar",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 8,
  "creation_timestamp": "2025-06-18T16:31:58.733892",
  "modules": [
    {
      "module_path": "Sexp_grammar.Field",
      "description": "Maps elements of a container using a provided function, producing a new container with transformed values. Operates on a parameterized type that represents a structured collection of elements. Used to convert data formats in parsing pipelines or transform input before processing.",
      "description_length": 280,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sexp_grammar.Case_sensitivity",
      "description": "Handles case sensitivity settings for string comparisons, providing a comparator that respects specified case rules. Works with custom type `t` representing case sensitivity configurations. Used to ensure consistent string ordering in parsing or sorting scenarios where case matters.",
      "description_length": 283,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sexp_grammar.Fold_nonrecursive",
      "description": "This module provides operations for constructing and manipulating non-recursive grammar rules, focusing on atomic type creation (e.g., bool, int, string), type combination (union, list, option), and structured data definitions (record, variant). It works with a custom `t` type representing grammar rules and a `list_t` type for non-recursive structures, enabling precise control over parsing S-expressions without recursive elements. Use cases include building type-safe parsers for flat data formats or simplifying recursive grammar handling by isolating non-recursive components.",
      "description_length": 582,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Sexp_grammar.Fold_recursive",
      "description": "Provides functions to construct and manipulate grammar structures for parsing S-expressions, including primitives like booleans and integers, and composite types such as lists, options, and records. Works with custom types `t` for grammar rules and `list_t` for list-based structures. Used to define recursive parsing rules by combining elements like unions, records, and variants with controlled evaluation.",
      "description_length": 408,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sexp_grammar.Eager_copy",
      "description": "Converts S-expression grammars into eager equivalents by replacing lazy constructs. Operates on Sexp_grammar types, including list_grammar and standard grammar structures. Used to prepare grammars for S-expression serialization without deferred evaluation.",
      "description_length": 256,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sexp_grammar.Unroll_recursion",
      "description": "Converts typed and untyped grammars into an unfolded format by eliminating recursive, type constructor, and type variable nodes. Operates on Sexp-based grammar structures, replacing them with lazy-evaluated alternatives to prevent infinite expansion. Used to simplify grammar processing in contexts where type tracking is unnecessary or problematic.",
      "description_length": 349,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "sexp_grammar",
      "description": "Provides functions to inspect and manipulate S-expression grammar structures, including extracting constructors, fields, and type information from parsed S-expressions. Works with types generated by the `[@@deriving sexp_grammar]` attribute, such as variant and record representations. Used to validate S-expressions against parser definitions and to generate completion suggestions during interactive sessions.",
      "description_length": 411,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Sexp_grammar",
      "description": "The module provides functions for constructing and manipulating S-expression grammars, focusing on atomic values (e.g., booleans, characters), composite structures (e.g., options, lists, unions), and structured data (e.g., records, variants). It operates on S-expression types like `t` and `list_t`, with dedicated operations for list-based syntactic forms. Use cases include parsing or generating S-expressions for complex data hierarchies, requiring explicit handling of recursive elements outside its scope.",
      "description_length": 510,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 8,
    "meaningful_modules": 8,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 582,
    "min_description_length": 256,
    "avg_description_length": 384.875,
    "embedding_file_size_mb": 0.02943897247314453
  }
}