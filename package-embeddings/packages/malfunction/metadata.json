{
  "package": "malfunction",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 9,
  "creation_timestamp": "2025-06-18T16:31:29.943218",
  "modules": [
    {
      "module_path": "Malfunction_compat.Subst",
      "description": "Provides operations to create and manage a substitution map that replaces identifiers with lambda expressions. Works with the `t` type, which represents a mapping from identifiers to lambda terms. Used to perform variable substitution in lambda expressions during transformation or evaluation.",
      "description_length": 293,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Malfunction.IntArith",
      "description": "This module offers arithmetic operations (addition, subtraction, multiplication, division, modulus), bitwise manipulations, and logical operations on abstract integer-like values, alongside equality comparisons. It works with an abstract type `t` designed for numerical and bitwise processing, enabling tasks like numerical computation, bit-level adjustments, and value comparisons in systems requiring precise control over integer-like data. Specific use cases include implementing custom numeric algorithms, optimizing low-level data processing, and enforcing type-safe arithmetic in applications.",
      "description_length": 599,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "malfunction",
      "description": "Provides operations for constructing, manipulating, and analyzing low-level program representations, including term rewriting, type inference, and control flow analysis. Works with abstract syntax trees, labeled expressions, and raw OCaml bytecode. Used to implement compiler passes, optimize intermediate code, and debug translation errors in functional language implementations.",
      "description_length": 380,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Malfunction_compat",
      "description": "Manages identifier substitution in lambda expressions through a mapping system. It operates on the `t` type, enabling the replacement of variables with corresponding lambda terms. Functions include building, updating, and applying substitutions to transform expressions. This allows for efficient manipulation of bound variables during evaluation or optimization processes.",
      "description_length": 373,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Malfunction_parser",
      "description": "Parses S-expression representations into internal Malfunction abstract syntax trees, converting lexing buffers and S-expression data structures into executable module expressions. Processes nested expressions and symbolic representations to construct structured module definitions. Used to load and interpret Malfunction source code from text files or in-memory S-expression data.",
      "description_length": 380,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Malfunction_sexp",
      "description": "Parses S-expressions from a lexing buffer, distinguishing between complete and partial reads. Handles structured data represented as tagged tuples with position metadata and nested S-expression components. Outputs S-expressions in a formatted text representation suitable for debugging or logging.",
      "description_length": 297,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Malfunction",
      "description": "provides arithmetic, bitwise, and logical operations on an abstract integer-like type `t`, supporting addition, subtraction, multiplication, division, modulus, and equality checks. It enables precise manipulation of numerical values and bit patterns, allowing for custom algorithm implementation and low-level data optimization. Users can perform type-safe computations, adjust bit-level data, and enforce strict numerical constraints. Examples include implementing cryptographic functions, optimizing data serialization, and building domain-specific numeric systems.",
      "description_length": 567,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Malfunction_compiler",
      "description": "Handles removal of temporary files and compilation of OCaml modules into various output formats, including bytecode and native code. Operates on module expressions, filenames, and custom options that control compilation behavior such as verbosity and linking. Used to generate executable files from source code and dynamically load compiled modules.",
      "description_length": 349,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Malfunction_interpreter",
      "description": "Evaluates Malfunction abstract syntax trees into executable values and converts those values into S-expression representations. It processes nested data structures and symbolic expressions inherent to the Malfunction language. Used to execute and visualize program states during debugging or runtime analysis.",
      "description_length": 309,
      "index": 8,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 9,
    "meaningful_modules": 9,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 599,
    "min_description_length": 293,
    "avg_description_length": 394.1111111111111,
    "embedding_file_size_mb": 0.03314781188964844
  }
}