{
  "package": "vue-jsoo",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 23,
  "creation_timestamp": "2025-08-15T14:17:32.190014",
  "modules": [
    {
      "module_path": "Vue_router.Internal",
      "library": "vue-jsoo.router",
      "description": "This module defines JavaScript-compatible route and router configurations for Vue applications. It provides functions to construct route objects with properties like components, redirects, and navigation hooks, as well as utilities to create router instances with specific modes and versions. Concrete use cases include setting up client-side routing with component mappings, redirects, and async navigation guards.",
      "description_length": 415,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vue_router.Tables",
      "library": "vue-jsoo.router",
      "description": "This module manages route definitions for a web application, providing operations to add and merge routes into a global list. It works with route objects represented as `(Mjs.top, Mjs.top) route Mjs.t` values. Concrete use cases include registering new routes dynamically and combining multiple route sets during application initialization.",
      "description_length": 340,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vue_router.Route",
      "library": "vue-jsoo.router",
      "description": "This module enables constructing Vue.js routes with typed components by adding methods, watchers, computed properties, and merging route hierarchies. It operates on route data structures using binding tables and functions to bridge JavaScript-compatible logic with OCaml type safety, ensuring validated component inputs and dynamic route composition for complex application architectures.",
      "description_length": 388,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vue_router",
      "library": "vue-jsoo.router",
      "description": "This module implements client-side routing for Vue.js applications with typed route definitions, redirects, and navigation hooks. It provides functions to create routers with specific modes, push or replace routes, and register pre- and post-navigation hooks that handle async validation and route resolution. Concrete use cases include setting up dynamic route mappings with component bindings, enforcing navigation guards for authentication, and managing route hierarchies in large-scale SPAs.",
      "description_length": 495,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vue_component.Make",
      "library": "vue-jsoo.component",
      "description": "This module defines a functor for creating Vue components with strict type checking of input data. It provides functions to register component methods, watchers, computed properties, and nested components, along with utilities to merge configuration lists and construct the final component. It works with data types such as `Mjs.t`, `Vue_component.Internal.component_arg`, and `Vue_component.component`, and is used to build type-safe Vue components with defined data, lifecycle hooks, and inter-component relationships.",
      "description_length": 520,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vue_component.Internal",
      "library": "vue-jsoo.component",
      "description": "This module defines low-level operations for constructing and manipulating Vue component arguments in JavaScript interop. It includes functions to convert OCaml component configurations into JavaScript-compatible structures, handle props, lifecycle hooks, directives, and templates. It works directly with JavaScript objects, arrays, and callbacks to interface with Vue's runtime.",
      "description_length": 380,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vue_component.Tables",
      "library": "vue-jsoo.component",
      "description": "This module defines tables for managing Vue component methods, watchers, computed properties, and child components, using a parameterized scope type. It provides functions to add methods with varying argument counts, define watchers and computed values, and register components with their configuration. Use it to declaratively build Vue component logic that integrates with the underlying JavaScript interop system.",
      "description_length": 416,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vue_component",
      "library": "vue-jsoo.component",
      "description": "This module defines data structures and functions to declare Vue component props with specific types, validators, and defaults, and to construct full component definitions with templates, data, methods, lifecycle hooks, and directives. It works directly with JavaScript interop types like `Mjs.any`, callbacks, and objects to interface with Vue's runtime. Concrete use cases include defining strongly-typed props for component inputs, registering Vue components with OCaml-defined logic, and integrating Vue templates and lifecycle hooks into OCaml code.",
      "description_length": 554,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vue_nav",
      "library": "vue-jsoo.component",
      "description": "This module handles navigation state in a Vue.js application by constructing and manipulating route objects with paths, parameters, and query strings. It provides functions to convert between OCaml and JavaScript representations of navigation data and extract query or parameter values. Concrete use cases include implementing custom navigation guards and building type-safe route transitions.",
      "description_length": 393,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vue_js.Root",
      "library": "vue-jsoo",
      "description": "This module supports creating Vuex-style state stores with typed operations for registering getters, mutations, and actions, while managing mappings between named operations and implementations using tables. It configures Vue.js instances with reactive properties, components, and routes through direct bindings to Vue's core data structures like `Mjs.t` and `Vue_router.route`, enabling patterns such as computed values and watchers. Typical use cases include setting up fully-featured Vue applications with integrated state management, dynamic component routing, and reactivity-driven UI updates.",
      "description_length": 598,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vue_js.Make",
      "library": "vue-jsoo",
      "description": "This module enables type-safe construction and configuration of Vue components through operations that manage methods, computed properties, watchers, and nested components, using typed tables and callbacks to enforce data integrity. It provides mechanisms to mount and retrieve fully typed Vue instances with customizable configuration options, ensuring type-correct interactions with Vue's lifecycle and state management features. It is particularly useful for building hierarchical Vue applications in OCaml where compile-time type guarantees are required for component data, props, and application state.",
      "description_length": 607,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vue_js.Router",
      "library": "vue-jsoo",
      "description": "This functor enables type-checked component creation, route registration, and merging strategies for Vue applications. It operates on typed data structures, Vue component hierarchies, and route definitions, while integrating with Vue instances, routers, and stores. Typical use cases include initializing applications with validated route configurations, dynamically composing components with reactive data, and ensuring type safety across Vue's ecosystem.",
      "description_length": 456,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vue_js.SPA",
      "library": "vue-jsoo",
      "description": "This module facilitates Vuex-like state management through operations to register and manage **getters**, **mutations**, **actions**, and **modules**, which manipulate typed **state** and **data** structures. It integrates routing capabilities by exposing utilities to access and inspect typed **route** data, including parameters and navigation context, while supporting component composition with **computed properties**, **watchers**, and **two-way data binding**. These features are ideal for building scalable single-page applications with modular state logic, dynamic route handling, and reactive UI components.",
      "description_length": 617,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vue_js",
      "library": "vue-jsoo",
      "description": "This module provides operations to construct and manage Vue.js components and applications with strong type safety, supporting features like reactive data, computed properties, watchers, and lifecycle hooks. It works with typed tables, Vue instances, routers, and stores to enable precise configuration of components and application state. Concrete use cases include building type-safe Vue applications with hierarchical components, integrating route-aware logic, and managing reactive state with compile-time guarantees.",
      "description_length": 521,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vue_chartjs",
      "library": "vue-jsoo.chartjs",
      "description": "This module creates and configures Chart.js-based Vue components for rendering line and bar charts. It works with JavaScript objects and strings to define chart types and their data. Concrete use cases include integrating interactive line and bar charts into Vue applications using Chart.js under the hood.",
      "description_length": 306,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Version",
      "library": "vue-jsoo.version",
      "description": "This module defines a version type with two variants, `v2` and `v3`, and provides a global reference to track the current version. It includes a function to set the version globally. This module is useful for applications needing to switch behavior based on a selected version, such as protocol implementations or feature toggles.",
      "description_length": 330,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Mjs",
      "library": "vue-jsoo.mjs",
      "description": "This module enables seamless interoperability between OCaml and JavaScript by providing utilities to handle JS-compatible optional values (null/undefined), type conversions (numbers, strings, arrays), and error propagation. It operates on OCaml representations of JavaScript values, supporting operations like regular expression construction, array manipulation, date initialization, and bidirectional type coercion, while exposing JS globals like Math and JSON. Key use cases include wrapping JS callbacks for OCaml consumption, normalizing data structures across both languages, and debugging JS interactions through type inspection and logging tools.",
      "description_length": 653,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vuex.Module",
      "library": "vue-jsoo.vuex",
      "description": "This module defines a Vuex store structure by registering state, getters, mutations, actions, and nested modules. It supports operations to dynamically add or merge these components, enabling modular and scalable state management. Use cases include organizing application state into reusable modules, implementing scoped state transformations, and structuring complex applications with nested state trees.",
      "description_length": 405,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vuex.Internal",
      "library": "vue-jsoo.vuex",
      "description": "This module provides functions to convert between internal JavaScript representations and OCaml types for state management, including creating store instances, transforming action inputs, and mapping mutations. It works with JavaScript objects and OCaml variants representing state, getters, actions, and mutations. Concrete use cases include initializing a Vuex store from OCaml-defined options and bridging OCaml actions with JavaScript-compatible formats.",
      "description_length": 458,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vuex.Tables",
      "library": "vue-jsoo.vuex",
      "description": "This module manages state, getters, mutations, actions, and submodules for a Vuex store using tables to map named operations to their implementations. It supports defining and registering individual getters, mutations, and actions with optional binding to computed properties or methods, and allows bulk merging of multiple entries. Concrete use cases include structuring complex state logic with modularized actions and organizing store components for scalable Vue applications.",
      "description_length": 479,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Vuex.Make",
      "library": "vue-jsoo.vuex",
      "description": "This module implements a Vuex store with typed state, getters, mutations, actions, and modules. It allows defining and registering store components dynamically, mapping getters and actions to computed properties and methods. It supports merging and initializing store elements with options like plugins, strict mode, and devtools integration.",
      "description_length": 342,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vuex.Map",
      "library": "vue-jsoo.vuex",
      "description": "This module provides functions to bind and access state, getters, mutations, and actions from a Vuex store using optional namespaces and string paths. It works with `'a Mjs.table` values, which represent JavaScript objects in ReasonML/OCaml. Use this module to directly interact with Vuex store properties without manually writing accessors or dispatchers.",
      "description_length": 356,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Vuex",
      "library": "vue-jsoo.vuex",
      "description": "This module provides operations to initialize a state store, manipulate state, dispatch mutations and actions, register modules, and apply hot updates. It operates on OCaml representations of JavaScript objects and state management components, supporting structured data flows through dynamic module composition and scoped state transformations, ideal for organizing complex application logic.",
      "description_length": 393,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 62,
    "meaningful_modules": 23,
    "filtered_empty_modules": 39,
    "retention_rate": 0.3709677419354839
  },
  "statistics": {
    "max_description_length": 653,
    "min_description_length": 306,
    "avg_description_length": 453.1304347826087,
    "embedding_file_size_mb": 0.3337383270263672
  }
}