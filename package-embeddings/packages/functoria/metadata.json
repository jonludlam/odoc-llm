{
  "package": "functoria",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 26,
  "creation_timestamp": "2025-08-15T12:27:01.330458",
  "modules": [
    {
      "module_path": "Functoria.Device.Graph",
      "library": "functoria",
      "description": "This module represents a directed acyclic graph of devices, where each node contains a device implementation, its dependencies, and configuration arguments. It provides operations to fold over the graph in topological order and generate valid OCaml variable and module names for each node. It is used to model and traverse device configurations in a way that respects dependency constraints.",
      "description_length": 391,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Functoria.Action.Syntax",
      "library": "functoria",
      "description": "Implements monadic and applicative syntax for composing actions that may perform system operations with a dry-run mode. Works with `Functoria.Action.t` values, enabling sequential composition and transformation of effectful computations. Useful for writing complex file manipulations or command executions while supporting simulation without side effects.",
      "description_length": 355,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Key.Alias",
      "library": "functoria",
      "description": "This module defines virtual command-line keys that map to other keys during configuration. It supports creating aliases with optional value transformations and adding configure-only boolean flags. Use it to expose alternate names or shorthand options for existing configuration parameters without runtime effects.",
      "description_length": 313,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Impl.Tbl",
      "library": "functoria",
      "description": "This module implements a hash table mapping abstract keys to arbitrary values, supporting insertion, lookup, deletion, iteration, folding, and in-place filtering operations, with updated variants aligning with newer OCaml standards. It provides bulk creation and modification capabilities from key-value sequences, optimized for scenarios like dependency tracking or configuration systems where abstract identifiers require efficient associative storage and dynamic updates.",
      "description_length": 474,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Action.Infix",
      "library": "functoria",
      "description": "This module provides infix operators for sequencing and transforming actions in a monadic context. It works with values of type `'a Functoria.Action.t`, enabling chaining of operations with `>>=` and mapping results with `>|=`. Concrete use cases include composing file system operations with dry-run support and structuring complex action workflows.",
      "description_length": 350,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Key.Set",
      "library": "functoria",
      "description": "This module offers standard set operations such as union, intersection, and difference, along with functions to add, remove, and check membership of elements. It works with a sorted set structure over ordered configuration keys, ensuring ordered traversal and supporting transformations like map and filter, as well as conversions to and from sequences. These features are particularly useful for managing unique runtime parameters and command-line arguments where ordering, uniqueness, and efficient lookups are crucial.",
      "description_length": 521,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Lib.Make",
      "library": "functoria",
      "description": "This module provides the `register` function to define and configure applications by specifying jobs, packages, keys, and initialization logic. It operates on data types like `package`, `abstract_key`, and `job impl` from the `Functoria.DSL`. Use it to assemble and register custom applications that generate configuration code based on selected targets and build parameters.",
      "description_length": 375,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Key.Arg",
      "library": "functoria",
      "description": "This module defines converters and metadata for cross-stage command-line arguments, supporting typed values like strings, booleans, integers, lists, and options. It provides functions to declare optional, required, and flag arguments with stage-specific behavior for configuration and runtime. Use cases include passing unikernel parameters consistently across stages and generating OCaml expressions from argument values.",
      "description_length": 422,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Action.List",
      "library": "functoria",
      "description": "Implements list traversal and transformation operations within the Functoria.Action context. Works directly with lists of values in action-returning functions, enabling sequential execution of effects across collections. Useful for processing multiple file paths, command-line arguments, or configuration items with side effects while supporting dry-run simulation.",
      "description_length": 365,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Tool.Make",
      "library": "functoria",
      "description": "This module provides functions to run a configuration builder that parses command-line arguments and generates code. It works with command-line arguments as a string array and uses formatters for error and help output. Concrete use cases include building CLI tools that assemble functors based on user input and generating corresponding code for specific configurations.",
      "description_length": 370,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Impl",
      "library": "functoria",
      "description": "This module implements type-erased module values with support for functor application, conditional selection, and pattern matching over key values. It works with abstract module implementations, devices, and dependency graphs, enabling construction and manipulation of compile-time configuration logic. Concrete use cases include building and simplifying device graphs based on runtime keys, generating dot representations for visualization, and collecting metadata across module hierarchies.",
      "description_length": 492,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Cli",
      "library": "functoria",
      "description": "This module handles command-line parsing and evaluation for applications, supporting operations like extracting output paths, evaluating subcommands, and configuring terminal settings via flags. It works with string arrays as input arguments and provides structured types for actions, queries, and argument configurations. Concrete use cases include parsing global options like `--output`, `--eval`, and subcommands such as `configure`, `build`, and `clean`, with support for custom command-line extensions via `Cmdliner`.",
      "description_length": 522,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Info",
      "library": "functoria",
      "description": "This module manages metadata about an application, including its name, main file, output path, dependencies, and configuration keys. It provides accessors to retrieve and modify properties like libraries, packages, and command-line arguments, along with generating OPAM files based on the application's configuration. It is used to configure and build MirageOS applications by capturing and propagating build-time information.",
      "description_length": 426,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Engine",
      "library": "functoria",
      "description": "This module processes abstract implementation graphs to extract configuration details and generate build artifacts. It provides functions to retrieve keys, packages, installed files, and Dune stanzas, as well as triggering configuration and connection hooks during the build process. Use cases include assembling MirageOS unikernels by resolving dependencies and generating the necessary build files and runtime code.",
      "description_length": 417,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Tool",
      "library": "functoria",
      "description": "This module enables the construction of CLI tools that assemble functors by parsing command-line arguments and generating code. It operates on string arrays representing command-line inputs and utilizes formatters for handling errors and help output. It is used to create configurable command-line interfaces that map user input to functor instantiations and generate corresponding code.",
      "description_length": 387,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Install",
      "library": "functoria",
      "description": "This module defines installation rules for promoting files during package builds, specifying source-to-destination mappings for binaries and configuration files. It supports combining rules, printing them in various formats (dune, opam, install), and creating empty or unioned rule sets. It is used to generate build configuration files that ensure installed files are correctly placed and tracked during package installation and promotion.",
      "description_length": 440,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Lib",
      "library": "functoria",
      "description": "This module enables defining and configuring applications through the `register` function, which assembles jobs, packages, keys, and initialization logic. It works with data types such as `package`, `abstract_key`, and `job impl` from the `Functoria.DSL` to generate configuration code tailored to specific build targets. Use it to construct custom applications that link with `config.ml` for deployment or further compilation.",
      "description_length": 427,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Type",
      "library": "functoria",
      "description": "This module represents module signatures as first-class values, enabling the construction and manipulation of functor types through combinators like `@->`. It works with abstract types that model OCaml module signatures, including built-in representations for common types like `job`, `argv`, and `info`. It is used to define and validate the structure of modules in a type-safe way, particularly when generating module implementations from specifications.",
      "description_length": 456,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Opam",
      "library": "functoria",
      "description": "This module constructs and formats Opam package configurations for MirageOS unikernels. It defines types for package dependencies, build instructions, and source specifications, supporting targets like switches and monorepos. Use it to generate `.opam` files programmatically when building or installing Mirage projects.",
      "description_length": 320,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Device",
      "library": "functoria",
      "description": "This module implements a directed acyclic graph of device configurations, where each node holds a device implementation, its dependencies, and configuration arguments. It provides operations to fold over the graph in topological order and generate valid OCaml variable and module names for each node. The graph structure ensures that device initialization respects dependency constraints during code generation and configuration.",
      "description_length": 429,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Key",
      "library": "functoria",
      "description": "This module supports defining and managing typed command-line arguments with dependency tracking, enabling structured parsing and dynamic evaluation across configuration and runtime stages. It operates on configuration keys, contexts for merging and default handling, and sets for dependency relationships, while generating code to bridge these configurations with command-line interface logic. Key use cases include orchestrating parameter parsing, resolving conditional or aliased values, and producing executable CLI components from declarative key definitions.",
      "description_length": 564,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Dune",
      "library": "functoria",
      "description": "This module constructs and manipulates Dune configuration files using types and formatters. It provides functions to create stanzas, format lists compactly, and generate minimal base configurations for projects and workspaces. Concrete use cases include generating `dune`, `dune-project`, and `dune-workspace` files tailored to specific package and build settings.",
      "description_length": 364,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Package",
      "library": "functoria",
      "description": "This module represents and manipulates opam packages, allowing creation and modification of package values with attributes like scope, build-time dependency status, sublibraries, version constraints, and pinning. It works with a concrete type `t` representing a package, along with scopes (`Switch` or `Monorepo`) and string lists for libraries and versions. Use cases include constructing package dependencies for MirageOS unikernels, specifying version ranges for compatibility, and handling pinned development packages in build configurations.",
      "description_length": 546,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria.Action",
      "library": "functoria",
      "description": "This module provides monadic operations for file system manipulation (creation, deletion, existence checks), environment variable handling, and shell command execution, all with built-in dry-run simulation capabilities. It works with file paths (`Fpath.t`), shell command representations (`Bos.Cmd.t`), and custom environment/file state types, leveraging applicative combinators like `map` and `bind` to compose sequences of effectful actions. The features are particularly useful in build systems, deployment scripts, or configuration management tools where safe, simulated execution of file and system operations is critical before applying real changes.",
      "description_length": 656,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Functoria",
      "library": "functoria",
      "description": "This module provides abstractions for constructing modular functors and dependency graphs, with operations for conditional composition (`if_impl`, `match_impl`), package/device management (`foreign`, `main`), and build artifact generation. It works with types like `typ`, `impl`, `key`, `package`, and Dune stanza structures, orchestrating MirageOS unikernel configurations through functor application (`@->`, `$`) and effectful actions. Use cases include compiling device dependency trees, generating `.opam`/`dune` files, and handling CLI-driven configurations with dry-run support.",
      "description_length": 584,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Functoria_test",
      "library": "functoria.test",
      "description": "This module provides a `run` function that executes a Functoria implementation within a given context, optionally initializing with a list of jobs and keys. It operates on Functoria's DSL types, including context, implementations, and keys. Use it to test and evaluate Functoria-based configurations in a controlled environment.",
      "description_length": 328,
      "index": 25,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 26,
    "meaningful_modules": 26,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 656,
    "min_description_length": 313,
    "avg_description_length": 434.38461538461536,
    "embedding_file_size_mb": 0.37714672088623047
  }
}