{
  "package": "hardcaml_step_testbench",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 245,
  "creation_timestamp": "2025-08-18T19:59:11.023620",
  "modules": [
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Component.Input_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing input-driven simulation steps in a hardware description context. It supports values wrapped in a custom monad representing simulation actions, enabling sequential composition with `bind`, value injection with `return`, transformation with `map`, and parallel execution with `both`. Concrete use cases include building and chaining signal propagation steps and input event sequences in digital circuit simulations.",
      "description_length": 467,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Component.Input_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing input-driven simulations in a step-based environment. It supports values wrapped in a monad representing simulation steps, enabling sequencing with `bind`, transforming values with `map`, combining parallel actions with `both`, and returning pure values with `return`. Concrete use cases include building and chaining signal transitions, modeling circuit input behavior, and synchronizing events in hardware simulation workflows.",
      "description_length": 483,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Component.Input_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing input signal simulations in a hardware description context. It supports values of type `t` representing input signals, with functions like `return`, `bind`, `map`, and `both` to sequence and transform signal values. Concrete use cases include building step-based testbenches where input signals are generated and combined over simulation cycles.",
      "description_length": 399,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Component.Input_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing input simulations in a cycle-accurate testing environment. It supports values wrapped in an input monad specific to component-based simulations, enabling sequencing of register transfers and signal updates. Concrete use cases include building testbenches that model hardware register behavior, where `bind` and `map` sequence and transform input signals, and `both` combines two input signals into a tuple within the same simulation context.",
      "description_length": 495,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Input_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing input-driven simulation steps in a hardware description context. It supports values of type `t`, representing computations that can be sequenced with `bind`, transformed with `map`, and combined pairwise with `both`. Concrete use cases include building testbenches that drive signal inputs through time-ordered simulation steps, enabling precise control over event timing and dependencies.",
      "description_length": 443,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Input_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing input simulation steps in a cycle-accurate testbench. It supports values wrapped in a step monad, enabling sequential composition with `bind`, value injection with `return`, transformation with `map`, and parallel combination with `both`. It is used to define input behaviors for hardware simulation, where each step represents a value that evolves over simulation cycles.",
      "description_length": 426,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Component.Flip_flop_with_load_enable.Input",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a flip-flop input structure with `input` and `load_enable` boolean fields. It provides serialization to S-expressions, equality checking, and an undefined value for testing or initialization. Concrete use cases include modeling register behavior in digital circuits where conditional loading is required.",
      "description_length": 324,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Input_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing input simulation steps in a functional event-driven simulation. It supports values of type `Input_monad.t`, enabling sequential composition with `bind`, value injection with `return`, transformation with `map`, and parallel execution with `both`. Concrete use cases include building complex signal sequences and synchronizing input events in hardware simulation testbenches.",
      "description_length": 428,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Component.Input_monad.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module defines monadic composition operators for sequencing input-driven simulation steps in a hardware description context. It works with values wrapped in the `Input_monad.t` type, enabling chaining of stateful operations that model hardware component interactions over simulation cycles. Concrete use cases include building complex testbenches by combining signal updates and clock cycle advancements in a sequential, composable manner.",
      "description_length": 444,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Component.Flip_flop_with_load_enable_and_reset.Input",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a flip-flop input interface with explicit control signals for data input, load enable, and reset. It provides operations to serialize the input state to S-expressions, compare input values for equality, and obtain an undefined input value for initialization purposes. The module is used to model register behavior in cycle-accurate hardware simulations where controlled state transitions are required.",
      "description_length": 421,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Component.Input_monad.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing input-driven simulation steps in hardware description contexts. It supports values wrapped in a custom monad representing simulation actions, enabling sequential composition with `bind`, value injection with `return`, transformation with `map`, and parallel execution with `both`. Concrete use cases include building and chaining signal propagation steps and input event sequences in digital circuit simulations.",
      "description_length": 466,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Component.Flip_flop_with_load_enable.Input",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a flip-flop input type with a data signal and a load enable signal, supporting operations to serialize, compare, and create undefined values. It works with boolean signals to model input behavior in event-driven simulations. Concrete use cases include modeling register inputs in digital circuits where conditional updates are required.",
      "description_length": 356,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Component.Input_monad.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic combinators for constructing and transforming input signal simulations in a cycle-accurate testbench environment. It operates on values of type `t` representing input signals, supporting composition through `return`, `bind` (`>>=`), `map` (`>>|`), and parallel combination with `both`. It is used to define sequences of input stimuli applied to hardware components during simulation, such as clocked signal patterns or input vector transitions.",
      "description_length": 473,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Component.Flip_flop_with_load_enable_and_reset.Input",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a structured input type for a flip-flop component with fields for data input, load enable, and reset signals. It includes functions to serialize the input to an S-expression, compare two inputs for equality, and provide an undefined input value. This module is used to model control and data inputs for simulation of flip-flop behavior in digital circuits.",
      "description_length": 376,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Component.Input_monad.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic composition for input-driven simulations, supporting `bind`, `map`, and `return` operations on values in a step-based simulation monad. It works with simulation steps that model hardware signal transitions and input events. Concrete use cases include sequencing input stimuli, transforming signal values across simulation steps, and synchronizing event-driven behavior in circuit testing.",
      "description_length": 417,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Component.Input_monad.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module defines monadic composition operators for sequencing input-driven simulation steps in a functional event-driven testbench. It works with values wrapped in the `Input_monad.t` type, enabling chaining of operations that represent hardware input events over time. Concrete use cases include building complex input stimulus sequences for digital circuit simulation, such as applying clock signals followed by data inputs in a pipelined register setup.",
      "description_length": 459,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Input_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing input simulation steps in a cycle-accurate testbench. It works with values wrapped in the `Input_monad.t` type, allowing sequential composition of input generation logic using `bind`, value injection with `return`, and parallel combination of two input steps with `both`. Concrete use cases include building complex input sequences for hardware simulation, such as feeding test vectors into a design under test over multiple clock cycles.",
      "description_length": 492,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Component.Flip_flop_with_load_enable.Input",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a flip-flop input structure with a data signal and a load enable control. It provides operations for creating, comparing, and serializing input values. Used to model register behavior in cycle-accurate simulations where conditional updates are required.",
      "description_length": 273,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Component.Input_monad.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module defines monadic composition operators for sequencing input operations in a cycle-accurate simulation environment. It provides `>>=` for chaining input actions that depend on prior results and `>>|` for transforming outputs of input actions without side effects. These operations are used to build complex input stimulus patterns for hardware simulation components.",
      "description_length": 376,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Component.Input_monad.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module defines monadic composition operators for sequencing input-driven simulation steps in a hardware description context. It provides the `>>=` and `>>|` operators to chain computations that produce values within the input monad, enabling precise control over simulation event ordering. Use this when building testbenches that require step-by-step manipulation of input signals in an event-driven simulation environment.",
      "description_length": 428,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Component.Flip_flop_with_load_enable_and_reset.Input",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a flip-flop input structure with boolean fields for data input, load enable, and reset. It provides operations to serialize the structure to S-expressions, compare instances for equality, and create an undefined instance. It is used to model control and data signals in digital circuit simulations involving state elements with conditional updates and resets.",
      "description_length": 379,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Component.Flip_flop_with_load_enable.Input",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a flip-flop input type with a data signal and a load enable control. It supports operations for checking equality, generating S-expressions, and providing an undefined value for initialization. It is used to model conditional state updates in cycle-accurate simulations of digital circuits.",
      "description_length": 310,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Component.Input_monad.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic composition for input signal simulations in a cycle-accurate testbench. It works with values wrapped in an input monad for component-based simulations, allowing sequencing and transformation of register transfers and signal updates. Use it to model hardware register behavior in testbenches, where `bind` sequences input steps, `map` transforms signals, and `both` combines two signals into a tuple within the same simulation context.",
      "description_length": 463,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Component.Flip_flop_with_load_enable_and_reset.Input",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a flip-flop input interface with explicit control signals for load enable and reset. It includes operations for comparing input values, converting them to S-expressions, and providing an undefined input value for testing or initialization. This structure is used to model register behavior in digital circuits where conditional updates and resets are required.",
      "description_length": 380,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Input_monad.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing input simulation steps in a cycle-accurate testbench. It supports values wrapped in a step monad, enabling sequential composition with `bind`, value injection with `return`, transformation with `map`, and parallel combination with `both`. It is used to define input behaviors for hardware simulation, where each step represents a value that evolves over simulation cycles.",
      "description_length": 426,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for sequencing and transforming values within a step-based simulation context. It supports imperative-style composition of actions that manipulate time-dependent signals and events, enabling precise control over simulation steps. Concrete use cases include modeling hardware behavior with timed dependencies, composing event-driven logic, and writing testbenches that require explicit step management.",
      "description_length": 441,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Output.All",
      "library": "hardcaml_step_testbench",
      "description": "Converts a collection of output signals from a functional simulation into a structured format where each signal is accessible by its corresponding module instance. Works with `'a M.t Output.t` values, extracting and organizing them into a record of outputs indexed by module. Useful for validating testbench results by comparing expected and simulated outputs per module instance in event-driven simulations.",
      "description_length": 408,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Output.Of_bits",
      "library": "hardcaml_step_testbench",
      "description": "This module provides functions for manipulating bit-level signals in a hardware simulation context. It supports operations like packing/unpacking bits, multiplexing, concatenation, and priority/one-hot selection with optional branching factors. Concrete use cases include modeling digital circuits, testbenches, and signal routing logic where precise bit-level control is required.",
      "description_length": 381,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Logic.Uop",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for performing arithmetic and comparison operations on `Logic.t` values, including addition, subtraction, multiplication, and comparisons like less than or equal to. It supports data manipulation and signal conversion with functions like `of_signal` and `to_signal`, enabling direct transformation and resizing of logic signals. These operations are used to model and simulate digital logic circuits with precise signal behavior.",
      "description_length": 461,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Component.Flip_flop_with_load_enable_and_reset",
      "library": "hardcaml_step_testbench",
      "description": "This module implements a flip-flop component with load enable and reset functionality. It provides a `create` function that initializes the flip-flop and defines behavior for updating its state based on input signals. It works with the `Input` structure containing data, load enable, and reset booleans, and is used to model sequential logic elements in digital circuit simulations where conditional state updates and resets are required.",
      "description_length": 438,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Logic.Unsigned",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for performing unsigned arithmetic and comparisons on logic signals in a hardware simulation context. It supports addition, subtraction, multiplication, and comparison operators like less than, greater than, and equality, all working on the `v` type representing unsigned logic values. It is used to model and simulate digital circuits where unsigned integer behavior is required, such as counters, arithmetic units, or control logic.",
      "description_length": 466,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Component.Next_input",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a monadic structure for sequencing input events in a simulation, specifically handling transitions between simulation steps. It works with input types `'i` and wraps them in a `t` type that supports monadic operations like `bind` and `return`. Concrete use cases include modeling step-based hardware input behavior, such as feeding a sequence of values to a circuit under test at specific simulation times.",
      "description_length": 426,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Input.Make_comb",
      "library": "hardcaml_step_testbench",
      "description": "This module implements combinational logic operations for signal manipulation in a hardware simulation context. It supports operations like packing/unpacking signals to/from a `comb` type, multiplexing, concatenation, and priority/one-hot selection with optional branching factors. It works with signal values represented as `comb Input.t` and is used for constructing and validating signal transformations in testbenches.",
      "description_length": 422,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Output.Names_and_widths",
      "library": "hardcaml_step_testbench",
      "description": "This module provides direct access to metadata about simulation output ports, including their names, widths, and associated tags. It exposes lists of port names, widths, and tags as separate values for inspection or iteration. Useful for generating reports, validating expected output structure, or driving external tooling based on simulation interface details.",
      "description_length": 362,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Component.Flip_flop_with_load_enable",
      "library": "hardcaml_step_testbench",
      "description": "This module implements a flip-flop component with load enable functionality, providing a `create` function to instantiate it in a step-based simulation. It works with boolean signals to control data input and load enable, allowing conditional state updates on each simulation step. Concrete use cases include modeling registers that update their stored value only when the load enable signal is active.",
      "description_length": 402,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Component.Input_monad",
      "library": "hardcaml_step_testbench",
      "description": "This module implements monadic operations for sequencing and transforming input signal simulations in a cycle-accurate testbench environment. It works with values wrapped in the `Input_monad.t` type, representing stateful simulation steps that model hardware component inputs over time. Concrete use cases include composing testbench signal updates, advancing simulation cycles, and modeling register transfers in a structured, composable way.",
      "description_length": 443,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Component.Next_input",
      "library": "hardcaml_step_testbench",
      "description": "Converts a value of type `'i` to an S-expression using the provided function, specifically for serializing input values in a step monad simulation. Works with the `Next_input` module's data type, which represents inputs to be applied in the next simulation step. Useful for debugging or logging input values during hardware simulation cycles.",
      "description_length": 342,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Input.All",
      "library": "hardcaml_step_testbench",
      "description": "This module provides a function `all` that transforms a structured input of type `'a M.t Input.t` into an `'a Input.t M.t`, effectively reorganizing input data across a module `M`. It works with input signals structured under a module type `M` and is useful for aggregating or redistributing input values in a simulation environment. A concrete use case includes preparing input data for event-driven simulations where inputs must be mapped across multiple components or test scenarios.",
      "description_length": 486,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Component.Flip_flop_with_load_enable_and_reset",
      "library": "hardcaml_step_testbench",
      "description": "This module implements a flip-flop component with load enable and reset functionality using a step monad for simulation. It operates on input signals including data, load enable, and reset, and maintains internal state to model sequential behavior in digital circuits. Concrete use cases include simulating register behavior in hardware designs where conditional updates and resets are required.",
      "description_length": 395,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Output.Of_always",
      "library": "hardcaml_step_testbench",
      "description": "This module provides functions to manipulate and assign values to hardware description signals in an imperative simulation context. It supports operations like reading variable values, assigning signals to variables, creating registers and wires with specified behavior. These functions are used to model synchronous and combinational logic in hardware designs, such as implementing register transfers or signal assignments in a testbench.",
      "description_length": 439,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Input.Make_comb",
      "library": "hardcaml_step_testbench",
      "description": "This module provides functions for manipulating input signals in a combinatorial simulation, including packing/unpacking values, multiplexing, concatenation, and selection operations. It works with combinatorial logic types (`comb`) and input interfaces (`Input.t`). Concrete use cases include building testbenches that drive simulation inputs, modeling digital circuits with fixed or dynamic signal widths, and validating signal integrity in hardware designs.",
      "description_length": 460,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Output.Of_signal",
      "library": "hardcaml_step_testbench",
      "description": "This module supports operations for composing and transforming structured signals in hardware simulations, including combinators for bit-level manipulation (`pack`, `concat`, `mux`), sequential element creation (`reg`, `pipeline`), and signal assignment (`<==`). It works with `Output.Of_signal.t` and `comb` types to model hierarchical digital circuits, enabling use cases like testbench validation, pipeline construction, and signal routing with customizable naming conventions to manage hierarchical signal relationships.",
      "description_length": 524,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Component.Input_monad",
      "library": "hardcaml_step_testbench",
      "description": "This module implements monadic operations for constructing and composing input signal simulations in a cycle-accurate testbench. It provides functions like `bind`, `map`, and `return` to sequence and transform input actions, and supports parallel execution with `all` and `both`. These operations are used to define precise input stimulus sequences, such as clocked data transitions or synchronized signal patterns, applied to hardware components during simulation.",
      "description_length": 465,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Output.Of_always",
      "library": "hardcaml_step_testbench",
      "description": "This module provides functions to manipulate and simulate event-driven hardware descriptions using signals and registers. It supports operations like assigning values to variables, creating registers with optional enable signals, and generating named wires. Concrete use cases include building and testing digital circuits where signal propagation and register updates are triggered by specific events.",
      "description_length": 402,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Input.Of_bits",
      "library": "hardcaml_step_testbench",
      "description": "This module provides functions for constructing and manipulating bit vector inputs in a hardware simulation context. It supports operations like packing/unpacking bit vectors, multiplexing, concatenation, and priority/one-hot selection, all working directly with `Input.Of_bits.comb` values. Concrete use cases include defining stimulus generators, test vectors, and interface adapters for digital circuit simulation.",
      "description_length": 417,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Input.Names_and_widths",
      "library": "hardcaml_step_testbench",
      "description": "This module defines and exposes input signal metadata for simulation, including port names paired with their bit widths, separate lists of port names and widths, and input tags. It works with basic data types like strings, integers, and lists to describe hardware interface properties. Concrete use cases include configuring testbenches, validating signal mappings, and generating simulation stimuli based on known interface dimensions.",
      "description_length": 436,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Logic.Unsigned",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for performing unsigned arithmetic and comparisons on logic values represented as signals in a hardware simulation. It supports addition, subtraction, multiplication, and comparison operators, along with resizing values to a specified bit width. These functions are used to model and simulate digital circuits where unsigned integer behavior is required, such as counters, arithmetic units, or control logic.",
      "description_length": 440,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Output.Of_bits",
      "library": "hardcaml_step_testbench",
      "description": "This module provides functions for manipulating bit-level signals in a simulation environment, including packing/unpacking, multiplexing, concatenation, and selection operations. It works with combinational logic values represented as bit vectors and structured signal types. Concrete use cases include building testbenches for digital circuits, simulating register transfers, and validating signal widths in hardware descriptions.",
      "description_length": 431,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Component.Combinational",
      "library": "hardcaml_step_testbench",
      "description": "This module provides combinational logic simulation capabilities using a step-based monadic interface. It works with signal and component data types to model hardware circuits where outputs depend solely on current inputs. Concrete use cases include building and simulating digital circuits like arithmetic units, multiplexers, and control logic without state elements.",
      "description_length": 369,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Component.Flip_flop_with_load_enable",
      "library": "hardcaml_step_testbench",
      "description": "This module implements a flip-flop component with load enable control in cycle-accurate digital circuit simulations. It provides a `create` function to instantiate the component, which takes an input with data and load enable signals and produces an output representing the stored value. The component is used to model conditional state updates where data is only stored when the load enable signal is active.",
      "description_length": 409,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Input_monad.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module defines monadic composition operators for sequencing input actions in a cycle-accurate simulation. It works with values wrapped in the `Input_monad.t` type, enabling chaining of effectful computations that produce input stimuli for hardware simulation. Concrete use cases include building testbenches that drive simulation inputs step-by-step, such as applying clock signals or feeding data into a pipeline.",
      "description_length": 419,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Input_monad.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module defines monadic composition operators for sequencing input-driven simulation steps in a hardware description context. It provides bind (`>>=`) and map (`>>|`) operations for a custom input monad, enabling chaining of effectful computations that manipulate simulation state. These functions are used to build complex testbenches by composing signal updates and event triggers in a step-based simulation environment.",
      "description_length": 426,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Component.Combinational",
      "library": "hardcaml_step_testbench",
      "description": "This module defines combinational logic components using a monadic interface, enabling sequential composition of signal transformations. It operates on signal and component data types, supporting operations like mapping, binding, and merging signals. Concrete use cases include building complex signal processing pipelines and modeling hardware components with well-defined input-output behavior.",
      "description_length": 396,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Input_monad.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic composition for input-driven simulation steps using bind (`>>=`) and map (`>>|`) operations. It works with values wrapped in the `Input_monad.t` type, enabling sequential chaining of simulation actions that depend on input events. Concrete use cases include building testbenches where input stimuli are applied in sequence, such as simulating register transfers or state transitions triggered by clock edges.",
      "description_length": 437,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Logic.Sop",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for constructing and manipulating logic signals using sum-of-products (SOP) expressions. It supports arithmetic and comparison operations on `Logic.t` values, enabling direct signal manipulation in a simulation context. These functions are used to model combinational logic behavior in digital circuit simulations.",
      "description_length": 346,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Logic.Signed",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for simulating signed integer arithmetic and comparisons using logic signals in an event-driven testbench environment. It supports addition, subtraction, multiplication, and comparison operators, along with signal conversion and bit-width resizing. Concrete use cases include modeling and testing digital circuits that require signed arithmetic, such as ALUs or control logic components.",
      "description_length": 419,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Component.Next_input",
      "library": "hardcaml_step_testbench",
      "description": "This module handles the transformation and serialization of input values within a cycle-accurate simulation environment. It provides the `sexp_of_t` function to convert a polymorphic input value into an S-expression, typically for logging or debugging purposes. It works with input types wrapped in a `Next_input.t` structure, which represents inputs scheduled for the next simulation step. A concrete use case is inspecting or logging input values during simulation step transitions.",
      "description_length": 484,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Component.Combinational",
      "library": "hardcaml_step_testbench",
      "description": "This module provides combinational logic simulation capabilities using a monadic interface. It works with signal and component data types to model digital circuits at the register-transfer level. Concrete use cases include building and simulating synchronous digital designs such as ALUs, multiplexers, and control logic blocks.",
      "description_length": 328,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for sequencing event-driven simulation steps in hardware verification. It supports composing and transforming values within a step monad context, enabling precise control over simulation events and their dependencies. Use cases include modeling hardware behavior with timed actions, managing state transitions, and synchronizing parallel simulation processes.",
      "description_length": 399,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Output.Names_and_widths",
      "library": "hardcaml_step_testbench",
      "description": "This module defines and exposes signal names, widths, and associated tags for output ports in an event-driven simulation. It provides direct access to lists of port names, their corresponding bit-widths, and output tags, all derived from a static interface. It is used to configure and validate simulation outputs based on predefined signal layouts.",
      "description_length": 349,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for sequencing stateful computations in a cycle-accurate simulation environment. It works with the `Step_monad.t` type, which represents actions that manipulate simulation state across clock cycles. Concrete use cases include composing register updates, memory operations, and test sequences that require precise timing control.",
      "description_length": 368,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Output.Make_comb",
      "library": "hardcaml_step_testbench",
      "description": "This module implements combinational logic operations for signal manipulation in a hardware simulation environment. It supports operations like packing/unpacking signals, multiplexing, concatenation, and priority/one-hot selection, working with `comb` type signals wrapped in an `Output.t` structure. Concrete use cases include building complex signal routing logic, decoding instruction fields, or managing bus multiplexing in digital circuit simulations.",
      "description_length": 456,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Input.Of_always",
      "library": "hardcaml_step_testbench",
      "description": "This module provides functions to define and manipulate input signals in an event-driven simulation. It supports operations like assigning values to variables, creating registers and wires, and applying custom naming conventions to signals. These functions work with `Always.Variable.t` and `Signal.t` types, enabling precise control over simulation inputs and behavior.",
      "description_length": 370,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Input_monad.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing input simulation steps in a functional event-driven simulation. It supports values of type `Input_monad.t`, enabling sequential composition with `bind`, value injection with `return`, transformation with `map`, and parallel execution with `both`. Concrete use cases include building complex signal sequences and synchronizing input events in hardware simulation testbenches.",
      "description_length": 428,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Component.Input_monad",
      "library": "hardcaml_step_testbench",
      "description": "This module implements monadic operations for sequencing input-driven simulation steps in hardware testing. It works with values wrapped in a monad representing simulation actions, enabling precise control over event ordering through `bind`, `map`, and `join`. Use it to build testbenches by composing signal transitions and input events step-by-step, such as driving clock cycles or injecting input patterns in digital circuit simulations.",
      "description_length": 440,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Input.Of_bits",
      "library": "hardcaml_step_testbench",
      "description": "This module provides functions to manipulate bit-level input signals in a simulation environment, including packing/unpacking bits, multiplexing, concatenation, and priority/one-hot selection. It operates on `Input.Of_bits.t` and `Bits.t` types, representing structured and raw bit-level data. Concrete use cases include constructing and validating digital signal inputs for hardware simulation, such as decoding instruction fields or modeling peripheral data streams.",
      "description_length": 468,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Component.Flip_flop_with_load_enable_and_reset",
      "library": "hardcaml_step_testbench",
      "description": "This module implements a flip-flop component with load enable and reset control signals, allowing conditional state updates and initialization in digital circuit simulations. It provides a `create` function to instantiate the flip-flop with an input interface that supports comparison, S-expression conversion, and undefined value handling. Use this component to model registers that require controlled updates and reset behavior in cycle-accurate hardware simulations.",
      "description_length": 469,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Input_monad.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module defines monadic composition operators for sequencing input actions in a cycle-accurate simulation. It works with values wrapped in the input monad type, enabling chaining of stateful simulation steps. Concrete use cases include building complex testbenches by combining signal assignments and clock cycle waits in a readable, sequential style.",
      "description_length": 355,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Component.Combinational",
      "library": "hardcaml_step_testbench",
      "description": "This module provides combinational logic simulation capabilities using a step-based monadic interface. It works with signal and component data types to model digital circuits where outputs depend solely on current inputs. Concrete use cases include building and testing logic gates, multiplexers, and arithmetic units in a hardware description workflow.",
      "description_length": 353,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Input.Unsafe_assoc_by_port_name",
      "library": "hardcaml_step_testbench",
      "description": "Converts between input structures and association lists mapping port names to values. Works with any type `'a` in the `Input.t` module, using strings as port identifiers. Useful for dynamically constructing or inspecting input configurations from named port-value pairs.",
      "description_length": 270,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Logic.Signed",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for manipulating signed logic values as first-class values, supporting arithmetic operations like addition, subtraction, and multiplication, as well as comparison operators for equality and ordering. It works directly with the `v` type representing signed logic signals, allowing for simulation of digital circuits with signed integer semantics. Concrete use cases include building and testing arithmetic logic units (ALUs) and control logic that require signed value comparisons and transformations during simulation.",
      "description_length": 550,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Logic.Uop",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for performing arithmetic and comparison operations on `Logic.t` signals, including addition, subtraction, multiplication, and comparisons like less than or equal to. It supports manipulating and converting `Logic.t` values, such as resizing and direct signal conversion. Concrete use cases include implementing digital logic circuits and simulating signal behavior in hardware designs.",
      "description_length": 418,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Output.Make_comb",
      "library": "hardcaml_step_testbench",
      "description": "This module implements combinational logic operations for signal manipulation in digital circuit simulation. It supports types like `comb Output.t` for representing signal outputs and provides functions for packing, unpacking, multiplexing, and concatenating signals with precise bit-level control. Use cases include constructing and validating digital signal paths, implementing multiplexers, and managing signal widths in testbenches.",
      "description_length": 436,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Input.Names_and_widths",
      "library": "hardcaml_step_testbench",
      "description": "This module defines and exposes input port metadata, including names, widths, and associated tags, used to configure and drive signals in an event-driven simulation. It works with lists of strings and integers to represent port names and widths, alongside a list of input tags for signal identification. Concrete use cases include setting up testbench interfaces and mapping simulation inputs to hardware signals.",
      "description_length": 413,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Input.Of_signal",
      "library": "hardcaml_step_testbench",
      "description": "This module enables the modeling of hardware signals and their interconnections through operations such as signal conversion (`of_int`, `pack`, `unpack`), multiplexing (`mux`, `priority_select`), register and pipeline creation (`reg`, `pipeline`), and signal assignment (`assign`). It operates on `Input.Of_signal` types, which represent digital signal interfaces, and supports tasks like component wiring (`<==`), port access (`inputs`, `outputs`), and hierarchical naming (`apply_names`) in event-driven simulations. These capabilities are specifically used for constructing register-transfer level designs, simulating digital circuits, and managing complex signal interactions in hardware verification workflows.",
      "description_length": 715,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Input.Unsafe_assoc_by_port_name",
      "library": "hardcaml_step_testbench",
      "description": "Converts between input signals and string-keyed lists of values, enabling dynamic mapping of signal names to associated data. Works with `'a Input.t` structures, which represent hardware input interfaces. Useful for runtime configuration or test vector generation where signal values are derived from named port entries in external data sources.",
      "description_length": 345,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Input_monad.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic composition for input-driven simulation steps in hardware testing. It sequences computations of type `t` using `bind` (`>>=`), transforms results with `map` (`>>|`), and combines pairs of steps using `both`. It is used to structure testbenches that control signal inputs over time, enabling precise simulation of hardware event timing and dependencies.",
      "description_length": 381,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Input.Of_always",
      "library": "hardcaml_step_testbench",
      "description": "This module provides functions to manipulate and assign values to hardware description variables in an imperative simulation context. It supports operations like reading variable values, assigning signals, creating registers with optional enable, and naming signals for debugging. Concrete use cases include building and simulating digital circuits with dynamic signal behavior and named signal tracing.",
      "description_length": 403,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Output.Unsafe_assoc_by_port_name",
      "library": "hardcaml_step_testbench",
      "description": "Converts between output signals and string-keyed lists of values, enabling direct mapping of signal names to associated data. Works with output types that have string identifiers, such as hardware signal representations. Useful for serializing or inspecting signal states by name during simulation.",
      "description_length": 298,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Input_monad.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing input simulation steps in a cycle-accurate testbench. It works with values wrapped in `Input_monad.t`, supporting sequential composition via `bind` (`>>=`), value injection via `return`, and function application over wrapped values via `map` (`>>|`). It enables constructing complex input sequences for hardware testing, such as applying stimulus over multiple clock cycles in a structured and composable way.",
      "description_length": 463,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Component.Input_monad",
      "library": "hardcaml_step_testbench",
      "description": "This module implements monadic operations for sequencing and composing input-driven simulation steps in a functional event-driven testbench. It works with values of type `Input_monad.t`, which represent hardware input events over time, allowing transformations, chaining, and synchronization of these events. Concrete use cases include defining clocked input sequences, applying stimulus patterns to digital circuits, and structuring testbenches with composable simulation steps.",
      "description_length": 479,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Component.Next_input",
      "library": "hardcaml_step_testbench",
      "description": "Converts a value of type `'i t` to an S-expression using the provided function to serialize the `'i` component. Works with any input type `'i` that can be converted to an S-expression. Useful for logging or debugging input values in a simulation step.",
      "description_length": 251,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Input.All",
      "library": "hardcaml_step_testbench",
      "description": "Converts a record of input signals into a record of signals, enabling the simulation of input values in an event-driven testbench. Works with records of input signals parameterized over a module M. Useful for testing hardware designs by applying structured input stimuli directly to simulation signals.",
      "description_length": 302,
      "index": 82,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Input.Of_signal",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for constructing and manipulating signal inputs through conversions (e.g., integer-to-signal), multiplexers, registers, and pipelines, enabling combinational and sequential logic design. It operates on signals and input structures from the Hardcaml library, facilitating use cases such as testbench construction, digital circuit simulation, and component interconnection with customizable signal naming strategies.",
      "description_length": 446,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Component.Flip_flop_with_load_enable_and_reset",
      "library": "hardcaml_step_testbench",
      "description": "This module implements a cycle-accurate flip-flop component with load enable and reset control signals, used for modeling register behavior in hardware simulations. It provides a `create` function to instantiate the component with an input interface that includes data, load enable, and reset signals. The component evaluates state transitions on each clock cycle, updating its output based on the control signals and input data.",
      "description_length": 429,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Output.Unsafe_assoc_by_port_name",
      "library": "hardcaml_step_testbench",
      "description": "Converts between output signals and string-keyed lists, enabling direct mapping of signal values by port name. Works with any output type `'a Output.t` and string-indexed value pairs. Useful for debugging or interfacing with external systems that require named signal access.",
      "description_length": 275,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Component.Flip_flop_with_load_enable",
      "library": "hardcaml_step_testbench",
      "description": "This module implements a flip-flop component with load enable control in a cycle-accurate simulation environment. It allows conditional updating of stored values based on the load enable signal and provided data. Useful for modeling register files or state elements that update only under specific conditions.",
      "description_length": 309,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Logic.Sop",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for constructing and manipulating logic signals using sum-of-products (SOP) expressions. It supports arithmetic and comparison operations such as addition, subtraction, multiplication, and equality checks, all returning logic signals. These operations are used to model digital circuits where signals are combined using Boolean logic expressions.",
      "description_length": 378,
      "index": 87,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Output.All",
      "library": "hardcaml_step_testbench",
      "description": "Converts a collection of module outputs into a structured format where each output is accessible by its corresponding module instance. Works with any module `M` that defines output signals. Useful for aggregating and inspecting individual output values from multiple testbench components during simulation.",
      "description_length": 306,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for sequencing stateful computations in a cycle-accurate simulation environment. It supports values wrapped in a three-parameter monad representing result, error, and state types, enabling composition of simulation steps with bind, map, and parallel execution with both. Used to build and combine hardware simulation actions that maintain internal state across clock cycles.",
      "description_length": 414,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Component.Flip_flop_with_load_enable",
      "library": "hardcaml_step_testbench",
      "description": "This module implements a flip-flop component with load enable functionality, providing a `create` function to instantiate it. It works with input structures containing `input` and `load_enable` boolean signals, maintaining state across simulation steps. It is used to model registers in digital circuits where data is conditionally loaded based on the enable signal.",
      "description_length": 366,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Event",
      "library": "hardcaml_step_testbench",
      "description": "This module provides functions to convert event values to S-expressions and extract optional values from events. It operates on event types that encapsulate optional data. Use cases include debugging event-driven simulations and inspecting event contents during testbench execution.",
      "description_length": 282,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Ops",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for constructing and manipulating event-driven simulation processes from Hardcaml circuits. It supports data types including simulation signals, processes, and circuit descriptions, enabling direct mapping of circuit nodes to simulation logic. Concrete use cases include generating testbenches with precise timing control, simulating external device interactions, and debugging circuit behavior through signal injection and monitoring.",
      "description_length": 467,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Event",
      "library": "hardcaml_step_testbench",
      "description": "This module represents events that may occur during simulation steps, providing a way to capture and inspect optional values at specific simulation points. It includes functions to extract the value of an event as an optional and convert it to an S-expression for debugging or logging. It is used to model and analyze discrete events in cycle-accurate hardware simulations.",
      "description_length": 373,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Ops",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for converting circuits into simulation processes, managing signal mappings, and retrieving simulation-specific signal representations. It works with simulation contexts (`t`), circuits, signals, and logic values. Concrete use cases include setting up event-driven simulations with custom signal delays and external instance handlers.",
      "description_length": 366,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Component_finished",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a monadic structure for representing computations that track component execution state in a cycle-accurate simulation. It provides a `sexp_of_t` function to serialize these computations into S-expressions, using converters for input and output types. It is used to inspect or log the progress of individual components during simulation runs.",
      "description_length": 361,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Input_monad",
      "library": "hardcaml_step_testbench",
      "description": "This module implements monadic operations for sequencing input simulation steps in a cycle-accurate testbench. It works with values wrapped in `Input_monad.t`, supporting bind (`>>=`), map (`>>|`), and composition through submodules like `Monad_infix` and `Let_syntax`. Concrete use cases include building structured testbenches by chaining signal updates, clock cycles, and input sequences in a composable, imperative-style workflow.",
      "description_length": 434,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Component_finished",
      "library": "hardcaml_step_testbench",
      "description": "Converts a component's input and output values into S-expressions for serialization. Works with component states represented as tuples of input and output types. Useful for logging and debugging cycle-accurate simulations by capturing component behavior in a human-readable format.",
      "description_length": 281,
      "index": 97,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Logic",
      "library": "hardcaml_step_testbench",
      "description": "This module offers operations on fixed-width bitvectors (`Logic.t`) for digital logic simulation, encompassing arithmetic (addition, multiplication, comparison), bitwise manipulation (AND/OR/XOR, shifting, masking), and conversions between numeric types, strings, and hardware signals. It supports both signed and unsigned interpretations, enabling tasks like signal processing, register modeling, and functional verification of digital circuits through hierarchical bitvector transformations and configurable signal resolution. Key use cases include simulating arithmetic logic units, bus protocols, and custom digital logic with precise bit-level control.",
      "description_length": 657,
      "index": 98,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Component",
      "library": "hardcaml_step_testbench",
      "description": "This module provides cycle-accurate simulation primitives for composing hardware components using monadic structures, focusing on both combinational logic (e.g., `or_`, `not_`) and sequential logic (e.g., flip-flops with load enable, reset controls). It operates on boolean signals and register states, enabling precise modeling of digital circuits where signal transformations and state transitions must align with clock cycles. Specific use cases include verifying register behavior in testbenches, simulating control logic with conditional state updates, and debugging hardware designs through serialized state tracking.",
      "description_length": 623,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Input_monad",
      "library": "hardcaml_step_testbench",
      "description": "This module implements monadic operations for sequencing input-driven simulation steps in hardware testing. It provides bind, map, and composition functions to chain signal updates and event triggers in a step-based simulation environment. Use cases include building testbenches that model hardware signal behavior over time, with precise control over event ordering and dependencies.",
      "description_length": 384,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Component_finished",
      "library": "hardcaml_step_testbench",
      "description": "Implements a monadic structure for tracking component completion in event-driven simulations. It provides a `sexp_of_t` function to convert component state transitions into S-expressions for debugging or logging. Works with input/output types `'a` and `'o` to represent simulation events and outcomes, enabling precise simulation step control in hardware verification workflows.",
      "description_length": 378,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Make.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing event-driven simulations, including value wrapping (`return`), chaining computations (`bind`), transforming results (`map`), and combining events (`both`). It works with event-driven simulation types represented by the `'a t` monad. Concrete use cases include modeling hardware behavior with precise timing and dependency tracking in simulation workflows.",
      "description_length": 409,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module defines monadic composition operators for sequencing simulation steps in a hardware description context. It provides `>>=` for chaining dependent simulation actions and `>>|` for transforming results of simulation steps. These operations work with the `Step_monad.t` type, which represents computations that can read and modify simulation state across clock cycles. Use cases include building complex testbenches by composing register transfers, memory operations, and clock-step assertions in a hardware simulator.",
      "description_length": 527,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Component",
      "library": "hardcaml_step_testbench",
      "description": "This module supports modeling and simulation of digital circuits through monadic sequencing of input-driven steps, combinational logic transformations, and stateful component updates. It operates on signal types (`'i`, `'o`) and digital components (`Digital_components.Data.t`), incorporating combinational gates (`or_`, `not_`) and sequential elements like configurable flip-flops with load enable, reset, and conditional state transitions. Typical use cases include simulating register-based logic, verifying signal propagation in combinational circuits, and debugging complex state transitions using S-expression logging.",
      "description_length": 624,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module defines monadic composition operators for sequencing simulation steps in an event-driven testing environment. It provides the `>>=` and `>>|` operators to chain and transform values within the `Step_monad.t` context, which represents actions that can interact with simulation state and events. These operations are used to build complex test scenarios by combining simpler simulation steps that depend on or affect the simulation's state and event timeline.",
      "description_length": 469,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.Logic.Signed",
      "library": "hardcaml_step_testbench",
      "description": "This module implements arithmetic and comparison operations for signed logic values represented as two-state logic signals. It supports addition, subtraction, multiplication, and comparisons like less than, greater than, and equality checks. These operations are used to model and simulate digital circuits with signed integer behavior in an event-driven simulation environment.",
      "description_length": 378,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface.Logic",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for constructing and manipulating fixed-width digital logic signals (`Logic.t`), enabling bitwise operations, arithmetic computations, and conversions between integers, strings, and boolean representations. It supports low-level hardware modeling tasks such as signal slicing, concatenation, multiplexing, and signed/unsigned arithmetic, with utilities for simulation-driven workflows like testbenches or circuit synthesis. Key use cases include digital logic verification, combinational circuit design, and bitvector manipulation for hardware emulation.",
      "description_length": 586,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Component",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for constructing cycle-accurate hardware simulations using monadic sequencing, combinational logic modeling, and stateful component management. It works with signal and component types from the `Hardcaml_step_testbench` library, supporting boolean transformations (e.g., `or_`, `not_`) and stateful elements like flip-flops with load enable/reset controls. Specific use cases include verifying digital circuits through precise stimulus application, simulating control-flow-driven hardware behavior, and debugging via S-expression serialization for waveform analysis or test vector exchange.",
      "description_length": 622,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.Logic.Unsigned",
      "library": "hardcaml_step_testbench",
      "description": "This module implements arithmetic and comparison operations for unsigned logic values in an event-driven simulation environment. It supports operations like addition, subtraction, multiplication, and comparisons (less than, greater than, equal, etc.), as well as resizing of unsigned values to a specified bit width. These functions are used to model and simulate digital circuits that perform unsigned integer arithmetic and control logic decisions based on such values.",
      "description_length": 471,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Make.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing sequential logic simulations, including value injection, chaining computations, mapping functions, and combining results. It works with simulation state transitions represented as functions over time steps. Use it to model clocked hardware behavior with explicit state updates across simulation cycles.",
      "description_length": 356,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic combinators for sequencing stateful operations in a cycle-accurate simulation context. It works with the `Step_monad.t` type, enabling composition of actions that manipulate simulation state across clock cycles. Concrete use cases include building testbenches that model register updates, memory interactions, and timed signal transitions.",
      "description_length": 368,
      "index": 111,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Event",
      "library": "hardcaml_step_testbench",
      "description": "This module defines operations for working with event values in a step-based simulation monad. It provides `sexp_of_t` to convert event values to S-expressions for serialization, and `value` to extract the current value from an event, if present. These functions are used to inspect and debug events during simulation cycles, particularly when integrating with testbenches that require value tracing or assertion checking.",
      "description_length": 422,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Component_finished",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a monadic structure for representing computations that track component completion in a step-based simulation. It provides a function to convert values of this structure into S-expressions for serialization or debugging, using provided conversion functions for input and output types. The module is used to model simulation steps where components may finish execution at different times, enabling inspection of their final states and outputs.",
      "description_length": 461,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.Logic.Uop",
      "library": "hardcaml_step_testbench",
      "description": "This module implements arithmetic and comparison operations for signal simulation in a digital circuit context. It provides functions to perform addition, subtraction, multiplication, and comparisons like less than or equal to on signal values, which are represented as logic types. These operations are used to model combinational logic behavior during event-driven simulation of digital circuits.",
      "description_length": 398,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.Logic.Sop",
      "library": "hardcaml_step_testbench",
      "description": "This module implements bitwise and arithmetic operations on logic signals in an event-driven simulation environment. It supports operations like addition, subtraction, multiplication, comparison, and resizing for logic values represented as simulation nodes. These functions are used to model digital circuit behavior by connecting logic signals through combinational operations.",
      "description_length": 379,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Input_monad",
      "library": "hardcaml_step_testbench",
      "description": "This module implements monadic operations for constructing input stimuli in cycle-accurate hardware simulations. It works with values wrapped in the `Input_monad.t` type, allowing sequential composition of input actions using `bind`, transformation with `map`, and parallel combination with `both`. Concrete use cases include defining clocked input sequences, driving test vectors into a design's inputs, and synchronizing multiple input sources over simulation cycles.",
      "description_length": 469,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Component",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic abstractions for modeling digital circuits in event-driven simulations, supporting combinational logic operations (like `and_`, `or_`, `not_`), input sequencing via structured monads, and sequential components such as flip-flops with load enable and reset functionality. It operates on hardware signal data types and simulation components, enabling functional verification of control logic, arithmetic units, and stateful circuits requiring precise timing or reset behavior. Specific use cases include simulating ALUs with conditional state updates and testing sequential designs with asynchronous resets or enable-controlled transitions.",
      "description_length": 667,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module defines monadic composition operators for sequencing simulation steps in an event-driven testbench. It works with the `Step_monad.t` type, which represents actions that can read and modify simulation state across clock cycles. These operators enable chaining stateful operations that model hardware behavior, such as sampling signals or advancing simulation time, in a concise and composable way.",
      "description_length": 408,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module defines monadic composition operators for sequencing simulation steps in a functional testbench. It provides `>>=` for chaining computations that depend on prior results and `>>|` for transforming results within the monadic context. These operations work with the `Step_monad.t` type, which represents a computation that can interact with simulation state and effects. Use this module to build complex testbenches by combining simpler steps that read or modify signal values over time.",
      "description_length": 497,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.Logic.Unsigned",
      "library": "hardcaml_step_testbench",
      "description": "This module implements arithmetic and comparison operations for unsigned logic values represented as signals in an event-driven simulation. It supports addition, subtraction, multiplication, and comparisons like less than, greater than, and equality, all operating on the `v` type which models unsigned binary values. These operations are used to model combinational logic behavior in hardware simulation, such as ALU operations, register comparisons, and bit-width manipulations.",
      "description_length": 480,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Event",
      "library": "hardcaml_step_testbench",
      "description": "This module represents events in a simulation timeline, where each event carries an optional value and is used to model discrete occurrences during hardware simulation steps. It provides `sexp_of_t` for serializing event values to S-expressions and `value` to extract the optional payload from an event. It is used to track and inspect signal changes or specific occurrences at precise simulation cycles in testbenches.",
      "description_length": 419,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.Logic.Uop",
      "library": "hardcaml_step_testbench",
      "description": "This module defines arithmetic and comparison operations on logic signals in an event-driven simulation environment. It supports operations like addition, subtraction, multiplication, and comparisons (less than, greater than, equal to, etc.), as well as signal conversion and resizing. These functions are used to model and simulate digital circuits where logic values change over time in response to events.",
      "description_length": 408,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic combinators for composing stateful, cycle-accurate hardware simulations. It works with computations wrapped in a three-parameter monad representing success values, error types, and shared state, enabling sequential composition via bind (`>>=`) and pure transformation via map (`>>|`). It is used to structure simulation steps that interact with hardware state across clock cycles, such as driving inputs, sampling outputs, and checking expected behavior.",
      "description_length": 483,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Input",
      "library": "hardcaml_step_testbench",
      "description": "This module enables the transformation, combination, and conversion of hardware interface signals in event-driven simulation environments. It operates on types like `Input.t`, `Signal.t`, and `Always.Variable.t`, alongside structured metadata and bit-level representations, to support testbench development tasks such as stimulus generation, combinatorial logic definition, and dynamic signal behavior modeling during hardware verification workflows.",
      "description_length": 450,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.Logic.Sop",
      "library": "hardcaml_step_testbench",
      "description": "This module implements bitwise and arithmetic operations on logic signals in a digital simulation environment. It supports operations like addition, subtraction, multiplication, comparison, and signal conversion, working directly with logic values represented as integers. These functions are used to model combinational logic behavior during event-driven simulation of digital circuits.",
      "description_length": 387,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface.Output",
      "library": "hardcaml_step_testbench",
      "description": "This module supports functional transformations and combinations of `Output.t` values, including mapping, zipping, and folding over structures like tuples, lists, and error types, while operating on signals and ports derived from static interfaces. It provides utilities for bit-level manipulation, combinational logic, and event-driven simulation features such as register creation and signal assignment through modules like `Of_always`. Key use cases include constructing and validating testbenches, simulating hardware circuits with structured output organization, and managing metadata for debugging or serialization via port name and width tracking.",
      "description_length": 654,
      "index": 126,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Input_monad",
      "library": "hardcaml_step_testbench",
      "description": "This module implements monadic operations for sequencing input-driven simulation steps in event-driven testbenches. It works with values of type `Input_monad.t`, supporting composition via `bind`, transformation via `map`, and parallel execution via `both`. It is used to model input event sequences, such as clock-triggered data transfers or synchronized signal changes in digital circuit simulations.",
      "description_length": 402,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.Logic.Signed",
      "library": "hardcaml_step_testbench",
      "description": "This module implements arithmetic and comparison operations for signed logic values in an event-driven simulation environment. It supports addition, subtraction, multiplication, and comparisons like less than or equal, converting between signed and standard logic representations. These operations are used to model and simulate digital circuits with signed integer behavior, such as ALUs or control units in hardware designs.",
      "description_length": 426,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic combinators for sequencing and transforming time-dependent computations in a step-driven simulation. It works with values wrapped in a step monad that represent actions manipulating signals and events over discrete simulation steps. It is used to build complex testbenches where actions must be explicitly ordered and synchronized with simulation time, such as triggering events at specific steps or sampling signals after known delays.",
      "description_length": 465,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for sequencing event-driven simulation steps in hardware verification. It supports composing and transforming values within a step monad context, enabling precise control over simulation events and their dependencies. Use cases include modeling hardware behavior with timed actions, managing state transitions, and synchronizing parallel simulation processes.",
      "description_length": 399,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Make.O_data",
      "library": "hardcaml_step_testbench",
      "description": "This module represents simulation data for hardware signals at clock cycle boundaries, storing values as bit vectors. It provides access to signal values before and after clock edges, supporting comparisons and serialization. Use it to capture and verify signal transitions in digital circuit simulations.",
      "description_length": 305,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Make.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing sequential computations, including `bind`, `map`, and `both` for structuring imperative-style code. It works with values wrapped in a monadic type `'a t`, enabling chaining of operations while handling effects. Concrete use cases include building testbenches with step-based simulation and managing state transitions in hardware verification workflows.",
      "description_length": 406,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads.Step_monad",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic constructs to sequence cycle-accurate simulation actions, supporting operations like binding, mapping, looping, and delaying signals while transforming inputs and outputs. It works with simulation components that track state through input/output ports, event triggers, and time-step metadata, enabling precise control over hardware behavior. Typical use cases include constructing testbenches for synchronous logic, modeling hierarchical hardware units with pipelined interactions, and debugging via event-driven assertions or waveform capture.",
      "description_length": 573,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.With_interface",
      "library": "hardcaml_step_testbench",
      "description": "This module implements an event-driven simulation framework for digital circuits, supporting operations like clock generation, process scheduling, and signal propagation. It works with logic signals, simulation processes, and interface ports to model hardware behavior with precise timing and state transitions. Concrete use cases include writing testbenches that drive input signals, monitor outputs, and verify expected circuit behavior over time.",
      "description_length": 449,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.Ops",
      "library": "hardcaml_step_testbench",
      "description": "This module manipulates simulation processes and signal mappings in an event-driven simulation environment. It provides access to processes, resolves or fabricates simulation signals for a given circuit, and converts circuits into simulation-ready processes with optional delay and external instance handling. Concrete use cases include setting up and modifying signal logic during simulation setup or testbench execution.",
      "description_length": 422,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.Logic",
      "library": "hardcaml_step_testbench",
      "description": "This module provides low-level operations for manipulating fixed-width, two-state logic values (`t`) with support for both signed and unsigned interpretations. It offers bitwise operations (concatenation, selection, shifting), arithmetic computations (addition, multiplication, comparisons), and conversions between integers, strings, and bitvectors, alongside utilities for signal resizing, encoding transformations (e.g., one-hot, Gray code), and simulation-specific testbench tasks like random signal generation. These capabilities target imperative event-driven simulation of digital circuits, enabling tasks such as signal processing, arithmetic logic verification, and bit-level data manipulation in hardware test environments.",
      "description_length": 733,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator.Vcd",
      "library": "hardcaml_step_testbench",
      "description": "This module implements a VCD (Value Change Dump) waveform recorder that captures signal changes during simulation. It works with logic ports and simulators to log transitions over time, producing output compatible with waveform viewers. Use it to debug digital circuits by visualizing signal behavior in tools like GTKWave.",
      "description_length": 323,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Make.I_data",
      "library": "hardcaml_step_testbench",
      "description": "Handles event-driven simulation data represented as tuples of `I`-indexed `Bits.t` values. Provides equality checking, S-expression conversion, and an undefined value placeholder for uninitialized signals. Useful for modeling and verifying digital circuits with symbolic simulation steps.",
      "description_length": 288,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Make.List",
      "library": "hardcaml_step_testbench",
      "description": "This module provides list operations within a step monad context, enabling imperative-style simulations with event-driven behavior. It supports mapping, iteration, and indexed operations over lists, where each element is processed in sequence with monadic effects. Concrete use cases include simulating digital circuits with per-cycle updates or processing time-varying signals in a functional manner.",
      "description_length": 401,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.Vcd",
      "library": "hardcaml_step_testbench",
      "description": "This module implements a VCD (Value Change Dump) waveform recorder for event-driven simulation. It captures signal transitions on logic ports during simulation and writes them to a VCD file for debugging and analysis. The module manages simulation processes to track and record changes in signal values over time.",
      "description_length": 313,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Make.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic bind and map operators for sequencing computations in a functional simulation context. It works with values wrapped in a simulation monad, enabling chaining of simulation steps and transformations. Concrete use cases include composing signal updates and event-driven actions in digital circuit simulations.",
      "description_length": 335,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Make.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing event-driven simulations, including value wrapping (`return`), chaining computations (`bind`), transforming results (`map`), and combining events (`both`). It works with event-driven simulation types represented by the `'a t` monad. Concrete use cases include modeling hardware behavior with precise timing and dependency tracking in simulation workflows.",
      "description_length": 409,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Make.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic composition operators for event-driven simulation, enabling sequential and transformed computation over simulation events. It works with simulation state and event-based computations represented by the `'a t` type. These operators are used to chain simulation steps and apply transformations to their results, directly supporting the construction of complex testbenches through compositional event sequencing.",
      "description_length": 438,
      "index": 143,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Make.Simulator",
      "library": "hardcaml_step_testbench",
      "description": "Simulates digital circuit designs by advancing simulation cycles and capturing input/output behavior. Works with hardware description types defined by Hardcaml, specifically designs with input and output interfaces. Used to test and verify circuit functionality by applying inputs and observing outputs over clock cycles.",
      "description_length": 321,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Make.List",
      "library": "hardcaml_step_testbench",
      "description": "This module provides list iteration and transformation operations within a step monad context, including indexed and pairwise processing. It works with lists of values wrapped in a step monad, enabling sequential execution of monadic actions over list elements. Concrete use cases include simulating sequential logic operations, testing stateful circuits, and managing time-dependent computations over list-structured data.",
      "description_length": 423,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Make.Simulation_step",
      "library": "hardcaml_step_testbench",
      "description": "This module implements simulation steps for event-driven testing, supporting operations like `cyclesim_compatible` and `rising_edge` that model input setting and output sampling around clock edges. It works with digital signal representations and clocked hardware behaviors. Concrete use cases include verifying synchronous circuit behavior by simulating precise timing interactions between inputs and outputs during clock transitions.",
      "description_length": 435,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Make.I_data",
      "library": "hardcaml_step_testbench",
      "description": "Handles input data representation for cycle-accurate simulation in hardware verification. Provides operations to convert data to S-expressions, compare values, and initialize undefined signals. Used to define and manipulate input stimuli in bit-level simulations.",
      "description_length": 263,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing cycle-accurate simulations, including binding, mapping, and combining simulation steps. It works with values wrapped in the `Cyclesim.t` type, representing hardware simulation actions. Concrete use cases include sequencing register transfers, modeling pipelined logic, and synchronizing signal updates in hardware testbenches.",
      "description_length": 380,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Make.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing and sequencing computations in a functional testbench environment. It supports values wrapped in a monadic type `'a t`, enabling chaining with `bind`, transforming results with `map`, and combining two computations in parallel with `both`. Concrete use cases include structuring simulation steps, managing test sequences, and handling dependent or concurrent test actions in hardware verification workflows.",
      "description_length": 461,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads.Step_monad",
      "library": "hardcaml_step_testbench",
      "description": "This module supports constructing cycle-accurate simulations using monadic combinators that sequence signal updates, model delays, and implement control flow constructs like loops over clock cycles. It operates on digital signal representations and structured components with input/output transformations, enabling hierarchical testbench composition and event-driven state tracking. Typical applications include verifying hardware designs through precise simulation of combinational logic, sequential circuits, and synchronized component interactions with optional value inspection for debugging.",
      "description_length": 596,
      "index": 150,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic composition for event-driven simulation actions, enabling sequencing, transformation, and parallel execution of simulation tasks. It works with values wrapped in the `Hardcaml_step_testbench.Imperative.Event_driven_sim.t` type, representing time-ordered simulation events. Concrete use cases include building complex testbenches by chaining signal updates, sampling values at specific simulation times, and running multiple simulation steps concurrently.",
      "description_length": 483,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.With_interface",
      "library": "hardcaml_step_testbench",
      "description": "This module implements an event-driven simulation environment for hardware verification with structured interface handling. It combines signal manipulation, clock generation, and testbench process orchestration using typed ports and bitvector logic, enabling simulation of digital circuits with precise timing and data flow control. Concrete applications include testbench development with VCD waveform generation, register transfer level simulation, and protocol validation through signal injection and expected value checking.",
      "description_length": 528,
      "index": 152,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.Ops",
      "library": "hardcaml_step_testbench",
      "description": "This module manipulates event-driven simulation processes and signals in a hardware simulation context. It provides access to simulation processes, maps real signals to simulated logic, and generates fake signal stubs for testing. Key operations include extracting processes from a simulation state, resolving signals to their simulated counterparts, and converting circuits into executable simulation operations with customizable delays and external instantiations.",
      "description_length": 466,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Make.O_data",
      "library": "hardcaml_step_testbench",
      "description": "Stores signal values before and after clock edges during simulation. Provides access to pre- and post-edge signal states using `before_edge` and `after_edge`. Used to track and compare signal transitions in event-driven simulations.",
      "description_length": 232,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Make.Array",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations to initialize, iterate over, and map array elements within a functional simulation context. It works with arrays of values in a hardware simulation environment, where each operation sequences through simulation cycles. Use cases include setting up test data, applying per-element transformations, and performing cycle-accurate assertions during simulation.",
      "description_length": 388,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator.Logic",
      "library": "hardcaml_step_testbench",
      "description": "This module provides bit-level manipulation, arithmetic operations, and type conversions for fixed-width, two-state logic values (`t`), enabling precise modeling of digital circuits. It supports operations like signed/unsigned arithmetic, bitwise logic, signal concatenation/splicing, and code conversions (e.g., binary to Gray) on logic signals. These capabilities are used for simulating combinational/sequential logic, verifying hardware behavior, and generating test cases with random or structured signal patterns.",
      "description_length": 519,
      "index": 156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Make.Array",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations for creating and manipulating arrays within an event-driven simulation context. It supports initialization, iteration, indexed iteration, and mapping over arrays, where each element is processed in the simulation monad. Use it to model and simulate digital circuits with array-based state or data structures.",
      "description_length": 340,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads.Step_monad",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic combinators for sequencing, parallelizing, and looping over event-driven simulation steps, along with time-based control and event handling. It operates on input/output signals, optional event values, and component state transitions, enabling functional verification of digital circuits through structured simulation workflows and runtime debugging of signal interactions and component behaviors.",
      "description_length": 425,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Make.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for composing sequential logic simulations, including value injection, chaining computations, mapping functions, and combining results. It works with simulation state transitions represented as functions over time steps. Use it to model clocked hardware behavior with explicit state updates across simulation cycles.",
      "description_length": 356,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads.Step_monad",
      "library": "hardcaml_step_testbench",
      "description": "This module supports composing time-dependent simulation steps for hardware verification using monadic abstractions that sequence signal transitions, manage delays, and synchronize events. It operates on digital signal values and simulation state through combinators like `bind`, `wait`, and `spawn`, enabling testbench workflows such as stimulus generation, combinational logic modeling, and component lifecycle tracking. Specific applications include hardware design validation with precise timing control, assertion-based verification, and hierarchical component simulation.",
      "description_length": 577,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Make",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations for constructing event-driven simulations of digital circuits, focusing on sequencing clock cycles, applying input transitions, and tracking signal states. It works with signal data types (`I_data.t`, `O_data.t`) and structured collections like lists and arrays to model time-dependent behaviors, supporting use cases such as merging input streams, synchronizing concurrent simulation tasks, and verifying circuit responses to timed input sequences. Key features include deferred execution, event timeouts, and array-based state management for hardware verification workflows.",
      "description_length": 616,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.List",
      "library": "hardcaml_step_testbench",
      "description": "This module provides imperative-style list operations within the step monad, enabling simulation cycles to process list values. It supports list creation, iteration, indexed iteration, and mapping operations, all sequencing effects through the `Cyclesim.t` monad. Concrete use cases include initializing and driving testbenches with lists of signals or configurations, where each element triggers timed simulation steps.",
      "description_length": 420,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Make.No_data",
      "library": "hardcaml_step_testbench",
      "description": "This module represents a placeholder with no associated data, used to signify absence or undefined states in testbenches. It provides basic equality checks, S-expression conversion, and an undefined value. Commonly used in scenarios requiring unit-like values without carrying data, such as signaling completion or initializing structures.",
      "description_length": 339,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Make.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic bind and map operators for composing computations in a functional testbench context. It works with values wrapped in a monadic type `'a t`, enabling sequential composition of test steps and transformations of their results. Concrete use cases include chaining signal assignments and assertions in hardware simulation workflows.",
      "description_length": 356,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Make.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic composition for hardware simulation workflows, supporting values in a wrapped type `'a t` with `return`, `bind (>>=)`, and `map (>>|)`. It enables sequencing and transformation of simulation steps, particularly useful for structuring testbenches where actions depend on prior results or need to be combined in parallel. Concrete use cases include defining test sequences with dependent signal injections and assertions in hardware verification.",
      "description_length": 473,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Make.O_data",
      "library": "hardcaml_step_testbench",
      "description": "This module represents signal data in a testbench, capturing values before and after clock edges. It provides accessors to retrieve data at specific clock transitions and supports comparison, serialization, and initialization with undefined values. It is used to model and verify hardware behavior by tracking signal changes across clock cycles.",
      "description_length": 345,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Make.List",
      "library": "hardcaml_step_testbench",
      "description": "This module provides functions for working with lists in a step monad context, enabling operations like initializing lists with index-dependent computations, mapping over elements with monadic effects, and iterating through elements or indices with side effects. It handles lists of values within a monadic type `'a list t`, supporting both element transformation and sequential execution of effects. Concrete use cases include constructing and processing sequences of stateful computations where each step depends on its position or elements from one or more lists.",
      "description_length": 566,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.M",
      "library": "hardcaml_step_testbench",
      "description": "Implements a cycle-accurate simulation environment for testing hardware designs. It tracks input and output signals over time, advancing simulation cycles to model hardware behavior. Useful for verifying sequential logic and timing in digital circuits.",
      "description_length": 252,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.M",
      "library": "hardcaml_step_testbench",
      "description": "Implements event-driven simulation for hardware verification, tracking signal transitions and propagating changes through a circuit. It processes input events, updates state, and generates output events based on combinational logic and clock cycles. Useful for simulating digital circuits with precise timing and for writing testbenches that assert expected signal behaviors.",
      "description_length": 375,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.No_data",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a placeholder type `t` representing the absence of data in testbench simulations. It includes functions for serialization, equality checking, and providing an undefined value. It is used in simulation scenarios where data is irrelevant or uninitialized.",
      "description_length": 273,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic composition of cycle-accurate simulation steps using `return`, bind `(>>=)`, and map `(>>|)`. It operates on values of type `Cyclesim.t`, representing hardware simulation actions. Use it to sequence register updates, model pipelined behavior, and coordinate signal transitions in hardware testbenches.",
      "description_length": 330,
      "index": 171,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim.Monads",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic combinators for building and sequencing cycle-accurate simulations, including signal updates, delay modeling, and control flow constructs over clock cycles. It works with digital signals and structured hardware components, supporting input/output transformations and hierarchical composition. It is used to simulate and verify hardware designs, including combinational logic, sequential circuits, and synchronized component interactions, with support for state tracking and value inspection.",
      "description_length": 520,
      "index": 172,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulation_step",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a simulation step type that represents a function taking a signal and returning a deferred unit. It provides operations like `rising_edge` to trigger actions on clock signal transitions and `cyclesim_compatible` to integrate with cycle-accurate simulations. Use it to model hardware behavior by sequencing signal updates and synchronizing with clock edges in event-driven simulations.",
      "description_length": 404,
      "index": 173,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Simulator",
      "library": "hardcaml_step_testbench",
      "description": "Implements an imperative event-driven simulation engine for digital circuits with support for signal propagation, process scheduling, and time-based execution. Works with logic values, signal mappings, and simulation processes to model circuit behavior during testbench runs. Directly used for running simulations, triggering signal updates, and managing simulation time in hardware verification workflows.",
      "description_length": 406,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.No_data",
      "library": "hardcaml_step_testbench",
      "description": "This module defines a placeholder type `t` representing the absence of data in event-driven simulation scenarios. It includes functions for serialization, equality checks, and a value indicating undefined state. It is used to manage simulation events where data presence is optional or irrelevant.",
      "description_length": 297,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monads",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic abstractions for composing time-dependent simulation steps in hardware verification. It works with digital signal values and simulation state, using combinators like `bind`, `wait`, and `spawn` to sequence signal transitions, manage delays, and synchronize events. Concrete use cases include stimulus generation, assertion-based verification, and hierarchical component simulation with precise timing control.",
      "description_length": 438,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Make.Array",
      "library": "hardcaml_step_testbench",
      "description": "This module provides imperative operations for working with arrays in a testbench context. It supports initializing arrays with index-dependent values, iterating over elements with and without indices, and mapping over elements to produce new arrays. These functions are used to simulate and test hardware designs where array-based data structures require sequential manipulation or transformation.",
      "description_length": 398,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Monads",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic abstractions for structuring event-driven simulations, enabling precise control over signal propagation, state transitions, and timing in digital circuit verification. It works with input/output signals, event streams, and simulation state to model component interactions and temporal behavior. Concrete use cases include sequencing simulation steps, managing concurrent signal updates, and injecting stimuli at specific time points for testing circuit functionality.",
      "description_length": 496,
      "index": 178,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Make.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic composition operators like `bind` (`>>=`) and `map` (`>>|`) for structuring imperative-style computations over a monadic type `'a t`. It supports building sequential logic and effectful pipelines, particularly useful for testbench automation and stateful simulations in hardware verification. The `Let_syntax` submodule enables syntactic sugar for monadic expressions, simplifying step-based simulation workflows.",
      "description_length": 442,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic composition operators for sequencing simulation actions in a cycle-accurate testbench environment. It works with values wrapped in the `Cyclesim.t` type, enabling chaining of stateful computations that model hardware behavior over time. Concrete use cases include writing testbenches that simulate register updates, signal propagation, and synchronous logic interactions across clock cycles.",
      "description_length": 420,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Make.List",
      "library": "hardcaml_step_testbench",
      "description": "This module provides imperative-style list operations within a step monad, enabling iteration and mapping over lists with effects. It supports operations like initializing lists with index-dependent computations, iterating with or without indices, and mapping values while preserving effectful sequencing. Concrete use cases include simulating sequential hardware behavior, managing stateful computations over list elements, and orchestrating effects in a step-based execution model.",
      "description_length": 483,
      "index": 181,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Make.I_data",
      "library": "hardcaml_step_testbench",
      "description": "Handles input data representation for testbenches using bit vectors indexed by integer keys. Provides operations to create undefined data, compare data structures, and convert them to S-expressions for debugging. Useful for defining and verifying expected input values in hardware simulation testbenches.",
      "description_length": 304,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic composition operators for sequencing event-driven simulation actions in a hardware description context. It works with the `t` type representing simulation computations, allowing chaining and transformation of these computations using `>>=` and `>>|`. Concrete use cases include structuring testbenches that simulate hardware behavior over time, where each action represents a time step or signal change.",
      "description_length": 432,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Array",
      "library": "hardcaml_step_testbench",
      "description": "This module provides imperative operations for working with arrays within a cycle-accurate simulation context. It supports initializing arrays with simulation-time values, iterating over elements with side effects, and mapping elements to new values while preserving array structure. These operations are used to model and test hardware behavior where array elements represent state or data processed over simulation cycles.",
      "description_length": 424,
      "index": 184,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Let_syntax",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operators for composing event-driven simulation tasks, including sequencing with `>>=`, transformation with `>>|`, and pure injection with `return`. It operates on values of type `Hardcaml_step_testbench.Imperative.Event_driven_sim.t`, which represent actions occurring at specific simulation times. It is used to construct and coordinate complex testbench behaviors, such as scheduling signal changes, waiting for clock cycles, and composing multiple simulation steps.",
      "description_length": 498,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim.Monads",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic operations to compose cycle-accurate simulation steps, including binding, mapping, looping, and signal delay. It operates on simulation components with stateful input/output ports, event triggers, and time-step tracking. It is used to build testbenches for synchronous circuits, model pipelined hardware interactions, and insert waveform captures or assertions for debugging.",
      "description_length": 404,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Make.Array",
      "library": "hardcaml_step_testbench",
      "description": "This module provides operations to initialize, iterate over, and map array values within a functional simulation context. It supports creating arrays with index-dependent elements, applying functions to each element or index-element pair, and transforming arrays element-wise. Use it to model array-based combinational logic or test scenarios involving array data structures in hardware simulations.",
      "description_length": 399,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Make.Monad_infix",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic bind and map operators for sequencing imperative-style computations. It works with values wrapped in a monadic type `'a t`, enabling chaining of operations where each step depends on the result of the previous. These operators are used to build testbenches with a linear flow of stateful or effectful actions, such as signal updates followed by clock cycles.",
      "description_length": 387,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.Array",
      "library": "hardcaml_step_testbench",
      "description": "This module provides imperative array operations within an event-driven simulation context. It supports initializing arrays with simulation-bound values, iterating over elements with side-effecting functions, and mapping elements to new values while preserving array structure. These operations are used to model and simulate hardware components where array-based state transitions are driven by simulation events.",
      "description_length": 414,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim.List",
      "library": "hardcaml_step_testbench",
      "description": "This module provides imperative-style list operations within a step monad simulation context, enabling sequential execution of effects over list elements. It supports operations like initializing lists of simulated values, mapping and iterating with index-aware functions, and pairwise iteration over two lists. These functions are used to model time-ordered behavior in hardware simulations, such as clock cycle-aligned signal processing or sequential test vector application.",
      "description_length": 477,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim.Simulator",
      "library": "hardcaml_step_testbench",
      "description": "This module implements an event-driven simulation engine for digital circuit verification, orchestrating signal propagation and process scheduling. It coordinates simulation steps, manages signal dependencies, and advances time in discrete steps to model hardware behavior. Used to execute testbenches, validate circuit timing, and drive VCD waveform generation for debugging.",
      "description_length": 376,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.M",
      "library": "hardcaml_step_testbench",
      "description": "This module implements imperative-style testbench components for simulating and verifying hardware designs. It provides operations for stepping through simulation cycles, managing signal updates, and asserting expected outcomes at specific time steps. It works with hardware description data types such as signals, clocks, and simulation states, and is used to build testbenches that drive input stimuli and verify circuit behavior over time.",
      "description_length": 442,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Event_driven_sim",
      "library": "hardcaml_step_testbench",
      "description": "This framework supports monadic composition of time-dependent actions to model concurrent hardware behavior with precise timing control, using operations like `cycle`, `spawn`, and `wait_for` to sequence signal transitions and delays. It leverages a simulation engine alongside imperative data structures (lists, arrays) and monadic utilities to manage effects across simulation steps, integrating with cycle-accurate workflows and deferred processes. It is particularly suited for hardware verification tasks requiring timed event sequencing, timeout handling, and structured concurrency in event-driven environments.",
      "description_length": 618,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Make",
      "library": "hardcaml_step_testbench",
      "description": "This module offers monadic sequencing for effectful, stateful computations and imperative array transformations tailored for step-based simulations. It manipulates monadic values (`'a t`) through binding, mapping, and concurrency primitives to orchestrate simulation steps, event waits, and task spawning, while its array operations support index-driven initialization, iteration, and mapping. These capabilities are critical for hardware verification testbenches requiring granular control over dynamic state transitions and structured data processing in",
      "description_length": 555,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.M",
      "library": "hardcaml_step_testbench",
      "description": "Implements functional testbench logic using monadic structures for input and output handling. Provides operations to define and run test scenarios with input sequences and verify output expectations. Works with input and output types defined by the I and O modules, using monads for effectful computations. Useful for simulating and testing hardware descriptions with precise input control and output validation.",
      "description_length": 412,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Cyclesim",
      "library": "hardcaml_step_testbench",
      "description": "This module provides a monadic framework for constructing cycle-accurate hardware simulations, enabling precise control over signal updates, delays, and clock cycle sequencing. It operates on digital signals and hardware components, supporting hierarchical composition and stateful simulation. It is used to model and verify complex synchronous digital circuits, including state machines, pipelined datapaths, and register-transfer level designs.",
      "description_length": 446,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative.Cyclesim",
      "library": "hardcaml_step_testbench",
      "description": "Implements monadic combinators and imperative simulation primitives for composing cycle-accurate hardware testbenches, enabling sequencing of simulation steps, concurrency management, loop iteration over cycles, and handling of placeholder data. It operates on lists and arrays to facilitate structured data manipulation within simulation steps, while coordinating execution with timeout handling through the `Cyclesim.t` monad. This module is used for modeling synchronous hardware behavior, including pipelining, signal synchronization, and testbench assertions.",
      "description_length": 564,
      "index": 197,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Make",
      "library": "hardcaml_step_testbench",
      "description": "This module provides monadic combinators and concurrency primitives for modeling hardware simulations with bit vector signals, structured around input/output data types (`I_data`, `O_data`) and index-driven collections. It enables testbench workflows like cycle-accurate signal sequencing, event-driven timing controls, and parallel task orchestration with input merging and defaulting behaviors. Key use cases include constructing timed simulation scenarios, composing hierarchical test logic, and managing complex dataflow dependencies in verification environments.",
      "description_length": 567,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional.Event_driven_sim",
      "library": "hardcaml_step_testbench",
      "description": "This module combines monadic abstractions and a simulation engine to model and verify digital circuits through event-driven simulation. It works with signals, event streams, and simulation state to precisely control timing, sequence operations, and manage concurrent updates. Concrete use cases include writing testbenches that apply timed input stimuli, verifying circuit behavior over simulation cycles, and generating waveform data for debugging.",
      "description_length": 449,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Imperative",
      "library": "hardcaml_step_testbench",
      "description": "This module provides imperative-style testbench components for simulating and verifying hardware designs, offering operations to step through simulation cycles, manage signal updates, and assert expected outcomes. It works directly with hardware description data types such as signals, clocks, and simulation states, enabling concrete use cases like driving input stimuli, verifying circuit behavior over time, and modeling synchronous hardware with pipelining and signal synchronization. The module supports granular control over dynamic state transitions and structured data processing in cycle-accurate and event-driven simulations.",
      "description_length": 635,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Step_monads",
      "library": "hardcaml_step_testbench",
      "description": "This module defines monadic structures for sequencing simulator updates within a testbench framework. It works with simulation state and action types to model step-based transitions and effects. Concrete use cases include composing clock cycles, signal changes, and delay injections in a hardware simulation workflow.",
      "description_length": 317,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench.Functional",
      "library": "hardcaml_step_testbench",
      "description": "This module provides a monadic framework for constructing cycle-accurate hardware simulations with precise control over signal updates, delays, and clock cycle sequencing. It operates on digital signals and hardware components, supporting hierarchical composition and stateful simulation. It is used to model and verify complex synchronous digital circuits, including state machines, pipelined datapaths, and register-transfer level designs.",
      "description_length": 441,
      "index": 202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_step_testbench.Before_and_after_edge",
      "library": "hardcaml_step_testbench",
      "description": "This module represents values associated with the states before and after a clock edge, storing separate data for each phase. It provides constructors to build such pairs, accessors to retrieve individual components, and mapping functionality to transform stored values. It is used to model signal transitions in digital circuit simulation, particularly for capturing register behavior around clock edges.",
      "description_length": 405,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_step_testbench",
      "library": "hardcaml_step_testbench",
      "description": "This module provides testbench infrastructure for hardware simulation, with constructs to model clock edges, sequence simulation steps, and manage signal transitions in digital circuits. It supports both functional and imperative simulation styles, handling digital signals, clock cycles, and state updates. Concrete use cases include building cycle-accurate testbenches, verifying synchronous logic, and simulating register transfers and pipelined operations.",
      "description_length": 460,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Component.Input_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module provides monadic operations for sequencing computations that produce input values within a digital component context. It supports `return`, `bind`, `map`, and `both` for composing and transforming input actions, enabling clean, imperative-style code for handling sequential logic. It works specifically with the `Component.Input_monad.t` type, representing values that may depend on future input events.",
      "description_length": 415,
      "index": 205,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Component.Flip_flop_with_load_enable_and_reset.Input",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module defines the input structure for a flip-flop component with load enable and reset signals. It includes operations to create an undefined input state, compare inputs for equality, and serialize inputs to S-expressions. It works with boolean signals for data input, load enable, and reset, and is used to control the behavior of a flip-flop in digital circuit simulations.",
      "description_length": 381,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Component.Input_monad.Let_syntax",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module provides monadic operations for sequencing and transforming input computations in a digital component context. It supports `return`, `bind` (`>>=`), `map` (`>>|`), and `both` to compose asynchronous input actions, working directly with `Component.Input_monad.t` values that represent future input events. Concrete use cases include building complex input pipelines, such as waiting for multiple signals, transforming input values, or chaining dependent input actions in hardware simulation or reactive systems.",
      "description_length": 522,
      "index": 207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Component.Input_monad.Monad_infix",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module defines monadic composition operators for sequencing and transforming computations within a specific monadic structure. It works with values of type `'a Component.Input_monad.t`, enabling chaining of operations where each computation may depend on or transform the result of the previous. These operators are used to build complex input-processing pipelines in a concise, readable form by combining individual input-handling steps.",
      "description_length": 443,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Component.Flip_flop_with_load_enable.Input",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module defines the input structure for a flip-flop with load enable, consisting of a boolean input and a load enable signal. It provides functions to serialize the input to an S-expression, compare inputs for equality, and obtain an undefined input value. This structure is used to model digital components where data is conditionally loaded based on the load enable signal.",
      "description_length": 379,
      "index": 209,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Digital_components.Component.Make.Input_monad.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module provides monadic operations for sequencing computations that produce values within an `Input_monad.t` context. It includes functions like `bind`, `map`, and `both` to compose and transform monadic values, enabling concise expression of dependent and parallel computations. It is used when building complex input-driven logic where intermediate results influence subsequent steps or need to be combined.",
      "description_length": 414,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Component.Make.Input_monad.Monad_infix",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module defines monadic composition operators for sequencing input-handling computations. It provides `>>=` for chaining input monad values and `>>|` for mapping results of such computations. These operations are used to build complex input processing pipelines, such as parsing sequences of user inputs or handling optional data flows, where each step depends on the result of the previous.",
      "description_length": 395,
      "index": 211,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Component.Make.Flip_flop_with_load_enable.Input",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module defines a data structure representing the input to a flip-flop with load enable functionality, consisting of a boolean input and a load enable signal. It provides functions to create an undefined input state, compare inputs for equality, and serialize inputs to S-expressions. This module is used to model control and data signals in digital circuit simulations where state updates are conditional on a load enable.",
      "description_length": 427,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Component.Input_monad",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module implements monadic operations for composing input-handling computations in a digital component context. It works with values of type `'a Component.Input_monad.t`, representing asynchronous input events, and provides sequencing (`>>=`), transformation (`>>|`), and combination operations like `all` and `join`. Concrete use cases include building input pipelines that wait for multiple signals, chain dependent input actions, or transform input values in hardware simulations or reactive systems.",
      "description_length": 507,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Component.Combinational",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module implements combinational logic components for digital circuits, providing operations to define and compose logic gates and multiplexers. It works with signal and port data types to model inputs, outputs, and internal connections. Concrete use cases include building arithmetic logic units, control logic, and data path elements in hardware descriptions.",
      "description_length": 365,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Component.Make.Input_monad.Let_syntax",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module provides monadic sequencing operations like `bind` (`>>=`) and `map` (`>>|`) for composing computations that yield values within an `Input_monad.t` context. It supports building complex input-processing pipelines where each step depends on or transforms the result of a prior computation. Use it to express chained or parallel input-driven logic, such as parsing structured input or validating multi-step forms.",
      "description_length": 423,
      "index": 215,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Component.Next_input",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "Converts a value of type `'i Component.Next_input.t` to an S-expression using a provided function to serialize the input type `'i`. Works with polymorphic input types and the `Component.Next_input.t` structure. Useful for logging or debugging step monad components that handle input transitions in signal processing pipelines.",
      "description_length": 326,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Let_syntax.Let_syntax",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module provides monadic operations for composing computations that carry additional context, such as error handling or state. It works with a polymorphic monadic type `('a, _, _) t`, supporting chaining through `bind`, transforming values with `map`, combining results with `both`, and wrapping values with `return`. Concrete use cases include structuring asynchronous workflows, managing validation pipelines, or sequencing stateful operations with clear error propagation.",
      "description_length": 479,
      "index": 217,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Component.Flip_flop_with_load_enable",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module implements a flip-flop with load enable functionality, providing a `create` function that constructs a component accepting an input structure with a boolean value and a load enable signal. It works with the `Input` type, which includes the data and enable flag, and the `Output` type representing the stored state. This component is used to model sequential logic circuits where data is conditionally stored based on the load enable input.",
      "description_length": 451,
      "index": 218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Digital_components.Component.Make.Flip_flop_with_load_enable_and_reset.Input",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module defines a data structure representing the input signals to a flip-flop with load enable and reset controls, consisting of three boolean fields: input, load_enable, and reset. It provides functions to serialize the input state to an S-expression, compare two input values for equality, and obtain an undefined input value. This module is used to model digital circuit behavior where flip-flop inputs need explicit control signals for loading, resetting, and data input.",
      "description_length": 480,
      "index": 219,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Component.Flip_flop_with_load_enable_and_reset",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module implements a flip-flop component with load enable and reset control signals. It provides a function to create a flip-flop component that takes input signals for data, load enable, and reset, and produces an output state based on clocked transitions. The component operates on boolean signal inputs and is used in digital circuit simulations to model state storage elements with conditional updates and reset behavior.",
      "description_length": 429,
      "index": 220,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Event",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module implements computations around events that transition from undetermined to determined states. It provides functions to inspect an event's current state (`value`) and serialize it (`sexp_of_t`). Use it to model time-sensitive data like asynchronous results or timed signals in reactive systems.",
      "description_length": 305,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Component.Make.Flip_flop_with_load_enable_and_reset",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module implements a flip-flop with load enable and reset controls, operating on input signals defined by the `Input` submodule, which includes `input`, `load_enable`, and `reset` boolean fields. It provides a `create` function to instantiate the component, which processes input signals to produce output values based on the flip-flop's state transitions. Use this module to model controlled data storage elements in digital circuits, where explicit load and reset signals determine when and how data is updated or cleared.",
      "description_length": 528,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Component",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module provides functions to construct and simulate digital circuits using combinational logic gates (e.g., OR, NOT) and sequential components like flip-flops with load enable/reset controls. It operates on boolean signals and structured input types to model state transitions and conditional updates, enabling applications such as hardware behavior modeling and digital system verification. Specific use cases include simulating logic gate networks, managing stateful storage elements, and validating sequential circuit behavior under varying input sequences.",
      "description_length": 565,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Component.Make.Next_input",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "Handles serialization of input values into S-expressions for digital circuit components. Works with generic input types `'i` and structures that represent input states. Useful for debugging or logging the current state of a component's inputs in a readable format.",
      "description_length": 264,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Component.Make.Combinational",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module implements combinational logic circuits using boolean gates and signal propagation. It provides functions to create and connect logic gates (AND, OR, NOT) and define circuit behavior through signal transformations. It operates on digital signals represented as boolean values and supports building complex circuits from primitive components. Use this module to model hardware circuits, simulate logic operations, or implement digital design patterns like multiplexers and adders.",
      "description_length": 491,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Component.Make.Input_monad",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module implements monadic operations for sequencing and transforming input-handling computations that produce values wrapped in `Input_monad.t`. It supports data types like `'a Input_monad.t`, allowing for chaining with `>>=`, mapping with `>>|`, and combining lists of monadic values with `all` and `all_unit`. Concrete use cases include parsing multi-step user input, validating form fields in sequence, and handling optional or conditional input flows where each step depends on the prior result.",
      "description_length": 504,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Component.Make.Flip_flop_with_load_enable",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module implements a flip-flop with load enable behavior, allowing state updates to occur only when the load enable signal is active. It works with boolean values and the input structure defined in the Input submodule to control data flow and state transitions. It is used in digital circuit simulations to model registers that conditionally store data based on control signals.",
      "description_length": 382,
      "index": 227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Monad_infix",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module provides monadic bind and map operations for a three-argument monad type, where the second and third arguments are carried through unchanged. It enables chaining computations that maintain additional static or configuration data across steps. Useful for scenarios like simulation steps with shared context or error handling with attached metadata.",
      "description_length": 359,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Component_finished",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "Converts values of type `('a, 'o) Component_finished.t` to S-expressions using provided conversion functions for the input and output types. Works with any algebraic data type that represents a component's final state, including success and error cases. Useful for logging or serializing the outcome of a step in a computation pipeline.",
      "description_length": 336,
      "index": 229,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Digital_components.Step_monad.Make.Let_syntax",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module provides monadic operations for composing context-aware computations, such as error handling or stateful transformations, using a polymorphic type `('a, _, _) t`. It supports chaining with `bind` (`>>=`), value transformation with `map` (`>>|`), and value injection with `return`. Concrete use cases include structuring validation flows, sequencing asynchronous operations, and managing state transitions with explicit error handling.",
      "description_length": 446,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Component.M",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module implements digital circuit components that process and transform input signals using monadic operations. It defines combinational and sequential logic elements, such as gates, multiplexers, and registers, which operate on signal values encapsulated in the `Input_monad` type. It is used to model hardware circuits where inputs propagate through interconnected components with defined timing and transformation behavior.",
      "description_length": 431,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Data.Pair",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module represents pairs of values from two distinct data modules, supporting equality checks, S-expression serialization, and providing an undefined value. It operates on the product type formed by the two parameter modules, enabling structured composition of heterogeneous data. Concrete use cases include modeling key-value pairs in a symbolic computation system or combining results from dual analysis passes.",
      "description_length": 417,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Step_monad.Make",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module provides monadic operations for simulating digital circuits, combining combinational logic with sequential elements through state transitions, signal propagation, and time-based control. It operates on boolean signals, events, and hierarchical components with S-expression serialization, enabling precise modeling of reactive systems like flip-flops, state machines, and hierarchical designs requiring explicit timing and input/output coordination.",
      "description_length": 460,
      "index": 233,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Digital_components.Data.Unit",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module defines a singleton type `t` representing the unit value, along with functions to serialize it to an S-expression, compare values for equality, and provide an undefined instance. It is used to model computations or signals that carry no meaningful data, such as representing the absence of input or output in digital circuits. Concrete use cases include placeholder values in test frameworks and signaling completion in event-driven systems.",
      "description_length": 453,
      "index": 234,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Digital_components.Data.Int",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module defines a concrete integer type with serialization, equality checking, and an undefined value. It supports operations for converting integers to S-expressions, comparing them for equality, and representing an uninitialized or invalid state. Use this module when working with integer data in contexts requiring serialization, such as configuration parsing or logging, and when needing a clear representation of undefined values.",
      "description_length": 439,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Component.Module",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module defines a set of operations for composing and simulating digital circuits, including functions to create, connect, and evaluate logic gates and signal wires. It works with data types representing circuit components such as gates, inputs, outputs, and wire connections. Concrete use cases include building combinational logic circuits, simulating circuit behavior with specific input patterns, and verifying circuit correctness through signal propagation.",
      "description_length": 466,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Step_monad.M",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module implements a monadic structure for sequencing computations that represent discrete steps, where each step may depend on the result of the previous. It works with input values wrapped in an input monad, allowing chaining of step-based operations while handling effects such as errors or state changes. It is useful for modeling workflows where each stage transforms data and passes it to the next, such as in a multi-phase compiler pipeline or a form-processing sequence.",
      "description_length": 482,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Data.Bool",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module defines a boolean type and provides serialization to S-expressions, equality checking, and an undefined value. It works directly with boolean values, offering concrete operations for comparison and data representation. Use cases include representing logical states in digital circuits and handling boolean data in configurations or protocols.",
      "description_length": 354,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Component.Make",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module supports composing circuits through input/output transformations and state updates, with operations for simulating sequential logic over input sequences and pruning inactive subcomponents. It works with combinational logic gates (e.g., AND, OR, NOT), boolean values, and stateful elements like flip-flops that incorporate control signals (load enable, reset) for conditional storage and transitions. These capabilities are tailored for digital circuit simulation and hardware modeling tasks requiring precise state management and signal propagation.",
      "description_length": 561,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Data.String",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module defines a string type and provides functions for converting strings to S-expressions, checking equality, and representing undefined string values. It works directly with Base strings and Sexplib0 S-expressions. Concrete use cases include serializing string data for debugging or configuration files and comparing string values in data processing pipelines.",
      "description_length": 368,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Step_monad",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module implements a monadic structure for sequencing step-based computations, where each step can transform data and pass it to the next, supporting workflows like multi-phase compiler pipelines or form-processing sequences. It works with input values wrapped in an input monad, enabling chaining of operations while handling effects such as errors or state changes. Additionally, it provides monadic operations for simulating digital circuits by combining combinational logic with sequential elements, operating on boolean signals and hierarchical components with S-expression serialization.",
      "description_length": 597,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Component",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module provides operations for constructing and simulating digital circuits using logic gates, signal wires, and stateful components. It supports combinational and sequential logic design, enabling tasks such as modeling register transfers, evaluating signal propagation, and simulating circuit behavior under varying input conditions. Key data types include representations for gates, inputs, outputs, wires, and state elements like flip-flops.",
      "description_length": 450,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Digital_components.Data",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module defines core data types\u2014boolean, integer, string, and unit\u2014with support for S-expression serialization, equality checks, and undefined value handling. Each submodule provides concrete operations tailored to its type, such as logical state representation for booleans, integer conversion for configuration parsing, string comparison in data pipelines, and unit values for signaling in digital circuits. Use these types directly in contexts requiring structured data serialization, state tracking, or explicit handling of uninitialized values.",
      "description_length": 553,
      "index": 243,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Digital_components",
      "library": "hardcaml_step_testbench.digital_components",
      "description": "This module combines digital circuit simulation with structured data handling and monadic workflow sequencing. It supports construction and simulation of logic gates, wires, and state elements, processes boolean, integer, string, and unit data with serialization and comparison, and sequences step-based computations for digital signal processing and pipeline execution. Use it to model register transfers, simulate circuit behavior, and implement multi-phase logic with typed data flow.",
      "description_length": 487,
      "index": 244,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 270,
    "meaningful_modules": 245,
    "filtered_empty_modules": 25,
    "retention_rate": 0.9074074074074074
  },
  "statistics": {
    "max_description_length": 733,
    "min_description_length": 232,
    "avg_description_length": 427.4,
    "embedding_file_size_mb": 3.551248550415039
  }
}