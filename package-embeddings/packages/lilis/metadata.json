{
  "package": "lilis",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 15,
  "creation_timestamp": "2025-06-18T16:34:25.876782",
  "modules": [
    {
      "module_path": "LisCC.Gen",
      "description": "Provides operations to create, transform, and traverse sequences, including mapping, expanding, iterating, and folding over elements. Works with two types: `t` for active generators and `stored` for restartable generator states. Used to generate and manipulate sequences in a controlled, stateful manner, such as producing custom iteration patterns or managing reinitialization of data sources.",
      "description_length": 394,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LisCC.KList",
      "description": "Provides operations to transform, iterate, and fold over persistent linked lists, including mapping, expanding elements, and converting between lists and stored representations. Works with persistent list structures and their stored variants, enabling efficient immutability and sharing. Used to process sequences with guaranteed persistence, such as maintaining versioned data or incremental updates.",
      "description_length": 401,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "LisCC.Sequence",
      "description": "Provides operations to create, transform, and iterate over sequences, including mapping, expanding, folding, and converting to and from lists. Works with two types: `'a t` for active sequences and `'a stored` for persistent storage. Used to process ordered data streams, accumulate results, and manage immutable sequence states efficiently.",
      "description_length": 340,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LisUtils.SMap",
      "description": "This module provides ordered map manipulations, including key-value pair management, traversal, and transformation, with operations like insertion, deletion, merging, and filtering. It works with structured data where keys are strings and values can be arbitrary types, enabling efficient querying and conditional processing. Use cases include configuration management, data aggregation, and scenarios requiring ordered key access or dynamic value adjustments.",
      "description_length": 460,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Calc.Env",
      "description": "Provides operations to manage a collection of named floating-point values, including adding entries, checking membership, merging environments, and creating from a list. Works with a custom type `t` representing a variable environment. Used to initialize standard mathematical constants like pi and e, or combine multiple sets of variables for computations.",
      "description_length": 357,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilis.SymbEnv",
      "description": "Creates and manages a symbolic environment by extracting rules from a stream and adding axioms or rules to it. Operates on streams of strings, rule lists with string keys, and polymorphic rule structures. Used to build environments for symbolic compression and decompression workflows.",
      "description_length": 285,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Lilis.Make",
      "description": "Provides operations to create, transform, and traverse a container type, including mapping over elements, expanding into new containers, and folding values. Works with two related types: a mutable container ('a t) and a snapshot version ('a stored'). Used to process collections by applying functions, accumulating results, and converting between list and container representations.",
      "description_length": 382,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "lilis",
      "description": "Provides functions to parse and manipulate lightweight JSON-like structures, including parsing from strings, extracting values by key, and merging maps. Works with associative arrays and nested key-value pairs represented as lists. Used to process configuration data and transform structured input in scripting workflows.",
      "description_length": 321,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LisCC",
      "description": "combines sequence generation, transformation, and traversal across active and persistent data structures, supporting both stateful and immutable operations. It handles two primary types: `t` for active sequences and `stored` for persistent representations, enabling tasks like custom iteration, data accumulation, and versioned updates. Operations include mapping, folding, expanding, and converting between list and stored forms, allowing for efficient processing of ordered data streams. Examples include generating dynamic sequences, maintaining immutable history, and managing reusable data sources.",
      "description_length": 603,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LisUtils",
      "description": "manages structured data through ordered maps with string keys and arbitrary values, supporting insertion, deletion, merging, and filtering for dynamic data manipulation. It enables efficient traversal and transformation, making it suitable for configuration handling and data aggregation tasks. Operations like conditional filtering allow for precise data extraction and modification. Examples include adjusting settings in a configuration file or combining multiple data sources into a unified structure.",
      "description_length": 505,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Calc",
      "description": "manages a collection of named floating-point values using a custom type `t`, enabling addition, membership checks, merging, and list-based creation. It supports initializing standard constants like pi and e, and combining multiple variable sets for complex calculations. Operations include `add`, `mem`, `merge`, and `of_list`. For example, you can create an environment with `pi` and `e`, then merge it with user-defined variables to evaluate expressions.",
      "description_length": 456,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "CalcUtils",
      "description": "Converts arithmetic expressions between string representations and internal data structures. Processes expressions using parsing and pretty-printing functions. Used to serialize and deserialize expressions for storage or transmission.",
      "description_length": 234,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Glilis",
      "description": "Provides functions to manage L-system rules and transformations, including mapping tokens to orders with arity and applying turtle graphics transformations. Operates on custom types like positions, colors, and turtle states, enabling abstract movement calculations. Used to generate and manipulate graphical L-systems, integrating with rendering backends like Cairo or Tyxml.",
      "description_length": 375,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Lilis",
      "description": "Provides operations to create and transform lazy, stream-like structures with O(1) concatenation, including mapping, expanding, iterating, and folding. Works with two types: `'a t` for lazy sequences and `'a stored` for immutable, reusable versions of these sequences. Enables efficient conversion between lists and streams, and allows reusing a stored sequence to generate new instances.",
      "description_length": 388,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "LisOptim",
      "description": "Optimizes L-systems by merging consecutive constant symbols into single symbols with combined post rules, and simplifies arithmetic expressions within rules using environment-aware compression. It operates on L-systems represented as tuples of a starting symbol and a list of calculated rules. This enables more efficient execution by reducing redundant symbols and simplifying calculations in geometric generation workflows.",
      "description_length": 425,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 15,
    "meaningful_modules": 15,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 603,
    "min_description_length": 234,
    "avg_description_length": 395.06666666666666,
    "embedding_file_size_mb": 0.054920196533203125
  }
}