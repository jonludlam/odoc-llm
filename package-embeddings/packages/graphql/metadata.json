{
  "package": "graphql",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 10,
  "creation_timestamp": "2025-08-14T23:29:25.312888",
  "modules": [
    {
      "module_path": "Graphql.Schema.Io.Stream",
      "library": "graphql",
      "description": "This module provides streaming capabilities for processing GraphQL schema elements incrementally. It supports operations like `map` to transform streamed values, `iter` to perform side effects on each item, and `close` to terminate the stream. It works with streams of arbitrary type `'a` in the context of GraphQL schema IO, enabling use cases such as real-time schema validation feedback or incremental schema documentation generation.",
      "description_length": 437,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql_schema.Make.StringMap",
      "library": "graphql",
      "description": "This module provides operations for managing ordered string-keyed maps, including creation, modification, and querying of key-value pairs, as well as bulk transformations, filtering, and structural operations like merging and splitting. It works with the `StringMap` data structure, which ensures ordered traversal and supports efficient lookups,",
      "description_length": 346,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql_schema.Make.Arg",
      "library": "graphql",
      "description": "This module defines argument types and values for building GraphQL schemas, supporting operations like creating scalar, enum, and object types with optional or non-null constraints. It works with abstract data structures representing GraphQL arguments, including typed values, enums, and nested objects. Concrete use cases include defining input parameters for GraphQL resolvers, such as filtering options, configuration objects, or validation rules.",
      "description_length": 450,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql.Schema.StringMap",
      "library": "graphql",
      "description": "This module provides operations for managing ordered maps with string keys and arbitrary values, supporting standard manipulations like insertion, deletion, and lookup, as well as transformations through mapping, filtering, and folding. It includes utilities for merging, splitting, and comparing maps, along with conversions to and from lists and sequences. These capabilities are particularly useful in GraphQL schema construction, query variable handling, and field mapping workflows where ordered string-keyed data structures are required.",
      "description_length": 543,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql.Schema.Io",
      "library": "graphql",
      "description": "This module implements monadic operations for building and composing GraphQL schema IO actions. It supports `return` to wrap values in the IO context and `bind` to chain schema IO computations, enabling precise control over side-effecting operations during schema execution. These functions are used to handle effects like logging, error reporting, or external data fetching while processing GraphQL schemas.",
      "description_length": 408,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Graphql.Schema.Arg",
      "library": "graphql",
      "description": "This module defines and constructs GraphQL argument definitions for schema fields, supporting scalar, enum, object, and composite types. It provides functions to specify argument metadata like documentation, type coercion, and field structure, enabling precise schema declarations. Concrete use cases include defining input parameters for GraphQL queries, such as filtering options, configuration objects, or scalar values with validation logic.",
      "description_length": 445,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql.Schema",
      "library": "graphql",
      "description": "This module enables constructing and validating GraphQL schemas through type-safe definitions of objects, enums, scalars, unions, and abstract types, alongside utilities for managing fields, arguments, and execution logic. It operates on structured data like parsed GraphQL documents and abstract values, supporting use cases such as API schema design with documented deprecation, argument validation, and efficient query resolution. The integration of string maps and IO operations facilitates dynamic schema assembly and interaction with external data sources during execution.",
      "description_length": 579,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql_schema",
      "library": "graphql",
      "description": "This module defines the structure and validation rules for GraphQL schemas, including type definitions, field configurations, and directive handling. It works with abstract syntax trees (ASTs) representing GraphQL documents and schema definitions. Concrete use cases include validating queries against a schema, inferring types from schema definitions, and generating introspection data for API documentation.",
      "description_length": 409,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql_intf",
      "library": "graphql",
      "description": "This module defines core abstractions for building GraphQL schemas, including type definitions for input/output handling, field error reporting, and schema construction. It works with algebraic data types representing GraphQL types, fields, and execution contexts. Concrete use cases include defining query and mutation resolvers, validating input values, and generating schema introspection data.",
      "description_length": 397,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Graphql",
      "library": "graphql",
      "description": "This module provides type-safe construction and validation of GraphQL schemas, including definitions for objects, enums, scalars, and abstract types, along with utilities for field and argument management. It works with structured data such as parsed GraphQL documents and abstract values, enabling precise schema design and query resolution. Concrete use cases include building documented APIs with deprecation support, validating input arguments during execution, and dynamically assembling schemas from external data sources.",
      "description_length": 528,
      "index": 9,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 11,
    "meaningful_modules": 10,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9090909090909091
  },
  "statistics": {
    "max_description_length": 579,
    "min_description_length": 346,
    "avg_description_length": 454.2,
    "embedding_file_size_mb": 0.14531898498535156
  }
}