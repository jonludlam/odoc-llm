{
  "package": "universo",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 28,
  "creation_timestamp": "2025-08-15T12:33:18.097655",
  "modules": [
    {
      "module_path": "Common.Universes.C",
      "library": "universo.common",
      "description": "This module implements a set-like structure for managing collections of constraints, supporting operations like union, intersection, and difference alongside element addition/removal. It provides traversal, transformation, and filtering capabilities (e.g., `fold`, `map`, `filter`) while enabling conversions to and from lists and bidirectional sequences. Designed for scenarios requiring precise constraint manipulation, such as constraint solving or static analysis workflows.",
      "description_length": 478,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Logic.MakeLraSpecif",
      "library": "universo.common",
      "description": "This module defines functions for constructing logical axioms, rules, and cumulative operations using a given logic structure. It works with polymorphic logic terms represented by the type `'b` and a context type `'c`, parameterized over the logic operations provided by the `Lra` module. Concrete use cases include building logical expressions and inference rules in formal verification tasks involving linear real arithmetic.",
      "description_length": 427,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Oracle.Util",
      "library": "universo.common",
      "description": "Implements Cartesian product operations for 2- and 3-argument functions over lists. Applies a given function to all combinations of elements from two or three input lists. Useful for generating combinations of configuration parameters or input values for testing.",
      "description_length": 263,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Constraints",
      "library": "universo.common",
      "description": "This module manages constraint generation and printing for type variables and universes, handling operations like creating equality constraints, rule construction, and dependency tracking. It works with data types including constraint records with equality, cumulative, and universe rules, as well as variable and universe predicates. Concrete use cases include enforcing type equality, generating universe constraints during type checking, and formatting constraint output for debugging or logging.",
      "description_length": 499,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Logic",
      "library": "universo.common",
      "description": "This module defines functions for constructing logical axioms, inference rules, and cumulative operations using a specified logic structure. It operates on polymorphic logic terms and a context type, parameterized over logic operations. It is used to build logical expressions and verification rules in formal reasoning tasks involving linear real arithmetic.",
      "description_length": 359,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Files",
      "library": "universo.common",
      "description": "This module supports path manipulation, output management, and mapping of file operations to input/output channels and module identifiers, abstracting file handling for compiler or build system workflows. It operates on file paths, processing steps, directory hierarchies, and theory files, enabling use cases like step-specific file routing, output directory orchestration, and structured data export in transformation pipelines.",
      "description_length": 430,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Common.Oracle",
      "library": "universo.common",
      "description": "This module implements operations for constructing and querying theories over a universe hierarchy, including checking truth values of axioms, cumulative relations, and rules within a given configuration. It works with predicates and universe levels, organizing them into theories that map predicates to boolean arrays indexed by universe levels. The module supports concrete tasks like enumerating universes up to a limit and generating full theories for testing or analysis.",
      "description_length": 476,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Universes",
      "library": "universo.common",
      "description": "This module provides operations for representing and manipulating universe levels and constraints, constructing and deconstructing terms, and inspecting term forms. It works with algebraic data types like `univ`, `pred`, and `cstr`, alongside terms (`T.term`), using set-like operations and encoding/decoding patterns. These tools are applied in type theory contexts for tasks such as constraint solving and managing universe polymorphism during type checking.",
      "description_length": 460,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common.Log",
      "library": "universo.common",
      "description": "This module provides colored output formatting through functions like `red`, `blu`, and `yel`, which transform format strings for terminal display. It supports conditional logging via `log`, `log_check`, and similar functions, allowing selective output based on active flags. Use cases include debugging with color-coded messages and controlling log verbosity in interactive development tools.",
      "description_length": 393,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Common",
      "library": "universo.common",
      "description": "This module aggregates functionalities for constraint management, file handling, logging, logical reasoning, theory querying, and universe manipulation. It includes operations for generating and solving type constraints, managing file paths and I/O, formatting log output, constructing logical expressions, verifying axiom truth values, and handling universe polymorphism. Use cases include type checking in compilers, structured data transformation, interactive development tools, and formal verification workflows.",
      "description_length": 516,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Solving.Z3cfg.Make",
      "library": "universo.solving",
      "description": "This module implements a solver for universe constraints using the Z3 SMT solver. It provides operations to add constraints incrementally and to solve them, determining the minimal number of universes required along with a corresponding model. It works with constraints represented as `Common.Universes.cstr` and interacts with environment and model types from `Solving.Utils`.",
      "description_length": 377,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Solving.Solver.Make",
      "library": "universo.solving",
      "description": "This module parses constraint files, solves them under a given environment to find the minimum number of universes required, and prints the resulting model to solution files. It operates on constraint data loaded from file paths and uses configuration rules to translate universes into output terms. Concrete use cases include solving logic puzzles or constraint satisfaction problems where the input defines dependencies between entities.",
      "description_length": 439,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Solving.Z3cfg.Arith",
      "library": "universo.solving",
      "description": "Implements SMT-based arithmetic reasoning with Z3, providing functions to construct variables, axioms, cumulativity, and rule expressions over universes. Operates on Z3 expressions, contexts, and models, translating Dedukti names and universe constraints into SMT terms. Used to encode and solve universe-level arithmetic constraints during type checking or proof search.",
      "description_length": 371,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Solving.Solver.MakeUF",
      "library": "universo.solving",
      "description": "This module parses constraint files, solves them under a given environment to determine the minimum number of universes required, and prints the resulting model to a solution file. It operates on constraint data loaded from file paths and uses environment configurations to guide solving. Concrete use cases include solving universe hierarchy constraints in formal verification tasks and generating model outputs for further analysis.",
      "description_length": 434,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Solving.Z3arith.Make",
      "library": "universo.solving",
      "description": "This module implements arithmetic constraint solving over integer variables using Z3 expressions, providing operations to construct variables, constants, and arithmetic expressions like maximum and inequalities. It supports solving systems involving universal values and integer bounds, with functions to extract solutions from Z3 models. Concrete use cases include encoding integer arithmetic constraints for program verification and automated reasoning tasks.",
      "description_length": 461,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Solving.Z3cfg.Syn",
      "library": "universo.solving",
      "description": "This module directly constructs and manipulates SMT expressions representing universes, variables, and logical predicates used in universe checking. It provides functions to build expressions for axioms, cumulativity, and rules, and to extract universe solutions from SMT models. It is used to encode and solve universe constraints in a logical context specific to type theory.",
      "description_length": 377,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Solving.Z3cfg",
      "library": "universo.solving",
      "description": "This module provides three submodules for solving universe constraints with Z3. `Make` implements a solver for incrementally adding and solving constraints, determining minimal universes and models. `Syn` constructs and manipulates SMT expressions for universe-related logical predicates, while `Arith` handles arithmetic reasoning over universes, translating Dedukti terms into SMT expressions for type checking and proof search.",
      "description_length": 430,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Solving.Solver",
      "library": "universo.solving",
      "description": "This module provides functions to parse constraint files, solve constraints under a given environment, and output the resulting model to solution files. It works with constraint data structures loaded from file paths and environment configurations that guide the solving process. It is used to solve logic puzzles, constraint satisfaction problems, and to generate universe hierarchies for formal verification tasks.",
      "description_length": 416,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Solving.Utils",
      "library": "universo.solving",
      "description": "This module defines core components for configuring and solving constraint satisfaction problems over logical theories. It includes types for logic kinds (`Qfuf`, `Lra`), solver interfaces, and environment settings to control universe bounds and output behavior. It is used to instantiate and manage SMT-based solvers that generate models mapping names to universe values under specified logical constraints.",
      "description_length": 408,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Solving.Z3arith",
      "library": "universo.solving",
      "description": "This module provides operations to construct and solve integer arithmetic constraints using Z3 expressions, including variables, constants, inequalities, and functions like maximum. It works with integer variables and expressions to model and solve constraint systems, particularly for program verification and automated reasoning tasks. Use cases include encoding arithmetic conditions for bounded integer variables and extracting concrete solutions from Z3 models.",
      "description_length": 466,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Solving.Z3syn",
      "library": "universo.solving",
      "description": "This module directly constructs and manipulates Z3 expressions and models for formal reasoning tasks. It provides functions to build variables, sorts, axioms, cumulativity constraints, and inference rules within a Z3 context, operating on expressions, models, and universes. Concrete use cases include encoding logical constraints for type systems and extracting solutions from Z3 models for universe variables.",
      "description_length": 411,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Solving",
      "library": "universo.solving",
      "description": "This module provides functions for parsing constraint files, solving constraint systems under specific environments, and outputting models. It operates on constraint data structures and environment configurations to support solving logic puzzles, constraint satisfaction problems, and generating universe hierarchies for formal verification. Each submodule targets specific aspects of constraint solving, from arithmetic reasoning to SMT expression construction and incremental solving.",
      "description_length": 486,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elaboration.Elaborate",
      "library": "universo.elaboration",
      "description": "This module handles the replacement of concrete universe declarations in terms with fresh variables, using a given environment. It operates on terms, rules, and entries, modifying their structure to abstract over specific universe instances. Use cases include preparing terms for further processing where universe variables need to be generalized.",
      "description_length": 347,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elaboration.Var",
      "library": "universo.elaboration",
      "description": "This module generates and manages fresh universe variables with unique identifiers, providing operations to check term properties and extract variable names. It works with terms and identifiers from the core type system, maintaining an internal counter for uniqueness. Concrete use cases include creating new universe variables during type elaboration and checking whether a term represents a universe variable or a placeholder for instantiation.",
      "description_length": 446,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Elaboration",
      "library": "universo.elaboration",
      "description": "This module replaces concrete universe declarations in terms with fresh variables using an environment, operating on terms, rules, and entries to abstract over specific universe instances. It works with terms from the core type system, modifying their structure to generalize universe variables. Concrete use cases include preparing terms for further processing where universe variables need to be generalized.",
      "description_length": 410,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Checking.Checker.Typing",
      "library": "universo.checking",
      "description": "This module implements type inference and type checking for terms in a given signature. It provides functions to infer a type from a term and context, verify that a term matches an expected type, and process partially typed rules into fully typed forms. The module works directly with terms, contexts, and rules from the `Kernel` module, producing or consuming `typ` values representing inferred or checked types. Use cases include validating term correctness during compilation, ensuring rule consistency, and supporting interactive proof systems by reporting type mismatches.",
      "description_length": 577,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Checking.Checker",
      "library": "universo.checking",
      "description": "This module manages type checking and constraint validation for terms and entries in a formal proof system. It provides operations to infer and verify types, apply user-defined constraints, and dynamically adjust type environments during checking. It works with terms, contexts, rules, and environments from the `Kernel` and `Api.Env` modules, supporting use cases such as validating term correctness during compilation and enforcing rule consistency in interactive proof systems. Key functions include `check_user_constraints`, which enforces constraints on constants, and `mk_entry`, which type checks entries with dynamic convertibility adjustments.",
      "description_length": 652,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Checking",
      "library": "universo.checking",
      "description": "This module performs type inference and constraint validation for terms and entries in a formal proof system. It supports operations like `check_user_constraints` for enforcing constant constraints and `mk_entry` for type checking entries with dynamic adjustments. It works with terms, contexts, rules, and environments to ensure correctness during compilation and maintain rule consistency in interactive proofs.",
      "description_length": 413,
      "index": 27,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 29,
    "meaningful_modules": 28,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9655172413793104
  },
  "statistics": {
    "max_description_length": 652,
    "min_description_length": 263,
    "avg_description_length": 436.5,
    "embedding_file_size_mb": 0.40616893768310547
  }
}