{
  "package": "markup",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 6,
  "creation_timestamp": "2025-07-15T23:05:28.051871",
  "modules": [
    {
      "module_path": "Markup.ASYNCHRONOUS-Encoding",
      "library": "markup",
      "description": "This module provides an asynchronous character encoding detection and conversion function `decode` that processes a byte stream and recovers from errors while parsing malformed input. It works with asynchronous streams of characters and integers, handling encoding-specific transformations on the fly. Use it to parse HTML or XML input incrementally in non-blocking applications, such as reading from or writing to network streams without blocking execution.",
      "description_length": 458,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markup.Error",
      "library": "markup",
      "description": "This module defines error types for malformed HTML or XML input and provides a function to convert them into human-readable strings. It works with string-based error codes and optional source location data. Use it to handle and report parsing errors during document processing.",
      "description_length": 277,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markup.Ns",
      "library": "markup",
      "description": "This module defines standard namespace URIs for XML, HTML, SVG, MathML, and related specifications. It provides string constants for common namespaces, enabling precise handling of namespaced elements and attributes in parsed documents. Use it when working with XML or HTML documents that require namespace-aware processing, such as validating or generating SVG or MathML content.",
      "description_length": 380,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markup.ASYNCHRONOUS",
      "library": "markup",
      "description": "This module enables non-blocking parsing and serialization of XML and HTML streams through monadic I/O abstractions, handling incremental input via continuation-passing style callbacks that process `Markup.signal` sequences. It operates on streaming markup events to construct validated abstract syntax trees or transformed output, supporting use cases like real-time document processing in event-driven applications or integrating with Lwt/Async-based web frameworks. Error-resilient parsing and bidirectional stream conversion make it suitable for handling malformed fragments or large documents where strict validation and partial results are required.",
      "description_length": 655,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Markup.Encoding",
      "library": "markup",
      "description": "Handles character encoding conversion for byte streams during HTML and XML parsing. It provides decoders for common encodings like UTF-8, UTF-16, ISO-8859-1, and others, converting byte sequences into Unicode code points. Use cases include processing HTML or XML input in various encodings, recovering from decoding errors by substituting invalid sequences with replacement characters, and ensuring correct parsing of documents with non-standard or legacy encodings.",
      "description_length": 466,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Markup",
      "library": "markup",
      "description": "This library parses and serializes HTML and XML with error-recovering streaming algorithms, converting byte streams into structured markup signals or DOM-like trees. It operates on byte sequences, Unicode characters, and markup signals, offering transformations like encoding detection, namespace resolution, and error reporting. You can process malformed documents incrementally, extract structured data from fragments, or enforce strict validation by handling detailed parsing errors. Submodules handle encoding conversion, namespace constants, and non-blocking I/O, enabling real-time, resilient parsing and generation of HTML5, XHTML, or XML with support for legacy encodings and namespaced elements.",
      "description_length": 704,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 6,
    "meaningful_modules": 6,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 704,
    "min_description_length": 277,
    "avg_description_length": 490.0,
    "embedding_file_size_mb": 0.022237777709960938
  }
}