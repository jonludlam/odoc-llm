{
  "package": "re_parser",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 11,
  "creation_timestamp": "2025-07-15T23:07:31.136593",
  "modules": [
    {
      "module_path": "Re_parser.Open_on_rhs_intf.S-Applicative_infix",
      "library": "re_parser",
      "description": "This module provides applicative-style function application and sequencing operations for values wrapped in a context. It supports combining and transforming computations that carry values of type `'a t`, typically used for effectful or monadic operations. These functions are useful for composing parsers or asynchronous actions where the result of one computation influences the next.",
      "description_length": 386,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Re_parser.Open_on_rhs_intf.S",
      "library": "re_parser",
      "description": "The module offers applicative combinators to build and execute regular expressions, supporting operations like sequencing, optional/repeated matching, and substring capture. It works with regex patterns represented as `'a t` values, which can be converted to `Re.t` for matching against strings, and includes utilities for case sensitivity control and failure handling. Use cases include parsing input formats, validating textual data, and extracting structured information from documents, with specialized support for character-level and numeric patterns via the Char and Decimal submodules.",
      "description_length": 592,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Re_parser.Let_syntax.Let_syntax",
      "library": "re_parser",
      "description": "This module provides monadic operations for building and transforming parsers, including returning values, mapping functions over parser results, and combining parsers to capture pairs of results. It works with parser values represented as `'a Re_parser.t`. Concrete use cases include sequencing parsing steps, transforming parsed data inline, and constructing complex parsers from simpler components.",
      "description_length": 401,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Re_parser.Open_on_rhs_intf.S-Decimal",
      "library": "re_parser",
      "description": "This module defines parsers for decimal numbers, including individual digits, optional signs, unsigned integers, and full integers. It operates on input streams to recognize numeric literals in string-based data. Use it to parse integers from text sources like configuration files, user input, or data formats.",
      "description_length": 310,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Re_parser.Open_on_rhs_intf.S-Char",
      "library": "re_parser",
      "description": "This module provides parsers for matching individual characters based on specific properties or sets. It supports operations like matching any character, checking against a list of allowed or disallowed characters, and recognizing common character classes such as digits, letters, and whitespace. Use cases include building lexers, validating input formats, and parsing structured text where character-level precision is required.",
      "description_length": 430,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Re_parser.Open_on_rhs_intf",
      "library": "re_parser",
      "description": "This module defines an interface for parsing regular expressions with support for RHS operations, enabling substitution, matching, and transformation of string and pattern data. It integrates applicative-style combinators for sequencing and transforming effectful computations, allowing structured parsing and dynamic regex construction. Submodules provide specialized parsers for decimal numbers and character-level matching, supporting tasks like input validation, log parsing, and structured data extraction. You can compose regex patterns, handle optional or repeated matches, extract substrings, and parse numeric literals or character classes from text sources.",
      "description_length": 667,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Re_parser.Applicative_infix",
      "library": "re_parser",
      "description": "This module provides infix operators for composing parsers in an applicative style. It combines parser values and functions, allowing sequential parsing where results are combined or ignored. Use cases include building complex parsers by chaining simpler ones, such as parsing structured text formats or extracting values from streams.",
      "description_length": 335,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Re_parser.Decimal",
      "library": "re_parser",
      "description": "Parses integer values from strings using regular expressions. It provides parsers for individual digits, optional signs, unsigned integers, and full integers including sign handling. This module is useful for converting string inputs into integer values where the input format may include optional positive or negative signs followed by numeric digits.",
      "description_length": 352,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Re_parser.Let_syntax",
      "library": "re_parser",
      "description": "This module provides monadic and applicative combinators for building and sequencing parser operations over values of type `'a Re_parser.t`. It supports operations like `return`, function application with `<*>`, and sequencing with `<*`, `*>`, and `>>|`, enabling transformations and composition of parsing steps. The module allows chaining regex parsers, extracting values from matched patterns, and combining multiple parsers into structured results. Submodules extend these capabilities with additional combinators for handling parser composition and result manipulation.",
      "description_length": 574,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Re_parser.Char",
      "library": "re_parser",
      "description": "This module provides parsers for matching individual characters based on specific properties or sets. It includes primitives for matching any character, character inclusion or exclusion from a list, and predefined character classes like digits, letters, and whitespace. Use cases include building lexers, validating character inputs, or parsing structured text formats like CSV or JSON.",
      "description_length": 386,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Re_parser",
      "library": "re_parser",
      "description": "This module combines applicative parser combinators with specialized submodules to enable structured text parsing through regular expressions. It provides core data types like `'a Re_parser.t` for building and composing parsers, supporting operations such as sequencing, mapping, alternation, repetition, and capturing to extract and transform values from strings. With built-in support for character-level parsing, integer parsing, and infix operators, it allows tasks like validating input formats, extracting structured data from logs, and building custom regex patterns dynamically. Submodules enhance this functionality with utilities for parsing numeric literals, matching character sets, and applying monadic and applicative combinators to complex parsing workflows.",
      "description_length": 773,
      "index": 10,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 11,
    "meaningful_modules": 11,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 773,
    "min_description_length": 310,
    "avg_description_length": 473.27272727272725,
    "embedding_file_size_mb": 0.040413856506347656
  }
}