{
  "package": "cviode",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 12,
  "creation_timestamp": "2025-06-18T16:32:21.719827",
  "modules": [
    {
      "module_path": "Cviode.D.Contact1_damped",
      "description": "Computes a damping factor based on a given float input, used to adjust interaction strength in physical simulations. Operates on scalar float values to produce adjusted output for dynamic systems. Applied in scenarios requiring controlled energy loss in motion calculations.",
      "description_length": 274,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cviode.D.Contact2_damped",
      "description": "Computes a damping factor based on a given float input, used to adjust interaction strength in physical simulations. Operates on scalar float values to model resistance or energy loss. Applied in scenarios requiring gradual reduction of motion or force over time.",
      "description_length": 263,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cviode.S.Contact1_damped",
      "description": "Computes a damping factor based on a given float input, used to adjust interaction strength in physical simulations. Operates on scalar float values to produce smoothed transitions. Applied in scenarios requiring gradual state changes, such as easing animations or force dampening.",
      "description_length": 281,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cviode.S.Contact2_damped",
      "description": "Calculates a damping factor based on a given float input, used to adjust interaction strength in physical simulations. Operates on scalar float values to model energy loss over time. Applied in physics-based animations to smooth transitions between states.",
      "description_length": 256,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cviode.Make.Scalar",
      "description": "This module provides arithmetic operations (addition, multiplication, division) and mathematical transformations (trigonometric, hyperbolic, activation functions) on scalar numeric values of type `elt`. It processes individual numerical elements, applying element-wise computations to yield results of the same type. Use cases include numerical analysis, signal processing, and machine learning workflows requiring precise scalar manipulations.",
      "description_length": 444,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cviode.Make.Mat",
      "description": "Creates diagonal, upper triangular, and lower triangular matrices from input arrays, and generates identity matrices of specified size. Operates on array-like structures representing matrices. Used for linear algebra tasks such as constructing transformation matrices or extracting submatrices for numerical computations.",
      "description_length": 321,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cviode.Make.Linalg",
      "description": "Computes matrix inverses, logarithmic determinants, and Cholesky decompositions for dense numerical arrays. Performs singular value, QR, and LQ factorizations, and solves Sylvester and Lyapunov equations. Solves linear systems, continuous-time algebraic Riccati equations, and supports specialized solvers for discrete Lyapunov equations.",
      "description_length": 338,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cviode.Make",
      "description": "Combines scalar arithmetic and transformation functions with matrix construction and decomposition tools, enabling both element-wise operations and advanced linear algebra computations. It supports operations on `elt` types, matrix creation, and solving complex equations like Riccati and Lyapunov. Users can compute trigonometric functions, build diagonal matrices, and perform matrix inversions or factorizations. Examples include signal processing with scalar functions, constructing transformation matrices, and solving systems of linear equations.",
      "description_length": 552,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cviode.S",
      "description": "Calculates damping factors from float inputs to control interaction strength and energy loss in simulations, enabling smooth state transitions. Processes scalar float values to generate adjusted outputs for animations and physics models. Can be used to create easing effects or stabilize dynamic systems. Examples include smoothing user interface transitions or reducing oscillation in simulated forces.",
      "description_length": 403,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cviode.D",
      "description": "Calculates damping factors from float inputs to control energy loss in dynamic systems, using scalar values to adjust interaction strength or model resistance. Both modules perform similar core operations but apply the damping in distinct contexts\u2014either for motion adjustment or gradual force reduction. Functions accept a single float and return a modified scalar output. Examples include stabilizing simulated movements or reducing velocity over time in physics-based applications.",
      "description_length": 484,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "cviode",
      "description": "Computes numerical solutions for differential equations using contact Lagrangian mechanics, implementing symplectic integrators tailored for dissipative systems. Operates on phase space trajectories represented as tuples of position, velocity, and time, with custom data types for Lagrangian functions. Applied to model damped oscillators and forced mechanical systems, preserving geometric properties of the underlying physical laws.",
      "description_length": 434,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cviode",
      "description": "Combines scalar arithmetic, matrix operations, and damping calculations to support both basic and advanced numerical computations. It handles `elt` types, matrices, and float-based damping factors, offering functions for trigonometry, matrix decomposition, and system stabilization. Users can construct transformation matrices, solve linear equations, or apply damping to control simulation behavior. Examples include processing signals with scalar functions, building diagonal matrices, or reducing oscillation in physics models.",
      "description_length": 530,
      "index": 11,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 12,
    "meaningful_modules": 12,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 552,
    "min_description_length": 256,
    "avg_description_length": 381.6666666666667,
    "embedding_file_size_mb": 0.04402923583984375
  }
}