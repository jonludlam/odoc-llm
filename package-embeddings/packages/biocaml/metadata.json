{
  "package": "biocaml",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 173,
  "creation_timestamp": "2025-07-15T23:41:40.987987",
  "modules": [
    {
      "module_path": "Biocaml_ez.Lines.MakeIO",
      "library": "biocaml.ez",
      "description": "This module provides functions for reading and writing lines of text using futures and pipes. It works with `Future.Reader.t` and `Future.Writer.t` for streaming input and output, and supports writing to files with optional permissions and append mode. Concrete use cases include processing large text files asynchronously, such as reading log entries or writing formatted data to disk without blocking.",
      "description_length": 403,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Fastq.Illumina",
      "library": "biocaml.ez",
      "description": "This module parses and formats Illumina FASTQ sequence identifiers and tile information. It handles data types like `tile` and `sequence_id`, which represent physical sequencing locations and metadata. Functions convert these identifiers to and from string representations, enabling analysis of sequencing data provenance and spatial information.",
      "description_length": 346,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Lines.Transform",
      "library": "biocaml.ez",
      "description": "This module processes streams of line-based data, converting between raw strings and structured line items while handling incomplete or malformed input. It supports operations like grouping consecutive lines into pairs, converting line items back to strings with buffer control, and building custom parsing transforms with error handling. Concrete use cases include parsing line-oriented formats (e.g., FASTA, BED) where input must be processed in fixed line groups or transformed to and from string representations with precise newline handling.",
      "description_length": 546,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Lines.Buffer",
      "library": "biocaml.ez",
      "description": "This module provides a line-based parsing buffer that accumulates and processes input strings, allowing incremental feeding and retrieval of complete lines. It supports operations to add data (`feed_line`, `feed_string`), inspect queued lines (`peek_line`, `queued_lines`), and extract lines (`next_line`, `next_line_exn`), while tracking the current parsing position. It is used when reading or processing text input incrementally, such as during file or stream parsing where lines may arrive in chunks.",
      "description_length": 504,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Bam",
      "library": "biocaml.ez",
      "description": "This module provides functions to read and write BAM files, including handling headers and alignment records. It works with BAM headers and alignment data structures, supporting both fully and partially parsed alignments. Concrete use cases include processing sequencing data for genomic analysis, streaming alignments from large BAM files, and writing aligned reads to disk.",
      "description_length": 375,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_ez.Roman_num",
      "library": "biocaml.ez",
      "description": "This module converts integers to and from Roman numeral string representations. It supports parsing valid Roman numeral strings into integers and formatting integers as Roman numerals. Use this module when working with historical or stylistic numbering systems, such as numbering chapters, acts, or sections in documents or applications.",
      "description_length": 337,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_ez.Fasta",
      "library": "biocaml.ez",
      "description": "This module parses and processes FASTA files, handling headers, sequences, and various formatting options like comment styles and line length limits. It provides low-level parsing of individual FASTA elements and high-level functions to read entire files into structured streams. Concrete use cases include extracting sequence data from genomic datasets and validating FASTA-formatted input against specific formatting rules.",
      "description_length": 425,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_ez.Range",
      "library": "biocaml.ez",
      "description": "This module handles interval arithmetic and positional analysis for closed integer intervals, using a `t` type with `lo` and `hi` bounds. It supports operations like union, intersection, overlap detection, gap calculation, and positional ordering, often working with lists or associative lists of intervals to model relationships like containment or adjacency. It is particularly useful in genomic interval analysis, sequence feature mapping, or any domain requiring precise interval comparisons and transformations.",
      "description_length": 516,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_ez.Seq_range",
      "library": "biocaml.ez",
      "description": "This module represents and manipulates sequence ranges, each consisting of a string identifier and a numeric range. It provides functions to create, compare, parse, and convert sequence ranges to and from string representations in the format `seq:start-end`. Use cases include handling genomic or sequence data where regions of interest are defined by identifiers and coordinate ranges.",
      "description_length": 386,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Strand",
      "library": "biocaml.ez",
      "description": "This module represents DNA strand orientations using a single character type, supporting values for forward (`+`) and reverse (`-`) strands. It provides functions to convert between string representations (\"fwd\", \"rev\") and the character type, as well as to invert or normalize strand directions. Useful in bioinformatics pipelines for handling sequence alignment and genomic feature annotations consistently.",
      "description_length": 409,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_ez.Fastq",
      "library": "biocaml.ez",
      "description": "This module processes FASTQ files by parsing and writing streams of sequencing data, supporting operations like reading from input channels, extracting sequence, comment, and quality fields, and writing formatted output. It includes utilities for splitting headers and converting FASTQ entries to strings, enabling tasks like validation and transformation of high-throughput sequencing data. A child module specializes in handling Illumina sequence identifiers and tile metadata, offering data types such as `tile` and `sequence_id` with conversion functions for tracking physical sequencing locations. Together, they support detailed analysis of FASTQ content, from basic sequence processing to provenance tracking and spatial data interpretation.",
      "description_length": 748,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Bamstats",
      "library": "biocaml.ez",
      "description": "This module tracks and updates statistics for BAM file alignments, including counts for total reads, QC-passing reads, single and paired reads, and mapped reads. It works with BAM alignment data types like `Biocaml_unix.Bam.Alignment0.t` and `Biocaml_unix.Sam.alignment`. Use cases include summarizing alignment results and incrementally updating statistics while processing BAM files.",
      "description_length": 385,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Lines",
      "library": "biocaml.ez",
      "description": "This module processes streams of text lines with functions to read from and write to files, channels, and streams, supporting line-based parsing, transformation, and structured data handling. It works with data types like `item` and parsing buffers to manage input incrementally, enabling operations such as reading log entries, transforming line-based data, and writing formatted output with custom buffering and error handling. Submodules extend this functionality with asynchronous I/O using futures and pipes, structured line conversion for formats like FASTA and BED, and incremental parsing buffers for handling incomplete or chunked input. Specific use cases include streaming large log files, parsing multi-line records, and building custom line-based parsers with precise control over input and output.",
      "description_length": 811,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Phred_score",
      "library": "biocaml.ez",
      "description": "This module represents and manipulates PHRED quality scores, which are integers indicating base call accuracy in sequencing data. It supports conversion to and from characters (using ASCII offsets 33 or 64), integers, and probability values, as well as conversion to and from Solexa scores. Use cases include parsing FASTQ quality strings, validating score ranges, and converting between different quality score encodings in bioinformatics pipelines.",
      "description_length": 450,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_ez",
      "library": "biocaml.ez",
      "description": "This collection of modules provides tools for handling genomic data formats, sequence analysis, interval arithmetic, and related utilities. Key data types include BAM and FASTQ records, FASTA sequences, intervals, sequence ranges, strand orientations, Roman numerals, and PHRED scores, with operations for parsing, converting, and manipulating these structures. You can process large sequencing files efficiently, analyze genomic intervals, represent sequence regions and orientations, convert quality scores, and format integers as Roman numerals. Specific tasks include streaming alignments, validating FASTA files, computing interval overlaps, parsing FASTQ data with Illumina metadata, and converting quality scores between encodings.",
      "description_length": 738,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred.Or_error.List",
      "library": "biocaml.unix",
      "description": "This module provides parallel and sequential execution of deferred list operations that may fail. It supports mapping and iterating over lists with functions returning deferred `Or_error` values, handling errors and concurrency via the `how` parameter. It is useful for batch processing tasks like file reads or network requests where each operation might fail independently.",
      "description_length": 375,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred.Let_syntax.Let_syntax",
      "library": "biocaml.unix",
      "description": "This module provides monadic operations for working with deferred values, enabling asynchronous computations through functions like `return`, `bind`, `map`, and `both` to chain and combine deferred actions. It supports managing non-blocking I/O operations and composing asynchronous tasks in a pipeline. The module includes a child module that, while currently empty, could be extended to provide additional scoping or syntactic conveniences. Specific uses include sequencing network calls, handling concurrency, and structuring callback-based code in a functional style.",
      "description_length": 571,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred.List",
      "library": "biocaml.unix",
      "description": "This module provides asynchronous list operations using deferred values, enabling non-blocking computation pipelines. It supports mapping, filtering, folding, and iteration over lists where each element transformation involves asynchronous I/O or computations. These functions are useful for handling large datasets or network-bound tasks without blocking the main execution thread.",
      "description_length": 382,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make.Dbtag",
      "library": "biocaml.unix",
      "description": "This module handles database tags used in Entrez queries, providing functions to construct, parse, and manipulate tag values associated with specific databases. It works with the `t` type, which pairs a database name string with an `Object_id.t` tag. Concrete use cases include managing identifiers retrieved from Entrez searches and preparing them for subsequent record fetching operations.",
      "description_length": 391,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make.Object_id",
      "library": "biocaml.unix",
      "description": "This module defines a polymorphic type `t` that represents object identifiers in Entrez databases, supporting both integer and string formats. It provides a `to_string` function to convert these identifiers into strings for use in constructing URLs or processing API responses. This functionality is essential when working with Entrez's esearch and efetch utilities to retrieve and manipulate records from databases like Pubmed, Gene, or Protein.",
      "description_length": 446,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Table.Row.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types for parsing table rows, specifically handling format issues like incorrect column counts or failed type conversions (e.g., string to int/float). It works with S-expressions to serialize and deserialize error values, supporting precise error reporting in table processing tasks such as reading CSV or TSV files.",
      "description_length": 342,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred.Monad_infix",
      "library": "biocaml.unix",
      "description": "This module provides infix operators for chaining asynchronous computations that handle values wrapped in the `Deferred.t` type. The `(>>=)` operator sequences two deferred actions, passing the result of the first to the second, while `(>>|)` maps a function over the result of a deferred action. These operations are used to compose non-blocking I/O operations, such as reading from or writing to files or network sockets, in a concise and readable manner.",
      "description_length": 457,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.GenomeMap.Make.Signal",
      "library": "biocaml.unix",
      "description": "This module represents a partial function over the genome where each base or interval can be associated with a value, supporting operations like evaluation at a specific position, folding over constant intervals, and conversion to and from streams of annotated regions. It works with non-overlapping genomic regions labeled with values, parameterized over chromosome identifiers and annotations. Concrete use cases include modeling genome-wide signals such as conservation scores or gene expression levels, where efficient querying and aggregation over genomic coordinates are required.",
      "description_length": 586,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make.PubmedSummary",
      "library": "biocaml.unix",
      "description": "This module provides a high-level interface to fetch PubMed summaries by searching with a query string, returning structured data including PMID, DOI, publication date, source, and title. It works with the `t` record type representing individual PubMed summary entries. Concrete use cases include retrieving metadata for scientific articles based on keywords or identifiers for further processing or display.",
      "description_length": 408,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make.Gene",
      "library": "biocaml.unix",
      "description": "This module provides functions to search for gene records in the Entrez Gene database using query strings, returning structured results containing gene identifiers, types, and summaries. It works with gene-specific data types, including structured representations of gene references and annotations. A typical use case involves querying for genes by name or symbol and retrieving their associated metadata, such as type classification and summary descriptions.",
      "description_length": 460,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Table.Row.Tags",
      "library": "biocaml.unix",
      "description": "This module defines and manipulates tags that describe the format of table rows, such as field separators and strictness constraints. It works with lists of tags that specify separators, strictness about row length or cell types, and row formats. Use cases include configuring how to parse or serialize tabular data with specific formatting rules, and determining how strictly to validate row structures during input or output operations.",
      "description_length": 438,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.GenomeMap.Make.LSet",
      "library": "biocaml.unix",
      "description": "This module represents sets of genomic locations and supports operations to query intersections, find the closest location, and convert between sets and streams. It works with annotated genomic regions, where each region is defined by a range and a chromosome identifier. Concrete use cases include identifying overlapping gene loci, finding nearest regulatory elements, and filtering regions from high-throughput sequencing data.",
      "description_length": 430,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.GenomeMap.Make.LMap",
      "library": "biocaml.unix",
      "description": "This module maps genomic locations to values, supporting operations to query intersections, find closest elements, and convert to and from streams. It works with annotated genomic regions, where each region is a location paired with a value. Concrete use cases include efficiently finding overlapping annotations and computing distances between genomic features.",
      "description_length": 362,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.GenomeMap.Make.Selection",
      "library": "biocaml.unix",
      "description": "This module manages collections of non-overlapping genomic regions, supporting operations such as union, intersection, and difference between region sets. It allows adding regions, checking overlaps with a given location, and converting between region sets and streams. It is suitable for applications like identifying CpG islands or merging genomic intervals from sequencing data.",
      "description_length": 381,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make.Gene_ref",
      "library": "biocaml.unix",
      "description": "This module provides functions to query and retrieve gene reference data from the Entrez Gene database using both low-level URL construction and high-level record fetching. It works with the `t` type, representing gene records with fields like locus, description, and database cross-references. Concrete use cases include retrieving gene annotations by ID and parsing associated metadata for downstream analysis.",
      "description_length": 412,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Table.Row.Transform",
      "library": "biocaml.unix",
      "description": "This module provides functions to convert between table rows and line-based formats using configurable tags. It defines `line_to_item` for parsing lines into rows with customizable tags and `item_to_line` for serializing rows back into lines using specified separators. These transformations are used when reading from or writing to tabular file formats like CSV or TSV.",
      "description_length": 370,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make.Pubmed",
      "library": "biocaml.unix",
      "description": "This module provides a high-level interface to search the Pubmed database via the Entrez API, returning structured records containing publication IDs, titles, and abstracts. It works with string-based search queries and produces parsed result data using the `t` type. A concrete use case is retrieving scientific article metadata based on a keyword or author query, such as finding all publications related to \"CRISPR\" or by a specific researcher.",
      "description_length": 447,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred.Or_error",
      "library": "biocaml.unix",
      "description": "This module enables efficient batch processing of operations that may fail, handling both parallel and sequential execution of deferred tasks. It supports mapping and iterating over lists with functions returning deferred `Or_error` values, allowing errors in individual operations to be isolated and handled without aborting the entire batch. The `how` parameter controls concurrency, making it suitable for tasks like reading multiple files or issuing concurrent network requests. For example, it can process a list of URLs with `Http.get` calls, handling failures in individual requests while continuing with the rest.",
      "description_length": 621,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred.Let_syntax",
      "library": "biocaml.unix",
      "description": "This module provides monadic operations for working with deferred values, enabling asynchronous computations through functions like `return`, `bind`, `map`, and `both` to chain and combine deferred actions. It supports managing non-blocking I/O operations and composing asynchronous tasks in a pipeline, such as sequencing network calls or handling concurrency. A child module is available for potential extensions, offering a placeholder for additional scoping or syntactic conveniences. Specific uses include structuring callback-based code in a functional style and scheduling operations that execute once a result is available.",
      "description_length": 631,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Fastq.MakeIO",
      "library": "biocaml.unix",
      "description": "Handles reading from and writing to FASTQ files using a streaming interface. Works with `Biocaml_unix.Fastq.item` values, which represent individual FASTQ records. Designed for processing large FASTQ files efficiently through non-blocking I/O operations.",
      "description_length": 254,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Bed.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types for parsing BED files, including specific parsing failures like incorrect column counts, invalid numeric conversions, and format issues, each carrying relevant contextual data. It works directly with `Sexplib.Sexp.t` for serialization and deserialization, enabling robust error handling and logging during file parsing. Concrete use cases include validating BED file rows during input processing and reporting structured errors for debugging or user feedback.",
      "description_length": 491,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Writer",
      "library": "biocaml.unix",
      "description": "This module provides functions for writing data to output channels, including writing strings, characters, and lines. It supports working with file paths by handling file opening and permissions, allowing for deferred execution of write operations. Concrete use cases include logging data to files, streaming output, and writing formatted text incrementally.",
      "description_length": 358,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future.S-Reader",
      "library": "biocaml.unix",
      "description": "This module provides asynchronous file reading operations with support for custom buffer lengths. It works with `Reader.t` and `Deferred.t` to handle input from files, offering functions like `read_line`, `read_all`, and `lines` for streaming or buffered content retrieval. Concrete use cases include reading large text files line-by-line, loading entire file contents into memory, or processing log files incrementally.",
      "description_length": 420,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Msg.Tree",
      "library": "biocaml.unix",
      "description": "Represents hierarchical messages with explanatory sub-messages, supporting structured error reporting. Works with string-labeled trees where each node can have multiple child trees. Used to build nested diagnostic output, such as detailed error explanations with supporting context or multi-level warnings.",
      "description_length": 306,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Bam.Header",
      "library": "biocaml.unix",
      "description": "This module converts between BAM and SAM header representations, ensuring compatibility between the two formats. It provides functions to construct a BAM header from a SAM header and to extract the SAM header from a BAM header. These operations are essential when reading or writing BAM files while maintaining alignment metadata.",
      "description_length": 330,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Psl.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types for handling invalid or malformed input when parsing PSL (Positional Cytoband) data. It includes specific variants for incomplete input, invalid integers, invalid strand values, and incorrect column counts, each carrying position and contextual information. These errors are used to report parsing issues during genomic alignment file processing.",
      "description_length": 378,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Accu.Bins",
      "library": "biocaml.unix",
      "description": "This module organizes values into bins based on a user-defined function, allowing efficient accumulation and grouping of data. It works with lists of arbitrary data and maps each element to a bin key using a provided function. Concrete use cases include categorizing sequences by length, grouping genomic features by chromosome, or aggregating values by a computed property.",
      "description_length": 374,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Wig.Transform",
      "library": "biocaml.unix",
      "description": "This module provides functions to parse and print WIG data items, converting between string representations and internal data structures while handling format-specific coordinate adjustments. It supports three WIG formats\u2014bed, variable-step, and fixed-step\u2014and ensures correct translation of positions and intervals during parsing and printing. Concrete use cases include transforming WIG lines into typed values, converting WIG items to bedGraph format, and maintaining correct coordinate semantics across format boundaries.",
      "description_length": 525,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Pipe",
      "library": "biocaml.unix",
      "description": "This module handles asynchronous data streams through operations like reading, transforming, and aggregating elements using deferred values and pipe readers. It supports concrete tasks such as processing network or file input incrementally, applying mappings or folds to stream elements, and inspecting or discarding values without consumption. Key data types include deferred values and pipe readers, with core operations like `read`, `junk`, and `peek_deferred` enabling precise stream manipulation. While it offers direct stream-processing capabilities, one of its submodules exists without additional functionality to extend its interface.",
      "description_length": 643,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Sam.MakeIO",
      "library": "biocaml.unix",
      "description": "Handles reading from and writing to SAM files using asynchronous I/O operations. It processes SAM headers and alignment records, supporting incremental parsing and serialization through futures and pipes. Useful for streaming large SAM files without loading the entire contents into memory.",
      "description_length": 290,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Bed.Transform",
      "library": "biocaml.unix",
      "description": "This module provides functions to convert between BED file lines and structured data items. It operates on BED file strings and item tuples, handling parsing and serialization with customizable column specifications. Concrete use cases include processing genomic interval data for analysis pipelines or converting BED entries to other formats.",
      "description_length": 343,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Gff.Transform",
      "library": "biocaml.unix",
      "description": "This module provides functions to convert between GFF file lines and structured GFF item representations. It works with strings and GFF items, using tag configurations to control parsing and printing behavior. Concrete use cases include parsing GFF2 or GFF3 formatted lines into validated item records and serializing those records back into properly formatted strings.",
      "description_length": 369,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Lines.Buffer",
      "library": "biocaml.unix",
      "description": "This module provides a buffer for incrementally parsing strings into lines, supporting operations to feed input, inspect or retrieve lines, and track parsing position. It works with strings and line items, maintaining internal state to handle partial lines and report positions. Concrete use cases include streaming line-based file parsing, handling incomplete line data, and error reporting with positional information.",
      "description_length": 420,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Wig.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types and conversion functions for handling WIG data parsing and transformation errors. It includes detailed parsing error variants for malformed input lines, missing or invalid fields, and incorrect values in WIG formats, along with serialization and deserialization functions for these errors. It is used to report and handle failures when parsing WIG files or converting between WIG and BED formats.",
      "description_length": 428,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future.S-Deferred-Let_syntax",
      "library": "biocaml.unix",
      "description": "This module provides monadic operations for working with deferred values, including binding (`>>=`), mapping (`>>|`), and a let-syntax for sequential composition. It handles asynchronous computations represented as `'a Deferred.t` values. Concrete use cases include chaining non-blocking I/O operations, composing event-driven tasks, and structuring asynchronous workflows in a readable, linear style.",
      "description_length": 401,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Reader",
      "library": "biocaml.unix",
      "description": "This module enables asynchronous file reading through operations like `read_line`, `contents`, and `file_lines`, supporting efficient text input handling for both in-memory and streaming use cases. It manages file descriptors and deferred computations, allowing tasks such as reading a file line-by-line or loading its full contents as a string. The module works with pipes and strings, making it suitable for processing large files without loading them entirely into memory. Although it includes a child module, it does not contribute additional functionality beyond the core API.",
      "description_length": 581,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Zip.Transform",
      "library": "biocaml.unix",
      "description": "This module provides streaming compression and decompression using the DEFLATE and GZIP formats. It operates on byte streams through the `Tfxm.t` type, handling raw DEFLATE or GZIP-wrapped data. Use it to process large compressed files incrementally or to generate compressed output without loading entire datasets in memory.",
      "description_length": 325,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Track.Transform",
      "library": "biocaml.unix",
      "description": "This module implements parsers and printers for UCSC Genome Browser track files in various formats, including WIG, GFF, and BED. It processes input strings into structured data types like `Biocaml_unix.Track.t`, `Biocaml_unix.Wig.item`, and `Biocaml_unix.Gff.item`, and serializes them back to string representations. It supports operations such as parsing track headers, converting content lines, and handling format-specific attributes, enabling direct manipulation and transformation of genomic data files.",
      "description_length": 509,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier-Map-Provide_of_sexp",
      "library": "biocaml.unix",
      "description": "This module provides a function `t_of_sexp` for converting S-expressions into maps where keys are of type `Key` and values are derived from parsing the S-expressions. It works with map data structures that use a key type defined within the module, typically representing sequence identifiers. A concrete use case is parsing structured data formats like BED or GFF into maps keyed by genomic sequence identifiers for efficient lookup and processing.",
      "description_length": 448,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.In_thread",
      "library": "biocaml.unix",
      "description": "Runs a function asynchronously in a separate thread, returning a deferred result. Works with functions that produce a value of any type `'a` and handles thread management internally. Useful for performing blocking or long-running computations without blocking the main thread, such as file I/O or CPU-intensive tasks.",
      "description_length": 317,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier-Set-Provide_hash",
      "library": "biocaml.unix",
      "description": "This module provides hashing operations for a set of sequence range identifiers, specifically through `hash_fold_t` and `hash` functions. It works with the `Set.t` type derived from a sequence range module, where each element represents a genomic region using a string identifier, start, and end positions. It is useful for efficiently hashing sets of genomic intervals, such as when storing or comparing collections of regions from BED files.",
      "description_length": 443,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.GenomeMap.Make",
      "library": "biocaml.unix",
      "description": "This module organizes genomic regions as chromosome-range pairs, enabling efficient set operations such as union, intersection, and difference, along with membership tests. It supports both bare region sets and annotated variants through its submodules, which extend functionality to include value associations, nearest-neighbor queries, and signal modeling over the genome. For example, you can compute overlaps between gene loci, annotate intervals with expression levels, or find the closest regulatory element to a variant. The combination of direct set operations and rich genomic querying makes it suitable for tasks like variant filtering, annotation aggregation, and genome-wide signal analysis.",
      "description_length": 703,
      "index": 56,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier-Set",
      "library": "biocaml.unix",
      "description": "This module provides a set data structure for managing collections of sequence identifiers with operations like union, intersection, difference, and membership testing. It works with elements representing genomic regions (e.g., chromosome identifiers paired with start/end coordinates) and supports conversions to/from lists, arrays, and hash sets, along with serialization via S-expressions. Key use cases include genomic interval analysis, BED file processing, and efficient querying of sequence regions using functional transformations and predicate-based filtering.",
      "description_length": 569,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Vcf.Transform",
      "library": "biocaml.unix",
      "description": "This module provides functions to transform raw VCF lines into structured `item` values, handling parsing errors according to the VCFv4.1 specification. It operates on string inputs, typically representing individual lines of a VCF file, and produces either a successfully parsed `Biocaml_unix.Vcf.item` or a `Biocaml_unix.Vcf.vcf_parse_error`. A typical use case involves processing VCF data line-by-line during file parsing or stream processing.",
      "description_length": 447,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future.S-Deferred-Or_error",
      "library": "biocaml.unix",
      "description": "This module provides operations for working with asynchronous values that may fail, combining `Deferred` and `Or_error` semantics. It supports computations over lists where each element is processed asynchronously and may result in an error, allowing for chaining and transformation of these values. Concrete use cases include handling asynchronous I/O operations with error propagation, such as reading and processing multiple files concurrently.",
      "description_length": 447,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred",
      "library": "biocaml.unix",
      "description": "This module orchestrates asynchronous workflows using deferred values, enabling non-blocking I/O, concurrency, and error-resilient pipelines. It provides core operations like `bind`, `map`, `all`, and `join` for sequencing and combining deferred computations, with support for lists, results, and error handling through specialized submodules. Infix operators allow fluent composition of asynchronous actions, while batch processing utilities manage parallel or sequential execution of tasks that may fail, isolating errors without aborting the whole process. For example, it can pipeline HTTP requests, process large files asynchronously, or coordinate concurrent database queries with structured error recovery.",
      "description_length": 713,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier-Replace_polymorphic_compare",
      "library": "biocaml.unix",
      "description": "This module defines comparison operations and equality checks for sequence range identifiers, specifically supporting lexicographic ordering and equality based on the underlying identifier, start, and end values. It works with the `t` type, which represents a genomic region as a triplet (identifier, start, end), typically used for handling ranges in formats like BED. Concrete use cases include sorting genomic intervals, checking for overlapping regions, and selecting the minimum or maximum range based on natural ordering.",
      "description_length": 527,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future.S-Pipe",
      "library": "biocaml.unix",
      "description": "This module provides operations for working with asynchronous data streams using pipe readers. It supports reading, discarding, and transforming items from a pipe, as well as consuming items through iteration or folding. Concrete use cases include processing streaming data from files, network connections, or other asynchronous sources without loading the entire dataset into memory.",
      "description_length": 384,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier-Set-Elt",
      "library": "biocaml.unix",
      "description": "This module represents genomic regions using a sequence identifier, start, and end positions. It provides functions for serializing and deserializing these regions to and from S-expressions and defines a comparator for ordering them. It is used when working with genomic interval data such as BED files where regions are identified by chromosome names.",
      "description_length": 352,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make",
      "library": "biocaml.unix",
      "description": "This module provides tools for interacting with Entrez databases by handling identifiers, tags, and search operations across resources like PubMed, Gene, and Protein. It centers on data types such as `Object_id.t` for polymorphic identifiers and record types for structured results like PubMed summaries and gene annotations. Operations include constructing and parsing database tags, converting identifiers to strings for URLs, and performing searches to retrieve structured metadata. Examples include fetching PubMed article summaries by keyword, querying gene records by symbol, and retrieving annotated gene references with cross-database links.",
      "description_length": 649,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Wig.Tags",
      "library": "biocaml.unix",
      "description": "This module handles parsing and serializing WIG format tags using S-expressions, specifically for configuring how WIG data is interpreted. It supports two key options: `allow_empty_lines` to control whether empty lines are permitted, and `sharp_comments` to enable or disable recognition of lines starting with '#'. These settings are used when reading or writing WIG data to ensure correct formatting and interpretation of tracks and associated metadata.",
      "description_length": 455,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Chr.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types for handling ambiguous chromosome representations, specifically when parsing or converting chromosome names involving Roman numerals. It includes a single error variant that captures cases where a string could be interpreted as a Roman numeral chromosome but is instead treated as an ambiguous or non-numeric chromosome (e.g., \"X\" as the maternal chromosome rather than 10). This type supports robust error reporting in functions that convert or compare chromosome names.",
      "description_length": 503,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Entrez.Fetch",
      "library": "biocaml.unix",
      "description": "This module defines core operations for performing HTTP-based data retrieval from Entrez databases. It provides `fetch` for initiating requests and handling responses with a parser function, along with combinators `>>=` and `>|=` for chaining and transforming fetched results. These functions enable concise workflows for querying and processing data from NCBI services like Pubmed, Gene, or Protein.",
      "description_length": 400,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.MzData.Precursor",
      "library": "biocaml.unix",
      "description": "Handles precursor ion data from mzData files, providing access to mass, charge state, and intensity. It supports calculations like determining the neutral mass of a precursor ion. Useful for analyzing tandem mass spectrometry data where precursor ions are fragmented for further analysis.",
      "description_length": 288,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Future.S-Writer",
      "library": "biocaml.unix",
      "description": "This module provides functions for asynchronously writing data to files or output channels. It supports operations like writing strings, characters, or lines, and allows opening files with specific permissions and append modes. Concrete use cases include logging to files, streaming data output, or handling large file writes without blocking execution.",
      "description_length": 353,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future.S-Deferred-Let_syntax-Let_syntax",
      "library": "biocaml.unix",
      "description": "This module provides operations for composing asynchronous computations using deferred values. It supports key operations like returning a value in a deferred context, binding functions to deferred results, mapping over deferred values, and combining two deferred values into a single pair. These functions are used to sequence and manipulate asynchronous tasks in a non-blocking manner.",
      "description_length": 387,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Lines.Transform",
      "library": "biocaml.unix",
      "description": "This module provides transforms for converting between strings and line items, grouping line items in pairs, and constructing parsing buffers that process line-based input. It operates on `Lines.item` and string streams, handling edge cases like incomplete input or odd numbers of lines. Concrete use cases include parsing line-oriented file formats, transforming raw string streams into structured line data, and building custom streaming parsers with error handling.",
      "description_length": 468,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Psl.Transform",
      "library": "biocaml.unix",
      "description": "Converts a string representation of a PSL (Positional Sensitivity Language) line into a structured item, handling parsing errors. Works with strings and PSL item types, validating and transforming input data. Useful for processing raw PSL data from files or streams into a usable format for genomic alignment analysis.",
      "description_length": 318,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier-Set-Provide_bin_io",
      "library": "biocaml.unix",
      "description": "This module provides binary serialization and deserialization functions for sets of sequence ranges, where each range is associated with an identifier. It works with `Set.t` structures containing elements of a specified type `Elt`, which represents sequence identifiers paired with start and end positions. Concrete use cases include efficiently storing and loading genomic region sets, such as those derived from BED file entries, to and from binary formats.",
      "description_length": 459,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Accu.Relation",
      "library": "biocaml.unix",
      "description": "This module maps keys to lists of values, supporting incremental construction via `add` and conversion to and from streams and association lists. It works with arbitrary key and value types `'a` and `'b`, using a hash table internally for efficient accumulation. Concrete use cases include grouping related data entries, such as collecting multiple annotations per sequence identifier in bioinformatics pipelines.",
      "description_length": 413,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Bam.Alignment0",
      "library": "biocaml.unix",
      "description": "This module represents partially parsed BAM alignment records, enabling efficient traversal by accessing only required fields. It supports operations to decode and encode alignments relative to a header, and provides accessors for key alignment data such as query name, flags, reference ID, position, mapping quality, and optional fields. Concrete use cases include processing large BAM files where full parsing is unnecessary, such as calculating coverage or filtering alignments based on specific criteria.",
      "description_length": 508,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future.S",
      "library": "biocaml.unix",
      "description": "This module implements asynchronous programming primitives for managing concurrent and parallel execution. It provides deferred values with monadic operators for chaining computations, exception handling via `try_with`, and support for parallelism through the `how` type. Concrete use cases include building non-blocking I/O pipelines, parallelizing CPU-bound tasks, and orchestrating asynchronous workflows with precise concurrency control.",
      "description_length": 441,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier-Set-Named",
      "library": "biocaml.unix",
      "description": "This module represents sets of named genomic ranges, supporting operations to check subset and equality relationships between sets. It works with sequence identifiers paired with start and end positions, structured as named ranges. Concrete use cases include validating that one set of genomic regions is fully contained within another or confirming equivalence between two region sets.",
      "description_length": 386,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Gff.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types and S-expression converters for handling GFF file parsing issues. It includes specific error cases like invalid floats, integers, strands, and malformed attributes or rows. These errors are used to report precise parsing failures when processing GFF version 2 or 3 files.",
      "description_length": 303,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Zip.Default",
      "library": "biocaml.unix",
      "description": "This module defines default configuration values for compression operations, including the internal buffer size and compression level. It provides constants that influence the behavior of streaming compression and decompression processes. These defaults are used when creating compressed streams or transforming data with the Zlib library.",
      "description_length": 339,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Zip.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types and S-expression converters for handling decompression failures in compressed streams. It includes specific variants for malformed GZIP headers, zlib errors, and trailing garbage data. These errors are used to report detailed failure reasons during streaming decompression of GZIP or DEFLATE-encoded data.",
      "description_length": 337,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Biocaml_result.List",
      "library": "biocaml.unix",
      "description": "This module provides list traversal functions that apply result-returning transformations to elements, collecting results or propagating errors. It works with lists and the extended result type from Biocaml_result. Use it to process sequences where each element may fail, such as parsing or validating file lines with indexed error tracking.",
      "description_length": 341,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier-Map",
      "library": "biocaml.unix",
      "description": "This module provides operations for managing maps with genomic region identifiers as keys, supporting transformations like folding, filtering, and merging of key-value pairs where keys represent sequence intervals (e.g., chromosome ranges) and values are arbitrary. It enables efficient querying for overlapping regions, range-based traversals, and aggregation of interval-associated data, with utilities for handling duplicates, errors, and ordered key comparisons. Use cases include genomic interval analysis (e.g., BED file processing), where operations like merging adjacent regions, finding overlaps, or computing coverage require structured manipulation of interval-anchored data.",
      "description_length": 686,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier",
      "library": "biocaml.unix",
      "description": "This module provides comparison, ordering, and validation operations for genomic intervals represented by a sequence identifier (e.g., chromosome name), start, and end positions. It works with structured range types like `Seq_range.t` that encapsulate these triplets, supporting use cases such as BED file parsing, genomic region analysis, and interval sorting. The module also enables efficient data organization through associated Map and Set collections, tailored for bioinformatics workflows requiring precise coordinate handling.",
      "description_length": 534,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Sam.Flags",
      "library": "biocaml.unix",
      "description": "This module decodes and interprets the bitwise flags field of SAM records, providing boolean checks for each flag defined in the SAM specification. It operates on a single integer-based type representing the flags, allowing direct inspection of alignment properties such as mapping status, orientation, segment order, and alignment quality. Use cases include filtering alignments based on mapping criteria, determining read orientation, and identifying duplicate or supplementary alignments directly from SAM data.",
      "description_length": 514,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.GenomeMap.Chromosome",
      "library": "biocaml.unix",
      "description": "This module represents chromosome identifiers with a totally ordered type `t` and comparison function `compare`. It supports efficient identity and ordering checks for chromosome identifiers, enabling correct grouping and comparison of genomic regions. Concrete use cases include managing and querying annotated genomic intervals on specific chromosomes, such as merging overlapping gene regions or filtering variants by chromosome.",
      "description_length": 432,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bamstats.Fragment_length_histogram",
      "library": "biocaml.unix",
      "description": "Tracks fragment length distributions from BAM alignments by accumulating counts of fragment lengths that meet a minimum mapping quality threshold. It uses a counter to store length frequencies and filters alignments based on MAPQ. Useful for quality control in genomic analyses where fragment size distribution is critical.",
      "description_length": 323,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier-Map-Key",
      "library": "biocaml.unix",
      "description": "This module defines a key type for maps based on sequence identifiers, specifically used to represent genomic regions with identifiers like chromosome names paired with start and end positions. It provides functions for converting values to and from S-expressions and a comparator for use in map structures. It is used when storing and retrieving data associated with genomic ranges indexed by sequence identifier.",
      "description_length": 414,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier-Set-Provide_of_sexp",
      "library": "biocaml.unix",
      "description": "This module parses S-expressions into sets of sequence ranges, where each range is defined by a string identifier, start, and end position. It works with the `Set.t` data structure to represent genomic regions, such as those found in BED files. A concrete use case is loading genomic intervals from a file into a set for efficient lookup and comparison.",
      "description_length": 353,
      "index": 88,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Bamstats.Chr_histogram",
      "library": "biocaml.unix",
      "description": "Tracks chromosome coverage from BAM alignments using a header and quality filter. It maintains counts per chromosome reference in a BAM file. Use to summarize alignment distribution across chromosomes for quality control or analysis.",
      "description_length": 233,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Fastq.Illumina",
      "library": "biocaml.unix",
      "description": "This module parses and constructs Illumina FASTQ sequence identifiers and tile information. It handles structured data like sequence IDs with fields for instrument, lane, tile, and position, and tiles with surface, swath, and number. Use it to extract metadata from FASTQ headers or generate valid Illumina identifiers for filtering or analysis.",
      "description_length": 345,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier-Map-Provide_hash",
      "library": "biocaml.unix",
      "description": "This module implements a hashable map data structure keyed by sequence identifiers, supporting efficient storage and retrieval of values associated with genomic ranges. It works with string-based sequence identifiers and provides hashing operations to enable use in hash tables or as keys in maps. Concrete use cases include indexing genomic intervals by chromosome name for fast lookup or grouping annotations by sequence.",
      "description_length": 423,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Future.S-Deferred-List",
      "library": "biocaml.unix",
      "description": "This module provides asynchronous list operations using deferred values, enabling non-blocking computation pipelines. It supports operations like `map`, `fold`, `iter`, and `filter`, where each function applies a deferred computation to list elements. Concrete use cases include processing large datasets concurrently without blocking, such as downloading multiple files asynchronously or transforming rows of a database query in parallel.",
      "description_length": 439,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Track.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types for parsing UCSC Genome Browser track files. It includes variants for handling incomplete input, incorrect browser positions, and malformed key-value pairs in track lines. These errors are used to report specific parsing issues when reading track file headers and attributes.",
      "description_length": 307,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future.S-Deferred-Monad_infix",
      "library": "biocaml.unix",
      "description": "This module provides infix operators for chaining asynchronous computations using the `Deferred` type. It allows binding and mapping over deferred values with `>>=` and `>>|`, enabling sequential composition of asynchronous operations. Concrete use cases include handling non-blocking I/O operations, scheduling tasks, and managing asynchronous workflows in concurrent applications.",
      "description_length": 382,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Lines.MakeIO",
      "library": "biocaml.unix",
      "description": "This module provides functions for reading from and writing to file lines using futures and pipes. It works with `Future.Reader.t` and `Future.Writer.t` for asynchronous I/O operations, and handles line-based data through `Biocaml_unix.Lines.item`. Concrete use cases include streaming line-oriented data from large files and writing processed lines to disk asynchronously.",
      "description_length": 373,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Identifier-Map-Provide_bin_io",
      "library": "biocaml.unix",
      "description": "This module provides functions for serializing and deserializing maps with sequence range keys using binary format. It supports efficient storage and retrieval of mappings from sequence identifiers to values, where the keys are ranges on sequences (e.g., genomic regions). Concrete use cases include saving and loading indexed genomic data, such as annotations or coverage information, to and from disk in a compact binary representation.",
      "description_length": 438,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Gff.Tags",
      "library": "biocaml.unix",
      "description": "Handles parsing and serialization of GFF file tags, specifically managing version differences (2 and 3) and formatting rules such as delimiters and comment styles. Works with a record type that specifies GFF version, empty line handling, and comment syntax. Used when reading or writing GFF files to ensure correct tag-value pair formatting and parsing.",
      "description_length": 353,
      "index": 97,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Table.Row",
      "library": "biocaml.unix",
      "description": "This module represents rows of structured tabular data with typed fields, enabling parsing from and conversion to text lines using configurable separators. It supports operations for enforcing type and length constraints during parsing, handling integers, floats, and strings, and is suitable for reading and writing formats like CSV, TSV, or BED. The module works with tags to define formatting rules such as separators and strictness, converts between rows and text lines, and includes error handling for format issues like incorrect column counts or type mismatches. Example uses include processing genomic data files with fixed schemas or validating structured log entries during import or export.",
      "description_length": 701,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future.S-Deferred",
      "library": "biocaml.unix",
      "description": "This module provides asynchronous computation handling through deferred values, supporting operations like binding, mapping, and joining deferred results. It works with deferred values (`'a Deferred.t`) and includes utilities for managing lists of deferred actions, error handling, and syntax for let-bindings. Concrete use cases include sequencing asynchronous I/O operations, parallel execution of deferred tasks, and handling optional or error-prone deferred computations.",
      "description_length": 475,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Future.S-In_thread",
      "library": "biocaml.unix",
      "description": "Runs a function asynchronously in a separate thread, returning a deferred result. Works with functions that produce a value and deferred values to handle results. Useful for performing blocking operations without delaying the main thread.",
      "description_length": 238,
      "index": 100,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Accu.Counter",
      "library": "biocaml.unix",
      "description": "This module provides a counter data structure for accumulating integer counts associated with arbitrary values. It supports operations to increment counts for specific keys, iterate over counted elements, and convert between streams and lists of counted pairs. It is useful for tasks like frequency counting in data analysis or tracking occurrences of events in a stream.",
      "description_length": 371,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Future.S-Deferred-Or_error-List",
      "library": "biocaml.unix",
      "description": "This module provides parallelized mapping and iteration over lists, where each element is processed asynchronously and may return an error. It supports operations that apply deferred, error-aware functions to each item in a list, aggregating results or errors. Use it for concurrent processing of list elements with error handling, such as fetching data from multiple URLs or validating a list of inputs.",
      "description_length": 404,
      "index": 102,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Make",
      "library": "biocaml.unix",
      "description": "This module represents genomic regions using a sequence identifier, start, and end positions. It provides operations to create, compare, and convert these ranges, including error handling for invalid ranges. Concrete use cases include parsing and manipulating BED file entries with custom sequence identifiers.",
      "description_length": 310,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Wig",
      "library": "biocaml.unix",
      "description": "This module translates WIG data between bed, variable-step, and fixed-step formats, automatically adjusting between their distinct coordinate conventions\u2014such as 0-based half-open intervals in bed versus 1-based closed intervals in variable and fixed-step formats. It provides data types representing WIG entries, including chromosome, position, value, and header information, along with operations to parse and print these entries while handling format-specific conversions. For example, it can transform a bed-formatted line like \"chrI 0 10 3.14\" into the internal representation (\"chrI\", 1, 10, 3.14), or convert internal data back into correctly formatted lines for any of the three formats. Submodules support error handling during parsing, configuration of format options like comment handling and empty lines, and conversion to and from BED format with correct coordinate translation.",
      "description_length": 891,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Chr",
      "library": "biocaml.unix",
      "description": "This module processes chromosome names by normalizing and converting them into canonical Arabic or Roman numeral forms, resolving ambiguities in favor of standard identifiers like \"X\" for maternal chromosome rather than Roman numeral 10. It provides functions that handle input with optional \"chr\" prefixes and varied suffixes, converting names such as \"Chr4\" or \"IV\" into a consistent form like \"4\" for reliable comparison. The module includes data types to represent conversion errors, particularly when a suffix like \"X\" could be ambiguous, ensuring robust parsing and normalization. Submodules enhance error handling during conversion, supporting precise identification and resolution of ambiguous chromosome representations.",
      "description_length": 729,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Accu",
      "library": "biocaml.unix",
      "description": "This module organizes data into bins using customizable logic, enabling efficient accumulation and aggregation of values based on shared keys. It supports operations to add elements to bins, retrieve aggregated results, and stream or transform grouped data, with internal use of hash tables for performance. Main data types include bins for grouping, counters for frequency tracking, and maps from keys to value lists, all supporting incremental construction and conversion to streams or lists. Examples include building histograms by computed properties, aggregating annotations per identifier, and counting event frequencies in data streams.",
      "description_length": 643,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Biocaml_result",
      "library": "biocaml.unix",
      "description": "This module extends Core's `Result` type with additional combinators and integrates submodules for processing lists with error-tracking. It supports operations like `map`, `bind`, and `iter`, enabling robust handling of computations that may fail, particularly useful in parsing or validation tasks. The list submodule provides functions to traverse lists, applying transformations that return results, and collects errors with element indices. For example, parsing a list of strings into integers while tracking line numbers on failure.",
      "description_length": 537,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bam",
      "library": "biocaml.unix",
      "description": "This module reads and writes BAM files, handling headers and alignment records with streaming access and error handling. It supports processing from input channels or files, enabling tasks like parsing for genomic analysis, filtering alignments, or converting to other formats. The header conversion submodule ensures compatibility with SAM by translating between the two formats, while the partial alignment submodule enables efficient traversal of large files by accessing only required fields. Examples include constructing BAM headers from SAM, decoding alignments for coverage analysis, or filtering by mapping quality without full parsing.",
      "description_length": 645,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Zip",
      "library": "biocaml.unix",
      "description": "This module provides streaming compression and decompression using the DEFLATE and GZIP formats, operating on input channels and byte streams through types like `Tfxm.t`. It supports processing large files incrementally and streaming compressed data over networks, with error handling via result and exception interfaces. The module includes configurations for buffer size and compression level, and defines detailed error types for diagnosing decompression failures such as malformed headers or trailing garbage. Use it to compress or decompress data on the fly, configure stream behavior, or handle format-specific errors during streaming operations.",
      "description_length": 652,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Vcf",
      "library": "biocaml.unix",
      "description": "This module parses VCF files into structured data according to the VCFv4.1 specification, converting header metadata and variant records into typed values with strict validation and error handling. It supports operations on chromosomes, positions, alleles, quality scores, filters, and sample genotypes, enabling tasks like loading variant data for analysis, validating file integrity, and extracting annotations. The line parser submodule transforms raw VCF lines into `item` values, producing either a parsed `Biocaml_unix.Vcf.item` or a `Biocaml_unix.Vcf.vcf_parse_error`, and is used for line-by-line file or stream processing. Together, these components provide a robust interface for reading, validating, and manipulating genomic variant data.",
      "description_length": 749,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Solexa_score",
      "library": "biocaml.unix",
      "description": "This module implements conversions between Solexa quality scores and ASCII characters or probability values. It provides functions to encode/decode scores using ASCII (33\u2013126), convert to/from probabilities using the Solexa formula, and supports the full visible ASCII range rather than a restricted subset. Concrete use cases include parsing and generating FASTQ files in the Solexa/Illumina format and converting quality scores for downstream analysis tools that expect different encoding schemes.",
      "description_length": 499,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.GenomeMap",
      "library": "biocaml.unix",
      "description": "This module organizes genomic regions as chromosome-range pairs with support for efficient set operations like union, intersection, and difference, along with membership and nearest-neighbor queries. It handles both overlapping and non-overlapping regions, with or without annotations such as expression levels or coverage data. The core data structures are parameterized over chromosome identifiers, enabling use with custom ordered types, and include operations for merging gene regions, filtering variants, and aggregating annotations. Submodules extend functionality to include signal modeling, annotation attachment, and chromosome-based grouping with comparison and ordering capabilities.",
      "description_length": 694,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Fasta",
      "library": "biocaml.unix",
      "description": "This module handles parsing and reading FASTA files with configurable formatting options, such as comment handling and line length limits. It processes input into structured items including descriptions, sequences, and comments, supporting different FASTA dialects. Use it to load FASTA data from files or channels, validate sequence content, or extract specific entries from large genomic datasets.",
      "description_length": 399,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bin_pred",
      "library": "biocaml.unix",
      "description": "This module computes performance metrics for binary classifiers using arrays of prediction scores and boolean labels. It provides functions to calculate confusion matrices, sensitivity, specificity, precision, recall, F1 score, and ROC and precision-recall curves with corresponding AUC and average precision values. Concrete use cases include evaluating machine learning models in bioinformatics or medical diagnostics, where score thresholds determine classification outcomes and performance trade-offs must be analyzed.",
      "description_length": 522,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Iset",
      "library": "biocaml.unix",
      "description": "This module manages sets of integers represented as contiguous ranges, offering efficient insertion, deletion, and set operations (union, intersection, difference) alongside range-aware queries like `from` or `after`. It emphasizes compact storage and fast manipulation for large, dense intervals\u2014such as genomic coordinates or time spans\u2014while incurring overhead for sparse, non-adjacent elements. Key features include range-based iteration, cardinality tracking, and conversions to streams or lists of intervals, optimized for scenarios where intervals dominate over discrete points.",
      "description_length": 585,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Psl",
      "library": "biocaml.unix",
      "description": "This module processes PSL alignment data, converting formatted input into structured `item` records that capture alignment statistics and positional data for query and target sequences. It handles parsing through a dedicated submodule that transforms raw lines into validated items, using a custom error module to report issues like invalid integers, incorrect strand values, or malformed lines with precise contextual feedback. You can read and analyze BLAT output files, extract alignment details, and integrate alignment results into genomic or transcriptomic analysis workflows. The combination of parsing, validation, and error reporting supports robust processing of alignment data from sequence analysis tools.",
      "description_length": 717,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Histogram",
      "library": "biocaml.unix",
      "description": "This module implements histograms with polymorphic bin types, where each bin is defined by a lower and upper bound and contains a floating-point count. It supports creating histograms from bin boundaries, incrementing counts for values within bins, querying bin ranges and counts, and copying or resetting histograms. Concrete use cases include analyzing distributions of genomic data, such as coverage depth across regions, or tracking frequency of sequence quality scores.",
      "description_length": 474,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Fastq",
      "library": "biocaml.unix",
      "description": "This module processes FASTQ data with functions for parsing, validating, and transforming four-line sequence records. It supports streaming large files through non-blocking I/O, using `item` values to represent each record, and handles structured metadata like Illumina headers with fields for instrument, lane, and position. You can filter reads by quality, extract sequence information, or generate valid FASTQ identifiers for analysis pipelines. The module enables efficient manipulation of high-throughput sequencing data while preserving format integrity during read and write operations.",
      "description_length": 593,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bar",
      "library": "biocaml.unix",
      "description": "This module parses Affymetrix BAR text files exported from Tiling Analysis Software, providing access to probe analysis data grouped by chromosome sections. It supports operations to retrieve sections by name or index, extract data as sorted triplets (chromosome, position, value), and access metadata such as data type, scale, and algorithm used. Concrete use cases include analyzing signal intensity or p-value data across genomic regions for downstream processing like visualization or statistical analysis.",
      "description_length": 510,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Line",
      "library": "biocaml.unix",
      "description": "This module represents and manipulates lines of text, handling operations like splitting, stripping, and parsing lines from strings. It provides functions to process lines with custom delimiters, manipulate their content, and convert between s-expressions and line values. Use cases include parsing file contents into lines, processing log entries, and building line-based data formats.",
      "description_length": 386,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bamstats",
      "library": "biocaml.unix",
      "description": "This module processes BAM file alignments to maintain detailed summary statistics, including total reads, QC-passing reads, mapped reads, and pair information. It tracks fragment length distributions by accumulating frequencies of lengths that meet a minimum mapping quality threshold, and summarizes chromosome coverage by counting alignments per reference. Main data types include counters for length frequencies and mappings per chromosome, with operations to update and retrieve these metrics. Example uses include analyzing sequencing data quality through fragment size distributions and assessing alignment uniformity across chromosomes.",
      "description_length": 643,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Sgr",
      "library": "biocaml.unix",
      "description": "This module handles reading and writing of Sequence Graph (SGR) files, which represent genomic data as tuples of chromosome, position, and value. It provides functions to convert between SGR data and in-memory structures like lists and channel-based I/O, with optional chromosome remapping and base pair adjustment. Use cases include processing ChIP-seq or genome annotation data where values at specific genomic coordinates need to be stored and retrieved efficiently.",
      "description_length": 469,
      "index": 122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Lines",
      "library": "biocaml.unix",
      "description": "This module processes text files line by line, enabling incremental reading, transformation, and writing of line-based data through synchronous and asynchronous I/O. It supports direct operations on files, channels, and streams, while its submodules handle parsing state, line item conversion, and structured streaming with futures and pipes. Main data types include `item` for line representations, `Buffer.t` for incremental parsing, and futures-based readers and writers for asynchronous processing. Examples include streaming log files line by line, converting between text formats using line pairs, and parsing large files with error reporting based on line positions.",
      "description_length": 673,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Range",
      "library": "biocaml.unix",
      "description": "This module offers operations for constructing, validating, and manipulating contiguous integer intervals (e.g., union, intersection, subset checks) using a bounded type `t` representing closed intervals `[lo, hi]`. It supports analysis of positional relationships like overlap, gaps, and membership, with applications in genomic coordinate mapping, interval-based data analysis, and temporal scheduling systems. Utilities for expanding associative lists into positional mappings and generating random subranges further enable tasks like region-based data aggregation or stochastic sampling.",
      "description_length": 591,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.RSet",
      "library": "biocaml.unix",
      "description": "This module represents integer sets optimized for handling large contiguous sequences. It supports operations like union, intersection, and difference, along with conversions to and from range lists and integer lists. It is useful for managing genomic intervals or similar data where ranges of integers are common.",
      "description_length": 314,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq",
      "library": "biocaml.unix",
      "description": "Handles nucleic acid sequence data with validation and manipulation functions. Provides safe and unsafe conversion from strings and buffers, indexing, slicing, and folding operations. Useful for bioinformatics tasks like sequence analysis, sub-sequence extraction, and validated input processing.",
      "description_length": 296,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range",
      "library": "biocaml.unix",
      "description": "This module represents genomic intervals using a combination of sequence identifiers and integer ranges, supporting operations like creation, parsing, comparison, and serialization. It provides core functionality for handling structured genomic data such as BED file entries, enabling tasks like interval parsing, region comparison, and coordinate-based analysis. Child modules extend this foundation with specialized tools for maps and sets keyed by ranges, hashing, binary and S-expression serialization, and efficient querying of genomic regions. Specific applications include loading intervals from structured files, validating region overlaps, and organizing annotations by chromosome and coordinate.",
      "description_length": 705,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Entrez",
      "library": "biocaml.unix",
      "description": "This module enables interaction with NCBI Entrez databases through HTTP requests, supporting both low-level URL construction for esearch, esummary, and efetch operations and high-level record retrieval with XML parsing. It centers on data types like `Object_id.t` for polymorphic identifiers and structured record types for results such as gene annotations and PubMed summaries, with operations to search, fetch, and transform data across databases like Gene, Protein, and Pubmed. Functions like `fetch` and pipeline combinators allow concise chaining of requests, enabling workflows such as querying gene records by symbol, retrieving publication metadata by keyword, or fetching sequence data for specific entries. Submodules handle identifier manipulation, structured result parsing, and HTTP response processing to support end-to-end data retrieval and analysis.",
      "description_length": 866,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Jaspar",
      "library": "biocaml.unix",
      "description": "This module provides functions to load and parse motifs from the Jaspar database, supporting various collections such as Core, Phylofacts, and PBM. It works with a structured motif type that includes metadata and a matrix representing the position weight matrix. Use this module to retrieve motif data from Jaspar SQL dumps for bioinformatics analysis, such as identifying transcription factor binding sites.",
      "description_length": 408,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Sam",
      "library": "biocaml.unix",
      "description": "This module provides type-safe parsing, validation, and conversion of SAM format components, handling headers, alignment records, and CIGAR operations with structured access to metadata such as reference sequences, read groups, and Phred scores. Its core functionality supports constructing and serializing alignments to SAM-compatible formats, enabling tasks like building custom headers or processing sequencing data in bioinformatics pipelines. The first child module extends this capability with asynchronous I/O for streaming large SAM files via futures and pipes, allowing memory-efficient, incremental parsing and writing. The second child module enhances alignment processing by decoding SAM bitwise flags into inspectable boolean properties, facilitating direct checks for mapping status, orientation, and alignment quality from parsed records.",
      "description_length": 853,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Msg",
      "library": "biocaml.unix",
      "description": "This module handles the consistent formatting and printing of diagnostic messages, including errors, warnings, and bugs, with optional source positions. It supports structured reporting through hierarchical message trees, where each message can have labeled sub-messages, enabling detailed and contextual diagnostic output. Main operations include creating and composing messages with positional information, and printing them in a unified format. Example uses include reporting user input errors with source locations, displaying multi-level warnings with explanatory context, and signaling internal bugs with nested diagnostic details.",
      "description_length": 637,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bpmap",
      "library": "biocaml.unix",
      "description": "This module reads and processes Affymetrix BPMAP files in text format, providing access to probe data including organism, genome version, chromosome, start position, and sequence. It supports operations to iterate over, fold, or convert probe rows to a list, and allows parsing from and writing to files with optional chromosome name remapping. Concrete use cases include analyzing microarray probe layouts and exporting processed probe data to disk.",
      "description_length": 450,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Interval_tree",
      "library": "biocaml.unix",
      "description": "This module implements an interval tree for storing and querying integer-bounded intervals labeled with arbitrary values. It supports efficient insertion, intersection checks, and retrieval of overlapping or closest intervals. Concrete use cases include genomic interval analysis, scheduling, and spatial range queries where fast access to overlapping intervals is required.",
      "description_length": 374,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix",
      "library": "biocaml.unix",
      "description": "This module implements asynchronous programming primitives for handling I/O-bound and parallelizable tasks using deferred values and pipelines. It supports binding and mapping over deferred results, error handling with result-aware operators, and thread-safe communication via pipes and readers/writers, enabling concrete tasks like managing concurrent network requests, streaming data processing, and coordinating background tasks with explicit concurrency control. The module includes submodules for writing data to output channels, handling asynchronous data streams, reading files asynchronously, running blocking functions in separate threads, and orchestrating complex asynchronous workflows with combinators and error handling. Together, these components provide a comprehensive toolkit for building efficient, non-blocking I/O pipelines that integrate file operations, streaming, concurrency, and structured error recovery.",
      "description_length": 931,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Gff",
      "library": "biocaml.unix",
      "description": "This module processes GFF version 2 and 3 files, parsing and serializing structured records with support for comments, custom tags, and version-specific formatting. It reads from input channels into streams of GFF items, converts items to strings or S-expressions, and handles errors related to invalid data such as malformed attributes or incorrect strand values. The module supports transformations of genomic annotations, enabling tasks like modifying feature attributes or converting between GFF2 and GFF3 formats. Tag parsing and error reporting are customized through configuration records that control delimiters, comment syntax, and validation rules.",
      "description_length": 658,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Roman_num",
      "library": "biocaml.unix",
      "description": "This module provides parsing and conversion between Roman numerals and integers. It supports case-insensitive string parsing into Roman numeral values, conversion of integers to Roman numerals, and bidirectional translation between the two representations. It is useful for applications requiring Roman numeral input/output, such as historical data processing or user interfaces needing numeric formatting in classical style.",
      "description_length": 425,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bed",
      "library": "biocaml.unix",
      "description": "This module processes BED file data, parsing lines into structured items with chromosome names, start and end positions, and optional additional columns. It supports reading from input channels, converting between lines and items, and applying strict or flexible parsing rules to handle genomic intervals. The error module defines detailed parsing failures such as column count mismatches and numeric conversion errors, enabling precise error reporting during input processing. The conversion module handles serialization and deserialization between BED strings and item tuples, supporting custom column formats for use in analysis pipelines or data transformation tasks.",
      "description_length": 671,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Pos",
      "library": "biocaml.unix",
      "description": "This module represents and manipulates file positions with optional source names, line numbers, and offsets. It supports creating positions, incrementing line numbers, and converting to human-readable strings. Useful for tracking locations in text files during parsing or logging, especially when handling input streams like files or standard input.",
      "description_length": 349,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Track",
      "library": "biocaml.unix",
      "description": "This module processes UCSC Genome Browser track files, supporting parsing, validation, and serialization of track lines, data content, and metadata. It handles core data types like track configurations with key-value attributes (e.g., `visibility`, `color`, `type`), and structured genomic entries such as `Wig.item` and `Gff.item`. Operations include reading and writing track files, validating attribute values, and transforming genomic data between string and internal representations. Error handling is supported through specific error types for malformed input, ensuring robust parsing and diagnostic reporting.",
      "description_length": 616,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Transcripts",
      "library": "biocaml.unix",
      "description": "This module represents and manipulates transcript structures as intervals with associated exon lists, where each exon is an interval. It supports operations such as merging overlapping transcripts, splitting transcripts into non-overlapping exonic regions, and calculating coverage across genomic positions. Concrete use cases include processing gene annotation data to identify splicing variants and analyzing exon-intron structures in RNA-seq pipelines.",
      "description_length": 455,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Table",
      "library": "biocaml.unix",
      "description": "This module provides typed representations of tabular data rows, supporting parsing and serialization of text-based formats like CSV, TSV, and BED. It defines data types for rows with fixed schemas, using tags to specify separators and strictness, and includes operations for converting between structured data and text lines. You can enforce type constraints on integers, floats, and strings, handle format errors during parsing, and validate column counts and types. Example uses include importing genomic datasets with fixed field counts or transforming structured logs while ensuring schema consistency.",
      "description_length": 607,
      "index": 141,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Biocaml_unix.Phred_score",
      "library": "biocaml.unix",
      "description": "This module handles PHRED quality scores used in bioinformatics, converting between integer scores, ASCII characters, and probability values. It supports decoding and encoding scores using either ASCII offset 33 (Sanger) or 64 (Illumina), and provides functions to convert scores to and from Solexa scores and probability values. Concrete use cases include parsing and generating FASTQ files with correct quality score encoding, and converting quality scores for downstream analysis tools that expect specific formats.",
      "description_length": 518,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Tfxm",
      "library": "biocaml.unix",
      "description": "This module enables the creation of composable transforms that process data streams with input buffering, error handling, and variable input/output mappings. It operates on generic types, streams, and channels, supporting use cases such as parsing error-prone data, asynchronous processing pipelines, and scenarios requiring flexible stream manipulation where outputs may depend on multiple inputs or partial failures need isolation. Key capabilities include transform composition, result-aware filtering, and bidirectional stream conversion with explicit control over buffering and termination states.",
      "description_length": 602,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bgzf",
      "library": "biocaml.unix",
      "description": "This library enables efficient handling of BGZF-compressed data through channel-based I/O operations, supporting both sequential and random access via virtual offsets. It works with custom input/output channels to process binary formats with precision, offering typed read/write functions for integers (u8, s16, s32) and blocks. Typical applications include genomic data processing pipelines requiring indexed access to compressed files and resource-safe streaming of large datasets.",
      "description_length": 483,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future",
      "library": "biocaml.unix",
      "description": "The module enables working with asynchronous values through promises, supporting composition, error handling, and cancellation. It provides core operations for creating and combining deferred computations, with support for monadic binding, mapping, and parallelism, working over types like `'a Deferred.t` and `Or_error`. Submodules extend this functionality to file I/O, stream processing, and list transformations, enabling concrete tasks like reading large files line-by-line, writing asynchronously to logs, or processing lists of deferred values with error propagation. Infix operators and let-syntax improve readability when chaining non-blocking operations, while utilities for running blocking code in threads maintain responsiveness in event-driven workflows.",
      "description_length": 768,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Pwm",
      "library": "biocaml.unix",
      "description": "This module implements position-weight matrices (PWMs) for DNA motif analysis, supporting operations like motif creation from count matrices, tandem motif construction with spacers, and scanning DNA sequences for motif matches above a score threshold. It works with DNA sequences represented as strings and matrices as arrays of arrays, using background frequency models to normalize scores. Concrete use cases include identifying transcription factor binding sites in genomic sequences and modeling composite motifs with specific spacing constraints.",
      "description_length": 551,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.File_mapper",
      "library": "biocaml.unix",
      "description": "This module provides functions to map over file contents using specific data formats. It supports line-based processing with `lines`, and BED format parsing with `bed5` and `bed5_raw` for genomic interval data. Use cases include reading and transforming text files line by line or processing genomic intervals in BED format directly from files.",
      "description_length": 344,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Cel",
      "library": "biocaml.unix",
      "description": "This module parses Affymetrix CEL files in text format and provides functions to process intensity data. It defines types for intensity values and rows, and offers iteration and transformation operations over intensity sections. Key functions include extracting PM, MM, or PM-MM intensity values across multiple CEL files for probes defined in a Bpmap.",
      "description_length": 352,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Strand",
      "library": "biocaml.unix",
      "description": "This module represents DNA strand orientations using the type `t`, which is a private character. It provides functions to convert between string representations like \"rev\" or \"fwd\" and the canonical characters '-' or '+', including parsing from strings with `of_string`. Use cases include handling input from bioinformatics tools that use varying strand notation conventions and ensuring consistent strand representation in genomic data processing.",
      "description_length": 448,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.MzData",
      "library": "biocaml.unix",
      "description": "This module reads mzData files, a mass spectrometry data format, and returns structured spectral data. It provides the `of_file` function to parse mzData files into lists of `spectrum` values, each containing m/z and intensity arrays, precursor information, and supplemental data. The module includes a child module for handling precursor ion data, enabling access to mass, charge state, and intensity, as well as calculations for neutral mass determination. Together, they support analysis of tandem mass spectrometry datasets by combining file parsing with detailed precursor ion examination.",
      "description_length": 594,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Sbml",
      "library": "biocaml.unix",
      "description": "This module provides functionality for parsing and manipulating SBML Level 2 Version 4 models, focusing on converting XML-based SBML data into structured OCaml representations. It handles core SBML components like mathematical expressions, units, compartments, species, reactions, and events, with specific support for parsing models from input channels and serializing math expressions into S-expressions. Typical use cases include systems biology modeling, simulation setup, and analysis of biochemical networks where precise handling of SBML's hierarchical data structures is required.",
      "description_length": 588,
      "index": 151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Math",
      "library": "biocaml.unix",
      "description": "This module provides statistical analysis, numerical computations, and array manipulation operations for floats, integers, arrays, lists, and matrices. It supports tasks like hypothesis testing (e.g., Wilcoxon rank sum tests), quantile normalization, prediction accuracy assessment, and numerical analysis (factorials, summation ranges). Functions handle array transformations, correlation calculations (Pearson, Spearman), matrix operations, and data processing workflows common in scientific computing.",
      "description_length": 504,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix",
      "library": "biocaml.unix",
      "description": "This module processes genomic data formats and provides utilities for handling biological sequences, alignments, and annotations. It includes data types for representing WIG, BED, BAM, VCF, FASTQ, and GFF records, along with operations to parse, convert, and manipulate these formats while handling coordinate system differences and quality encodings. Users can perform tasks such as converting WIG to BED with correct interval translation, parsing VCF variants with strict validation, streaming BAM alignments with header compatibility, and evaluating classifier performance on genomic datasets. Additional components support interval arithmetic, sequence manipulation, motif analysis, and asynchronous I/O for scalable bioinformatics pipelines.",
      "description_length": 746,
      "index": 153,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_base.Bed.Bed3",
      "library": "biocaml.base",
      "description": "This module represents BED3 format genomic intervals with operations to serialize and deserialize interval data. It works with strings and integers to store chromosome names, start and end positions, and additional fields. Concrete use cases include parsing and generating BED-formatted lines for genomic data processing tasks such as interval intersection or annotation.",
      "description_length": 371,
      "index": 154,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_base.Fasta.Parser0",
      "library": "biocaml.base",
      "description": "This module processes FASTA file chunks into low-level items, handling very long sequences efficiently in constant memory. It works with streams of strings and produces parsed items incrementally using a stateful step function. Use it when streaming or parsing large FASTA files without loading the entire file into memory.",
      "description_length": 323,
      "index": 155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_base.Table.Field",
      "library": "biocaml.base",
      "description": "This module provides parsers for converting string fields into specific typed values, including integers, bounded integers, and strings without separators. It supports concrete operations like validating integer ranges, parsing lists of values with context-aware error handling, and enforcing format constraints. Use cases include parsing tabular data such as genomic coordinates, quality scores, or structured biological records where strict field validation is required.",
      "description_length": 472,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Macs2.Broad_peaks",
      "library": "biocaml.base",
      "description": "This module parses and represents broad peak data generated by MACS2, focusing on genomic regions with enriched signals. It processes tab-separated lines into structured items containing chromosome, start and end positions, scores, strand, and statistical values like fold change and p-values. Use this module to extract and analyze broad peak annotations from ChIP-seq experiments.",
      "description_length": 382,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Bed.Bed5_raw",
      "library": "biocaml.base",
      "description": "This module represents BED5 format data with a chromosomal interval, name, score, and optional additional fields. It provides functions to construct and validate items, convert between S-expressions and items, and parse or format items to and from text lines. Use this module to read and write BED5 files for genomic interval data with associated scores and annotations.",
      "description_length": 370,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Lines.Parser",
      "library": "biocaml.base",
      "description": "This module implements a line parser that processes byte chunks to extract lines, maintaining state across incremental steps. It works with `state` to track parsing progress and `Line.t` values representing parsed lines, handling both partial and complete input. It is useful for streaming line-based formats like FASTA or BED where input arrives in chunks and precise line counting matters.",
      "description_length": 391,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Bed.Bed4",
      "library": "biocaml.base",
      "description": "This module represents BED4 format data, which includes chromosome, start and end positions, a name, and additional fields. It provides functions to convert BED4 items to and from S-expressions for serialization and parsing. This is useful for working with genomic interval data in bioinformatics, such as annotating regions of interest in genomes.",
      "description_length": 348,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Macs2.Xls",
      "library": "biocaml.base",
      "description": "This module parses XLS output from MACS2 into structured items, supporting direct interpretation of peak data. It processes lines into comments, headers, or records containing genomic peak information. Use it to extract and analyze peak calls directly from MACS2 output files.",
      "description_length": 276,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Bed.Bed5",
      "library": "biocaml.base",
      "description": "This module handles BED5 format data, providing functions to construct items from chromosomal coordinates and metadata, parse lines into items, and convert items back to lines. It works with strings, integers, and specialized item types representing genomic intervals. Concrete use cases include reading and writing BED5 files for genomic region annotations, such as gene locations or regulatory elements.",
      "description_length": 405,
      "index": 162,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_base.Fasta.Parser",
      "library": "biocaml.base",
      "description": "This module parses FASTA file chunks into structured items using a streaming interface. It maintains parsing state across chunks and yields completed FASTA entries as they are read. Use it to process large FASTA files incrementally without loading the entire file into memory.",
      "description_length": 276,
      "index": 163,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_base.Lines",
      "library": "biocaml.base",
      "description": "This module processes line-based file formats by parsing byte chunks into lines, maintaining state across incremental steps. It uses `state` to track parsing progress and `Line.t` to represent parsed lines, supporting both complete and partial input handling. It enables streaming through formats like FASTA or BED, allowing line-by-line processing as data arrives in chunks. For example, it can parse a multi-byte chunk into multiple complete lines or retain partial line data for continuation in the next step.",
      "description_length": 512,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Macs2",
      "library": "biocaml.base",
      "description": "This module processes MACS2 output files into structured genomic peak data, enabling analysis of enriched regions from ChIP-seq experiments. It supports parsing both broad peak files and XLS-formatted output, extracting key information such as chromosome, start and end positions, scores, strand, fold change, and p-values. The parsed data can be used for downstream analysis like peak annotation, filtering, and visualization. For example, users can extract high-confidence peaks based on statistical thresholds or summarize peak distribution across chromosomes.",
      "description_length": 563,
      "index": 165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_base.Gff",
      "library": "biocaml.base",
      "description": "This module parses and constructs GFF2 and GFF3 records, handling differences in attribute delimiters and supporting optional fields like source, score, and phase. It processes lines into structured items, including comments and records with attributes represented as string-list pairs. Use it to read or generate genome annotation data while preserving format-specific details.",
      "description_length": 378,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Line",
      "library": "biocaml.base",
      "description": "This module represents and manipulates single lines of text, handling operations like splitting, stripping, and parsing lines from strings. It provides functions to convert lines to and from S-expressions, append or concatenate lines, and validate line content through character checks. Use cases include parsing file contents line-by-line, processing structured text formats, and handling line-based input/output efficiently.",
      "description_length": 426,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Bed",
      "library": "biocaml.base",
      "description": "This module processes BED-formatted genomic interval data, supporting BED3, BED4, and BED5 variants through unified parsing and construction functions. It defines core data types representing intervals with varying field counts and provides operations to convert between structured data and text lines, handling errors in malformed input. The child modules specialize in specific BED formats: parsing and serializing BED3 intervals with chromosome and position data, constructing and validating BED4 items with names, and handling BED5 data with scores and optional fields. You can use this module to read, write, and manipulate genomic intervals for tasks like region annotation or interval comparison.",
      "description_length": 703,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Table",
      "library": "biocaml.base",
      "description": "This module parses string fields into typed values like integers, bounded integers, and separator-free strings, ensuring strict validation of formats and ranges. It supports operations for parsing lists with context-aware error handling, validating genomic coordinates, and enforcing data constraints in structured biological records. Examples include parsing and validating a column of integers within a specific range or extracting tab-separated values with error tracking. Use it to transform and validate rows of tabular data where type safety and data integrity are critical.",
      "description_length": 580,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Fasta",
      "library": "biocaml.base",
      "description": "This module provides robust parsing and unparsing of FASTA records, converting between structured representations\u2014such as headers, descriptions, and sequences\u2014and their textual format. It supports configurable formatting and error handling to accommodate FASTA dialects, enabling tasks like processing genomic sequences, aligning records, or transforming data between bioinformatics tools. The core API constructs, serializes, and validates FASTA entries, while child modules enable efficient streaming of large files using stateful step functions and incremental parsing. For example, users can parse a multi-FASTA file in chunks, process each entry as it is read, or reformat sequences with custom header conventions.",
      "description_length": 719,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Ucsc_genome_browser",
      "library": "biocaml.base",
      "description": "This module generates UCSC Genome Browser track lines and custom track URLs. It supports creating track configuration lines with attributes like name, visibility, color, and data source, and constructs URLs for embedding custom tracks with optional parameters. Use cases include visualizing genomic data tracks for specific genome assemblies like hg19 or mm10, and generating browser links for programmatic access to annotated genomic regions.",
      "description_length": 443,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base",
      "library": "biocaml.base",
      "description": "This module processes a variety of genomic and text-based file formats through stateful parsing and structured data conversion. It supports streaming and incremental parsing of FASTA, BED, GFF, and MACS2 files, representing genomic intervals, annotations, and peak data using typed records and line-based structures. Key operations include parsing byte chunks into lines, validating and transforming tabular data, and constructing track visualizations for genome browsers. Examples include extracting and filtering peaks from ChIP-seq data, streaming multi-FASTA records for processing, and generating custom UCSC track URLs for data visualization.",
      "description_length": 648,
      "index": 172,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 181,
    "meaningful_modules": 173,
    "filtered_empty_modules": 8,
    "retention_rate": 0.9558011049723757
  },
  "statistics": {
    "max_description_length": 931,
    "min_description_length": 233,
    "avg_description_length": 477.91907514450867,
    "embedding_file_size_mb": 0.6287698745727539
  }
}