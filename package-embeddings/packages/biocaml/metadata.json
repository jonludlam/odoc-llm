{
  "package": "biocaml",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 145,
  "creation_timestamp": "2025-08-15T17:04:13.528035",
  "modules": [
    {
      "module_path": "Biocaml_ez.Fastq.Illumina",
      "library": "biocaml.ez",
      "description": "This module parses and formats Illumina FASTQ sequence identifiers and tile information. It provides functions to convert between string representations and structured data types for tiles and sequence IDs, including validation and access to components like instrument, lane, and position. Concrete use cases include processing FASTQ files to extract metadata for quality filtering or spatial analysis of sequencing data.",
      "description_length": 421,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Lines.Transform",
      "library": "biocaml.ez",
      "description": "This module provides transforms for processing streams of line-based items, enabling conversions between strings and line items, grouping consecutive lines into pairs, and constructing custom line-oriented parsing buffers. It operates on `Lines.item` and string streams, handling edge cases like incomplete input or missing newlines. Concrete use cases include parsing line-based formats (e.g., FASTA, BED) where structured processing of paired or sequential lines is required.",
      "description_length": 477,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_ez.Lines.Buffer",
      "library": "biocaml.ez",
      "description": "This module provides a buffer for incrementally parsing strings into lines. It supports feeding raw strings or individual lines, retrieving queued lines, and inspecting the current parsing position. Use it when streaming or processing large text files line-by-line without loading the entire file into memory.",
      "description_length": 309,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Lines.MakeIO",
      "library": "biocaml.ez",
      "description": "This module provides functions for reading and writing lines of text using futures and pipes. It works with `Future.Reader.t` and `Future.Writer.t` for streaming input and output, and supports writing to files with optional permissions and append mode. Concrete use cases include processing large text files asynchronously, such as reading log entries or writing formatted data to disk without blocking.",
      "description_length": 403,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Bamstats",
      "library": "biocaml.ez",
      "description": "This module tracks and updates statistics for BAM file alignments, including counts for total reads, QC-passing reads, single reads, read pairs, mapped reads, and mapped pairs. It works with BAM alignment data types from `Biocaml_unix` and provides functions to incrementally update statistics as alignments are processed. Concrete use cases include summarizing alignment results and monitoring mapping quality during BAM file analysis.",
      "description_length": 436,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Strand",
      "library": "biocaml.ez",
      "description": "This module represents DNA strand orientations using a single character type, supporting values for forward (`+`) and reverse (`-`) strands. It provides functions to convert between string representations (\"fwd\", \"rev\") and the strand type, as well as retrieving the corresponding character or string for a given strand. Concrete use cases include parsing and formatting strand information in genomic data such as BED or GFF files.",
      "description_length": 431,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Fasta",
      "library": "biocaml.ez",
      "description": "This module parses and processes FASTA files, handling headers, sequences, and comments with configurable formatting options. It provides low-level parsing of individual FASTA elements and high-level functions to read entire files into structured streams. Concrete use cases include extracting sequence data from genomic datasets and validating FASTA-formatted input against specific formatting rules.",
      "description_length": 401,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Phred_score",
      "library": "biocaml.ez",
      "description": "This module implements conversions between PHRED quality scores and integers, characters, probabilities, and Solexa scores, with support for ASCII encoding offsets 33 and 64. It provides functions to encode/decode PHRED scores as ASCII characters, convert to and from probability values, and interoperate with Solexa scores using optional rounding functions. Concrete use cases include parsing and generating FASTQ files, recalibrating sequencing quality scores, and converting between different quality score formats in bioinformatics pipelines.",
      "description_length": 546,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Lines",
      "library": "biocaml.ez",
      "description": "This module processes streams of text lines with functions to parse, transform, and serialize line-based data. It works with `Lines.item`, character streams, and input/output channels, supporting operations like line-by-line file reading, asynchronous streaming with futures, and in-memory parsing via buffers. Concrete use cases include parsing genomic data formats (e.g., FASTA, GFF), processing log files, and transforming line-oriented input incrementally without loading entire files into memory.",
      "description_length": 501,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Range",
      "library": "biocaml.ez",
      "description": "This module supports operations for creating and manipulating integer ranges and genomic intervals, including comparisons, overlap detection, union and intersection calculations, and gap analysis. It works with bounded range structures defined by `lo` and `hi` integer endpoints, emphasizing interval arithmetic and set relationships in both scalar and list contexts. Typical applications include genomic region analysis, such as identifying overlapping DNA segments, merging adjacent intervals, or determining coverage gaps in sequencing data.",
      "description_length": 544,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Bam",
      "library": "biocaml.ez",
      "description": "This module provides functions for reading and writing BAM files, including handling headers and alignment records. It works with `Header.t` for file metadata and `alignment` or `Alignment0.t` for sequence alignment data, using streams for efficient processing. Concrete operations include parsing BAM files into header and alignment streams, writing aligned data back to BAM format, and low-level access for reading headers or individual alignments from compressed channels.",
      "description_length": 475,
      "index": 10,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Biocaml_ez.Fastq",
      "library": "biocaml.ez",
      "description": "This module processes FASTQ files with functions to read and write streams of FASTQ items, split sequence names, and extract components like sequence, quality scores, and comments from individual lines. It supports concrete workflows such as parsing raw FASTQ data from a reader, writing processed items to a file or pipe, and handling Illumina-specific metadata for downstream analysis like quality filtering or spatial mapping. The Illumina submodule specifically handles parsing and formatting of Illumina FASTQ identifiers into structured data, including validation and access to components such as instrument, lane, and position.",
      "description_length": 634,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Seq_range",
      "library": "biocaml.ez",
      "description": "This module represents and manipulates sequence ranges, each consisting of a string identifier and a numeric range. It provides functions to construct, parse, compare, and convert sequence ranges to and from string representations in the format `<seq>:<start>-<end>`. Use cases include handling genomic or sequence data where regions of interest are specified by identifiers and coordinate ranges.",
      "description_length": 397,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez.Roman_num",
      "library": "biocaml.ez",
      "description": "This module defines a type `t` representing Roman numerals as integers and provides direct conversions between Roman numeral strings and their integer equivalents. It includes functions to convert a Roman numeral string to an integer (`to_arabic`), an integer to a Roman numeral string (`to_roman`), and functions to construct values from either integers or strings. Concrete use cases include parsing and formatting Roman numerals in data processing tasks, such as handling historical numbering systems or specific domain representations.",
      "description_length": 539,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_ez",
      "library": "biocaml.ez",
      "description": "This module provides focused tools for handling genomic data formats and related utilities. It includes operations for reading and writing BAM files, computing alignment statistics, parsing FASTA and FASTQ files, processing line-based data, converting PHRED scores, manipulating genomic intervals, handling Roman numerals, and representing sequence ranges and DNA strands. Each submodule targets specific data types such as alignment records, quality scores, genomic intervals, and sequence identifiers, enabling concrete workflows like parsing sequencing data, analyzing alignment quality, and processing genomic regions with precise interval arithmetic.",
      "description_length": 655,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Bed.Bed4",
      "library": "biocaml.base",
      "description": "This module represents BED4 format data, which includes chromosome, start and end positions, a name, and additional fields. It provides functions to convert BED4 items to and from S-expressions for serialization and parsing. This is useful for working with genomic interval data in bioinformatics, such as annotating regions of interest in genomes.",
      "description_length": 348,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Bed.Bed5",
      "library": "biocaml.base",
      "description": "This module represents BED5 format data items, providing functions to construct, parse, and convert them. It works with strings, integers, and optional additional fields, validating required BED5 columns. Use it to read and write BED5 lines from genomic data files, ensuring correct structure and format.",
      "description_length": 304,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Bed.Bed5_raw",
      "library": "biocaml.base",
      "description": "This module represents BED5 format data with a focus on parsing and constructing BED5 records. It provides functions to convert between BED5 lines and structured items, validate fields, and manipulate the score field of an item. Use cases include reading and writing BED5 files, modifying annotation scores, and integrating with data-processing pipelines that require strict BED5 compliance.",
      "description_length": 391,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Macs2.Xls",
      "library": "biocaml.base",
      "description": "This module parses XLS output from the MACS2 peak caller into structured data, supporting direct interpretation of peak records, headers, and comments. It operates on line-based input and produces typed items representing different elements of the XLS format. Use this module to extract peak data or process MACS2 results directly from command-line output or files.",
      "description_length": 365,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Fasta.Parser0",
      "library": "biocaml.base",
      "description": "This module processes FASTA file chunks into low-level items without merging sequence lines, enabling efficient handling of large sequences like genomes in constant memory. It works with streams of strings and produces items containing raw sequence data as lists of lines, alongside parsing state and format settings. Concrete use cases include streaming genome-sized FASTA files where memory usage must remain bounded.",
      "description_length": 419,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Table.Field",
      "library": "biocaml.base",
      "description": "This module provides parsers for converting string fields into typed values, including integers, positive integers, bounded integers, and strings without separators. It supports concrete use cases like validating and parsing tabular data fields with specific constraints, such as ensuring numeric ranges or formatting requirements. Functions like `parse_all` allow applying these parsers across lists of strings to produce typed results with context-aware error handling.",
      "description_length": 471,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Lines.Parser",
      "library": "biocaml.base",
      "description": "This module implements a line parser with a `step` function that processes byte chunks to extract lines, maintaining state across calls. It works with byte strings and tracks line numbers, handling both partial and complete input scenarios. It is suitable for streaming or incremental parsing in asynchronous contexts.",
      "description_length": 318,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Macs2.Broad_peaks",
      "library": "biocaml.base",
      "description": "This module parses and represents broad peak data from MACS2 output files. It works with genomic intervals and associated scores, fold changes, and statistical values. Concrete use cases include extracting regions of enriched signal in ChIP-seq data and filtering peaks by significance thresholds.",
      "description_length": 297,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Bed.Bed3",
      "library": "biocaml.base",
      "description": "This module represents BED3 format genomic intervals with fields for chromosome, start, and end positions. It provides functions to convert items to and from S-expressions for serialization and parsing. Use this module to read, write, and manipulate BED3 data in bioinformatics workflows.",
      "description_length": 288,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Fasta.Parser",
      "library": "biocaml.base",
      "description": "This module parses FASTA files by processing a stream of strings into a sequence of FASTA items, handling variations in comment and description line formats. It works with `state` to track parsing progress and `item` to represent each sequence entry, supporting configurable delimiters and sequence interpretations. It is used to read large FASTA files in chunks, enabling memory-efficient parsing of genomic data without loading entire sequences into memory at once.",
      "description_length": 467,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Ucsc_genome_browser",
      "library": "biocaml.base",
      "description": "This module constructs and manipulates UCSC Genome Browser track lines and custom track URLs. It supports data types for genome assemblies, track attributes (such as color, visibility, and data source), and URL parameters. Concrete use cases include generating custom track URLs for visualizing genomic data like BED or BigWig files, and formatting track lines with specific display settings for integration into UCSC browser sessions.",
      "description_length": 435,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_base.Lines",
      "library": "biocaml.base",
      "description": "This module processes byte strings to extract lines incrementally, maintaining state across input chunks and tracking line numbers. It is ideal for streaming or asynchronous parsing of line-oriented file formats, handling both partial and complete lines efficiently. Use it when building parsers for large or continuous text data sources like log files or genomic data streams.",
      "description_length": 377,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_base.Macs2",
      "library": "biocaml.base",
      "description": "This module processes MACS2 peak caller output, providing structured access to XLS-formatted peak records and broad peak data. It supports parsing genomic intervals with associated scores, fold changes, and statistical values from either command-line output or files. Use it to extract and filter enriched regions from ChIP-seq experiments based on peak significance or to directly interpret MACS2 output.",
      "description_length": 405,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Gff",
      "library": "biocaml.base",
      "description": "This module parses and constructs GFF2 and GFF3 records, handling differences like attribute delimiters and version-specific formatting. It operates on `record` and `item` types, representing structured genomic features and comments. Use it to read or write individual GFF lines, validate syntax, or manipulate genomic annotations directly.",
      "description_length": 340,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Bed",
      "library": "biocaml.base",
      "description": "This module parses and constructs BED-formatted genomic interval data, converting between lines and structured items with validated fields. It supports BED3, BED4, and BED5 formats, handling chromosome names, positional ranges, optional annotations, and scores. Use it to process genomic interval files for bioinformatics tasks like region annotation or data filtering.",
      "description_length": 369,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Table",
      "library": "biocaml.base",
      "description": "This module processes tabular data by mapping string fields to typed values with strict validation. It supports operations like parsing lists of strings into structured records using predefined field parsers for integers, bounded values, and sanitized strings. Concrete use cases include loading and validating CSV or TSV files where each row must conform to a specific schema with error reporting.",
      "description_length": 398,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Line",
      "library": "biocaml.base",
      "description": "This module represents a single line of text and provides operations to manipulate lines, including parsing strings into lines, stripping whitespace, splitting on characters, and appending lines. It supports standard string-like operations while ensuring lines are handled safely, with utilities to convert to and from S-expressions. Use cases include processing text files line-by-line, handling FASTA or GFF formats, and building custom text parsers.",
      "description_length": 452,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base.Fasta",
      "library": "biocaml.base",
      "description": "The module provides operations for parsing and unparsing FASTA files with configurable comment delimiters and line-length handling, supporting both nucleotide/amino acid sequences as strings and quality score conversions via integer lists. It processes data using types like `item` (description and sequence) and `item0` for low-level parsing events, offering in-memory APIs for typical workflows and streaming via the `Parser0` submodule to efficiently handle large datasets like genomes. This enables applications ranging from standard sequence analysis to memory-constrained processing of high-throughput biological data.",
      "description_length": 624,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_base",
      "library": "biocaml.base",
      "description": "This module provides precise parsing and construction of genomic data formats including BED, GFF, FASTA, and MACS2 output, along with utilities for line-based and tabular data processing. It handles structured genomic intervals, sequence data, and annotation records with strict validation and efficient streaming capabilities. Concrete applications include processing ChIP-seq peak calls, validating genomic intervals, parsing large sequence files, and constructing custom genome browser tracks.",
      "description_length": 496,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred.Let_syntax.Let_syntax",
      "library": "biocaml.unix",
      "description": "This module provides monadic operations for working with deferred values, including binding, mapping, and combining futures. It handles asynchronous computations represented as `Deferred.t` values, enabling sequential composition and parallel execution of asynchronous tasks. Concrete use cases include chaining non-blocking I/O operations and handling results of concurrent system calls.",
      "description_length": 388,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred.Or_error.List",
      "library": "biocaml.unix",
      "description": "This module provides parallelized `map` and `iter` functions for processing lists with deferred, error-aware computations. It works with lists of values and applies functions that return deferred results wrapped in `Or_error`. Concrete use cases include executing I/O-bound operations concurrently over a list, such as fetching remote data or processing files, while handling failures gracefully.",
      "description_length": 396,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.GenomeMap.Make.LSet",
      "library": "biocaml.unix",
      "description": "This module represents sets of genomic locations and supports operations to query intersections, find closest elements, and convert between streams and sets. It works with abstract chromosome identifiers and annotated genomic ranges, enabling efficient analysis of spatial relationships between features like gene loci. Concrete use cases include identifying overlapping genomic regions, finding nearest genes to a given locus, and filtering regions that intersect a query interval.",
      "description_length": 482,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred.Or_error",
      "library": "biocaml.unix",
      "description": "This module provides parallelized `map` and `iter` functions for processing lists using deferred computations that may return errors. It is designed to work with lists of values and functions that produce deferred results wrapped in `Or_error`. It is useful for running I/O-bound tasks concurrently over a list, such as downloading multiple files or querying remote services, while aggregating and handling any failures that occur during execution.",
      "description_length": 448,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make.Object_id",
      "library": "biocaml.unix",
      "description": "This module defines a polymorphic type `t` that represents object identifiers in Entrez databases, supporting both integer and string-based IDs. It provides a conversion function `to_string` to serialize these identifiers for use in API requests. This module is used to handle record identifiers obtained from Entrez search operations, enabling their direct use in subsequent data retrieval requests.",
      "description_length": 400,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make.Dbtag",
      "library": "biocaml.unix",
      "description": "This module provides functions to construct and manipulate database tag identifiers used in Entrez API requests. It works with the `t` type, which combines a database name and an `Object_id.t` tag. Concrete use cases include creating and parsing identifiers for records in Entrez databases such as PubMed, Gene, or Protein.",
      "description_length": 323,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Table.Row.Transform",
      "library": "biocaml.unix",
      "description": "Converts between table rows and text lines, using configurable separators and tags to parse or format data. It operates on `Biocaml_unix.Lines.item` and `Biocaml_unix.Table.Row.t` types, enabling reading from and writing to tabular file formats like CSV or TSV. Useful for importing or exporting structured biological data with specific delimiters.",
      "description_length": 348,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Table.Row.Tags",
      "library": "biocaml.unix",
      "description": "This module defines and manipulates tags that specify the format of table rows, such as field separators and strictness constraints. It operates on a list-based structure of type `t`, which includes separators, strictness flags, and row type formats, supporting operations to query and serialize these properties. It is used to configure and interpret table parsing and printing behavior, such as determining the default TSV format or validating cell types and row lengths.",
      "description_length": 473,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.GenomeMap.Make.LMap",
      "library": "biocaml.unix",
      "description": "This module represents sets of genomic locations with attached values, supporting operations to query intersections, find closest elements, and convert between maps and streams. It works with a parameterized chromosome identifier type and location ranges, enabling precise genomic region analysis. Concrete use cases include identifying overlapping genomic features, retrieving nearest annotated regions, and streaming large genomic datasets for processing.",
      "description_length": 457,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred.Monad_infix",
      "library": "biocaml.unix",
      "description": "This module provides infix operators for chaining asynchronous computations that return deferred values. It supports binding and mapping operations over deferred results, enabling sequential composition of asynchronous tasks. Use it to handle asynchronous workflows, such as scheduling and transforming the result of a deferred computation.",
      "description_length": 340,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make.Pubmed",
      "library": "biocaml.unix",
      "description": "This module provides a search function to query the PubMed database using a string term, returning a list of parsed publication records containing PMID, title, and abstract. It works with the `t` record type representing PubMed entries. A concrete use case is retrieving metadata for scientific articles related to a specific topic, such as \"machine learning in genomics\".",
      "description_length": 372,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make.Gene",
      "library": "biocaml.unix",
      "description": "This module provides functions to search the Gene database via the Entrez API and retrieve structured gene records. It works with gene identifiers and returns records containing gene annotations, types, and summaries. A concrete use case is querying human gene records by symbol or description to obtain their functional annotations and related metadata.",
      "description_length": 354,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make.Gene_ref",
      "library": "biocaml.unix",
      "description": "This module provides functions to query and retrieve gene reference data from the Entrez Gene database via the Entrez Utilities API. It works with gene records containing fields such as locus, allele, description, map location, and database cross-references. Concrete use cases include fetching gene annotations by ID and parsing structured gene data for integration with bioinformatics workflows.",
      "description_length": 397,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make.PubmedSummary",
      "library": "biocaml.unix",
      "description": "This module provides a high-level interface to search the Pubmed database and retrieve structured summaries of articles. It works with query strings to perform searches and returns results as a list of records containing fields like PMID, title, publication date, and DOI. Concrete use cases include fetching metadata for scientific articles by keywords or identifiers to build literature reviews or citation graphs.",
      "description_length": 416,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.GenomeMap.Make.Selection",
      "library": "biocaml.unix",
      "description": "This module manages collections of non-overlapping genomic regions, supporting operations such as union, intersection, and difference between region sets. It allows adding regions, checking overlaps, and converting between region sets and streams of locations. It is useful for tasks like merging CpG island annotations or querying genomic coverage.",
      "description_length": 349,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Table.Row.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types for parsing table rows, specifically handling format issues like incorrect column counts or failed type conversions (e.g., string to int/float). It works with S-expressions to serialize and deserialize error values, enabling structured error reporting in table-processing pipelines. Concrete use cases include validating CSV or TSV data during parsing and providing detailed error messages for malformed lines.",
      "description_length": 442,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred.Let_syntax",
      "library": "biocaml.unix",
      "description": "This module provides monadic operators for composing asynchronous computations represented as `Deferred.t` values. It supports binding with `>>=`, mapping with `>>|`, and returning values with `return`, enabling precise control over sequential and parallel execution of non-blocking system calls and I/O operations. Use cases include orchestrating asynchronous workflows, such as handling the results of concurrent system calls or chaining dependent futures in a clear, composable way.",
      "description_length": 485,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred.List",
      "library": "biocaml.unix",
      "description": "This module provides asynchronous list operations using deferred values. It supports `fold`, `iter`, `map`, and `filter` functions that process list elements concurrently or sequentially, depending on the `how` parameter. These functions are useful for performing I/O-bound or computationally intensive tasks on each element of a list while composing the results into a single deferred outcome.",
      "description_length": 394,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bam.Header",
      "library": "biocaml.unix",
      "description": "This module converts between BAM and SAM header formats, providing `of_sam` to encode a SAM header into a BAM header and `to_sam` to decode a BAM header back to SAM format. It operates on the `t` type representing BAM headers and interacts directly with `Biocaml_unix.Sam.header`. Use this module when reading or writing BAM files to handle header translation while preserving alignment record compatibility.",
      "description_length": 408,
      "index": 52,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Wig.Transform",
      "library": "biocaml.unix",
      "description": "This module provides functions to parse and transform WIG data items, including converting between different WIG formats and BED graph representations. It operates on `item` values, which represent individual WIG entries such as variable-step, fixed-step, or bed-style data points. Concrete use cases include parsing raw WIG strings into structured items, printing those items in standardized format, and converting variable or fixed step data to BED graph values for downstream genomic analysis.",
      "description_length": 496,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Track.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types and S-expression converters for parsing track files. It handles errors related to incomplete input, incorrect browser positions, and malformed key-value pairs. These functions are used to report and serialize parsing issues when processing UCSC Genome Browser track data.",
      "description_length": 303,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Lines.Buffer",
      "library": "biocaml.unix",
      "description": "This module implements a line parsing buffer that processes strings into complete lines, handling partial input incrementally. It works with strings and tracks line positions, supporting operations like feeding input, peeking or retrieving lines, and checking parsing progress. Use it to parse line-based formats from streaming sources like file readers or network sockets.",
      "description_length": 373,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Fastq.Illumina",
      "library": "biocaml.unix",
      "description": "This module parses Illumina FASTQ name lines into structured sequence identifiers and provides functions to convert between string representations and typed records for tiles and sequence IDs. It handles data types like `tile` and `sequence_id`, which capture machine-specific metadata such as instrument, lane, tile, and position. Concrete use cases include extracting unique sequence identifiers from high-throughput sequencing data and validating or transforming tile information for downstream analysis.",
      "description_length": 507,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Gff.Transform",
      "library": "biocaml.unix",
      "description": "This module provides functions to convert between GFF file lines and structured item representations. It works with GFF version 2 and 3 formats, handling differences like attribute delimiters. Use cases include parsing GFF lines from a stream and serializing GFF items back to string format.",
      "description_length": 291,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range.Make",
      "library": "biocaml.unix",
      "description": "This module represents genomic regions as a sequence identifier paired with a numeric range, supporting operations like creation, comparison, and string formatting. It works with a customizable sequence identifier type and a range defined by start and end integers. Concrete use cases include parsing and manipulating BED file entries where regions are identified by chromosome names and coordinate ranges.",
      "description_length": 406,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Zip.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types for handling failures during decompression operations, specifically for gzip and zlib streams. It includes detailed variants for malformed headers, unsupported compression methods, and trailing garbage data. These errors are used to signal issues when processing compressed data streams in a streaming context.",
      "description_length": 342,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bamstats.Chr_histogram",
      "library": "biocaml.unix",
      "description": "Tracks chromosome coverage from BAM alignments, filtering by mapping quality. It uses a counter to accumulate base pair counts per chromosome. Use this to generate coverage statistics from aligned sequencing data.",
      "description_length": 213,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Lines.MakeIO",
      "library": "biocaml.unix",
      "description": "This module provides functions for reading from and writing to file lines using a `Future`-based I/O system. It handles line-based data through pipes, allowing asynchronous processing of input and output streams. Concrete use cases include reading lines from a file asynchronously, writing processed line streams to a file, and appending to existing files with specified permissions.",
      "description_length": 383,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.GenomeMap.Make",
      "library": "biocaml.unix",
      "description": "This functor creates data structures for managing genomic regions with abstract chromosome identifiers, supporting set operations like union, intersection, and difference. It includes modules for handling non-overlapping regions, location sets, and location-value mappings, enabling tasks such as merging annotations, querying overlaps, and finding nearest genomic features. The structures work with customizable chromosome types and ranges, suitable for applications like genomic coverage analysis and annotation filtering.",
      "description_length": 524,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Bamstats.Fragment_length_histogram",
      "library": "biocaml.unix",
      "description": "Tracks fragment length distributions from BAM alignments by accumulating counts of fragment lengths that meet a minimum mapping quality threshold. It uses a counter to store length-to-count mappings and updates statistics based on aligned reads. Useful for quality control in genomic analyses where fragment size distribution informs library preparation characteristics.",
      "description_length": 370,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.In_thread",
      "library": "biocaml.unix",
      "description": "Runs a function asynchronously in a separate thread, returning a deferred result. Works with functions that produce a value of any type `'a` and handles thread management internally. Useful for performing blocking or long-running computations without delaying the main thread, such as file I/O or intensive data processing tasks.",
      "description_length": 329,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Psl.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types for handling invalid or malformed input when parsing PSL (Positional Selection Language) data. It includes specific variants for incomplete input, invalid integers, incorrect strands, and mismatched column counts, each carrying position and contextual information. These errors are used to report parsing issues in functions that process PSL files or streams.",
      "description_length": 391,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Sam.MakeIO",
      "library": "biocaml.unix",
      "description": "Handles reading from and writing to SAM files using asynchronous I/O, supporting operations to parse and serialize SAM headers and alignment records. Works directly with `Biocaml_unix.Sam.header` and `Biocaml_unix.Sam.alignment` types through deferred and pipe-based streams. Useful for processing large genomic sequence data files where asynchronous handling improves performance, such as streaming alignments from disk or network sources.",
      "description_length": 440,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Accu.Counter",
      "library": "biocaml.unix",
      "description": "This module counts occurrences of values using a hash table. It provides operations to increment counts, iterate over counted items, and convert to or from lists and streams. Use it to tally elements in a sequence or track frequencies of events.",
      "description_length": 245,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Accu.Bins",
      "library": "biocaml.unix",
      "description": "This module organizes values into bins based on a provided function, allowing efficient accumulation and grouping of related data. It operates on lists and maps elements to bins using a classification function, aggregating results in a histogram-like structure. Concrete use cases include categorizing sequences by length, grouping genomic features by chromosome, or tallying occurrences of specific patterns in biological data.",
      "description_length": 428,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Accu.Relation",
      "library": "biocaml.unix",
      "description": "This module maps keys to lists of values, supporting incremental construction via `add` and conversion to and from streams and association lists. It works with arbitrary key and value types `'a` and `'b`, using a hash table internally to accumulate values per key. Use it to collect multiple values per key, such as grouping lines by identifiers in a file or aggregating related data entries.",
      "description_length": 392,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Deferred",
      "library": "biocaml.unix",
      "description": "This module implements asynchronous computation chaining and composition using `Deferred.t` values. It provides monadic operations like `bind`, `map`, and `join`, along with infix operators `>>=` and `>>|`, to sequence and transform deferred results. Key use cases include managing non-blocking I/O operations, scheduling dependent tasks, and aggregating concurrent system call results.",
      "description_length": 386,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Biocaml_result.List",
      "library": "biocaml.unix",
      "description": "This module provides functions to map over lists while propagating error results, handling each element with operations that may fail. It works with lists and the extended `Result` type that includes error information. Use this to process sequences of values where each transformation step can fail, such as parsing or validating elements in a list.",
      "description_length": 349,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Vcf.Transform",
      "library": "biocaml.unix",
      "description": "This module provides functions to transform raw VCF lines into structured data, specifically parsing strings into `Biocaml_unix.Vcf.item` values. It handles VCFv4.1 format, including metadata and variant call records, and reports parsing errors explicitly. Use it when processing VCF files for genomic analysis, such as extracting variant information or validating VCF content.",
      "description_length": 377,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Wig.Tags",
      "library": "biocaml.unix",
      "description": "This module handles parsing and serialization of WIG format tags, specifically supporting configuration options like `allow_empty_lines` and `sharp_comments`. It works with string inputs and outputs, converting between textual representations and structured tag values using S-expressions. Concrete use cases include reading and writing WIG header tags in genomic data processing workflows.",
      "description_length": 390,
      "index": 73,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Table.Row",
      "library": "biocaml.unix",
      "description": "This module represents rows of tabular data with typed fields (`int`, `float`, `string`) and provides parsing and serialization to text lines using configurable separators and type constraints. It supports concrete operations like parsing a line into a typed row with validation against a specified format, and converting rows back to lines for output. The module integrates with S-expressions for serializing row data and type definitions, enabling structured data exchange and error reporting in formats like CSV or TSV.",
      "description_length": 522,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Lines.Transform",
      "library": "biocaml.unix",
      "description": "This module provides transforms for processing streams of line items, enabling operations like converting strings to line items, grouping lines into pairs, and converting line items back to strings. It works with `Lines.item` and string streams, handling edge cases such as incomplete input or missing newlines. Concrete use cases include parsing line-based file formats, transforming line streams for further processing, and building custom line-oriented parsers with error handling.",
      "description_length": 484,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Gff.Tags",
      "library": "biocaml.unix",
      "description": "This module handles parsing and serialization of GFF file tags, supporting version 2 and 3 formats with configurable delimiters and comment handling. It operates on a record type specifying version, empty line allowance, and comment syntax, using S-expressions for serialization. Concrete use cases include reading and writing GFF file headers with precise tag-value pair formatting.",
      "description_length": 383,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bed.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types for parsing BED files, including errors related to format issues such as incorrect column numbers, invalid numeric conversions, and malformed rows. It provides S-expression conversion functions for serializing and deserializing these error types. Concrete use cases include handling and reporting errors during BED file parsing, particularly when dealing with malformed input or non-conformant data.",
      "description_length": 431,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Sam.Flags",
      "library": "biocaml.unix",
      "description": "This module decodes and interprets the bitwise flags field of a SAM file alignment record. It provides functions to check specific alignment properties such as whether a segment is mapped, reversed, part of a pair, or marked as a duplicate. These operations are essential for filtering and analyzing sequencing alignments directly from SAM data.",
      "description_length": 345,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bed.Transform",
      "library": "biocaml.unix",
      "description": "This module provides functions to convert between BED-formatted strings and parsed item representations, supporting customizable parsing and serialization of BED data streams. It operates on `string` and `item` types, where `item` represents a BED interval with chromosome, start, end, and optional additional fields. Concrete use cases include parsing BED lines with custom column specifications and converting parsed BED items back to string format for output.",
      "description_length": 462,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Chr.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types for handling chromosome name conversions, specifically when ambiguity arises in Roman numeral representations. It includes a single error case for indicating when a chromosome name cannot be uniquely determined in Roman form. This helps ensure reliable parsing and conversion of chromosome identifiers when using Roman numerals.",
      "description_length": 360,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Wig.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types for parsing WIG data and converting it to BED-like formats. It includes detailed parsing errors with positional information and specific failure reasons, such as missing or malformed fields, and conversion errors for ensuring correct state during output generation. The module supports error reporting in both parsing and transformation stages, specifically handling format-specific constraints for variable-step, fixed-step, and BED-style WIG data.",
      "description_length": 481,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Track.Transform",
      "library": "biocaml.unix",
      "description": "This module implements parsers and printers for UCSC Genome Browser track files in various formats. It processes input into structured representations like GFF, WIG, and BED, handling track metadata and content lines separately. Use it to convert between raw text files and typed data structures for genomic annotations.",
      "description_length": 320,
      "index": 82,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Psl.Transform",
      "library": "biocaml.unix",
      "description": "Converts a string representation of a PSL (Pattern Spline Likelihood) record into a structured item, optionally validating against a specified filename. Works with result types that encapsulate either a parsed PSL item or an associated error. Useful for transforming raw PSL data lines into typed data structures during file parsing or data ingestion workflows.",
      "description_length": 361,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Zip.Default",
      "library": "biocaml.unix",
      "description": "This module defines default configuration values for compression operations, including the internal buffer size and compression level. It provides constants used by streaming compression functions, particularly for the Zlib library. These defaults are applied in transformations like `Transform.zip` to control performance and compression efficiency.",
      "description_length": 350,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Writer",
      "library": "biocaml.unix",
      "description": "This module provides functions for writing text data to files asynchronously. It supports operations like writing strings, characters, and lines to an output channel. Use it to efficiently handle file output in concurrent applications, such as logging events or exporting large datasets without blocking execution.",
      "description_length": 314,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Fastq.MakeIO",
      "library": "biocaml.unix",
      "description": "This module implements reading from and writing to FASTQ files using a custom `Future` concurrency model. It processes FASTQ records as `item` values, which include name, sequence, comment, and qualities fields, and ensures correct formatting and parsing of the four-line structure. It supports use cases like streaming large FASTQ files, transforming records, and writing processed data to files or pipelines.",
      "description_length": 410,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Pipe",
      "library": "biocaml.unix",
      "description": "This module provides functions for reading and processing asynchronous data streams, such as reading values one at a time, discarding values, and applying transformations or folds over the stream. It works with deferred values and readers that represent a sequence of asynchronous elements, typically used for handling input from files, network streams, or inter-process communication. Concrete use cases include parsing large files line-by-line without blocking, processing asynchronous event streams, and building pipelines that transform or aggregate data incrementally.",
      "description_length": 573,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Gff.Error",
      "library": "biocaml.unix",
      "description": "This module defines error types and S-expression converters for handling GFF file parsing issues. It includes specific errors like `cannot_parse_float`, `wrong_attributes`, and `empty_line`, each tied to a file position and contextual string data. Use cases include reporting malformed numeric fields, invalid strand values, or incorrect attribute formatting during GFF version 2 or 3 parsing.",
      "description_length": 393,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bam.Alignment0",
      "library": "biocaml.unix",
      "description": "This module represents partially parsed BAM alignment records, providing access to specific fields like query name, flags, reference ID, position, mapping quality, CIGAR string, and optional tags without fully decoding the entire record. It works with data types including raw BAM headers, alignment records, and SAM-compatible structures such as CIGAR operations and optional fields. Concrete use cases include efficiently processing large BAM files when only a subset of alignment fields is needed, such as calculating coverage or filtering reads based on mapping quality or position.",
      "description_length": 586,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Msg.Tree",
      "library": "biocaml.unix",
      "description": "This module represents a tree structure for organizing hierarchical messages, where each node contains a string message and a list of sub-message trees. It provides operations to construct leaf nodes, add child nodes to existing trees, and convert the entire tree to a string representation. It is used to build structured error or diagnostic messages with nested explanations, such as reporting multi-level validation failures or detailed error causes in command-line tools.",
      "description_length": 475,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Zip.Transform",
      "library": "biocaml.unix",
      "description": "This module provides streaming compression and decompression transforms for working with zlib and gzip formats. It supports operations to zip and unzip data streams with configurable parameters like compression level and buffer size. Concrete use cases include processing large files or network data incrementally without loading the entire content into memory.",
      "description_length": 361,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix.Reader",
      "library": "biocaml.unix",
      "description": "This module provides functions for asynchronous file reading operations, including opening and closing files, reading lines or entire contents, and processing data through pipes. It works with file descriptors, strings, and deferred values to handle I/O in a non-blocking manner. Concrete use cases include reading large text files line-by-line without loading the entire file into memory and asynchronously processing log files or genomic data streams.",
      "description_length": 453,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Entrez.Make",
      "library": "biocaml.unix",
      "description": "This module implements a generic interface for querying and retrieving structured data from Entrez databases such as PubMed, Gene, or Protein. It provides functions to search databases with query strings, extract object identifiers, and fetch detailed records in a single operation. The module works with typed identifiers and structured record formats to support concrete workflows like fetching gene annotations by symbol or retrieving metadata for scientific articles by keywords.",
      "description_length": 483,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.MzData.Precursor",
      "library": "biocaml.unix",
      "description": "This module represents precursor ions in mass spectrometry data, specifically supporting operations to access and compute properties such as mass, m/z ratio, charge, and intensity. It works with the `t` type, which encapsulates key attributes of a precursor ion. A concrete use case includes extracting and analyzing precursor ion data from mzData files for downstream processing in proteomics workflows.",
      "description_length": 404,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Entrez",
      "library": "biocaml.unix",
      "description": "This module implements a generic interface for querying and retrieving structured data from Entrez databases such as PubMed, Gene, or Protein. It provides functions to search databases with query strings, extract object identifiers, and fetch detailed records in a single operation. The module works with typed identifiers and structured record formats to support concrete workflows like fetching gene annotations by symbol or retrieving metadata for scientific articles by keywords.",
      "description_length": 483,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Vcf",
      "library": "biocaml.unix",
      "description": "This module parses VCFv4.1 files into structured data, converting lines into `vcf_row` values with detailed fields for chromosomes, variants, quality scores, and annotations. It validates and transforms metadata like INFO, FORMAT, and FILTER entries, enforcing type correctness and reporting errors such as malformed numbers or unknown identifiers. Use it to extract and process genomic variant calls from 1000 Genomes Project data or similar VCF sources.",
      "description_length": 455,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq_range",
      "library": "biocaml.unix",
      "description": "This module represents genomic regions using a sequence identifier and a numeric range, supporting creation, comparison, parsing, and string formatting. It works with tuples of strings and integer ranges, tailored for handling data like BED file entries. Concrete use cases include parsing chromosome regions, comparing genomic intervals, and serializing regions to and from string formats.",
      "description_length": 390,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Strand",
      "library": "biocaml.unix",
      "description": "This module represents DNA strand orientations using the type `t` as either `'-'` or `'+'`. It provides functions to parse strand names from strings, convert between strand values and their string representations (\"rev\" or \"fwd\"), and access predefined strand values. It is used when handling genomic data to standardize and manipulate strand information from various input formats.",
      "description_length": 382,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Jaspar",
      "library": "biocaml.unix",
      "description": "This module provides functions to load and parse motifs from the Jaspar database, supporting various collections such as Core, Phylofacts, and PBM. It works with a structured motif type that includes metadata and a matrix representing the position weight matrix. Use it to retrieve motif data from a local SQL dump file for downstream analysis like motif matching or sequence scanning.",
      "description_length": 385,
      "index": 99,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Pos",
      "library": "biocaml.unix",
      "description": "This module represents and manipulates file positions using a record type with optional source, line, and offset fields. It supports creating positions with `make`, advancing line numbers with `incr_line`, and converting positions to human-readable strings with `to_string`. Concrete use cases include tracking locations in text files during parsing or reporting errors at specific lines and offsets.",
      "description_length": 400,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Tfxm",
      "library": "biocaml.unix",
      "description": "This module enables stream transformations where input data can be accumulated and processed asynchronously to produce output chunks, often handling cases where multiple inputs generate a single output or vice versa. It operates on generic input/output streams with support for error-aware transformations using `result` types, and includes utilities for composing transforms, merging error states, and interfacing with IO channels. Typical applications include parsing variable-length data formats, error-tolerant stream processing, and building asynchronous pipelines that require buffering intermediate results.",
      "description_length": 614,
      "index": 101,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Fasta",
      "library": "biocaml.unix",
      "description": "This module parses and writes FASTA files, handling variations in comment syntax, sequence formatting, and header structure. It processes data into items containing descriptions and sequences, with options to control comment handling, line length, and alphabet validation. Use cases include reading genomic sequences from standard FASTA files, streaming large files with `read0`, and converting space-separated numeric sequences with `sequence_to_int_list`.",
      "description_length": 457,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Sgr",
      "library": "biocaml.unix",
      "description": "This module provides functions to read and write Sequence Graph (SGR) data from channels or files, supporting transformations of chromosome names and base pair coordinates. It works with a custom type `t` representing SGR data, which consists of chromosome-position-score entries. Concrete use cases include parsing SGR files into structured data, modifying chromosome identifiers or adjusting genomic coordinates during import or export, and converting between in-memory representations and file formats.",
      "description_length": 505,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.File_mapper",
      "library": "biocaml.unix",
      "description": "This module provides functions to map over file contents using specific data formats, such as lines and BED5 records. It supports operations on file-based data through typed mappers that process content incrementally. Use cases include parsing genomic intervals from BED files or processing large text files line by line without loading the entire file into memory.",
      "description_length": 365,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Line",
      "library": "biocaml.unix",
      "description": "This module handles line-oriented string manipulation, providing operations to split strings into lines, strip whitespace, split on delimiters, and append or concatenate lines. It supports parsing and converting lines to and from strings and S-expressions, with utilities to process incomplete or partial lines. Use cases include parsing text files line-by-line, handling streaming input with partial lines, and safely or efficiently converting between strings and line representations.",
      "description_length": 486,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Table",
      "library": "biocaml.unix",
      "description": "This module handles parsing and serializing tabular data with typed fields (int, float, string) using configurable separators. It supports operations like validating rows against a specified format and converting rows to text lines for output. Use cases include processing CSV, TSV, or BED files with strict type and structure requirements.",
      "description_length": 340,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Psl",
      "library": "biocaml.unix",
      "description": "This module parses and processes PSL (Positional Selection Language) data, converting raw lines into structured alignment records with detailed positional and sequence information. It handles input from channels or individual lines, providing error reporting for malformed entries, and supports serialization to and from S-expressions. Concrete use cases include loading PSL files for genome alignment analysis, validating alignment data from sequencing pipelines, and integrating PSL records into larger bioinformatics workflows.",
      "description_length": 530,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.MzData",
      "library": "biocaml.unix",
      "description": "This module reads mzData files, parsing mass spectrometry data into spectra containing m/z values, intensities, and precursor ion information. It supports operations to access and process spectral data, including retrieving precursor details and working with binary arrays of float and integer values. A concrete use case is extracting and analyzing MS/MS spectra for proteomics research, such as identifying peptides from tandem mass data.",
      "description_length": 440,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Pwm",
      "library": "biocaml.unix",
      "description": "This module implements position-weight matrices (PWMs) for DNA motif analysis, supporting creation from count matrices and background distributions. It provides operations to scan DNA sequences for motif matches above a threshold, compute reverse complements, and construct composite motifs with spacers. Use cases include identifying transcription factor binding sites and analyzing regulatory sequence elements.",
      "description_length": 413,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Phred_score",
      "library": "biocaml.unix",
      "description": "This module implements conversions between PHRED quality scores and related representations such as ASCII characters, integers, probabilities, and Solexa scores. It supports two ASCII encodings via offset selection (`Offset33` and `Offset64`) to decode or encode PHRED scores in FASTQ files. Concrete operations include parsing ASCII characters into PHRED scores, converting scores to probability values, and transforming between PHRED and Solexa scores with customizable rounding functions.",
      "description_length": 491,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Interval_tree",
      "library": "biocaml.unix",
      "description": "This module implements an interval tree for storing and querying integer-bounded intervals labeled with arbitrary values. It supports efficient operations such as adding intervals, checking for intersections, finding closest and overlapping intervals, and filtering based on overlap with a given range. Use cases include genomic interval analysis, scheduling, and spatial range queries where fast access to overlapping or nearby intervals is required.",
      "description_length": 451,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bamstats",
      "library": "biocaml.unix",
      "description": "This module tracks statistics from BAM alignments, including counts of total, passing-quality, single, paired, mapped, and properly aligned reads. It works with BAM alignment data to compute metrics useful for genomic quality control and analysis. The module includes submodules for tracking fragment length and chromosome coverage histograms, which are used to analyze sequencing library characteristics and genomic coverage.",
      "description_length": 426,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bam",
      "library": "biocaml.unix",
      "description": "This module reads and writes BAM files, handling both headers and alignment records. It supports two levels of alignment parsing: full parsing via `alignment` and partial parsing via `Alignment0`, which allows efficient access to specific fields without decoding entire records. Use cases include processing large BAM files for tasks like coverage calculation or filtering reads by mapping quality or position.",
      "description_length": 410,
      "index": 113,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Chr",
      "library": "biocaml.unix",
      "description": "This module handles conversion of chromosome names between Arabic and Roman numeral formats, ensuring consistent and unambiguous representations. It works with string inputs representing chromosome identifiers, such as \"chr4\" or \"chrX\", and normalizes them to canonical forms like \"4\" or \"X\". Use cases include parsing genomic data files where chromosome names must be standardized for comparison or indexing.",
      "description_length": 409,
      "index": 114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Roman_num",
      "library": "biocaml.unix",
      "description": "This module provides functions to convert between Roman numerals and integers, validating input in both directions. It defines a private type `t` representing valid Roman numerals (integers \u2265 1) and supports parsing case-insensitive Roman strings, converting integers to Roman numerals, and converting between the two formats. Concrete use cases include processing historical date formats, parsing Roman-numbered document sections, and generating Roman numeral labels for UI elements.",
      "description_length": 484,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Cel",
      "library": "biocaml.unix",
      "description": "This module parses Affymetrix CEL files in text format and provides access to intensity data, including mean, standard deviation, and pixel count per probe. It supports operations to fold or iterate over intensity rows and extract PM, MM, or PM-MM values across multiple CEL files. Concrete use cases include analyzing microarray intensity data for gene expression studies by aggregating values from multiple samples.",
      "description_length": 417,
      "index": 116,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Lines",
      "library": "biocaml.unix",
      "description": "This module processes line-based data from files, channels, and streams, offering functions to read, write, and transform lines asynchronously or incrementally. It works with line items, character streams, and strings, supporting operations like parsing, buffering, and streaming line data to and from files or channels. Concrete use cases include asynchronous line-by-line file reading, incremental line parsing from network sockets, and transforming line streams for format conversion or analysis.",
      "description_length": 499,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bpmap",
      "library": "biocaml.unix",
      "description": "This module reads, writes, and processes Affymetrix BPMAP text files, which describe probe coordinates and sequences for microarray data. It supports parsing files into structured data, including probe metadata and genomic positions, and converting that data back to the BPMAP format. Use cases include importing probe information for analysis pipelines or exporting processed probe data for downstream tools.",
      "description_length": 409,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future",
      "library": "biocaml.unix",
      "description": "This module defines operations for working with asynchronous values using a `Future` type, which represents a value that may become available at some point in the future. It includes functions for creating, chaining, and composing futures, as well as handling errors and cancellation. Concrete use cases include managing concurrent I/O operations, implementing non-blocking algorithms, and coordinating asynchronous computations.",
      "description_length": 429,
      "index": 119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Fastq",
      "library": "biocaml.unix",
      "description": "This module parses and writes FASTQ files, handling each four-line record as an `item` with name, sequence, comment, and qualities fields. It supports reading and writing streams of FASTQ records, validating quality line length against the sequence, and converting Illumina name lines into structured identifiers. Concrete use cases include processing high-throughput sequencing data, filtering or transforming FASTQ records in pipelines, and extracting metadata from Illumina sequence identifiers.",
      "description_length": 498,
      "index": 120,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Biocaml_result",
      "library": "biocaml.unix",
      "description": "This module enhances error handling and monadic processing for computations that may fail, offering serialization, comparison, and combinators like `bind` and `map`. It operates on values of type `('a, 'e) t`, supporting conversions between `Either0`, `option`, and list-based error propagation, with utilities for aggregating errors or transforming success/failure states. Typical uses include parsing structured data, processing lists with error-prone elements, and composing error-aware workflows that require exception capture or bidirectional conversion between error representations.",
      "description_length": 589,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Histogram",
      "library": "biocaml.unix",
      "description": "This module implements histograms with polymorphic bin types, where each bin is defined by a lower and upper bound and contains a floating-point count. It supports operations to create histograms from bin boundaries, find bin indices for values, increment bin counts, and retrieve bin ranges and counts. Concrete use cases include statistical analysis of numerical data, such as tracking the distribution of floating-point measurements or categorizing values into discrete intervals.",
      "description_length": 483,
      "index": 122,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Zip",
      "library": "biocaml.unix",
      "description": "This module provides streaming compression and decompression for zlib and gzip formats, operating on input channels and producing string streams. It supports incremental processing of large files or network data with configurable buffer sizes and compression levels. Concrete use cases include reading compressed log files in chunks and transmitting compressed data over sockets without full in-memory buffering.",
      "description_length": 412,
      "index": 123,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Transcripts",
      "library": "biocaml.unix",
      "description": "This module represents and manipulates transcript structures as integer intervals with associated exon lists, where each exon is an interval. It supports operations such as merging overlapping transcripts, splitting transcripts into exons, and calculating coverage across genomic regions. Concrete use cases include processing gene annotation data, analyzing RNA-seq alignments, and generating interval-based summaries for downstream genomic analyses.",
      "description_length": 451,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Accu",
      "library": "biocaml.unix",
      "description": "This module implements a flexible accumulation data structure using hash tables to group and aggregate values based on a binning function. It supports operations to create custom accumulators with user-defined binning logic and aggregation rules, retrieve accumulated values, and convert results to streams or lists. Concrete use cases include building histograms, counting event frequencies, grouping genomic data by chromosome, and aggregating related entries in biological datasets.",
      "description_length": 485,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Track",
      "library": "biocaml.unix",
      "description": "This module processes UCSC Genome Browser track files, supporting parsing and serialization of track metadata and content lines in formats like GFF, WIG, and BED. It handles structured representations of track lines, comments, and browser directives, enabling conversion between text files and typed genomic annotation data. Use it to read, manipulate, and write track files with precise control over display attributes and genomic positions.",
      "description_length": 442,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Gff",
      "library": "biocaml.unix",
      "description": "This module parses and serializes GFF files, handling both version 2 and 3 formats with configurable delimiters for tag-value pairs. It processes structured records containing sequence annotations, including fields like `seqname`, `feature`, and `attributes`, alongside comments. Key operations include streaming GFF data from input channels, converting items to strings, and handling parsing errors tied to specific file positions.",
      "description_length": 432,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bar",
      "library": "biocaml.unix",
      "description": "This module parses Affymetrix BAR text files exported from Tiling Analysis Software, providing access to genomic score data organized by chromosome sections. It supports operations to retrieve sections by name or index, extract data as sorted triplets (chromosome, position, value), and access metadata such as data type, scale, and algorithm information. Use cases include analyzing probe signal or p-value data across chromosomes, integrating with genomic pipelines, and post-processing tiling array results.",
      "description_length": 510,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Math",
      "library": "biocaml.unix",
      "description": "This module provides statistical analysis, numerical computations, and array manipulation operations for numeric values, arrays, and matrices. It supports tasks like calculating descriptive statistics (mean, variance, median), performing hypothesis tests (e.g., Wilcoxon rank sum), analyzing correlations (Pearson, Spearman), processing histograms and windowed data, and handling matrix operations such as transposition and ranking with tie resolution. Use cases include data preprocessing, scientific computing, and evaluation of predictive models through accuracy metrics and statistical validation.",
      "description_length": 601,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Range",
      "library": "biocaml.unix",
      "description": "This module supports operations for defining, comparing, and combining contiguous integer intervals through arithmetic (union, intersection, gap calculation) and set-like relationships (subset checks, membership testing). It primarily handles ranges represented by lower and upper bounds, along with lists of ranges for positional analysis, region expansion, or containment logic. These capabilities are commonly applied in genomic interval analysis, interval tree construction, and scheduling systems requiring precise contiguous range management.",
      "description_length": 548,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Sam",
      "library": "biocaml.unix",
      "description": "This module provides bidirectional conversion between SAM format components and typed OCaml representations, supporting operations like parsing headers, alignment records, and CIGAR operations into structured data or S-expressions. It works with SAM-specific data structures including header tags (`HD`, `SQ`), alignment flags, reference sequences, optional fields, and CIGAR operations, while leveraging deferred I/O for streaming large genomic datasets. Key use cases include validating SAM file integrity, transforming alignment metadata for analysis pipelines, and efficiently serializing/deserializing SAM data with error-resilient parsing.",
      "description_length": 645,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Msg",
      "library": "biocaml.unix",
      "description": "This module formats and prints error, warning, and bug messages with optional source positions, and includes a tree structure for building hierarchical diagnostic messages. It works with strings and tree-based data to organize multi-level error explanations. Use it to report structured errors in command-line tools or validate complex inputs with nested failure reasons.",
      "description_length": 371,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Bed",
      "library": "biocaml.unix",
      "description": "This module parses and serializes BED file data, converting between BED-formatted lines and structured `item` values representing genomic intervals. It supports customizable parsing of additional columns and handles chromosome name transformations and interval adjustments for non-standard formats. Use cases include reading BED files into interval data streams, validating interval overlaps, and converting parsed intervals to and from S-expressions for serialization.",
      "description_length": 469,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.GenomeMap",
      "library": "biocaml.unix",
      "description": "This module implements efficient data structures for managing genomic regions with abstract chromosome identifiers, supporting set operations like union, intersection, difference, and membership tests. It includes variants for non-overlapping regions, location sets, and location-value mappings, enabling tasks such as merging annotations, querying overlaps, and finding nearest genomic features. The structures work with customizable chromosome types and ranges, suitable for applications like genomic coverage analysis and annotation filtering.",
      "description_length": 546,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Wig",
      "library": "biocaml.unix",
      "description": "The module supports parsing and format conversion of WIG data into structured representations like `bed_graph_value` and `variable_step`, handling genomic coordinates with inclusive ranges. It processes input streams into typed data structures while managing format-specific conventions across bed, variable-step, and fixed-step WIG formats. This enables use cases such as genomic dataset analysis, error-resilient parsing of large-scale sequence data, and transformation between WIG subformats for downstream processing.",
      "description_length": 521,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Sbml",
      "library": "biocaml.unix",
      "description": "This module enables parsing SBML files into structured models and converting mathematical expressions to S-expressions. It handles data structures like `sb_model`, which includes compartments, species, reactions, parameters, and events, along with types for mathematical operators, units, and kinetic laws. This supports applications such as systems biology modeling, simulation workflows, and programmatic analysis of SBML-encoded biological systems.",
      "description_length": 451,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Iset",
      "library": "biocaml.unix",
      "description": "This structure manages sets of integers using range-based encoding, optimized for efficient operations on contiguous intervals rather than sparse points. It supports set algebra (union, intersection, difference), range slicing, and transformations with logarithmic time complexity for large-scale data. Typical applications include genomic interval analysis, time-range scheduling, and other domains where compact representation of dense integer ranges is critical.",
      "description_length": 465,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Solexa_score",
      "library": "biocaml.unix",
      "description": "This module implements conversions between Solexa quality scores and ASCII encodings, probabilities, and Phred scores. It provides functions to encode/decode scores using ASCII characters, compute scores from probabilities, and convert scores to their probability equivalents. Use cases include parsing and generating FASTQ files in the Solexa/Illumina format, adjusting quality score representations, and integrating with probabilistic sequence analysis tools.",
      "description_length": 461,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.RSet",
      "library": "biocaml.unix",
      "description": "This module implements efficient integer sets optimized for large contiguous sequences, using range-based representations. It supports operations like union, intersection, and difference, along with conversions to and from range lists and integer lists. It is useful for handling genomic intervals or other data with long runs of consecutive integers.",
      "description_length": 351,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Seq",
      "library": "biocaml.unix",
      "description": "This module handles nucleic acid sequences using a specialized type `t`, supporting operations like creating sequences from strings or buffers, slicing, and folding over elements. It validates characters against IUB/IUPAC nucleic acid codes and provides indexed access to sequence elements. Use cases include parsing and processing DNA or RNA sequences, extracting sub-sequences, and converting sequences to and from string representations.",
      "description_length": 440,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Bgzf",
      "library": "biocaml.unix",
      "description": "This module enables efficient compression and decompression of BGZF-formatted data through custom channel abstractions that manage block structure and virtual offset addressing. It handles binary data manipulation with support for reading/writing raw bytes, strings, and numeric primitives (8/16/32-bit signed/unsigned) while ensuring safe resource management via scoped file operations and explicit disposal. The design facilitates random access to compressed genomic datasets and streaming workflows for large-scale sequence analysis.",
      "description_length": 536,
      "index": 141,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Biocaml_unix.Bin_pred",
      "library": "biocaml.unix",
      "description": "This module computes performance metrics for binary classifiers using arrays of prediction scores and boolean labels. It generates confusion matrices, ROC and precision-recall curves, and calculates metrics like sensitivity, specificity, accuracy, and F1 score. Concrete use cases include evaluating machine learning models on medical diagnostics or spam detection tasks where score thresholds determine classification outcomes.",
      "description_length": 428,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix.Future_unix",
      "library": "biocaml.unix",
      "description": "This module implements asynchronous computation and I/O handling through deferred values, pipes, and threads. It provides monadic composition for chaining non-blocking operations, concurrent file reading and writing, and thread-based execution for blocking tasks. Concrete use cases include processing large genomic data files line-by-line, aggregating results from concurrent system calls, and managing background computations without blocking the main thread.",
      "description_length": 461,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Biocaml_unix",
      "library": "biocaml.unix",
      "description": "This module provides operations for parsing, transforming, and analyzing genomic data formats (BAM, BED, VCF, GFF, FASTQ), handling genomic intervals and sequences, and performing statistical analysis on sequencing data. It works with structured biological data types like interval trees, range sets, position-weight matrices, and streaming I/O for efficient processing of large datasets. Specific use cases include genomic variant detection, transcript interval analysis, binary classifier evaluation, and scalable aggregation of high-throughput sequencing results using concurrent workflows.",
      "description_length": 593,
      "index": 144,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 150,
    "meaningful_modules": 145,
    "filtered_empty_modules": 5,
    "retention_rate": 0.9666666666666667
  },
  "statistics": {
    "max_description_length": 655,
    "min_description_length": 213,
    "avg_description_length": 431.37931034482756,
    "embedding_file_size_mb": 2.1014719009399414
  }
}