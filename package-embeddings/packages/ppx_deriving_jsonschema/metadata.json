{
  "package": "ppx_deriving_jsonschema",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 3,
  "creation_timestamp": "2025-07-15T23:05:00.949067",
  "modules": [
    {
      "module_path": "Ppx_deriving_jsonschema.Schema",
      "library": "ppx_deriving_jsonschema",
      "description": "This module constructs JSON schema expressions programmatically, generating OCaml AST nodes representing JSON schema primitives, compositions, and constraints. It supports operations for creating schema elements such as `null`, `char`, enums, arrays with min/max bounds, and logical combinations like `oneOf` and `anyOf`. Concrete use cases include embedding JSON schema generation directly into OCaml code during PPX rewriting, enabling compile-time schema validation for custom data types.",
      "description_length": 491,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppx_deriving_jsonschema",
      "library": "ppx_deriving_jsonschema",
      "description": "This module generates JSON schemas from OCaml types by converting type declarations into schema expressions, encoding variants and labeled fields into JSON structures, and supporting optional types and type checks. It builds schema elements programmatically through AST nodes, including primitives like `null` and `char`, collections with constraints, and logical combinators such as `oneOf`. You can use it to automatically derive schemas for validating API requests or documenting configuration formats at compile time. Submodules enable direct construction of complex schema nodes during PPX processing, allowing seamless integration with custom data type definitions.",
      "description_length": 671,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppx_deriving_jsonschema_runtime",
      "library": "ppx_deriving_jsonschema.runtime",
      "description": "This module generates JSON Schema representations from OCaml values, allowing customization of metadata like version, title, and description. It works with polymorphic variant types and associative lists to construct schema definitions dynamically. Concrete use cases include validating data structures in web APIs and generating documentation for configuration formats.",
      "description_length": 370,
      "index": 2,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 3,
    "meaningful_modules": 3,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 671,
    "min_description_length": 370,
    "avg_description_length": 510.6666666666667,
    "embedding_file_size_mb": 0.011332511901855469
  }
}