{
  "package": "ppx_poly_record",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 6,
  "creation_timestamp": "2025-06-18T16:30:16.634242",
  "modules": [
    {
      "module_path": "Ppx_poly_record.Poly_record.Internal",
      "description": "Provides direct access and modification of internal state using hash keys, and supports creating and copying instances with specified fields. Operates on opaque type 'a t and hash values. Used for low-level manipulation in scenarios requiring direct memory or state control.",
      "description_length": 274,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppx_poly_record_plugin.Ppx",
      "description": "Calculates hash values for labels, manages polymorphic record handling, and validates attributes and fields during parsing. It operates on OCaml AST nodes, locations, and expressions, supporting transformations in syntax tree manipulation. It enables error checking for illegal fields and extends AST mappers for custom processing.",
      "description_length": 331,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppx_poly_record.Poly_record",
      "description": "manages mutable state through hash-keyed access and modification, enabling direct manipulation of internal data structures. It works with the opaque type 'a t and hash values, allowing creation, copying, and field-specific updates. Users can dynamically alter fields without exposing internal representation, making it suitable for performance-critical or custom data handling. For example, it supports setting a specific field in an instance or duplicating an object with modified values.",
      "description_length": 489,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "ppx_poly_record",
      "description": "Provides operations to construct, deconstruct, and manipulate polymorphic records, including field access, projection, and extension. Works with the `Poly_record.t` type, which represents records with field types encoded as object types. Used to implement extensible data structures with type-safe field operations in domain-specific languages.",
      "description_length": 344,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_poly_record_plugin",
      "description": "Calculates hash values for record labels, manages polymorphic records, and validates attributes during parsing, operating on OCaml AST nodes, locations, and expressions. It supports syntax tree transformations and error checking for invalid fields. Custom processing is enabled through extended AST mappers. Examples include enforcing field constraints, generating unique identifiers for labels, and modifying record structures during compilation.",
      "description_length": 447,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppx_poly_record",
      "description": "manages mutable state via hash-keyed access, operating on the opaque type 'a t to enable direct field manipulation. It supports creating, copying, and updating specific fields without exposing internal structure, allowing dynamic modifications. Users can set individual fields or generate new instances with adjusted values. This facilitates efficient, controlled data handling in scenarios requiring runtime flexibility.",
      "description_length": 421,
      "index": 5,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 6,
    "meaningful_modules": 6,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 489,
    "min_description_length": 274,
    "avg_description_length": 384.3333333333333,
    "embedding_file_size_mb": 0.022230148315429688
  }
}