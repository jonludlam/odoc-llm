{
  "package": "hardcaml_xilinx_reports",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 42,
  "creation_timestamp": "2025-07-15T23:14:49.395953",
  "modules": [
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Of_bits",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides operations to manipulate structured hardware interfaces with clock signals, using bit vectors to represent combinational logic. It supports construction, validation, and transformation of interfaces through functions like packing/unpacking, multiplexing, concatenation, and selection. Use cases include building and verifying register-wrapped hardware designs for accurate synthesis reporting in Xilinx Vivado.",
      "description_length": 431,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.All",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides the `all` function, which transforms a monadic interface of registered signals into a registered interface of monadic values, effectively reordering the monad and interface structure. It operates on data types involving `I_with_clock.t`, which represents clocked interfaces with input and output ports, wrapped within an arbitrary monad `M`. A concrete use case is combining multiple registered signal computations within a monadic context, such as accumulating state or handling side effects during the construction of a synthesizable circuit with registered inputs and outputs.",
      "description_length": 600,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Names_and_widths",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines the interface for a registered circuit wrapper by specifying port names, widths, and associated tags. It provides direct access to lists of port names, widths, and tags used to describe the inputs and outputs of the wrapped circuit. This interface is used to generate accurate synthesis reports with input and output delays accounted for, particularly when analyzing timing and utilization in a hierarchical design flow.",
      "description_length": 440,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Of_signal",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides combinational logic primitives, register instantiation, and signal manipulation utilities for constructing clocked hardware interfaces. It operates on signal interfaces composed of Hardcaml signal values, organized under clocked interface definitions, enabling precise structural validation and timing analysis. These capabilities support use cases like generating synthesis reports with accurate input/output delay measurements and creating register-wrapped circuits for hierarchical timing analysis in FPGA designs.",
      "description_length": 538,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx_reports",
      "description": "This module maps interface signals to and from an association list using port names as keys, enabling programmatic manipulation of signal values indexed by their string identifiers. It operates on `I_with_clock.t` values, which represent hardware interfaces with clocked inputs and outputs. This supports dynamic signal routing or transformation workflows where port-level access is required, such as custom register insertion or signal tracing during synthesis report generation.",
      "description_length": 480,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Of_always",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides functions to work with clocked interfaces using the Always API, enabling the creation and manipulation of register and wire variables within always blocks. It operates on `I_with_clock.t` interfaces, supporting operations like signal assignment, register instantiation with optional enable, and naming of interface fields. Concrete use cases include building synchronous logic for FPGA designs with precise timing control, such as pipelined data paths or state machines, and generating named signals for synthesis report analysis.",
      "description_length": 551,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Comb",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides combinational logic operations for constructing and manipulating register-wrapped hardware interfaces. It supports operations like multiplexing, concatenation, and priority/one-hot selection on interfaces with clocked input/output ports. Concrete use cases include building complex control logic and data paths where precise timing and signal selection are required in synthesized FPGA designs.",
      "description_length": 415,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Make_comb",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides combinational logic operations for wrapping circuit interfaces with clocked registers, including packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection functions. It works with typed interfaces (`t`) composed of a specific combinational logic type (`comb`) and clocked signals. Concrete use cases include constructing and validating structured signal interfaces for synthesis timing reports, enabling precise control over input/output register behavior in FPGA designs.",
      "description_length": 519,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Advanced.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines variant types representing advanced Xilinx primitive groups such as MAC, GT, Interlaken, PCIe, and SysMon. It provides operations to fold, iterate, map, and construct matchers over these variants, enabling structured processing of Vivado synthesis utilization data. These functions are used to analyze and report resource usage metrics like cell counts and hierarchy ranks in FPGA designs.",
      "description_length": 409,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Io.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines specific variants of IO primitives used in Xilinx Vivado Ultrascale designs, such as input/output buffers, bidirectional buffers, SERDES, and metastability handling. It provides operations to fold, iterate, map, and match over these variants, enabling detailed analysis of IO-related utilization and timing. These functions are used to extract and process data from Vivado synthesis reports, particularly for counting and categorizing IO cell usage in a design.",
      "description_length": 481,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Register.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines variants of register primitives used in Xilinx Vivado synthesis reports, including sdr, ddr, latch, and metastability. It provides operations to fold, iterate, map, and match over these variants to compute utilization metrics based on register types. These functions are used to extract counts and properties of specific register instances in a synthesized design for detailed reporting.",
      "description_length": 407,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Clock.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines clock primitive variants used in Xilinx Vivado Ultrascale utilization analysis, including buffer, mux, and pll. It provides operations to fold, iterate, map, and match over these variants, enabling structured processing of clock-related cell properties. These functions support precise extraction and transformation of clock utilization data from synthesis reports.",
      "description_length": 385,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Configuration.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines variant configurations for Xilinx primitive groups used in Vivado synthesis reports. It provides operations to fold, iterate, map, and construct matcher functions over these variants, enabling structured processing of configuration-specific data. Use cases include filtering and aggregating utilization metrics for hardware primitives like BSCAN, DNA, and Block RAM in FPGA designs.",
      "description_length": 402,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock",
      "library": "hardcaml_xilinx_reports",
      "description": "This module enables functional transformations over clocked hardware interfaces, combining operations like mapping, zipping, folding, and scanning with structured manipulation of input/output ports, clock signals, and register insertion. It supports bit vector operations, combinational logic primitives, and monadic reordering to build and validate register-wrapped circuits for Xilinx synthesis. You can construct interfaces from signal lists, insert registers for timing control, dynamically route signals by port name, or define synchronous logic using always blocks with named fields. Use cases include generating synthesis reports with accurate timing delays, building pipelined data paths, and transforming structured interfaces through multiplexing, concatenation, or selection while preserving hierarchical timing behavior.",
      "description_length": 832,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Blockram.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines and operates on variants of block RAM primitives (FIFO, BRAM, URAM) used in Xilinx Vivado synthesis reports. It provides functions to fold, iterate, map, and match over these variants, enabling precise querying and aggregation of utilization data based on block RAM types. These operations support concrete use cases like generating utilization summaries or filtering cells by memory type for analysis.",
      "description_length": 422,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Arithmetic.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines variants of arithmetic primitives used in Xilinx Vivado Ultrascale designs, specifically targeting DSP utilization analysis. It provides operations to map, fold, iterate over, and match arithmetic primitive types, enabling precise extraction and categorization of DSP cell usage from synthesis reports. Use cases include generating utilization statistics and filtering cells based on arithmetic properties for design optimization.",
      "description_length": 450,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Clb.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines and operates on variants of CLB (Configurable Logic Block) primitives in Xilinx Vivado Ultrascale designs, such as LUTs, carry chains, and SRLs. It provides functions to fold, iterate, map, and match over these variants, enabling detailed inspection and aggregation of utilization data. These operations are used to extract counts, ranks, and names of specific CLB components directly from synthesis reports.",
      "description_length": 428,
      "index": 16,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Io",
      "library": "hardcaml_xilinx_reports",
      "description": "This module classifies I/O-related primitive groups in Xilinx Vivado Ultrascale designs, including buffers, Serdes, and DDR interfaces, and provides predicates and extraction functions to analyze their usage in synthesis reports. It supports operations to filter, count, and query properties of I/O components, enabling precise hardware characterization. Submodules extend this with variants for specific primitives like bidirectional buffers and metastability handling, offering mapping and iteration functions for detailed utilization and timing analysis. Together, they facilitate processing and reporting of I/O cell instances directly from netlist data.",
      "description_length": 658,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Report.Clock",
      "library": "hardcaml_xilinx_reports",
      "description": "Handles parsing and representation of clock timing data from Vivado synthesis reports. Works with clock constraint data including setup and hold times. Used to analyze and report critical timing paths for specific clocks in FPGA designs.",
      "description_length": 237,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.Command_flags",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines command-line flags and parameters for configuring synthesis runs with Vivado. It includes options to control output paths, device parts, report generation, design flattening, retiming, and concurrency settings. These flags are used to construct and execute synthesis commands with specific tool behaviors and design constraints.",
      "description_length": 348,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Arithmetic",
      "library": "hardcaml_xilinx_reports",
      "description": "This module organizes arithmetic primitive groups for analyzing Xilinx Vivado Ultrascale designs, focusing on DSP element identification. It provides the `t` type, with variants like `Dsp`, to represent arithmetic properties and supports operations to classify, filter, and extract utilization data from synthesis reports. Child modules extend this functionality with mapping, folding, and iteration tools for detailed DSP cell usage analysis. Together, they enable tasks like generating utilization statistics and optimizing designs based on arithmetic properties.",
      "description_length": 565,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Clb",
      "library": "hardcaml_xilinx_reports",
      "description": "This module classifies Xilinx CLB primitives into categories such as LUTs, latches, and carry chains, and extracts attributes like SRL values or subgroup identifiers from Vivado synthesis reports. It operates on a variant type representing CLB subgroups, supporting analysis of FPGA resource utilization by filtering and counting cells based on their logic function and structure. The child module extends this by defining the variant types and providing operations to fold, map, and iterate over them, enabling aggregation of metrics such as component counts and ranks. Together, they allow processing synthesis data to derive detailed utilization statistics for different logic elements in Ultrascale designs.",
      "description_length": 711,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Blockram",
      "library": "hardcaml_xilinx_reports",
      "description": "This module organizes and processes block RAM resources in Xilinx Vivado Ultrascale designs, focusing on FIFO, BRAM, and URAM cell types. It includes constructors, predicates, and property extractors for these primitives, allowing direct querying of the Vivado database to count and classify memory instances. Submodules extend this functionality with folds, maps, and iterators that enable detailed aggregation and reporting, such as filtering cells by type or summarizing memory usage across a design. Together, they support tasks like generating utilization metrics or analyzing memory distribution in synthesized circuits.",
      "description_length": 626,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Report.Group",
      "library": "hardcaml_xilinx_reports",
      "description": "This module organizes hierarchical groups of synthesis report data, where each group contains a name, a numeric value, and a list of subgroups. It supports structured traversal and aggregation of report metrics such as area or timing. Use this module to extract and analyze nested performance data from Xilinx Vivado synthesis reports.",
      "description_length": 335,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides functions to generate and execute Vivado synthesis commands for a design with specified input and output interfaces. It supports creating a command line interface, running synthesis with customizable flags, and generating reports based on primitive groups and sorting options. Concrete use cases include automating synthesis workflows and generating timing and utilization reports for specific design instances.",
      "description_length": 432,
      "index": 24,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make",
      "library": "hardcaml_xilinx_reports",
      "description": "This module wraps circuits with input and output registers to enable accurate synthesis timing reports in Vivado, supporting both combinational and sequential designs through interface descriptions `I` and `O`, with optional clocked input registers via `I_with_clock`. It provides functions like `create`, `hier`, and `create_list` to instantiate and compose multiple registered designs for hierarchical reporting. The child module enables functional transformations over clocked interfaces, combining mapping, zipping, and folding with register insertion, bit vector operations, and synchronous logic definition using always blocks. You can build pipelined data paths, generate timing reports with precise delays, and manipulate structured interfaces through concatenation, selection, or dynamic routing while preserving synthesis behavior.",
      "description_length": 841,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Subgroup",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines subgroups of primitive cells for Xilinx Vivado Ultrascale designs, focusing on categorizing and filtering cells based on their utilization properties. It includes operations to retrieve the subgroup name and determine whether macro primitives should be ignored. These subgroups are used to accurately count specific types of cells, such as LUTs or flip-flops, during synthesis utilization analysis.",
      "description_length": 418,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Configuration",
      "library": "hardcaml_xilinx_reports",
      "description": "This module models Xilinx hardware primitive configurations using a variant type `t` with constructors and inspection functions, allowing extraction of boolean flags and subgroup identifiers for filtering hardware cells based on features like ECC enable. It supports analysis of synthesis reports by identifying cells tied to specific primitive groups such as Clb or Register for utilization tracking. The child module extends this by defining variant configurations for Vivado synthesis reports and providing operations to fold, iterate, map, and build matcher functions over them. Together, they enable structured processing, filtering, and aggregation of utilization metrics for FPGA primitives like BSCAN, DNA, and Block RAM.",
      "description_length": 729,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Advanced",
      "library": "hardcaml_xilinx_reports",
      "description": "This module organizes advanced Xilinx primitives into an enumerated type with variants for categories like MAC, GT, PCIe, and SysMon, offering inspection and transformation operations such as membership checks, value extraction, and mapping to Vivado subgroup strings. It enables filtering and counting specialized hardware components in synthesis reports, particularly for complex blocks beyond basic logic elements, supporting configuration-driven exclusion of macros. Submodules provide structured processing through folds, iterators, and matchers, facilitating analysis of resource metrics like cell counts and hierarchy ranks across different primitive groups. Example uses include extracting GT transceiver counts or excluding specific PCIe blocks from utilization summaries based on project settings.",
      "description_length": 807,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines variant types representing different categories of Xilinx Vivado primitives such as CLB, register, and block RAM. It provides operations to fold, iterate, and map over these variants, enabling structured processing of primitive groups for utilization analysis. These functions are used to extract and analyze specific cell counts and properties from synthesis reports.",
      "description_length": 388,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Project.Config",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines configuration options for generating Vivado synthesis projects, including flags to enable timing and utilization reports, settings for design optimization and retiming, and control over hierarchy traversal during reporting. It works with records containing boolean flags, optional values, and lists of primitive groups, along with blackbox configurations. It is used to customize the behavior of synthesis project generation and reporting in Xilinx FPGA workflows.",
      "description_length": 484,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Clock",
      "library": "hardcaml_xilinx_reports",
      "description": "This module organizes clock primitives\u2014buffers, multiplexers, and phase-locked loops\u2014for Xilinx Vivado Ultrascale designs, offering classification and inspection tools to analyze clock-related utilization metrics. It includes functions to check membership, extract values, and apply transformations across primitive groups, enabling queries on design-wide clock cell properties. Submodules extend this with variant-specific operations like folding, mapping, and matching, which facilitate structured traversal and data extraction from synthesis reports. Together, they support tasks such as filtering clock cells, aggregating utilization statistics, and transforming clock hierarchy data.",
      "description_length": 688,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential",
      "library": "hardcaml_xilinx_reports",
      "description": "Wraps circuit inputs and outputs with registers to enable accurate synthesis timing reports in Vivado. Works with Hardcaml interfaces `I` and `O` to manage port registration and hierarchy. Used to generate timing-critical reports with input/output delays included via `blackbox=none` and `hier=true` flows.",
      "description_length": 306,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Report.Subgroup",
      "library": "hardcaml_xilinx_reports",
      "description": "Handles subgroups of synthesis report data, providing structured access to named integer values. Works with strings and integers to represent categorized metrics like timing or utilization details. Used to extract and process specific metric groups from Vivado-generated reports.",
      "description_length": 279,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Register",
      "library": "hardcaml_xilinx_reports",
      "description": "This module organizes register primitive groups for Xilinx Vivado Ultrascale designs, offering operations to classify and analyze register types such as Sdr, Ddr, Latch, and Metastability. It enables filtering and identification of these types within a design, supporting precise utilization counting in synthesis reports. Child modules extend this functionality with folding, mapping, and iteration utilities to extract detailed register metrics. Examples include counting flip-flops in a design block or identifying metastability resolution circuits for timing analysis.",
      "description_length": 572,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers",
      "library": "hardcaml_xilinx_reports",
      "description": "This module wraps circuit inputs and outputs with registers to enable accurate synthesis timing reports in Vivado, supporting both combinational and sequential designs through structured interfaces. It provides operations like `create`, `hier`, and `create_list` to instantiate and compose registered designs, enabling hierarchical reporting with precise input and output delay tracking. Users can build pipelined data paths, apply functional transformations over clocked interfaces, and manipulate structured interfaces using operations like mapping, zipping, and bit vector selection. It facilitates synthesis flows that preserve timing behavior for accurate analysis in timing-critical applications.",
      "description_length": 702,
      "index": 35,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command",
      "library": "hardcaml_xilinx_reports",
      "description": "This module generates command-line interfaces for synthesizing and analyzing Hardcaml circuits using Vivado, combining flag configuration and command execution into a unified workflow. It supports constructing synthesis commands with customizable options such as device parts, output paths, and report settings, while operating directly on Hardcaml circuits, scopes, and primitive groups. The module enables running synthesis flows programmatically, producing timing and utilization reports, and customizing design constraints and execution behavior through submodules that handle flag definitions and command generation. Example uses include automating synthesis for different design instances and generating structured reports based on circuit properties.",
      "description_length": 757,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Project",
      "library": "hardcaml_xilinx_reports",
      "description": "This module generates and executes Vivado synthesis projects for hardware circuits, creating project files and RTL with configurable clocks, FPGA parts, and output paths, while optionally running placement and routing to produce timing and utilization reports. Its child module defines configuration options including report settings, optimization flags, and hierarchy traversal controls, using records with booleans, optional values, and blackbox configurations. Users can customize synthesis behavior, enable retiming, and specify primitive groups for detailed control over the generated project. Example usage includes setting up a synthesis project with custom optimization levels and generating reports for specific circuit components.",
      "description_length": 740,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Clock",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines clock configurations for a design's top-level module, primarily specifying clock net names, periods, and optional BUFG constraints for skew approximation. It provides functions to create clocks using either a period in nanoseconds or a frequency in MHz, and to access clock properties. Use cases include setting up clock constraints for Vivado synthesis and generating accurate timing reports.",
      "description_length": 413,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Report",
      "library": "hardcaml_xilinx_reports",
      "description": "This module parses Vivado synthesis reports into structured data, organizing clock timing, hierarchical groups, and subgroups for analysis of FPGA synthesis results. It supports reading report files and generating utilization and timing tables by correlating circuit data with parsed entries, enabling extraction of timing slack values and structured reporting. Clock data is handled through constraint analysis of setup and hold times, while hierarchical groups allow traversal and aggregation of metrics like area or timing across nested structures. Subgroups provide access to categorized metrics, supporting detailed analysis of specific performance data from synthesis reports.",
      "description_length": 682,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group",
      "library": "hardcaml_xilinx_reports",
      "description": "This module organizes Xilinx Vivado Ultrascale primitives into hierarchical groups and subgroups, enabling precise hardware utilization analysis through property-based filtering and aggregation. It defines key data types such as variant representations of primitive categories (e.g., logic blocks, registers, block RAMs) and associated property records, supporting operations to classify, count, and extract synthesis-time metrics from design cells. Child modules refine this structure with specialized functionality for arithmetic units, I/O components, CLB subgroups, memory elements, clocking resources, and register types, each providing typed variants, predicates, and traversal tools to enable detailed reporting and optimization. For example, it can count LUTs in a logic block, extract FIFO memory instances, or filter DDR registers for timing analysis.",
      "description_length": 861,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports",
      "library": "hardcaml_xilinx_reports",
      "description": "This module enables end-to-end synthesis reporting for FPGA designs by integrating clock configuration, design wrapping, command-line automation, project generation, report parsing, and primitive classification. It centers around circuit and clock data types, with operations to define timing constraints, register interfaces, generate synthesis commands, and extract structured utilization and timing metrics. Users can wrap designs for accurate timing analysis, synthesize with custom constraints, and programmatically analyze report data to optimize area and performance. Example workflows include automating synthesis for multiple design variants, extracting slack values from timing reports, and aggregating LUT or register counts for targeted optimization.",
      "description_length": 762,
      "index": 41,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 42,
    "meaningful_modules": 42,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 861,
    "min_description_length": 237,
    "avg_description_length": 536.452380952381,
    "embedding_file_size_mb": 0.1529712677001953
  }
}