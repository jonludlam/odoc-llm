{
  "package": "hardcaml_xilinx_reports",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 90,
  "creation_timestamp": "2025-06-18T16:49:49.693999",
  "modules": [
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. While no concrete data types or functions are defined, it serves as a foundation for integrating domain-specific notations. Developers can use its syntax to write more expressive and concise code when working with effectful computations.",
      "description_length": 437,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations include `let%` and `and%` for chaining computations. It is designed to simplify code structure when using monadic interfaces.",
      "description_length": 342,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity during conversions.",
      "description_length": 291,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise control over signed integer operations in hardware description or low-level numeric processing.",
      "description_length": 317,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over bit-width and extension. Resizes vectors to specified widths while maintaining numerical integrity during operations.",
      "description_length": 351,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types encapsulating values and side effects. Enables chaining of asynchronous or effectful operations with value transformation.",
      "description_length": 238,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.All.Let_syntax",
      "description": "Introduces custom syntax for binding and sequencing monadic operations, enabling more readable and expressive code for effectful computations. It relies on underlying monadic structures but does not define new data types or functions itself. Developers can use this syntax to chain operations in a way that mirrors imperative style, improving clarity in complex workflows. For example, it allows writing nested binds in a more linear fashion, simplifying error handling and state management.",
      "description_length": 491,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is typically used to simplify code that involves monadic structures like option, result, or async.",
      "description_length": 405,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is particularly useful for writing concise, composable code in a monadic style.",
      "description_length": 386,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a generic type wrapped in a record structure and Base.string keys. Used to serialize and deserialize data structures based on named fields in network-related contexts.",
      "description_length": 291,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.All",
      "description": "Combines monadic sequencing with syntactic enhancements to manage effectful computations, allowing operations to be chained and transformed using bind and map. It supports asynchronous or side-effecting processes by wrapping values in monadic types and enabling value manipulation throughout the chain. The syntax simplifies complex workflows, making nested operations more readable and reducing boilerplate in error handling and state transitions. For example, it lets developers write sequential computations in a linear, imperative style while maintaining the composability of monadic structures.",
      "description_length": 599,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of `v` values to specified widths. Used for manipulating fixed-width binary values in hardware description or digital logic contexts.",
      "description_length": 374,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface records with fixed field widths. Used to pack signals into a single bit vector for output, unpack from a bit vector input, and select between multiple interface configurations based on control signals.",
      "description_length": 382,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Of_signal",
      "description": "This module offers signal manipulation functions for hardware interfaces, including packing/unpacking, multiplexing, concatenation, and value assignment, alongside renaming and field modification operations. It works with `comb t` types representing named hardware interfaces and `Hardcaml.Signal.t` structures, enabling tasks like signal routing, control flow management, and interface customization. Specific use cases include designing register pipelines and adapting signal layouts in digital circuit designs.",
      "description_length": 513,
      "index": 14,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Of_always",
      "description": "Provides functions to construct and manage hardware interface components within always blocks, including variable assignment, register creation, and wire initialization. Works with signal types and variable containers from the Hardcaml library to model digital circuit behavior. Used to define clocked registers with enable signals and name signals with customizable prefixes and suffixes.",
      "description_length": 389,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts port names and widths as separate lists or combines them into a list of (name, width) tuples. Used to generate or inspect hardware interface configurations.",
      "description_length": 324,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 272,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed vectors of arbitrary width. Used for precise arithmetic in hardware description or digital logic simulations where overflow and bit-width management are critical.",
      "description_length": 352,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over width and extension. Resizes vectors to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 348,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of numeric values in hardware description or digital logic contexts.",
      "description_length": 324,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, result, or list. Enables chaining of effectful operations and transformation of wrapped values in a concise, readable manner.",
      "description_length": 295,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.All.Let_syntax",
      "description": "Introduces custom syntax for chaining monadic operations, enabling cleaner and more readable code. Provides `let%` and `and%` for binding and sequencing values within monadic contexts. Supports complex workflows by abstracting away boilerplate associated with monadic composition. Allows developers to write imperative-style code that integrates seamlessly with monadic interfaces.",
      "description_length": 381,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Operates on a custom `v` type representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity during conversions.",
      "description_length": 296,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise arithmetic in hardware description, such as adding or multiplying vectors of different widths without loss of precision.",
      "description_length": 342,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bit vectors or signals, allowing for width-aware operations and conversions. Resizes vectors to specified widths while maintaining value integrity during transformations.",
      "description_length": 353,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing signed binary values, such as Bits.t or Signal.t. Enables precise manipulation of fixed-width signals in hardware description or digital logic contexts.",
      "description_length": 312,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, result, or list. Enables chaining of effectful operations like error handling, asynchronous tasks, or stateful computations.",
      "description_length": 294,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of effectful computations through constructs like `let%bind` and `let%map`. Supports sequencing and binding within monadic contexts, simplifying workflows involving types such as option, result, or async. Allows for more readable and structured code when chaining operations that involve side effects or nested computations. Example: binding values from an option chain without explicit pattern matching.",
      "description_length": 479,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.Make_comb.Unsigned",
      "description": "Converts between signed and unsigned vector representations, performs arithmetic and comparison operations on vectors with automatic bit-width extension, and resizes vectors to specified widths while preserving value. Operates on `v` type, representing unsigned bit vectors. Used for hardware description tasks requiring precise control over binary arithmetic and signal conversion.",
      "description_length": 382,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed vectors, and supports conversions between `v` and `Comb.t`. Enables precise control over signed integer operations in hardware description or low-level numeric processing.",
      "description_length": 361,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise width control and extension. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 342,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.Make_comb.Sop",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and resizing. Works with custom data types representing signed binary values, such as Bits.t or Signal.t. Enables precise manipulation of fixed-width signals in hardware description or digital logic contexts.",
      "description_length": 322,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, list, or result. Enables chaining of operations that depend on previous results, like handling optional values or accumulating results in a list.",
      "description_length": 315,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.All.Let_syntax",
      "description": "Introduces custom syntax for monadic composition, enabling cleaner handling of effectful operations through constructs like `let%bind` and `let%map`. Supports sequential binding and transformation of values within monadic contexts, simplifying complex workflows. Allows for more readable and maintainable code when working with monads such as option, result, or async. Example: chaining multiple monadic steps with `let%bind` to process a series of dependent computations.",
      "description_length": 472,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock",
      "description": "Provides operations to pack, unpack, and manipulate interface structures composed of combinatorial signals. Works with `comb` and `t` types representing interface signals and their widths. Used to construct and validate hardware interfaces, perform multiplexing, and concatenate signal groups in digital design workflows.",
      "description_length": 321,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.Unsafe_assoc_by_port_name",
      "description": "Provides functions to convert between a structured data type and an association list using field names as keys. Operates on a type that maps string keys to values, typically used for parsing or serializing data with named fields. Enables direct lookup and construction of data based on explicit field names.",
      "description_length": 307,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.All",
      "description": "Combines monadic sequencing and custom syntax to streamline effectful computations. Supports operations like bind and map on wrapped values, including option, result, and list types, enabling fluent manipulation of context-aware data. Allows imperative-style coding with `let%` and `and%` to simplify monadic workflows. Example: chaining multiple optional computations or transforming results within a list monad.",
      "description_length": 413,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary numbers in hardware description or digital logic contexts.",
      "description_length": 378,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on `comb` (bit vectors) and `t` (interface records) to support hardware design tasks. Enables multiplexing, concatenation, and selection operations for digital circuit descriptions.",
      "description_length": 327,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.Of_signal",
      "description": "The module provides functions for constructing, manipulating, and validating hardware interface signals, including packing, unpacking, multiplexing, concatenating, and renaming operations on `comb t` types and `Hardcaml.Signal.t` structures. It supports tasks like signal routing, control flow management, and register pipeline configuration, along with name transformations and field-level modifications within structured interfaces. Specific use cases include interface multiplexing, signal concatenation, and dynamic name adjustments for hardware design workflows.",
      "description_length": 567,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.Of_always",
      "description": "Provides functions to construct and manage hardware interface components within always blocks, including variable assignment, register creation, and wire initialization. Works with signal types and variable containers from the Hardcaml library to define hardware behavior. Used to generate named signals, configure registers with enable logic, and wire signals with default values.",
      "description_length": 381,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. It exposes separate lists for names and widths, as well as a combined list of name-width pairs. Used to extract and organize metadata from hardware description models.",
      "description_length": 326,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.Unsafe_assoc_by_port_name",
      "description": "Provides functions to convert between a structured data type and an association list using field names as keys. Operates on a type that maps string keys to values, typically used for parsing or serializing data with named fields. Enables direct manipulation of data structures where field names are critical for access and modification.",
      "description_length": 336,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.All",
      "description": "Combines monadic sequencing and custom syntax to handle effectful computations, allowing operations on types like option, result, and list through chained binds and maps. Provides `let%bind` and `let%map` to simplify nested or error-prone workflows, reducing boilerplate in asynchronous or stateful code. Enables safe value extraction from option chains and structured handling of results without explicit pattern matching. Example: sequentially processing a list of results while handling potential errors in each step.",
      "description_length": 520,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary values in hardware description or digital logic contexts.",
      "description_length": 377,
      "index": 45,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface structures composed of bit vectors. Used to pack signals into a single bus, unpack from a bus, or select between multiple interface configurations based on control signals.",
      "description_length": 353,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.Of_signal",
      "description": "The module provides signal manipulation functions for tasks like packing, unpacking, multiplexing, and renaming, along with interface management through named field operations. It works with hardware interface types such as `comb t` and signal structures like `Hardcaml.Signal.t`, enabling precise control over signal routing and data flow. Specific use cases include designing register pipelines, optimizing control flow, and transforming signal names in digital circuit implementations.",
      "description_length": 488,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.Of_always",
      "description": "Provides functions to construct and manage hardware interface components within always blocks, including variable assignment, register creation, and wire initialization. Works with signal types, variable containers, and register specifications from the Hardcaml library. Used to define clocked registers with enable signals and name interface fields with customizable prefixes and suffixes.",
      "description_length": 390,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process and analyze hardware or circuit descriptions by separating and accessing specific metadata.",
      "description_length": 357,
      "index": 49,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Advanced.Variants",
      "description": "Provides access to predefined variant identifiers such as MAC, GT, and PCIe, and supports mapping, iteration, and folding over these variants with custom functions. Operates on a custom variant type and returns structured data like names, ranks, and descriptions. Used to generate configuration-specific code paths and validate hardware variant compatibility.",
      "description_length": 359,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Configuration.Variants",
      "description": "Provides access to specific variant configurations such as BSCAN, DNA, EFUSE, and others, along with operations to iterate, fold, and map over these variants. Works with a custom variant type and associated metadata like names and ranks. Used to generate descriptive lists, apply side-effecting operations, and transform variant data in hardware configuration workflows.",
      "description_length": 370,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Arithmetic.Variants",
      "description": "Processes variant types by extracting their names, ranks, and descriptions. Applies transformations, folds, and iterations over variant instances using custom functions. Supports pattern matching and data extraction for structured variant handling.",
      "description_length": 248,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Clb.Variants",
      "description": "Provides operations to process and transform variant types representing hardware primitives, including mapping, iteration, and folding over specific variant tags like latch, carry, and lut. Works with custom variant types and associated metadata such as names and integer ranks. Used to generate hardware descriptions, analyze circuit structures, and perform tag-specific transformations.",
      "description_length": 388,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Clock.Variants",
      "description": "Provides operations to process and transform variant types, including folding, iteration, and mapping over specific variant cases. Works with a custom variant type `t` and associated metadata like names and ranks. Used to generate structured outputs from variant data, such as converting variants to ranked identifiers or building custom match handlers.",
      "description_length": 353,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Io.Variants",
      "description": "Provides operations to extract and process specific hardware-related variant configurations, including signal buffers, timing controls, and interface protocols. Works with a custom variant type representing hardware components and their attributes. Used to generate descriptive metadata, apply transformation pipelines, and traverse variant configurations for hardware synthesis or verification tasks.",
      "description_length": 401,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Blockram.Variants",
      "description": "Provides operations to process and transform variant types representing hardware resources, including folding over specific variants, iterating through them, mapping values, and generating matchers. Works with a custom variant type `t` and associated metadata like names and ranks. Used to generate configuration code, validate resource usage, and extract descriptive information for system diagnostics.",
      "description_length": 403,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Register.Variants",
      "description": "Provides operations to extract and process specific variant types (sdr, metastability, ddr, latch) from a structured variant representation. Supports mapping, iteration, and folding over these variants with custom functions, and includes utilities to convert variants to names, ranks, and descriptive tuples. Enables precise handling of hardware or protocol variant configurations in low-level system modeling.",
      "description_length": 410,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a custom type representing interfaces and lists of string-value pairs. Used to map configuration data from a list of named fields into a structured format.",
      "description_length": 279,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.All",
      "description": "Combines monadic sequencing and custom syntax to handle effectful computations in a structured way. Provides operations like bind and map for transforming values within contexts such as option, list, or result, and supports custom syntax for cleaner code. Enables chaining dependent computations, such as processing optional values or accumulating results. Example: using `let%bind` to sequentially compute values that may fail or return multiple results.",
      "description_length": 455,
      "index": 59,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary values in hardware description or digital logic contexts.",
      "description_length": 377,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on `comb` (bit vectors) and `t` (interface records) to support hardware design tasks. Enables multiplexing, concatenation, and selection operations for digital circuit descriptions.",
      "description_length": 327,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.Of_signal",
      "description": "The module provides operations for constructing, manipulating, and validating hardware signals, including packing, multiplexing, concatenating, and renaming, working with combinatorial signal types (comb t) and structured interfaces (t) that have named fields. It enables tasks like signal routing, width validation, and name transformations, supporting applications such as hardware synthesis, interface design, and precise signal management through field-level modifications and prefix/suffix adjustments. Specific use cases include managing signal assignments, ensuring correct bit-widths for synthesis, and dynamically reconfiguring signal names in digital circuit designs.",
      "description_length": 677,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.Of_always",
      "description": "Provides functions to construct and manage hardware interface components within always blocks, including variable assignment, register creation, and wire initialization. Works with signal types and variable containers from the Hardcaml library to define hardware behavior. Used to generate named signals with specific defaults or naming conventions for digital circuit descriptions.",
      "description_length": 382,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts port names and widths as separate lists or combines them into a list of (name, width) tuples. Used to process hardware description data for signal mapping and validation.",
      "description_length": 338,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential",
      "description": "Converts, validates, and manipulates interface structures composed of bit-widthed fields. Performs packing, unpacking, multiplexing, and concatenation of interface values, and checks for width consistency. Accepts integer constants to initialize interface fields and supports priority and one-hot selection from lists of interfaces.",
      "description_length": 332,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make",
      "description": "Provides operations to convert, validate, and manipulate interface structures representing digital logic signals. Works with `comb` and `t` types, which encapsulate signal widths and values. Enables packing and unpacking of interfaces into vectors, multiplexing, concatenation, and selection based on control signals.",
      "description_length": 317,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Advanced",
      "description": "Encapsulates variant management with operations for mapping, iteration, and folding over hardware identifiers like MAC, GT, and PCIe. Processes a custom variant type to extract structured information including names, ranks, and descriptions. Enables dynamic code generation and compatibility checks based on variant configurations. Examples include generating device-specific initialization routines and validating component interactions.",
      "description_length": 438,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Arithmetic",
      "description": "Handles variant types by enabling extraction of names, ranks, and descriptions, along with custom transformations, folds, and iterations. Provides pattern matching and structured data extraction capabilities. Users can manipulate variant instances with user-defined functions, such as converting variant data into structured records or aggregating values across instances. Example tasks include flattening nested variants or generating descriptive summaries based on variant tags.",
      "description_length": 480,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Blockram",
      "description": "Processes and transforms variant types representing hardware resources, enabling operations like folding, iteration, mapping, and matcher generation. It works with a custom type `t` and associated metadata such as names and ranks. This allows for configuration code generation, resource validation, and diagnostic information extraction. For example, it can map resource values to new representations or fold over variants to accumulate usage statistics.",
      "description_length": 454,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Clb",
      "description": "Processes variant types representing hardware primitives, enabling operations like mapping, iteration, and folding over specific tags such as latch, carry, and lut. Supports custom variants with metadata including names and integer ranks, facilitating hardware description generation and circuit analysis. Allows tag-specific transformations and structured data manipulation. Examples include extracting all luts from a design or reordering elements based on rank.",
      "description_length": 464,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Clock",
      "description": "Processes and transforms a custom variant type `t` with metadata, enabling operations like folding, iteration, and mapping over specific cases. Supports generating ranked identifiers or custom match handlers from variant data. Allows selective manipulation of variant branches while preserving associated metadata. Can convert variants into structured formats or apply case-specific transformations.",
      "description_length": 399,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Configuration",
      "description": "Encapsulates variant-specific configuration data, enabling traversal and transformation of hardware-related types like BSCAN, DNA, and EFUSE through iteration, folding, and mapping. Supports custom variant types with metadata such as names and ranks, allowing for structured data manipulation. Operations include generating detailed lists, applying side effects, and modifying configuration data during setup processes. Examples include extracting ranked variant names or applying conditional transformations based on metadata.",
      "description_length": 527,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Io",
      "description": "Processes hardware variant configurations through custom types representing components and their attributes, enabling metadata generation, transformation pipelines, and configuration traversal. Supports signal buffer adjustments, timing control modifications, and interface protocol validation. Can generate detailed hardware descriptions or modify existing configurations for synthesis. Examples include adjusting buffer depths, validating timing constraints, and converting protocol formats.",
      "description_length": 493,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Register",
      "description": "handles variant types such as sdr, metastability, ddr, and latch by enabling extraction, transformation, and analysis through mapping, iteration, and folding. it supports converting variants to names, ranks, and tuples, allowing detailed configuration manipulation. users can apply custom functions to process specific variant cases within structured data. for example, it can extract all ddr instances from a configuration and generate a ranked list of their properties.",
      "description_length": 471,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Variants",
      "description": "Provides functions to transform and process lists of specialized hardware components, including advanced logic, arithmetic units, block RAM, CLB structures, clocks, configurations, and I/O modules. Offers mapping, iteration, and folding over these components, along with utilities to extract identifiers, ranks, and descriptive metadata. Enables structured manipulation of hardware variant data for synthesis and analysis workflows.",
      "description_length": 432,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.Command_flags",
      "description": "Provides functions to manage and retrieve command-line flag configurations, including a default set of flags and a parameterized flag structure. Works with a custom type representing flag settings and a Core.Command.Param.t structure for parsing. Used to define and parse command-line options in CLI tools with specific behavioral defaults.",
      "description_length": 340,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface",
      "description": "Converts interface values to S-expressions, validates port widths, and packs/unpacks interfaces into vectors. Supports multiplexing, concatenation, and selection operations on interface data. Accepts integer constants and derives bit widths for each field.",
      "description_length": 256,
      "index": 77,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Project.Config",
      "description": "Provides functions to serialize configuration data into S-expressions and retrieve a default configuration instance. Works with a record type containing project-specific settings. Used to generate human-readable configuration dumps and initialize settings with fallback values.",
      "description_length": 277,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Report.Subgroup",
      "description": "Provides operations to convert internal representations to S-expression format, enabling serialization and debugging. Works with a record type containing structured data elements. Used to generate human-readable logs and facilitate data exchange in parsing workflows.",
      "description_length": 267,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Report.Group",
      "description": "Provides operations to convert a structured data type into an S-expression format. Works with a record type containing fields for group identification and member lists. Used to serialize group data for logging or configuration output.",
      "description_length": 234,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Report.Clock",
      "description": "Provides operations to convert time representations into S-expression format. Works with a structured time type containing hours and minutes. Used to serialize clock states for logging or configuration purposes.",
      "description_length": 211,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Clock",
      "description": "Creates clocks with specified names, periods in nanoseconds, or frequencies in MHz, and optional BUFG source references. Operates on string-based clock names, floating-point periods and frequencies, and optional BUFG location constraints. Used to define clock properties for hardware synthesis tools to manage timing and skew.",
      "description_length": 326,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command",
      "description": "Manages command-line configuration and interface data manipulation, combining flag parsing with interface serialization and transformation. It handles custom flag types and Core.Command.Param.t for CLI options, and processes interface values as S-expressions with width validation and vector operations. Users can define CLI defaults, parse options, and manipulate interface data through packing, unpacking, and selection. Examples include generating synthesis commands with specified parameters and transforming interface structures for simulation or verification.",
      "description_length": 565,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group",
      "description": "Provides operations to extract a subgroup identifier from a structured data type and to determine if macro primitives should be ignored. Works with a custom type `t` representing grouped data. Used to filter and process specific subgroup configurations in parsing workflows.",
      "description_length": 274,
      "index": 84,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Project",
      "description": "Encapsulates project configuration management through a structured record type, enabling serialization to S-expressions and retrieval of default settings. Supports initialization with fallback values and generation of human-readable configuration outputs. Allows manipulation and inspection of project-specific parameters through defined operations. Example tasks include saving custom settings to a file and loading a baseline configuration for new projects.",
      "description_length": 459,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Report",
      "description": "Converts structured data, group information, and time values into S-expression format for serialization and logging. Operates on record types representing general data, group memberships, and time values with hours and minutes. Enables generation of human-readable logs and configuration outputs from internal representations. Can serialize group memberships, clock states, and arbitrary structured data for debugging or data exchange.",
      "description_length": 435,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers",
      "description": "Encapsulates and manages interface signals with precise bit-width control, enabling packing, unpacking, and manipulation of digital logic structures. Supports operations like multiplexing, concatenation, and selection using `comb` and `t` types, along with integer constants for initialization. Allows for priority and one-hot selection from interface lists, ensuring width consistency across signals. Can be used to generate accurate timing reports by wrapping circuits with registers, facilitating synthesis with detailed delay analysis.",
      "description_length": 539,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "hardcaml_xilinx_reports",
      "description": "Processes hierarchical Hardcaml designs by invoking Xilinx Vivado synthesis on individual modules, extracting resource utilization and timing data. Supports configuration to report statistics for a single module or its entire subtree. Enables detailed analysis of design performance and resource consumption at multiple levels of abstraction.",
      "description_length": 342,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports",
      "description": "Combines clock definition, CLI configuration, subgroup filtering, project management, data serialization, and interface signal handling into a unified workflow for hardware synthesis reporting. It supports clock period/frequency definitions, CLI flag parsing with S-expression interfaces, subgroup extraction, configuration serialization, data logging, and precise signal manipulation with bit-width control. Users can generate synthesis commands, filter design configurations, and serialize interface data for analysis. Examples include creating timing reports, transforming interface structures, and generating debug logs from structured design data.",
      "description_length": 652,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 94,
    "meaningful_modules": 90,
    "filtered_empty_modules": 4,
    "retention_rate": 0.9574468085106383
  },
  "statistics": {
    "max_description_length": 677,
    "min_description_length": 211,
    "avg_description_length": 381.1111111111111,
    "embedding_file_size_mb": 0.3273162841796875
  }
}