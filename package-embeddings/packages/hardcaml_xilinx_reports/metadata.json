{
  "package": "hardcaml_xilinx_reports",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 40,
  "creation_timestamp": "2025-08-15T14:11:27.245388",
  "modules": [
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.All",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides a function `all` that transforms a wrapped interface of monadic values into a monadic interface of combined values, preserving clocking information. It operates on data structures of type `'a M.t I_with_clock.t`, where `I_with_clock` represents an interface with associated clock signals, and `M` is a monadic structure. A concrete use case is aggregating multiple register-wrapped circuit components into a single synchronized interface, enabling accurate timing analysis in synthesis reports.",
      "description_length": 515,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Make_comb",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides combinational logic operations for wrapping circuit interfaces with clocked registers, including packing/unpacking signals, multiplexing, concatenation, and selection functions. It works with typed interfaces (`I_with_clock.t`) and vector representations of those interfaces. Concrete use cases include constructing and validating register-wrapped hardware designs for synthesis reporting, enabling precise timing analysis through structured signal manipulation and constant initialization.",
      "description_length": 511,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Names_and_widths",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines the interface for a circuit wrapped with input and output registers, specifying port names, widths, and associated tags for clocked signals. It provides direct access to lists of port names, widths, and tags, enabling precise configuration of register-wrapped circuits for synthesis reporting. Concrete use cases include generating accurate timing reports in Vivado by ensuring input and output delays are accounted for through registered ports.",
      "description_length": 465,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx_reports",
      "description": "This module maps clocked interface values to and from association lists keyed by port names. It supports converting structured hardware interfaces into string-indexed lists of values and reconstructing interfaces from such lists. Use this when serializing or dynamically constructing clocked hardware interfaces by name, such as when integrating with external tooling or report generation.",
      "description_length": 389,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Of_always",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides functions to work with clocked interfaces using the Always API, enabling the creation and manipulation of register and wire variables within always blocks. It operates on `I_with_clock.t` interfaces, supporting operations like assigning signals, creating registers with optional enable, and applying naming conventions to interface fields. Concrete use cases include building synchronous logic for FPGA designs with precise timing control, such as pipelined data paths or state machines with registered inputs and outputs.",
      "description_length": 543,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Of_signal",
      "library": "hardcaml_xilinx_reports",
      "description": "This module enables the construction and manipulation of registered hardware interfaces for Xilinx synthesis reporting, focusing on operations like register insertion (`reg`, `pipeline`), signal routing (`assign`, `wires`), multiplexing (`mux`, `priority_select`), and width validation. It operates on signal interfaces, input/output ports, and named signal groups, supporting hierarchical design assembly with precise timing constraints. Key use cases include generating synthesis reports with accurate input/output delay modeling and validating register-connected interfaces in pipelined or timed circuits.",
      "description_length": 608,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock.Of_bits",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides operations to manipulate structured hardware interfaces with clock signals, where each field is represented as a bit vector. It supports construction from integers, packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection operations with validity signals. These functions enable precise control over hardware signal transformations in synthesis workflows, particularly for generating accurate timing reports with registered input/output ports.",
      "description_length": 489,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Clb.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines and operates on variants of CLB (Configurable Logic Block) primitives in Xilinx Vivado Ultrascale designs, such as LUTs, carry chains, SRLs, and multiplexers. It provides functions to fold, iterate, map, and match over these variants, enabling detailed inspection and aggregation of CLB utilization data. These operations are used to extract counts, ranks, and names of specific CLB components directly from synthesis reports.",
      "description_length": 446,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make.I_with_clock",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides operations to manipulate structured clocked hardware interfaces by tag or port name, supporting transformations like mapping, zipping, and folding over port configurations. It works with clocked interface values (`I_with_clock.t`), enabling dynamic construction, serialization, and analysis of port metadata (names, widths, timing tags) while integrating unsafe name-based association for flexibility. These capabilities are specifically used to prepare FPGA designs for Vivado synthesis reporting, ensuring accurate timing analysis of input/output delays and register-wrapped circuits in hierarchical designs.",
      "description_length": 631,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Configuration.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines variant configurations for Xilinx primitive groups used in Vivado synthesis reports. It provides operations to fold, iterate, map, and construct matcher functions over these variants, enabling structured processing of configuration-specific data. Use cases include filtering and aggregating utilization metrics for FPGA primitives like BSCAN, DNA, and Block RAM during post-synthesis analysis.",
      "description_length": 413,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Register.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines variants of register primitives used in Xilinx Vivado synthesis reports, including SDR, metastability, DDR, and latch. It provides operations to fold, iterate, map, and match over these variants to compute utilization metrics or extract register properties. These functions enable precise querying and analysis of register usage in synthesized hardware designs.",
      "description_length": 381,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Arithmetic.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines variants of arithmetic primitives used in Xilinx Vivado Ultrascale designs, specifically targeting DSP elements. It provides operations to fold, iterate, and map over these variants, enabling precise analysis and categorization of arithmetic components in synthesis reports. Use cases include extracting utilization metrics and generating structured reports based on arithmetic cell properties.",
      "description_length": 414,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Io.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines variant types representing different IO primitive groups in Xilinx Vivado Ultrascale designs, such as input/output buffers, serdes, and latches. It provides operations to fold, iterate, map, and match over these variants, enabling structured processing of IO-related utilization data. These functions support concrete tasks like reporting, ranking, and filtering IO elements based on their type and properties.",
      "description_length": 430,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Advanced.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines variant types and operations for handling advanced Xilinx primitive groups in Vivado synthesis reports. It provides functions to fold, iterate, map, and match over variants like `mac`, `gt`, `interlaken`, `pcie`, and `sysmon`, each representing a specific hardware primitive category. These operations enable querying and transforming utilization data based on primitive type, supporting concrete tasks like filtering cells by property or aggregating resource counts.",
      "description_length": 487,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Blockram.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines and processes variants of block RAM primitives (FIFO, BRAM, URAM) for Xilinx Vivado Ultrascale designs. It provides operations to fold, iterate, map, and match over these variants, enabling precise extraction and aggregation of utilization data from synthesis reports. Functions like `to_rank` and `to_name` support reporting and analysis by converting block RAM types into comparable metrics and identifiers.",
      "description_length": 429,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Clock.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines clock primitive variants used in Xilinx Vivado Ultrascale utilization analysis, including buffer, mux, and pll. It provides operations to fold, iterate, map, and match over these variants, enabling precise extraction and transformation of clock-related utilization data. These functions are used to analyze and report clock resource usage in synthesized hardware designs.",
      "description_length": 391,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make_sequential",
      "library": "hardcaml_xilinx_reports",
      "description": "Wraps circuit interfaces with registers to enable accurate synthesis timing reports, including input and output delays. Works with Hardcaml interfaces defined by modules I and O, and supports hierarchical design instantiation. Used to structure designs for Vivado synthesis with precise timing analysis in blackbox=none and hier=true flows.",
      "description_length": 340,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Report.Clock",
      "library": "hardcaml_xilinx_reports",
      "description": "Handles parsing and representation of clock timing data from Vivado synthesis reports. Works with clock constraint data including setup and hold times. Used to analyze and report clock domain timing requirements and violations.",
      "description_length": 227,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Clock",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines clock primitive types\u2014`Buffer`, `Mux`, and `Pll`\u2014used in Xilinx Vivado Ultrascale utilization analysis. It provides direct access to each primitive variant, predicates to identify them, and functions to extract subgroup names and filter macro primitives. These primitives are used to analyze clock resource usage in synthesized hardware designs by filtering cells based on specific clock-related properties.",
      "description_length": 427,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.With_interface",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides functions to generate and execute Vivado synthesis commands for a Hardcaml design with specified input and output interfaces. It supports creating a command line interface, running synthesis asynchronously, and generating reports with optional sorting and primitive grouping. Concrete use cases include automating synthesis timing and utilization analysis for FPGA designs directly from OCaml code.",
      "description_length": 419,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Configuration",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides operations for extracting and categorizing configuration properties of Xilinx FPGA primitives, such as BSCAN, DNA, and Block RAM, by analyzing Vivado synthesis data. It works with a variant type representing configuration options and exposes functions to inspect values like ECC settings or ICAP modes, enabling filtering of hardware primitives during post-synthesis analysis. These utilities are particularly useful for quantifying utilization metrics or validating design constraints in Ultrascale FPGAs.",
      "description_length": 527,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Clb",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides type-safe enumeration and inspection of Xilinx Configurable Logic Block (CLB) primitives such as LUTs, carry chains, and multiplexers, enabling precise categorization and filtering of synthesis report data. It defines operations to test membership in specific CLB subgroups, extract SRL values, and ignore macro primitives, facilitating detailed utilization analysis of Vivado Ultrascale designs. These capabilities are used to quantify resource usage by identifying and counting relevant cell types in synthesis timing reports.",
      "description_length": 549,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Advanced",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines types and operations for handling specialized Xilinx hardware primitives like DSP blocks (mac), gigabit transceivers (gt), and PCIe interfaces in synthesis reports. It provides variant-aware queries to filter and analyze utilization metrics for these advanced components, along with configuration checks to exclude macro primitives during report processing. These capabilities support detailed hardware characterization and optimization in FPGA design flows.",
      "description_length": 478,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Register",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines register primitive subgroups for Xilinx Vivado synthesis reports, including SDR, metastability, DDR, and latch. It provides functions to check and extract register types, determine subgroups, and filter macro primitives for accurate utilization analysis. These operations support precise querying of register properties in synthesized hardware designs.",
      "description_length": 372,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Io",
      "library": "hardcaml_xilinx_reports",
      "description": "This module provides operations to identify and categorize Xilinx Vivado Ultrascale I/O primitives such as input/output buffers, serdes, and delay elements, using type predicates and property accessors. It works with the `t` type to filter and extract utilization data from synthesis reports, focusing on I/O-related cell properties. Specific use cases include analyzing metastability handling, DDR/SDR configurations, and macro primitive exclusion in FPGA resource utilization reports.",
      "description_length": 486,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Variants",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines variant types representing different categories of Xilinx Vivado Ultrascale primitives such as CLBs, registers, and block RAMs. It provides operations to construct, fold, iterate, and map over these variants, enabling detailed inspection and aggregation of synthesis utilization data. These functions are used to extract and process specific primitive groups from Vivado reports, supporting precise resource usage analysis for hardware designs.",
      "description_length": 464,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Report.Subgroup",
      "library": "hardcaml_xilinx_reports",
      "description": "Handles subgroups of synthesis report data, providing structured access to named integer values. Works with strings and integers to represent categorized metrics like timing or utilization. Used to extract and analyze specific performance data from Xilinx Vivado synthesis reports.",
      "description_length": 281,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Blockram",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines block RAM primitive types (FIFO, BRAM, URAM) used in Xilinx Vivado Ultrascale designs and provides direct access to their variants, properties, and subgroup classifications. It includes functions to identify and filter these primitives based on utilization data extracted from synthesis reports. Specific use cases include querying block RAM counts and types in a design for resource estimation and optimization.",
      "description_length": 432,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers.Make",
      "library": "hardcaml_xilinx_reports",
      "description": "This module wraps hardware interfaces with clocked registers to enable accurate timing analysis in Vivado synthesis reports. It supports both combinational and sequential circuit instantiations, allowing hierarchical composition with explicit name-based scoping. Use cases include generating timing-critical FPGA designs with registered I/O ports and analyzing input/output delays in hierarchical modules.",
      "description_length": 405,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group.Arithmetic",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines arithmetic primitive groups for Xilinx Vivado Ultrascale designs, specifically targeting DSP elements. It provides operations to categorize and analyze arithmetic components in synthesis reports, including checks for DSP elements and extraction of associated properties. Use cases include filtering cells by arithmetic type and computing utilization metrics based on their presence in a design.",
      "description_length": 414,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Project.Config",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines configuration options for generating Vivado synthesis reports, including flags to enable timing and utilization reports, control retiming, and specify blackbox behavior. It works with data types such as boolean flags, optional values, and lists of primitive groups to customize report generation and synthesis behavior. Concrete use cases include configuring whether to generate detailed utilization reports, enabling retiming for timing optimization, and specifying which design elements to include in the report through primitive groups.",
      "description_length": 559,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command.Command_flags",
      "library": "hardcaml_xilinx_reports",
      "description": "Handles command-line flags for configuring synthesis runs, including options for output paths, part names, clock configurations, and control over synthesis stages like placement, routing, and optimization. Works with strings, booleans, lists, and options to define Vivado execution parameters. Used to construct and customize command lines for generating synthesis reports with specific design constraints and logging settings.",
      "description_length": 427,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Report.Group",
      "library": "hardcaml_xilinx_reports",
      "description": "Handles hierarchical grouping of synthesis report data, providing functions to access and manipulate nested subgroups. Works with strings for group names, integers for values, and lists of subgroups. Used to organize and extract structured utilization or timing data from Vivado synthesis reports.",
      "description_length": 297,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Project",
      "library": "hardcaml_xilinx_reports",
      "description": "This module generates and executes Vivado synthesis projects for hardware designs, producing timing and utilization reports. It works with circuits, clock configurations, and FPGA part specifications to create project files and run synthesis, optionally including placement and routing. Concrete use cases include generating synthesis reports for specific FPGA parts, running timing analysis on a design with defined clocks, and exporting the resulting artifacts to a specified output directory.",
      "description_length": 495,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Primitive_group",
      "library": "hardcaml_xilinx_reports",
      "description": "This module organizes Xilinx Vivado Ultrascale hardware components into hierarchical groups like CLBs, registers, block RAM, and arithmetic units, enabling precise resource categorization. It provides predicates and filtering operations to analyze cell properties in synthesis reports, focusing on FPGA utilization metrics such as counting instances of specific primitives. Key applications include quantifying logic blocks, memory elements, and I/O resources in a design for performance and area optimization.",
      "description_length": 510,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Report",
      "library": "hardcaml_xilinx_reports",
      "description": "Reads and processes Xilinx Vivado synthesis reports into structured data for analysis. It parses report files into a list of hierarchical groups and clock timing data, enabling extraction of utilization and timing metrics. Used to generate hierarchical utilization and timing tables by correlating circuit data with synthesis results.",
      "description_length": 334,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Clock",
      "library": "hardcaml_xilinx_reports",
      "description": "This module defines clock parameters for a top-level design, including the clock net name, period, and optional BUFG location constraint. It provides functions to create clocks using either a period in nanoseconds or a frequency in MHz, and to access clock properties. It is used to specify clock inputs for accurate synthesis timing analysis in Xilinx Vivado.",
      "description_length": 360,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Command",
      "library": "hardcaml_xilinx_reports",
      "description": "Constructs and executes command lines for synthesizing Hardcaml circuits using Vivado, generating timing and utilization reports. Accepts circuit definitions along with synthesis flags and primitive groups to customize report generation. Directly supports running synthesis flows with configurable output paths, part names, and clock constraints.",
      "description_length": 346,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports.Wrap_with_registers",
      "library": "hardcaml_xilinx_reports",
      "description": "This module wraps the input and output ports of a circuit with registers to enable accurate timing analysis in synthesis reports. It works with Hardcaml circuit descriptions and is used in conjunction with Vivado synthesis to capture input and output delays in timing paths. A concrete use case is preparing a design for synthesis reporting where register insertion is required at the boundaries to measure end-to-end timing performance.",
      "description_length": 437,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx_reports",
      "library": "hardcaml_xilinx_reports",
      "description": "This module automates the generation of synthesis timing and utilization reports for Hardcaml circuits using Xilinx Vivado. It provides structured data parsing from synthesis reports, clock constraint specification, and command-line synthesis execution. Concrete use cases include analyzing FPGA resource usage by primitive type, measuring critical path delays, and preparing designs with registered I/O for accurate timing analysis.",
      "description_length": 433,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 40,
    "meaningful_modules": 40,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 631,
    "min_description_length": 227,
    "avg_description_length": 439.025,
    "embedding_file_size_mb": 0.5800237655639648
  }
}