{
  "package": "yocaml",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 47,
  "creation_timestamp": "2025-08-15T14:43:20.201903",
  "modules": [
    {
      "module_path": "Yocaml.Make.Data_reader.Pipeline",
      "library": "yocaml",
      "description": "Reads files and parses their metadata using a data provider, supporting customizable extraction strategies. Works with data types that implement the `DATA_READABLE` signature and file paths represented by `Yocaml.Path.t`. Useful for extracting structured metadata from files during static site generation or data processing tasks.",
      "description_length": 330,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Make.Data_reader.Eff",
      "library": "yocaml",
      "description": "Implements file metadata reading operations for data providers, handling both metadata extraction and content parsing. Works with `Yocaml.Path.t` paths and metadata types conforming to `Yocaml.Required.DATA_READABLE`. Useful for loading structured metadata from files during site generation, such as parsing YAML front matter or configuration files.",
      "description_length": 349,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Archetype.Datetime.Infix",
      "library": "yocaml",
      "description": "This module defines standard comparison operators (`=`, `<>`, `>`, `>=`, `<`, `<=`) for comparing `Yocaml.Archetype.Datetime.t` values. It enables direct, readable date comparisons in blog-related logic, such as filtering posts by publication date or sorting entries chronologically. These operators simplify conditional checks and ordering operations on datetime values within blog processing pipelines.",
      "description_length": 404,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Data.Validation.Syntax",
      "library": "yocaml",
      "description": "This module provides binding operators to compose and sequence validation steps over data structures represented as `Yocaml.Data.t`. It supports building complex, nested validations by linking field validations together, enabling transformations from validated AST nodes into typed OCaml values. Concrete use cases include validating configuration files or structured metadata inputs where correctness is enforced through combinators that accumulate or short-circuit on errors.",
      "description_length": 477,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Data.Validation.Infix",
      "library": "yocaml",
      "description": "This module provides infix operators to compose and combine data validation functions that transform values of type `Yocaml.Data.t` into validated OCaml values. It supports sequential validation composition, fallback validation, and post-processing of validated values using familiar operator syntax. Concrete use cases include chaining checks like parsing an integer followed by a range validation, or providing alternative parsing strategies for optional data fields.",
      "description_length": 469,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Eff.Syntax",
      "library": "yocaml",
      "description": "This module provides monadic and applicative operators for composing effectful computations in an IO monad. It works with values wrapped in the `Yocaml.Eff.t` type, enabling sequential binding and transformation of effectful results. Concrete use cases include chaining file I/O operations, handling side effects in a controlled manner, and structuring programs that require effect interpretation at runtime.",
      "description_length": 408,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Data.Validation",
      "library": "yocaml",
      "description": "This module provides combinators to validate and transform generic AST values into typed OCaml data, supporting structured types like lists, records, pairs, and sums. It enables type checking (bool, int, string), value constraints (positive, bounded), and compositional pipelines with infix operators for error handling and nested data validation, commonly used to enforce metadata schemas from source documents or convert AST nodes into OCaml values with precise error reporting.",
      "description_length": 480,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Reader.Over",
      "library": "yocaml",
      "description": "This module implements a monadic reader structure that allows functions to access a shared environment of type `T.env`. It provides `return` to wrap values in the monad and `bind` to sequence computations that depend on the environment. Concrete use cases include managing configuration or context during file processing or static site generation.",
      "description_length": 347,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Archetype.Articles",
      "library": "yocaml",
      "description": "Transforms pages into article indexes by injecting and organizing article metadata. It processes directories of articles, sorts them by date, and generates index pages with customizable URL routing. Designed for blog archives or content listings where articles are stored as files with associated metadata.",
      "description_length": 306,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Action.Dynamic",
      "library": "yocaml",
      "description": "Handles file generation tasks with dynamic dependencies by writing content produced from a task to a specified path. It works with `Path.t` for file locations and `Task.t` that yields content along with dependency metadata. Useful for building files whose content and dependencies are determined at runtime, such as compiling templates or generating documentation.",
      "description_length": 364,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Eff.List",
      "library": "yocaml",
      "description": "This module provides effect-aware list operations such as `traverse`, `sequence`, `filter_map`, and `fold_left`, enabling composition of effectful computations over lists. It works with lists of values wrapped in an effect type `Yocaml.Eff.t`, allowing sequential evaluation and transformation of effectful elements. Concrete use cases include processing lists of I/O-bound values, applying effectful filters or transformations, and accumulating results from effectful operations.",
      "description_length": 480,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Archetype.Article",
      "library": "yocaml",
      "description": "This module defines a structured model for blog articles with required metadata including title, synopsis, and date. It provides functions to access and modify article properties, as well as to parse, validate, and normalize article data from raw inputs. Use cases include building blog-aware pages with consistent metadata handling and injecting article content into templates.",
      "description_length": 378,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Archetype.Datetime",
      "library": "yocaml",
      "description": "This module offers operations to create, validate, compare, and format datetime values with a focus on blog metadata workflows. It centers on a structured type `t` representing dates and times as typed components (year, month, day, etc.), supporting normalization to standard formats like `yyyy-mm-dd HH:mm-ss` and RFC822/RFC3339. Key use cases include chronological sorting of blog posts, validating timestamp inputs, and generating machine-readable date strings for feeds or headers.",
      "description_length": 485,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Runtime.Make",
      "library": "yocaml",
      "description": "Implements the execution of YOCaml programs by interpreting effects within a provided runtime context. Works with functions producing effectful values and handles custom error formatting during execution. Useful for running YOCaml pipelines that interact with external systems like file systems or version control.",
      "description_length": 314,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Archetype.Page",
      "library": "yocaml",
      "description": "This module defines a structured model for HTML pages with metadata such as title, charset, description, and tags. It supports parsing, validation, and injection of page data, enabling generation of HTML content with proper metadata. Concrete use cases include building blog posts or documentation pages with customizable SEO fields and table-of-contents handling.",
      "description_length": 364,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Task.Static",
      "library": "yocaml",
      "description": "This module provides functions to manipulate tasks by focusing on either metadata or content independently. It supports operations like lifting a task to act solely on content or metadata, discarding metadata, and attaching an empty body to a task. These utilities are useful when processing static content transformations where dependencies are not dynamically determined.",
      "description_length": 373,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Task.Syntax",
      "library": "yocaml",
      "description": "This module provides syntactic operators for composing task values, enabling sequential and parallel task execution through `let+` and `and+`. It works with task values of type `'a Yocaml.Task.ct`, which represent effectful computations. Concrete use cases include chaining file generation steps and combining independent build tasks in a declarative manner.",
      "description_length": 358,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Sexp.Canonical",
      "library": "yocaml",
      "description": "This module handles the canonical serialization and deserialization of S-expressions in the Csexp format. It operates directly on `Yocaml.Sexp.t` values, providing functions to convert between S-expressions and strings or character sequences, as well as measure and output their serialized form. It is used for efficiently reading and writing compact, standardized representations of structured data, particularly when interfacing with external systems or persisting configuration and data files.",
      "description_length": 496,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Task.Infix",
      "library": "yocaml",
      "description": "This module provides infix operators for composing and sequencing effectful computations represented as task values, enabling idiomatic syntax for dependency management, branching logic, and parallel execution. It works with first-class functions and task-wrapped values, supporting applicative-style application of transformations across success/failure outcomes using Either types. These operators simplify common patterns like chaining dependent steps, merging independent tasks, and handling partial failures in data processing pipelines or build system workflows.",
      "description_length": 568,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Path.Map",
      "library": "yocaml",
      "description": "This module provides specialized map operations for associating file paths with arbitrary values, supporting ordered key traversal, structural manipulation, and sequence-based conversions. It works with maps where keys are abstract path descriptions and values can be any type, offering ordered search, filtered transformations, and ordered sequence integration. Specific use cases include aggregating path-bound data (e.g., file metadata), merging hierarchical configurations, and processing directory structures in deterministic order.",
      "description_length": 537,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Make.Runtime",
      "library": "yocaml",
      "description": "This module provides the `run` function to execute a YOCaml program within a specific runtime context, interpreting its effects and handling custom errors through an optional formatter. It operates on units of computation wrapped in `Yocaml.Eff.t` and is used to bootstrap a YOCaml application using runtime implementations like Unix or Git. Concrete use cases include launching static site generators or configuration management tools by interpreting effectful descriptions into real-world actions.",
      "description_length": 499,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Action.Static",
      "library": "yocaml",
      "description": "Handles writing static files to disk by executing tasks that produce string content, using paths to specify destinations. Works with `Yocaml.Path.t` for file locations and `Yocaml.Task.t` that yield either strings or tuples of metadata and strings. Useful for generating output files like HTML pages or configuration files from static data or templates.",
      "description_length": 353,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Path.Infix",
      "library": "yocaml",
      "description": "This module defines infix operators for constructing and manipulating file system paths using fragments. It supports appending multiple fragments to a path with `++`, adding a single fragment with `/`, and creating relative paths from a list of fragments with `~/`. These operations facilitate concise path composition in YOCaml programs, particularly when building complex paths incrementally or expressing directory structures dynamically.",
      "description_length": 441,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Sexp.Provider",
      "library": "yocaml",
      "description": "This module parses S-expressions from strings into a structured format and converts them into a normalized data representation. It operates on S-expressions and transforms them into a generic data type used elsewhere in the framework. It is used to process configuration or input files written in S-expression syntax, enabling further manipulation and interpretation within the system.",
      "description_length": 385,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Task.Dynamic",
      "library": "yocaml",
      "description": "This module provides functions to manipulate tasks by transforming their content, metadata, or dependencies independently. It supports operations like lifting tasks to act solely on content, metadata, or dependencies, and modifying task structure by dropping metadata or attaching an empty body. These functions are used to build and refine tasks that handle dynamic dependencies during execution.",
      "description_length": 397,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Make.Data_reader",
      "library": "yocaml",
      "description": "Reads structured metadata from files using a data provider, supporting customizable parsing strategies. Works with `Yocaml.Path.t` paths and data types implementing `DATA_READABLE`, such as YAML or JSON front matter. Useful for extracting metadata during static site generation or data processing workflows.",
      "description_length": 307,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Markup.Toc",
      "library": "yocaml",
      "description": "This module builds and transforms hierarchical table of contents structures from indexed content, such as document headings. It supports converting flat lists into nested trees, labeling nodes with positional indices, and generating HTML output for structured navigation. Concrete use cases include rendering Markdown document TOCs with clickable links and nested lists.",
      "description_length": 370,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Eff.Infix",
      "library": "yocaml",
      "description": "This module defines infix operators for working with effectful computations in an IO monad, providing map, apply, bind, and composition operations. It handles values wrapped in `Yocaml.Eff.t` and supports chaining and transforming effectful functions, particularly for handling effects in a structured way. Concrete use cases include sequencing file I/O operations, composing effectful parsers, and building pipelines that handle errors and side effects in a controlled manner.",
      "description_length": 477,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Required",
      "library": "yocaml",
      "description": "This module defines core abstractions for data handling and execution contexts in a YOCaml program. It includes interfaces for data providers, readers, and templates, along with error types for metadata validation and parsing failures. These components enable structured processing of configuration and content during static site generation workflows.",
      "description_length": 351,
      "index": 28,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Nel",
      "library": "yocaml",
      "description": "This module provides safe construction, transformation, and traversal operations for non-empty lists, ensuring at least one element is always present. It supports structural manipulations like reversal, concatenation, and indexed mapping, along with folds and equality checks tailored for non-empty sequences. Designed for use cases requiring guaranteed populated data, such as error aggregation or validated collections, it maintains invariants while enabling efficient list processing.",
      "description_length": 487,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Runtime",
      "library": "yocaml",
      "description": "The module implements execution of YOCaml programs by interpreting effectful computations within a runtime context. It works with functions that produce values wrapped in effect types, handling custom error formatting and interaction with external systems. Concrete use cases include running pipelines that read from or write to the file system, or manage version-controlled data through Git.",
      "description_length": 392,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Eff",
      "library": "yocaml",
      "description": "This module provides monadic and applicative operations for composing effectful computations, emphasizing structured handling of impure operations like file system manipulation, process execution, and error propagation. It works with an IO monad type (`t`) that wraps values, enabling effect tracking and runtime interpretation through handlers, while operating on data such as paths, strings, and metadata. Its design supports use cases requiring controlled side effects, including static site generation or build systems, where runtime specialization and effect auditing are critical.",
      "description_length": 586,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Archetype",
      "library": "yocaml",
      "description": "This module provides structured models and utilities for building blog-aware content pipelines. It includes components for handling datetime values with validation and formatting, and defines models for pages, articles, and article indexes with support for metadata parsing, injection, and organization. Concrete use cases include generating SEO-friendly blog posts, managing article archives with date-based sorting, and creating templated content from structured inputs.",
      "description_length": 472,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Reader",
      "library": "yocaml",
      "description": "This module implements a reader monad for computations that require access to a shared environment of type `T.env`. It provides `return` to wrap values and `bind` to chain environment-dependent operations, enabling context-aware processing of files or configuration-driven workflows. Concrete use cases include static site generation where templates or build steps depend on shared configuration data.",
      "description_length": 401,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Deps",
      "library": "yocaml",
      "description": "This module manages sets of file dependencies using a monoid structure, supporting operations like union, reduction, and construction from lists. It works with file paths to track dependencies and provides functions to retrieve modification times, serialize, and deserialize dependency sets. Concrete use cases include building dependency graphs for artifacts and checking file modification dates to determine rebuild requirements.",
      "description_length": 431,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Task",
      "library": "yocaml",
      "description": "This module provides abstractions for constructing and composing effectful computations with explicit dependencies, enabling workflows that model tasks as first-class values. It operates on task structures (`t` and `ct` types) that encapsulate dependencies, effects, and dynamic/static relationship flags, supporting functional transformations like mapping, branching on `Either` values, and parallel composition. Designed for scenarios requiring precise dependency tracking and task orchestration\u2014such as build systems, pipeline processing, or declarative workflows\u2014it combines applicative and arrow-like patterns to model complex execution graphs with both sequential and concurrent semantics.",
      "description_length": 695,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Metadata",
      "library": "yocaml",
      "description": "This module validates and extracts metadata from documents using customizable strategies. It processes strings with delimiters or custom parsers, returning validated metadata and cleaned content. Use it to handle front-matter in markup files or structured data headers.",
      "description_length": 269,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Cmd",
      "library": "yocaml",
      "description": "This module enables constructing and manipulating shell commands with precise control over arguments, flags, and parameters, using typed representations like `t`, `arg`, and `value`. It operates on strings, numerical values, filesystem paths, and lists to model command-line interfaces, supporting cross-platform execution by normalizing commands into executable pairs. Typical applications include building dynamic CLI workflows, managing dependencies for build systems, or generating platform-agnostic shell scripts.",
      "description_length": 518,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Slug",
      "library": "yocaml",
      "description": "This module generates and validates slugs for URLs using a fixed, opinionated strategy. It operates on strings, applying character replacements and separators to produce URL-friendly identifiers. Typical use includes converting blog post titles into path components for static site generation.",
      "description_length": 293,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Diagnostic",
      "library": "yocaml",
      "description": "This module provides functions to convert exceptions and runtime errors into human-readable diagnostic messages. It works with exceptions and custom error types defined in `Yocaml.Data.Validation`, formatting them using OCaml's `Format` module. Concrete use cases include displaying structured error messages during site generation or configuration validation failures.",
      "description_length": 369,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Action",
      "library": "yocaml",
      "description": "This module defines actions that manipulate a build cache to generate or update artifacts during a YOCaml pipeline. It provides operations for writing static and dynamic files, copying files or directories, executing shell commands, and iterating over file collections or lists with stateful transformations. These functions work directly with paths, tasks producing content or dependencies, and the cache structure to manage build outputs and dependencies.",
      "description_length": 457,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Sexp",
      "library": "yocaml",
      "description": "This module implements S-expression parsing, serialization, and manipulation with support for atoms and nested nodes. It provides functions to convert S-expressions to and from strings or character sequences, handle parsing errors, and compare or pretty-print structured data. It is used to process configuration files, exchange structured data with external systems, and build domain-specific languages using nested symbolic expressions.",
      "description_length": 438,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Markup",
      "library": "yocaml",
      "description": "This module provides functions for parsing, transforming, and generating structured markup content, particularly supporting formats like Markdown. It includes operations for building and manipulating hierarchical document structures, such as converting heading lists into nested trees and generating HTML navigation elements. Concrete use cases include constructing document tables of contents with labeled sections and clickable links from Markdown input.",
      "description_length": 456,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Make",
      "library": "yocaml",
      "description": "This module provides functors to build specialized modules for handling file transformations and data processing pipelines. It works with file paths, metadata structures, and effectful computations described in `Yocaml.Eff.t`. Concrete use cases include generating static websites from templates or converting configuration files between formats using declarative descriptions.",
      "description_length": 377,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml.Pipeline",
      "library": "yocaml",
      "description": "This module composes tasks for file processing, dependency tracking, and shell command execution. It handles paths, file contents, metadata, and shell outputs, enabling workflows like reading and combining files, validating metadata, and running commands with customizable success checks. Concrete uses include building static sites by processing templated files, checking file existence, and chaining command-line tools with tracked dependencies.",
      "description_length": 447,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Yocaml.Cache",
      "library": "yocaml",
      "description": "This module manages build artifact caching by tracking hashed content, dependencies, and timestamps for file paths. It supports creating, updating, and retrieving cache entries, as well as serializing and comparing cache states. Use it to avoid redundant builds by checking if source content and dependencies have changed since the last build.",
      "description_length": 343,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Yocaml",
      "library": "yocaml",
      "description": "This module provides core abstractions for static site generation, including task orchestration, dependency tracking, and effect handling. It works with file paths, metadata, non-empty lists, and cache structures to manage builds, execute shell commands, and process templated content. Concrete use cases include generating blog posts with validated metadata, building dependency-aware pipelines, and managing incremental builds via cached content hashes.",
      "description_length": 455,
      "index": 46,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 49,
    "meaningful_modules": 47,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9591836734693877
  },
  "statistics": {
    "max_description_length": 695,
    "min_description_length": 269,
    "avg_description_length": 420.27659574468083,
    "embedding_file_size_mb": 0.6815109252929688
  }
}