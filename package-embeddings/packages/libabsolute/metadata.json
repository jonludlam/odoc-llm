{
  "package": "libabsolute",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 36,
  "creation_timestamp": "2025-08-15T14:26:18.913054",
  "modules": [
    {
      "module_path": "Libabsolute.Domains.Product.Make",
      "library": "libabsolute",
      "description": "This module combines two abstract domains into a product structure, enabling operations like variable management, lattice joins/meets, constraint refinement, and expression evaluation over their combined state. It works with abstract elements (`t`) composed of two domains' representations (`A` and `B`) and internal constraint encodings, prioritizing exact filtering in domain `B` for compatible constraints. It is used to build hierarchical abstract interpreters where distinct domains specialize in different constraint classes, such as handling linear arithmetic in one domain and structural properties in another.",
      "description_length": 618,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libabsolute.Domains.Boolean.Make",
      "library": "libabsolute",
      "description": "This abstract domain specializes in boolean constraint manipulation, offering variable management, set-theoretic operations (union, intersection, difference), and conversion between concrete and abstract representations. It operates on boolean expressions lifted from numerical domains, using a structured type `t` to represent abstract elements. Key applications include constraint solving with boolean logic, integrating logical conditions into numerical domain analyses, and verifying systems with mixed data-type constraints.",
      "description_length": 529,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Domains.Utree.Make",
      "library": "libabsolute",
      "description": "This module enables manipulation of disjunctive abstract elements with optimized meet precomputation, offering variable management, join/meet operations, volume computation, constraint conversion, and concretization. It operates on abstract constraint environments (type `t`) and internal constraints (`internal_constr`), incorporating boolean expressions to enforce constraint consistency and representability. These capabilities are particularly useful for combining abstract domains and optimizing constraint-solving workflows where fast precomputed meets are critical.",
      "description_length": 572,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Domains.BoxS",
      "library": "libabsolute",
      "description": "This module provides operations for managing floating-point bounded boxes, including variable manipulation, domain combination via join/meet, constraint filtering, and arithmetic evaluation within constraint satisfaction problems. It works with variables, constraints, and box domains, supporting tasks like domain splitting, volume computation, and conversion between internal and external constraint representations. Specific use cases include numerical constraint solving and visualization through textual output or graphical rendering of box domains.",
      "description_length": 554,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libabsolute.Polynom.Int",
      "library": "libabsolute",
      "description": "This module enables symbolic manipulation of integer polynomials through arithmetic operations (addition, multiplication, scalar division, exponentiation) and structural transformations like normalization, linearity detection, and coefficient extraction. It operates on multivariate polynomials represented as lists of monomial cells, with internal term-level handling via a `cell` type, supporting precise algebraic analysis. These capabilities are critical for constraint solving and formal verification tasks requiring exact integer polynomial manipulations in abstract domains.",
      "description_length": 581,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Solver.Make",
      "library": "libabsolute",
      "description": "Implements constraint solving algorithms using an abstract domain to analyze and verify properties of constraint satisfaction problems. It provides concrete operations for computing solution space coverage, checking satisfiability, and generating witnesses for feasible solutions. Designed for use in program verification and formal methods where precise domain-specific analysis is required.",
      "description_length": 392,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libabsolute.Domains.Utree",
      "library": "libabsolute",
      "description": "This module implements disjunctive abstract elements with optimized meet precomputation, supporting operations such as variable management, join, meet, volume computation, constraint conversion, and concretization. It works with abstract constraint environments (`t`) and internal constraints (`internal_constr`), integrating boolean expressions for consistency and representability. It is used to combine abstract domains and optimize constraint-solving workflows where fast precomputed meets are critical.",
      "description_length": 507,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Domains.ApronBox",
      "library": "libabsolute",
      "description": "This implementation provides interval-based abstract interpretation operations for numerical constraint solving, including variable domain manipulation, constraint filtering, and domain transformations like join/meet. It works with abstract elements representing variable intervals (ApronBox.t) and supports visualization through formatted printing and graphical rendering. Useful for static analysis tasks like program verification, where precise variable range tracking and constraint interaction are required.",
      "description_length": 512,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Domains.Oct",
      "library": "libabsolute",
      "description": "This module provides numerical constraint analysis using the Octagon abstract domain, enabling operations like variable manipulation, constraint evaluation, and combinations of abstract elements through join/meet. It works with Octagon abstract elements, numerical variables, and constraint systems, supporting concretization and volume computation. Specific use cases include symbolic reasoning for program analysis and graphical visualization of abstract states via rendering or formatted output.",
      "description_length": 498,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libabsolute.Domains.Boolean",
      "library": "libabsolute",
      "description": "This module lifts numerical domains to boolean abstractions, enabling operations like union, intersection, and difference on boolean expressions derived from numerical constraints. It works with abstract elements of type `t` representing boolean conditions, supporting variable management and conversions between concrete and abstract forms. It is used for constraint solving with logical conditions, integrating boolean logic into numerical analyses, and verifying systems with mixed-type constraints.",
      "description_length": 502,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Tools.VarSet",
      "library": "libabsolute",
      "description": "This string-based set abstraction provides standard set algebra operations (union, intersection, difference), functional transformations (mapping, filtering, folding), and interconversion with lists and sequences for ordered processing. It operates on sets of string elements, supporting subset checks, membership queries, and bulk operations, making it suitable for managing variables in constraint systems or symbolic analysis workflows where precise set relationships and efficient traversal are critical.",
      "description_length": 508,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Polynom.Rational",
      "library": "libabsolute",
      "description": "This module enables symbolic manipulation of rational polynomials through operations like monomial property detection, arithmetic (addition, multiplication, exponentiation), term simplification, and normalization. It operates on polynomials represented as lists of coefficient-cell pairs, where cells encode variable-exponent combinations, supporting applications in algebraic simplification and constraint solving over abstract arithmetic domains.",
      "description_length": 448,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Domains.Product",
      "library": "libabsolute",
      "description": "This module implements a specialized reduced product of two abstract domains, where constraints are selectively filtered by one domain and propagated to the other based on exact solvability. It operates on pairs of abstract values from the combined domains, enabling precise constraint solving by leveraging the strengths of each domain. A typical use case involves combining a numerical domain with a symbolic one, where the symbolic domain handles complex constraints that the numerical domain cannot solve directly.",
      "description_length": 518,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Domains.Poly",
      "library": "libabsolute",
      "description": "This module implements polyhedral abstract domain operations for numerical constraint analysis, offering variable management, set-theoretic operations (union, intersection, exclusion), and constraint refinement through filtering. It operates on abstract elements representing convex polyhedra over numerical variables, enabling volume calculations, concretization checks, and abstraction validity verification. The module supports debugging and visualization workflows via textual formatting and graphical rendering of polyhedral constraints, particularly useful in program analysis and verification pipelines.",
      "description_length": 610,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Tools.VarMap",
      "library": "libabsolute",
      "description": "This module provides dictionary-like operations for managing polymorphic key-value pairs with string-derived keys, supporting standard manipulations (insertion, lookup, deletion) and advanced combinators for merging, filtering, and transforming maps. It emphasizes functional transformations through iteration, folding, and mapping, while enabling safe value extraction via optional returns and conversions to ordered sequences or lists. Typical applications include handling variable bindings in constraint systems, combining sparse data structures with merge strategies, and processing key-value collections without exception-based failure modes.",
      "description_length": 648,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Polynom.Float",
      "library": "libabsolute",
      "description": "This module provides arithmetic operations on multivariate polynomials with float-based coefficients, including addition, scalar multiplication, exponentiation, and normalization through term combination. It works with polynomial structures represented as symbolic expressions over abstract arithmetic rings, supporting coefficient extraction, property checks (e.g., linearity), and form conversions. These capabilities are used in symbolic computation tasks for constraint solving and abstract interpretation in program analysis.",
      "description_length": 530,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Q",
      "library": "libabsolute",
      "description": "This module enables precise arithmetic operations on rational numbers, including addition, multiplication, exponentiation, and comparisons, alongside utilities for rounding, equality checks, and format-preserving string conversions. It operates on a rational number type represented by `t` (internally `Mpqf.t`), supporting exact computations and flexible textual representations. Its features are particularly useful in domains requiring numerical precision, such as constraint solving, symbolic mathematics, or scenarios where floating-point approximations would introduce unacceptable errors.",
      "description_length": 595,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Dom",
      "library": "libabsolute",
      "description": "This module represents variable definition domains using rational numbers, offering constructors for finite intervals, semi-open intervals, finite sets, and unbounded domains. It provides operations to check membership, determine boundedness, and convert domains into constraints for variables. Use cases include specifying valid ranges for variables in constraint-solving problems, such as restricting a variable to a closed interval or a discrete set of rational values.",
      "description_length": 472,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.I",
      "library": "libabsolute",
      "description": "This module implements basic integer arithmetic operations such as addition, multiplication, division, and negation, with support for conversions to and from integers, floats, and rational numbers. It works directly with the built-in `int` type and includes utilities for comparison, equality checks, and formatted printing. Concrete use cases include performing safe integer division, converting numeric types in constraint expressions, and printing integer values in symbolic analysis contexts.",
      "description_length": 496,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Solver",
      "library": "libabsolute",
      "description": "Implements constraint solving algorithms using an abstract domain to analyze and verify properties of constraint satisfaction problems. It provides concrete operations for computing solution space coverage, checking satisfiability, and generating witnesses for feasible solutions. Designed for use in program verification and formal methods where precise domain-specific analysis is required.",
      "description_length": 392,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libabsolute.Kleene",
      "library": "libabsolute",
      "description": "This module implements a three-valued logic system with values False, True, and Unknown. It provides logical operations for conjunction (and_), disjunction (or_), and negation (not_) that operate on these truth values. These operations are used to model uncertain or incomplete information in constraint solving scenarios, such as when reasoning about program analysis or symbolic execution where boolean values may be unknown.",
      "description_length": 427,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Domains",
      "library": "libabsolute",
      "description": "This module manages abstract domain registration and combination for constraint solving, providing functions to register numeric, boolean, and domain combinators of arity 1 or 2. It supports parsing domain expressions into concrete abstract domains, enabling dynamic composition through predefined combinators like product. Concrete use cases include building and manipulating hybrid abstract domains for numerical and boolean constraint analysis, such as combining interval arithmetic with boolean logic for program verification tasks.",
      "description_length": 536,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.F",
      "library": "libabsolute",
      "description": "This module provides arithmetic operations (addition, multiplication, division), rounding functions, and conversions between float, integer, and rational number types (Mpqf.t). It handles float values alongside these types to support precise numerical computations, comparisons, and formatted string representations, facilitating constraint solving over real numbers and debugging through value serialization.",
      "description_length": 409,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Instance",
      "library": "libabsolute",
      "description": "This module represents points in a rational coordinate space, mapping variables to their values. It supports constructing instances from variable-value lists, translating points by vectors, and converting to APRON generators. Typical use cases include modeling program states for constraint solving and applying numerical analysis techniques like gradient descent.",
      "description_length": 364,
      "index": 23,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libabsolute.Ring",
      "library": "libabsolute",
      "description": "Implements algebraic operations for abstract domains with ring structures, supporting addition, multiplication, and their inverses. Works with elements of a ring, including integers, polynomials, and matrices, under abstraction. Enables precise symbolic manipulation and constraint propagation in static analysis tasks.",
      "description_length": 319,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Polynom",
      "library": "libabsolute",
      "description": "This module provides symbolic manipulation of multivariate polynomials through arithmetic operations such as addition, multiplication, exponentiation, and normalization. It works with polynomials represented as lists of monomial cells or coefficient-cell pairs, supporting exact integer, floating-point, and rational coefficient computations. Concrete use cases include algebraic simplification, linearity detection, and constraint solving in abstract interpretation and program analysis tasks.",
      "description_length": 494,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Libabsolute.Signature",
      "library": "libabsolute",
      "description": "This module defines the core operations for abstract domains used in constraint solving, including consistency checking, domain splitting, and precision adjustment. It works with abstract value types representing constrained variable domains, typically numeric ranges or symbolic expressions. Concrete use cases include implementing domain-specific constraint solvers for program analysis and formal verification tasks.",
      "description_length": 419,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Expr",
      "library": "libabsolute",
      "description": "This module provides a numerical expression language with constructors for constants, variables, and binary operations (addition, subtraction, multiplication, division, exponentiation), alongside utilities for expression analysis (e.g., linearity checks, variable collection) and transformation (variable substitution, evaluation, simplification). It operates on expressions represented as `Libabsolute.Expr.t`, annotated expressions, and numeric constants (`Libabsolute.Q.t`), with use cases in constraint solving, symbolic analysis, and numerical evaluation within abstract domains. Applications include building and manipulating symbolic expressions, verifying structural properties, and generating human-readable representations for debugging or output.",
      "description_length": 757,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Consistency",
      "library": "libabsolute",
      "description": "This module implements consistency checks and filtering operations for abstract values relative to predicates, producing refined subsets that satisfy given constraints. It works with abstract domains and constraint satisfaction instances, tracking feasibility through the `feasible` type that indicates whether a solution is unfeasible, possible, or witnessed. Concrete use cases include refining variable domains during constraint solving and verifying predicate consistency in abstract interpretation workflows.",
      "description_length": 513,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Tools",
      "library": "libabsolute",
      "description": "This module provides precise error signaling with formatted exceptions, in-place terminal output control, and list combination folding for constraint analysis workflows. It handles option types with lattice operations and includes specialized data structure modules for string-indexed maps and sets with functional transformation capabilities. These features support variable management in constraint solving systems and combinatorial analysis of structured data.",
      "description_length": 463,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Constraint",
      "library": "libabsolute",
      "description": "This module provides a constraint language for expressing and manipulating logical comparisons between abstract expressions and rational values, supporting operations like equality checks, interval inclusions, and logical combinations. It works with symbolic expressions, rational constants, and constraint types that enable inversion, substitution, and convex hull construction over variable mappings. These capabilities are used for tasks like program analysis, abstract interpretation, and formal verification where combining symbolic and concrete constraints is critical.",
      "description_length": 575,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Result",
      "library": "libabsolute",
      "description": "This module represents solutions from an abstract solver as covers, tracking inner and outer elements. It provides operations to add elements, compute the inner ratio of a solution, and print results. Use it to manage and evaluate approximate solutions in constraint solving workflows.",
      "description_length": 285,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Constant",
      "library": "libabsolute",
      "description": "This module provides configuration and control operations for a constraint-solving system, managing mutable global state through primitive-typed reference variables (floats, integers, strings, booleans). It exposes parameters to tune solver behavior\u2014such as iteration limits, domain selection, pruning strategies, and output formats\u2014alongside debugging flags for tracing execution and precision adjustments. These mechanisms are used to optimize solver performance, enable stepwise analysis, and customize diagnostic output during abstract interpretation tasks.",
      "description_length": 561,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Parser",
      "library": "libabsolute",
      "description": "This module provides functions to parse numeric expressions, constraints, and CSP problem files into their corresponding abstract syntax trees. It works with strings and file inputs, producing structured representations like expressions, constraints, and CSP problems. It supports concrete use cases such as reading and validating `.abs` files, parsing individual expressions or constraints for dynamic problem construction, and enforcing syntactic and semantic correctness during parsing.",
      "description_length": 489,
      "index": 33,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute.Csp",
      "library": "libabsolute",
      "description": "This module defines core data structures and operations for building and manipulating constraint satisfaction problems (CSPs) with integer and real variables, including variable declarations, constraints, and objective functions. It provides functions to create and modify CSPs by adding variables with specified domains, fixing variable values, and appending constraints. Concrete use cases include modeling optimization problems with bounded variables and managing constraint logic in static analysis workflows.",
      "description_length": 513,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Libabsolute",
      "library": "libabsolute",
      "description": "Libabsolute provides constraint solving capabilities over abstract domains, enabling precise modeling and analysis of numerical problems with integer and real variables. It supports operations such as variable domain specification, constraint creation and manipulation, expression construction, and instance management, all grounded in abstract interpretation techniques. Concrete use cases include program analysis, formal verification, and optimization workflows where symbolic and numeric constraints must be combined and solved within customizable abstract domains.",
      "description_length": 569,
      "index": 35,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 38,
    "meaningful_modules": 36,
    "filtered_empty_modules": 2,
    "retention_rate": 0.9473684210526315
  },
  "statistics": {
    "max_description_length": 757,
    "min_description_length": 285,
    "avg_description_length": 504.8611111111111,
    "embedding_file_size_mb": 0.5224170684814453
  }
}