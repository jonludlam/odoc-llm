{
  "package": "ppx_deriving_hardcaml",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 3,
  "creation_timestamp": "2025-08-14T22:53:51.194700",
  "modules": [
    {
      "module_path": "Ppx_deriving_hardcaml_runtime.Array",
      "library": "ppx_deriving_hardcaml.runtime",
      "description": "This module offers functional and imperative operations for manipulating structured arrays of type `'a t`, including transformations (mapping, filtering, folding), searches (with early termination), aggregations (summing, min/max), and in-place modifications (swapping, reversing). It supports advanced array workflows like matrix operations, binary search, and serialization, with specialized handling for float arrays and indexed computations. Use cases include algorithmic data processing, hardware description workflows in HardCaml, and scenarios requiring precise control over array structure and memory.",
      "description_length": 609,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Ppx_deriving_hardcaml_runtime",
      "library": "ppx_deriving_hardcaml.runtime",
      "description": "This module provides operations for concatenating strings with optional separators and extends array manipulation with functional and imperative utilities. It works with arrays of arbitrary type, with specialized support for float arrays and indexed computations. Concrete use cases include implementing matrix transformations, performing in-place array modifications, and handling serialization workflows in hardware description contexts.",
      "description_length": 439,
      "index": 1,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Ppx_deriving_hardcaml",
      "library": "ppx_deriving_hardcaml",
      "description": "This module generates Hardcaml-specific code for sum types, allowing them to be used in hardware descriptions. It provides functions to convert sum type values to and from bit vectors, enabling their use in circuit definitions and simulations. Concrete use cases include defining state machines and tagged data representations in digital logic designs.",
      "description_length": 352,
      "index": 2,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 3,
    "meaningful_modules": 3,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 609,
    "min_description_length": 352,
    "avg_description_length": 466.6666666666667,
    "embedding_file_size_mb": 0.04386425018310547
  }
}