{
  "package": "key-parsers",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 63,
  "creation_timestamp": "2025-07-15T23:16:21.226835",
  "modules": [
    {
      "module_path": "Key_parsers.Pgp.Packet.Public_key.Value",
      "library": "key-parsers",
      "description": "This module defines a variant type `t` representing different public key algorithms (RSA, DSA, Elgamal) and provides operations to compare, print, and check equality of these values. It supports concrete use cases such as parsing and displaying public key data from PGP packets. Functions like `compare`, `equal`, `pp`, and `show` enable direct manipulation and inspection of cryptographic key material in a type-safe manner.",
      "description_length": 425,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Packet.Signature.Subpacket",
      "library": "key-parsers",
      "description": "This module defines and operates on subpacket data structures used in PGP signatures, including key flags, revocation reasons, and various subpacket types like key expiration, issuer ID, and usage flags. It provides comparison, equality checks, and string formatting functions for these types. Concrete use cases include parsing and handling signature metadata during cryptographic operations or key management tasks.",
      "description_length": 417,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Packet.Secret_key.S2k",
      "library": "key-parsers",
      "description": "This module defines and manipulates string-to-key (S2K) specifiers used in OpenPGP secret key packets. It supports parsing and representing S2K methods, including simple, salted, and iterated salted types, along with their associated hash algorithms, salts, and iteration counts. The module provides comparison, equality checks, and pretty-printing for these S2K variants, enabling precise handling of key derivation parameters in secret key material.",
      "description_length": 451,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Asn1.Ec.Public",
      "library": "key-parsers",
      "description": "This module provides functions to parse, encode, and compare public keys in ASN.1 format for elliptic curve cryptography. It operates on the `Key_parsers.Asn1.Ec.point` type, supporting operations like equality checking, pretty printing, and conversion to and from `Cstruct.t` for network or storage representation. Concrete use cases include reading and validating EC public keys from X.509 certificates or TLS handshakes.",
      "description_length": 423,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Cvc.Ec.Public",
      "library": "key-parsers",
      "description": "This module parses and represents public key components of Elliptic Curve (EC) Card Verifiable Certificates, specifically extracting and structuring values such as the modulus, base points, curve coefficients, and cofactor. It provides functions to decode raw certificate data into a structured format, compare and print key components, and validate their equality. It is used in cryptographic applications requiring secure parsing and handling of EC public keys from CVC certificates, such as in smart card authentication systems.",
      "description_length": 531,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Pgp.Packet.Secret_key",
      "library": "key-parsers",
      "description": "This module represents and processes PGP secret key packets, combining public key data with encryption parameters like S2K specifiers, initialization vectors, and checksums. It supports decoding secret keys from binary buffers, comparing key values, and formatting key data for debugging. The S2K submodule handles key derivation parameters, supporting simple, salted, and iterated salted methods with hash algorithms, salts, and iteration counts. You can parse encrypted secret keys, extract and compare their components, or inspect S2K parameters for cryptographic analysis.",
      "description_length": 576,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.Dh.Public",
      "library": "key-parsers",
      "description": "This module parses and encodes Diffie-Hellman public keys in ASN.1 format, working with the `t` type representing a public key as a big integer. It provides `decode` to parse a key from a Cstruct buffer and `encode` to serialize a key into a buffer, along with standard comparison, equality, and formatting functions. Use this module when handling DH public keys in X.509 certificates or TLS handshakes.",
      "description_length": 403,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Elgamal.Public",
      "library": "key-parsers",
      "description": "This module defines and manipulates ElGamal public keys used in OpenPGP, consisting of the parameters `p`, `g`, and `y`, all represented as arbitrary-precision integers. It provides functions to compare, print, and decode these keys from binary data. A typical use case involves parsing ElGamal public keys from PGP key packets or serializing them for storage and transmission.",
      "description_length": 377,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Pgp.Packet.Body",
      "library": "key-parsers",
      "description": "This module defines a variant type `t` representing different PGP packet body types, such as identifiers, keys, signatures, and markers. It provides functions to compare, print, and decode packet bodies from binary data based on the packet type. These operations support parsing and inspecting PGP key material, including public and private keys, subkeys, and signatures.",
      "description_length": 371,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Ltpa.Rsa.Private",
      "library": "key-parsers",
      "description": "This module parses and represents RSA private keys in a specific binary format used by IBM WebSphere and Lotus Notes for Lightweight Third Party Authentication. It decodes keys with components d, e, p, and q, where values are big-endian with size prefixes or fixed encodings. The module ensures correct key structure and validates that e is exactly 0x010001, raising errors otherwise.",
      "description_length": 384,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Asn1.Dh.Private",
      "library": "key-parsers",
      "description": "This module implements ASN.1 encoders and decoders for Diffie-Hellman private keys represented as big integers (`Z.t`). It provides functions to convert private keys to and from ASN.1 structures, supporting secure key exchange protocols. Use this module when parsing or generating DH private keys in cryptographic applications.",
      "description_length": 327,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Rsa.Private",
      "library": "key-parsers",
      "description": "This module handles RSA private key components in PGP, providing parsing from binary data and operations for comparing, printing, and checking equality of keys. It works with a record type containing modular integers `d`, `p`, `q`, and `u`, representing the private exponent and prime factors. It is used to decode and manipulate RSA private keys during cryptographic operations like signature generation or decryption.",
      "description_length": 419,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.Rsa.Public",
      "library": "key-parsers",
      "description": "This module parses and encodes RSA public keys in ASN.1 format, handling operations like decoding from and encoding to Cstruct.t buffers. It works with RSA public key data structures containing modulus (n) and exponent (e) values as Z.t integers. Concrete use cases include reading and writing RSA public keys in X.509 certificates or TLS handshake messages.",
      "description_length": 358,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Dsa.Public",
      "library": "key-parsers",
      "description": "This module defines and manipulates DSA public keys used in OpenPGP, consisting of the parameters (p, q, g, y) represented as arbitrary-precision integers. It provides functions to decode these keys from binary format, compare and check equality between them, and format or display their contents. It is used when parsing and handling DSA-based OpenPGP public key data in cryptographic applications.",
      "description_length": 399,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Packet.Private_key_value",
      "library": "key-parsers",
      "description": "This module defines a variant type `t` representing different private key formats (RSA, DSA, Elgamal) and provides operations to compare, check equality, format, and convert these private key values to strings. It works directly with the private key types from the corresponding cryptographic modules. Concrete use cases include parsing and displaying private key data in OpenPGP packets.",
      "description_length": 388,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Algo.Symmetric",
      "library": "key-parsers",
      "description": "This module defines a set of symmetric encryption algorithms used in PGP, including their corresponding integer codes and key sizes. It provides functions to convert between algorithm identifiers and their string representations, as well as retrieving key sizes in bytes. It is used to interpret and serialize symmetric encryption parameters in PGP key and packet parsing.",
      "description_length": 372,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Pgp.Packet.Signature",
      "library": "key-parsers",
      "description": "This module handles the decoding and representation of OpenPGP signature packets, including support for signature types such as revocation, subkey binding, and user certification. It structures binary signature data into accessible components like version, signature type, and subpackets, enabling tasks such as cryptographic signature parsing and key validation. The subpacket module complements this by defining and manipulating associated metadata, such as key flags, expiration times, and issuer identifiers, with utilities for comparison and formatting. Together, they support concrete operations like analyzing PGP key signatures, verifying key usage constraints, and extracting revocation details from binary data.",
      "description_length": 721,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Rsa.Public",
      "library": "key-parsers",
      "description": "This module defines and manipulates RSA public keys used in PGP, consisting of modulus `n` and exponent `e`. It provides functions to compare, print, and decode RSA public keys from binary data. Typical use cases include parsing PGP key material and validating RSA public key equality during cryptographic operations.",
      "description_length": 317,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.Dsa.Private",
      "library": "key-parsers",
      "description": "This module implements DSA private key parsing and serialization for ASN.1 encoded data. It provides functions to decode DSA private keys from Cstruct.t buffers and encode them back into ASN.1 format, ensuring compatibility with cryptographic standards. The module directly works with DSA private key values represented as Z.t integers.",
      "description_length": 336,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.Ec.Private",
      "library": "key-parsers",
      "description": "This module handles parsing and encoding of EC private keys in ASN.1 format, specifically for PKCS#8 structures. It operates on `t` values containing the private key material, optional EC parameters, and optional public key. Concrete use cases include reading and writing EC private keys from/to binary ASN.1-encoded data, such as when loading or exporting cryptographic keys.",
      "description_length": 376,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Algo.Public",
      "library": "key-parsers",
      "description": "This module defines a set of public key algorithms used in PGP, including RSA, Elgamal, DSA, and EC variants. It provides operations to convert integers to algorithm types, compare and check equality of algorithm values, and format or display them as strings. Concrete use cases include parsing and representing public key algorithm identifiers in PGP key data structures.",
      "description_length": 372,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Asn1.Rsa.Private",
      "library": "key-parsers",
      "description": "This module defines and implements parsers and encoders for RSA private keys in ASN.1 format, specifically handling PKCS#1 structures. It works with a record type `t` representing RSA private key components, including standard fields like modulus `n`, exponents `e` and `d`, and CRT parameters, along with optional additional primes. It supports concrete operations such as parsing from and serializing to ASN.1-encoded byte buffers (`Cstruct.t`), enabling direct use in cryptographic applications that require key import/export.",
      "description_length": 529,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.Ec.Params",
      "library": "key-parsers",
      "description": "Handles parsing and serialization of elliptic curve parameters in ASN.1 format, specifically supporting named curves, implicit curves, and explicitly specified domain parameters. Works directly with `Cstruct.t` for binary encoding and decoding, and provides structural comparison, equality checks, and pretty-printing for parameter values. Used for processing EC key parameters in cryptographic protocols like TLS and X.509 certificate handling.",
      "description_length": 445,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Elgamal.Private",
      "library": "key-parsers",
      "description": "This module implements operations for parsing and manipulating ElGamal private keys in the context of OpenPGP. It provides functions to decode private keys from binary format, compare and check equality between keys, and format or display keys as strings. The module works directly with ElGamal private key values represented as `Key_parsers.Derivable.Z.t`, and is used during key deserialization and inspection in PGP key handling workflows.",
      "description_length": 442,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Dsa.Private",
      "library": "key-parsers",
      "description": "This module provides functions to decode, compare, and format DSA private keys in PGP. It works with DSA private keys represented as `Key_parsers.Derivable.Z.t` and supports parsing from binary data using `Cstruct`. Concrete use cases include reading and displaying DSA private key values during PGP key processing.",
      "description_length": 315,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Cvc.Rsa.Public",
      "library": "key-parsers",
      "description": "This module parses RSA public keys from Cstruct.t buffers into a structured format containing modulus and exponent. It supports direct comparison, pretty-printing, and string serialization of RSA public key components. Use this module to extract and manipulate RSA public key data from binary certificate structures in cryptographic applications.",
      "description_length": 346,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Packet.Id",
      "library": "key-parsers",
      "description": "This module defines a type `t` representing PGP packet IDs as strings, along with functions for comparing, printing, and decoding these IDs. It provides `compare`, `equal`, `pp`, `show`, and `decode` operations tailored for handling PGP packet identifiers in parsing and serialization tasks. Use cases include processing binary PGP data streams and validating packet headers.",
      "description_length": 375,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Pgp.Algo.Hash",
      "library": "key-parsers",
      "description": "This module defines a set of common cryptographic hash algorithms used in PGP, including MD5, SHA-1, SHA-2 variants, and SHA-3. It provides operations to convert hash algorithm identifiers to and from integer representations, compare and check equality between them, and obtain their string names or formatted output. Concrete use cases include parsing and serializing PGP key data that references specific hash algorithms by name or numeric ID.",
      "description_length": 445,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Packet.Header",
      "library": "key-parsers",
      "description": "This module defines a type `t` representing the header of a PGP packet, including its type, length, and format version. It provides functions to decode a header from a Cstruct buffer, compare and check equality between headers, and format or display header contents as strings. These operations are used when parsing and analyzing PGP key data to identify packet structure and layout.",
      "description_length": 384,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.Ec.Field",
      "library": "key-parsers",
      "description": "This module defines data structures and parsers for representing elliptic curve (EC) field parameters in ASN.1 formats. It handles both prime fields and characteristic two fields, including basis types like GN, TP, and PP, along with associated comparison, serialization, and parsing functions. Concrete use cases include decoding and encoding EC parameters in cryptographic key formats such as PKCS#8 and X.509.",
      "description_length": 412,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Ltpa.Rsa.Public",
      "library": "key-parsers",
      "description": "This module parses and represents RSA public keys used in IBM WebSphere and Lotus Notes LTPA tokens. It provides functions to decode keys from binary data, compare key components, and format keys for debugging or logging. The module works directly with RSA public key parameters stored as `Z.t` values, specifically the exponent `e` and modulus `n`.",
      "description_length": 349,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Asn1.Dh.Params",
      "library": "key-parsers",
      "description": "This module defines operations for parsing and encoding Diffie-Hellman (DH) key parameters in ASN.1 format. It works with a record type containing prime modulus `p`, generator `g`, and optional subgroup order `l`, all represented as arbitrary-precision integers (`Z.t`). Concrete use cases include decoding DH parameters from X.509 certificates and encoding them into PKCS#8 private key structures.",
      "description_length": 398,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.Ec.Specified_domain",
      "library": "key-parsers",
      "description": "This module defines and parses ASN.1 structures for elliptic curve domain parameters, including field elements, curves, and domain-specific values like base points, orders, and cofactors. It works with `Cstruct.t` for binary data, `Z.t` for integers, and custom types for curves and domains. It is used to parse and serialize EC key material in formats like PKCS#8 and X.509.",
      "description_length": 375,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Asn1.Rsa.Params",
      "library": "key-parsers",
      "description": "Parses ASN.1 structures for RSA key parameters, specifically handling modulus and public exponent values. Works with ASN.1 encoded data to extract RSA key components used in X.509 certificates and PKCS#8 formats. Directly supports parsing operations for cryptographic key validation and certificate processing workflows.",
      "description_length": 320,
      "index": 33,
      "embedding_norm": 1.0000001192092896
    },
    {
      "module_path": "Key_parsers.Pgp.Packet.Public_key",
      "library": "key-parsers",
      "description": "This module represents public key packets in PGP data, capturing fields like version, creation time, algorithm, and key material. It supports decoding from binary, comparison, and structured display of keys, enabling tasks like keyring parsing and cryptographic metadata inspection. The included child module models public key algorithms (RSA, DSA, Elgamal) with type-safe operations for comparison and rendering, enhancing key handling during PGP packet analysis. Together, they allow precise manipulation and interpretation of public key data in OpenPGP workflows.",
      "description_length": 566,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Asn1.Dsa.Params",
      "library": "key-parsers",
      "description": "This module parses and encodes DSA parameters in ASN.1 format, handling values p, q, and g as big integers. It supports reading and writing these parameters from and to Cstruct buffers, ensuring correct ASN.1 serialization. Use cases include processing DSA keys in X.509 certificates or PKCS#8 structures.",
      "description_length": 305,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.Dsa.Public",
      "library": "key-parsers",
      "description": "This module implements DSA public key parsing and serialization according to ASN.1 standards. It provides functions to encode and decode DSA public keys from `Cstruct.t` buffers, along with comparison, equality checks, and pretty-printing for `Z.t` values representing the key material. It is used to handle DSA public keys in X.509 certificates and related cryptographic operations.",
      "description_length": 383,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Derivable.Cstruct",
      "library": "key-parsers",
      "description": "Implements equality checks, ordering, and string formatting for Cstruct.t values. Provides `equal`, `compare`, `pp`, and `show` functions to facilitate testing, debugging, and serialization of Cstruct data. Useful when working with binary data buffers in network protocols or file parsing.",
      "description_length": 289,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.PKCS8",
      "library": "key-parsers",
      "description": "This module provides ASN.1 encoders and decoders for PKCS#8 private key formats, supporting RSA, DSA, EC, and DH key types. It operates on Cstruct.t buffers and works with structured key types including private keys and associated parameters. Use this module to serialize and deserialize cryptographic keys to and from binary ASN.1-encoded data.",
      "description_length": 345,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.Dsa_private_key",
      "library": "key-parsers",
      "description": "This module parses and encodes DSA private keys in ASN.1 format, handling conversion to and from DER-encoded data. It operates on a structured type containing the DSA parameters (p, q, g), public key, and private key, all represented as arbitrary-precision integers. Use this module to load or export DSA private keys from/to binary ASN.1 streams, such as reading from or writing to PEM or DER files.",
      "description_length": 400,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.Rsa",
      "library": "key-parsers",
      "description": "This module handles RSA key parsing and serialization in ASN.1 format, supporting both public and private key structures. It operates on key components like modulus (n), exponents (e, d), and CRT parameters, using Z.t integers and Cstruct.t buffers for encoding and decoding. Functionality includes reading and writing RSA keys in X.509 certificates, TLS handshakes, and PKCS#1 or PKCS#8 formats. Examples include extracting public key parameters from a certificate or serializing a private key for storage.",
      "description_length": 507,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Packet",
      "library": "key-parsers",
      "description": "This module structures OpenPGP packets by parsing and comparing packet headers, bodies, and identifiers, enabling precise decoding and inspection of raw PGP data. It handles key packets for both public and private material, supporting operations like parsing secret keys with S2K specifiers, extracting signature components, and inspecting key algorithms. Variant types represent packet bodies and private key formats, with utilities for comparison, formatting, and binary decoding. Signature packets are modeled with subpacket metadata, allowing analysis of revocations, certifications, and key bindings, while header and packet ID types facilitate structured parsing and validation of PGP data streams.",
      "description_length": 704,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Asn1.X509",
      "library": "key-parsers",
      "description": "This module parses and encodes X.509 public keys for RSA, DSA, EC, and DH algorithms using ASN.1. It provides functions to decode raw key data into structured types and encode those structures back into binary format. Use cases include processing PEM-encoded certificates and handling cryptographic key exchanges.",
      "description_length": 313,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Asn1.Ec",
      "library": "key-parsers",
      "description": "This module processes elliptic curve cryptographic key material in ASN.1 format, providing structured access to EC points, domain parameters, and public and private keys through `Cstruct.t`-based parsing and serialization. It supports equality checks, pretty printing, and conversions for EC points and keys, enabling validation and extraction of key components from X.509 certificates or PKCS#8 structures. Submodules handle field-specific parameters, named curves, and ASN.1 encodings for domains and keys, allowing precise manipulation of EC key material in cryptographic protocols. Example uses include parsing EC public keys from TLS handshakes, extracting private key parameters, and decoding domain-specific curve data for cryptographic operations.",
      "description_length": 755,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Cvc.Rsa",
      "library": "key-parsers",
      "description": "This module processes RSA public keys by parsing them from binary buffers into structured components, including modulus and exponent. It enables direct comparison, pretty-printing, serialization, and extraction of key data for use in cryptographic operations. Developers can use it to analyze and manipulate RSA keys embedded in certificates or network protocols. Example use cases include validating key parameters and converting binary key representations into human-readable or comparable forms.",
      "description_length": 498,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Pgp.Packet_error",
      "library": "key-parsers",
      "description": "This module defines error types for handling PGP packet parsing failures. It includes `Fatal` for unrecoverable errors and `Header` for errors during packet header parsing, which carries a message and the length of data to skip. These errors are used to manage and respond to malformed or unsupported PGP packet structures during parsing operations.",
      "description_length": 349,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.Dsa",
      "library": "key-parsers",
      "description": "This module handles DSA key and parameter parsing and serialization in ASN.1 format, supporting both private and public keys as well as DSA parameters. It provides operations to encode and decode values such as `p`, `q`, `g`, and private/public key integers (`Z.t`) to and from `Cstruct.t` buffers, ensuring compatibility with cryptographic standards like X.509 and PKCS#8. Specific examples include extracting DSA parameters from a certificate, reconstructing a DSA private key from raw data, or serializing a public key for transmission. The module enables direct manipulation and conversion of key components while maintaining correct ASN.1 encoding.",
      "description_length": 653,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Pgp.Elgamal",
      "library": "key-parsers",
      "description": "This module handles ElGamal key operations for OpenPGP, supporting both public and private key types. Public keys are composed of `p`, `g`, and `y`, with functions to parse, compare, and serialize them, while private keys are represented as `Key_parsers.Derivable.Z.t` and support decoding, comparison, and string formatting. It enables tasks like extracting ElGamal keys from PGP packets, verifying key equality, and preparing keys for storage or transmission. Example uses include parsing a public key from a binary key packet and comparing private keys during cryptographic operations.",
      "description_length": 588,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Derivable.Asn_oid",
      "library": "key-parsers",
      "description": "Implements equality checks, ordering, and string formatting for ASN.1 object identifiers. Works directly with `Asn.OID.t` values to support comparison and display operations. Useful for validating and presenting OIDs in cryptographic key parsing workflows.",
      "description_length": 256,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1.Algorithm_identifier",
      "library": "key-parsers",
      "description": "Parses ASN.1 algorithm identifiers for cryptographic key formats including RSA, DSA, EC, and DH. It defines grammars to decode algorithm parameters from ASN.1 structures into typed representations specific to each algorithm. Used to extract key parameters from PKCS#8 and X509 certificates during parsing.",
      "description_length": 305,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Cvc.Ec",
      "library": "key-parsers",
      "description": "This module handles the parsing and representation of elliptic curve public key components from Card Verifiable Certificates, structuring values such as modulus, base points, curve coefficients, and cofactor. It supports decoding raw certificate data into typed values, comparing key components for equality, and printing structured representations. You can use it to validate and inspect EC keys in cryptographic systems, such as verifying smart card credentials during authentication. For example, it enables extracting and checking the base point of a certificate's public key against known curve parameters.",
      "description_length": 611,
      "index": 50,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Key_parsers.Asn1.Dh",
      "library": "key-parsers",
      "description": "This module handles Diffie-Hellman key operations in ASN.1 format, supporting public and private keys along with parameter sets. It provides types for keys as big integers (`Z.t`) and parameters as records with prime modulus `p`, generator `g`, and optional subgroup order `l`, along with encoding and decoding functions for Cstruct buffers. You can decode a public key from a TLS handshake, encode a private key for storage, or extract DH parameters from an X.509 certificate.",
      "description_length": 477,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Rsa",
      "library": "key-parsers",
      "description": "This module handles RSA key components for PGP, supporting both private and public key operations. It defines private keys using modular integers `d`, `p`, `q`, and `u`, and public keys using `n` and `e`, with functions to parse, compare, and print these keys. It enables decoding RSA keys from binary data and performing cryptographic operations such as signature validation and decryption. For example, it can parse a PGP key block into its RSA components or verify that two public keys are equal.",
      "description_length": 499,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Algo",
      "library": "key-parsers",
      "description": "This module provides a comprehensive set of cryptographic algorithms used in PGP, including symmetric encryption, public key, and hash algorithms. It supports conversions between integer codes and string representations, comparison operations, and retrieval of properties like key sizes for symmetric algorithms, cryptographic operations for public key types, and digest sizes for hash functions. Examples include converting an integer to a SHA-256 identifier, determining the key size of a symmetric algorithm, or comparing two public key algorithm values for equality.",
      "description_length": 570,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Pgp.Dsa",
      "library": "key-parsers",
      "description": "This module handles DSA key operations for PGP, supporting both public and private keys. It provides data types for representing DSA parameters (p, q, g, y) as arbitrary-precision integers and private keys as `Key_parsers.Derivable.Z.t`. Key operations include decoding from binary, comparison, equality checks, and formatting. Examples include parsing DSA public or private keys from a PGP data stream and displaying their components for verification or debugging.",
      "description_length": 465,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Ltpa.Rsa",
      "library": "key-parsers",
      "description": "This module handles RSA key parsing and representation for IBM WebSphere and Lotus Notes LTPA tokens, supporting both private and public key operations. It works with key components such as `d`, `e`, `p`, `q`, and `n`, all represented as `Z.t` values, enforcing big-endian encoding with size prefixes or fixed layouts. The module decodes binary key data, validates that `e` is 0x010001, and provides comparison and formatting functions for debugging. Example uses include extracting key parameters from binary blobs and validating key structure for cryptographic operations.",
      "description_length": 574,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Derivable.Z",
      "library": "key-parsers",
      "description": "This module implements equality checking, comparison, and string formatting for arbitrary-precision integers (`Z.t`). It provides `equal`, `compare`, `pp`, and `show` for use in data processing pipelines and serialization tasks involving large integers. These operations support precise numeric analysis and debugging output in systems handling unbounded integer values.",
      "description_length": 370,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Asn1",
      "library": "key-parsers",
      "description": "This module handles ASN.1 encoding and decoding of cryptographic key formats used in PKCS#8, X.509, and TLS, supporting RSA, DSA, EC, and DH algorithms. It provides structured types for key components such as RSA's modulus and exponents, DSA's p/q/g parameters, EC points and curves, and DH primes and generators, all manipulated via `Z.t` and `Cstruct.t`. Operations include parsing PEM or DER-encoded keys, extracting parameters from certificates, serializing private keys, and reconstructing key material from raw data. Examples include decoding an EC public key from a TLS handshake, exporting a DSA private key to DER, or extracting RSA parameters from an X.509 certificate.",
      "description_length": 679,
      "index": 57,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Pgp",
      "library": "key-parsers",
      "description": "This module decodes OpenPGP key data into structured representations for RSA, DSA, and Elgamal cryptographic primitives, parsing packets and handling decoding errors. It provides types for key components\u2014such as `n` and `e` for RSA, `p`, `q`, `g`, and `y` for DSA, and `p`, `g`, and `y` for Elgamal\u2014and operations to parse, compare, and format them. Submodules structure packet parsing, define error handling for malformed data, and model cryptographic algorithms with support for encoding, comparison, and property lookup. For example, it can extract RSA private keys from binary PGP data, validate DSA public keys, or decode Elgamal parameters for cryptographic operations.",
      "description_length": 675,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers.Cvc",
      "library": "key-parsers",
      "description": "This module provides tools to parse, represent, and manipulate RSA and EC public key components from Card Verifiable Certificates. It defines structured types for key elements such as modulus, exponent, base points, curve coefficients, and cofactor, supporting operations like comparison, pretty-printing, and serialization. Developers can extract and validate key data from binary buffers, enabling tasks like checking RSA key parameters or verifying EC base points against known curves during cryptographic operations. Example uses include inspecting certificate-embedded keys and converting raw key data into structured, comparable forms for security analysis.",
      "description_length": 663,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Ltpa",
      "library": "key-parsers",
      "description": "This module provides RSA key parsing and validation for LTPA tokens used in IBM WebSphere and Lotus Notes, representing key components like `d`, `e`, `p`, `q`, and `n` as `Z.t` values with strict big-endian encoding. It decodes binary key data, enforces standard key checks such as `e` being 0x010001, and supports key comparison and debugging output. Example uses include extracting key parameters from binary blobs and verifying key structure before cryptographic operations.",
      "description_length": 477,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Key_parsers.Derivable",
      "library": "key-parsers",
      "description": "This module provides equality, comparison, and string formatting operations for Cstruct.t, Asn.OID.t, and Z.t types. It enables direct value inspection and validation in binary data processing, cryptographic workflows, and arbitrary-precision arithmetic. You can compare network buffers, display OIDs from certificates, or format large integers for debugging. Specific functions like `equal`, `compare`, `pp`, and `show` support these operations across each data type.",
      "description_length": 468,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Key_parsers",
      "library": "key-parsers",
      "description": "This module processes cryptographic key data across multiple formats and protocols, converting encoded key material into structured components for analysis, validation, and serialization. It defines key types for RSA, DSA, EC, and DH algorithms using `Z.t` and `Cstruct.t`, with operations to parse PEM, DER, and binary formats, extract parameters from certificates or packets, and compare or format key elements. Supported tasks include decoding TLS key exchanges, validating PGP keys, inspecting certificate-embedded RSA or EC keys, and extracting LTPA token keys with strict encoding rules. Examples include reconstructing RSA parameters from DER, validating DSA public keys, or formatting Zarith integers for debugging.",
      "description_length": 723,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 63,
    "meaningful_modules": 63,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 755,
    "min_description_length": 256,
    "avg_description_length": 449.92063492063494,
    "embedding_file_size_mb": 0.2292938232421875
  }
}