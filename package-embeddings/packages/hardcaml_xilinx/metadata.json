{
  "package": "hardcaml_xilinx",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 195,
  "creation_timestamp": "2025-08-18T19:19:22.394118",
  "modules": [
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a value of type `'a M.t I.t` into `'a I.t M.t`, effectively reorganizing nested structures. It works with data types involving nested applicative structures, specifically where `M` is a module with its own type and operations. A concrete use case is flattening or restructuring deeply nested hardware description values for simulation or synthesis purposes.",
      "description_length": 411,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly maps 1D read port fields to string keys, enabling direct lookup and construction of port configurations from named field associations. It operates on `Read_port_1d.t` values specialized by width, using association lists that pair string names with field values. Concrete use cases include dynamically configuring or inspecting memory read ports by named fields at runtime, such as mapping port names to specific address or data configurations.",
      "description_length": 464,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a structure of monadic values into a monadic structure of values, effectively reorganizing nested effects. It operates on 2D read port configurations, lifting monadic behavior from inner layers to the outer structure. Use it when combining multiple memory read operations that are parameterized by a monadic context, such as error handling or state tracking, into a single coherent result.",
      "description_length": 443,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bit-vector interfaces with combinational logic. It supports functions like packing/unpacking interfaces to/from vectors, multiplexing, concatenation, and priority/one-hot selection, all while ensuring correct signal widths. Concrete use cases include building register files, control logic, and data path circuits where structured signal manipulation is required.",
      "description_length": 429,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly maps 2D write port configurations to field names using unsafe but efficient associative operations. It provides `to_alist` and `of_alist` functions for converting between record-like structures and string-indexed association lists. This is used when specializing memory write ports by field name during hardware generation, where direct name-based access is required.",
      "description_length": 388,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to construct and manipulate 1D write ports using Xilinx memory configurations, specifically integrating with the Always API for hardware description. It works with interfaces containing `Always.Variable.t` and `Signal.t` types, enabling register and wire variable creation, signal assignment, and naming customization. Concrete use cases include defining memory write ports with specific Xilinx URAM or BRAM configurations, assigning signals in always blocks, and applying hierarchical names to generated signals.",
      "description_length": 544,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly associates 1D read port fields with configuration values by port name, using unsafe but efficient name-based lookups. It operates on association lists mapping string keys to arbitrary values, enabling dynamic configuration of memory ports from named field data. Concrete use cases include instantiating memory ports with precomputed configuration values indexed by port names in hardware generation pipelines.",
      "description_length": 430,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that combines a collection of monadic write port values into a single monadic value of write ports, effectively lifting the monad outside the structure. It operates on 1D write ports specialized for specific widths. Use this to sequence memory write operations across multiple ports within a single monadic context.",
      "description_length": 353,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D read ports specialized with a memory configuration, working with combinatorial logic types. It supports concrete use cases such as packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/onehot selection of memory fields. Key functions include `mux`, `concat`, `priority_select`, and `pack`, which enable efficient and type-safe manipulation of memory read ports in hardware descriptions.",
      "description_length": 487,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module implements combinational logic operations for bit vectors, including packing/unpacking, multiplexing, concatenation, and selection primitives. It works with `comb` types representing hardware signals and `t` as a structured wrapper for these signals. Use cases include building custom digital circuits, implementing control logic, and manipulating bit-level data in hardware descriptions.",
      "description_length": 400,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating 1D memory write ports using signal-based representations, supporting tasks like constant assignment, multiplexing, concatenation, and pipeline insertion. It operates on `Of_signal.comb t` and `Of_signal.t` types to model memory fields and signal interfaces, enabling precise control over hardware behavior. These capabilities are particularly useful for implementing configurable memory systems (e.g., mixing URAM and BRAM storage) and optimizing timing-critical paths in hardware designs through register insertion and signal interface customization.",
      "description_length": 617,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines the names and widths of read ports used in a 2D memory configuration. It provides access to port names, their corresponding data widths, and associated tags for identifying specific memory access patterns. It is used to specify the interface of a memory block when building custom memory systems with mixed storage elements like URAM and BRAM.",
      "description_length": 363,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module provides concrete values for port names, widths, and tags after specializing a 1D write port configuration with specific width constraints. It works with lists of strings, integers, and a `tag` type to describe memory port attributes. These values are used to generate precise signal names and bit-widths for hardware description in memory implementations targeting Xilinx FPGAs.",
      "description_length": 391,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module provides values that define the names, widths, and tags of write ports based on a specialized memory configuration. It works with lists of strings, integers, and a `tag` type to describe port properties. Concrete use cases include generating port metadata for hardware description or configuring memory interface generators with precise signal names and bit widths.",
      "description_length": 377,
      "index": 13,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bitvector interfaces with combinational logic, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions. It works with types representing signal interfaces parameterized over a combinational logic type, tracking field widths and values. Concrete uses include building register files, memory interfaces, and control logic where signal routing and selection among structured interfaces are required.",
      "description_length": 499,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to construct and manipulate 1D write ports using the Always API, specifically for Xilinx memory implementations. It works with interfaces containing `Always.Variable.t` values, enabling register and wire creation, signal assignment, and field naming. Concrete use cases include defining memory write behavior in an always block, such as assigning register-backed write data and enabling named signal tracing for debugging.",
      "description_length": 453,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bit vector signals in a hardware description context. It supports values of type `t`, representing structured bit vectors, and includes functions for packing/unpacking, multiplexing, concatenation, and selection operations. Concrete use cases include building custom digital circuits, implementing control logic, and handling signal routing in FPGA designs using Xilinx primitives.",
      "description_length": 447,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines port names and widths for a synchronous FIFO interface with valid signaling. It provides lists of port names, widths, and associated tags for use in hardware description and simulation contexts. These values are used to specify the structure of FIFO signals in a Xilinx-specific implementation.",
      "description_length": 314,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D write port configurations using a specified combinatorial logic module. It supports data types involving vectors and records of fixed-width fields, enabling concrete use cases like memory initialization, signal packing/unpacking, and multiplexing. Functions include constant assignment, concatenation, priority/one-hot selection, and validation of port widths against expected configurations.",
      "description_length": 455,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate register and wire variables within an `Always` block when building 2D read ports with memory configurations. It supports operations like assigning signals to variables, extracting signal values, and applying naming conventions to interface fields. Concrete use cases include constructing and wiring memory read interfaces with specific signal defaults and naming schemes during hardware description in Hardcaml.",
      "description_length": 467,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.All",
      "library": "hardcaml_xilinx",
      "description": "Lifts monadic values within an interface to the monad outside the interface. Works with any monad `M` and interface `I` containing monadic values. Useful for combining multiple monadic computations within an interface into a single monadic result.",
      "description_length": 247,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module provides concrete names and widths for read ports in a 1D memory configuration. It defines lists of port names, widths, and tags derived from a specialized read port structure. These values are used to generate memory implementations with specific port interfaces, such as when mapping memory bits to Xilinx URAM or BRAM primitives with defined address and data widths.",
      "description_length": 381,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions for constructing and manipulating 2D memory read port interfaces using signal-based hardware descriptions. It operates on structured signal interfaces (`Of_signal.t`) to enable operations like multiplexing, concatenation, priority selection, and configuration-driven specialization of memory implementations. These utilities are particularly useful for building FPGA memory systems with mixed resource types (e.g., URAM/BRAM) across different bit ranges, where precise control over read port behavior and signal routing is required.",
      "description_length": 563,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that combines a 2D write port of monadic values into a monadic 2D write port, effectively lifting the monad outside the port structure. It operates on the `t` type representing 2D write ports, specialized over a module `M` that provides the monadic context. A concrete use case is aggregating multiple write operations within a monadic context, such as constructing a memory write port that depends on dynamically computed values within a simulation or synthesis monad.",
      "description_length": 507,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between an interface type and an association list indexed by field names. Works with polymorphic interface values and string-keyed lists. Useful for dynamically inspecting or constructing interfaces from named components, such as during simulation setup or debugging.",
      "description_length": 276,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D write ports for specialized memory configurations using bit-level signals. It supports creating constant ports from integers, packing/unpacking ports to/from bit vectors, and multiplexing or concatenating ports with strict width validation. Concrete use cases include defining memory write interfaces with precise bit widths and routing control signals through multiplexers or priority encoders in hardware designs.",
      "description_length": 478,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module implements combinational logic operations for bit-level manipulation using a parameterized `comb` type. It supports operations like `pack`, `unpack`, `mux`, `concat`, and selection primitives such as `priority_select` and `onehot_select`, working with structured data via the `I.t` nested type. Use it to build and manipulate hardware registers, control logic, and data routing circuits directly in OCaml.",
      "description_length": 417,
      "index": 26,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and transform 1D memory write ports using signal-based interfaces, supporting tasks like constant assignment, multiplexing, concatenation, and pipelining via register stages. It operates on `Of_signal.t` and `Of_signal.comb` types, which encapsulate memory port configurations and signal connections, enabling precise control over hardware signal interfaces. These capabilities are particularly useful for implementing memory subsystems in FPGA designs where structured signal routing, width-specific optimizations, and timing-critical pipelining are required.",
      "description_length": 605,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating synchronous FIFO interfaces using bit vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing between multiple interfaces, concatenating interfaces, and validating signal widths. Concrete use cases include building hardware FIFOs with fixed or dynamic field widths, selecting between multiple data sources with priority or one-hot encoding, and ensuring correct bit-widths during simulation or synthesis.",
      "description_length": 506,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to manipulate interface values within an always block, supporting operations like assignment, register creation, and wire initialization. It works with interface types parameterized over signal and variable fields, enabling structured hardware description. Concrete use cases include building synchronous FIFOs with named signals, assigning values to interface ports in sequential logic, and creating register or wire interfaces with customizable defaults.",
      "description_length": 487,
      "index": 29,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly converts between an interface type and an association list mapping field names to values. It enables working with field-based data structures through standard list operations, allowing field access and construction by string keys. Use this when dynamically inspecting or building interfaces from named fields, such as in serialization or configuration systems.",
      "description_length": 381,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module enables constructing and transforming synchronous hardware interfaces composed of signals, supporting operations like packing/unpacking to bit vectors, multiplexing, concatenation, pipeline/register insertion, and signal assignment. It operates on signal interfaces (`I.Of_signal.t`) and bit vectors, facilitating tasks such as connecting components via directed signal assignments, defining input/output interfaces, and applying hierarchical naming conventions. These features are particularly applied in modeling Xilinx FIFO pipelines and structuring signal interactions in FPGA designs with explicit timing control.",
      "description_length": 630,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a single function `all` that transforms a signal of a nested module type into a nested module of signals, enabling parallel computation across hardware descriptions. It operates on data types involving signals (`O.t`) and modules (`M.t`), specifically handling nested combinations of these types. A concrete use case includes restructuring hierarchical hardware designs where signals from submodules need to be collected and processed in parallel.",
      "description_length": 468,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating synchronous FIFO interfaces with valid signals, including packing/unpacking interfaces to vectors, multiplexing, concatenation, and priority/one-hot selection. It works with combinational logic types (`comb`) and structured interface types that carry valid signals. Concrete use cases include building control logic for dataflow pipelines, managing handshaking protocols, and constructing multiplexed data paths in hardware designs.",
      "description_length": 481,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Maps 2D write port configurations to and from association lists indexed by field names, enabling programmatic manipulation of memory write ports based on named fields. Works directly with `'a t` and `(string * 'a) list` types. Useful for dynamically constructing or inspecting write port configurations tied to specific memory implementations.",
      "description_length": 343,
      "index": 34,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D memory read ports specialized for specific signal widths, enabling tasks like constant assignment, signal routing, multiplexing, and pipeline insertion. It operates on combinational (`comb t`) and registered (`t`) signal types, ensuring correct field widths through validation utilities. These capabilities are particularly useful when building memory hierarchies that mix storage types (e.g., URAM for wider segments, BRAM for narrower ones) or when integrating hardware designs requiring precise signal wiring and naming conventions.",
      "description_length": 598,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly maps 1D write port configurations to field names using unsafe associative operations. It works with polymorphic write port types and string-indexed association lists. Use it to dynamically construct or deconstruct memory write ports by name when the exact field structure is known and safety checks are unnecessary.",
      "description_length": 336,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that combines a collection of monadic values within a specialized write port structure, lifting the monad outside the interface. It operates on 1D write ports configured with a specific memory implementation, enabling the aggregation of multiple write operations into a single monadic result. A concrete use case involves collecting and sequencing multiple memory write actions into a unified operation, such as committing a batch of register updates in a synchronous process.",
      "description_length": 514,
      "index": 37,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to manipulate interface values within an always block, specifically for creating and assigning registers and wires. It works with interface types parameterized over `Hardcaml.Always.Variable.t`, allowing structured hardware description with named fields. Concrete use cases include instantiating register interfaces with optional enables, assigning signal values to variable interfaces, and applying naming conventions to interface signals for clarity in generated hardware.",
      "description_length": 505,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D read ports specialized with memory configurations, working with `comb` types representing bit vectors. It supports concrete tasks like packing/unpacking interfaces into vectors, multiplexing and concatenating read port interfaces, and validating signal widths against expected configurations. Use cases include building configurable memory read paths with precise bit-level control and ensuring correctness of memory port interconnects.",
      "description_length": 499,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.All",
      "library": "hardcaml_xilinx",
      "description": "Lifts monadic values within an interface to the outer monad, combining them into a single result. Works with interfaces containing values wrapped in a monad `M`. Useful for synchronizing and aggregating multiple valid signals in a hardware description context.",
      "description_length": 260,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module offers utilities for constructing and manipulating synchronous FIFO interfaces in hardware designs, focusing on signal composition, routing, and structural transformations. It operates on signal combinator types (`comb`) and FIFO interface values (`t`), enabling tasks like concatenating signals, creating pipelined registers, and validating interface connections. Key applications include wiring signal groups, assigning meaningful names to signals for debugging, and building hierarchical HDL constructs in FPGA or ASIC workflows.",
      "description_length": 544,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate bit-level interfaces for hardware descriptions, including packing/unpacking signals, multiplexing, concatenation, and priority/one-hot selection. It works with `t` values representing structured bit vectors and `comb` values for combinational logic signals. Concrete use cases include defining register interfaces, implementing control logic, and managing signal routing in digital circuits.",
      "description_length": 451,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to construct and manipulate 1D read port interfaces using the Always API, specifically for register and wire variables. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying names to interface fields. Concrete use cases include building memory interfaces with specialized signal types, such as initializing read ports with zero-default wires or registering signals under specific naming conventions.",
      "description_length": 498,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that takes a nested interface of monadic values and transforms it into a monadic interface, effectively lifting the monad out of the interface structure. It operates on data types that are both interfaces (`O.t`) and monadic values (`M.t`). A concrete use case is when working with hardware description interfaces where each field is a monadic computation, and you need to sequence those computations while preserving the interface structure.",
      "description_length": 480,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module provides concrete values for port names, widths, and tags derived from a specialized 2D write port configuration. It works with lists of strings, integers, and a `tag` type to describe memory port properties. Use it to extract structured metadata about memory ports for code generation or configuration purposes.",
      "description_length": 324,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module provides values for inspecting the structure of a 2D write port specialized with a memory configuration, including the names and widths of each port and their associated tags. It works with lists of strings and integers to represent port metadata and predefined `tag` values for identifying port types. Concrete use cases include generating signal names and widths for hardware description languages or tools that require explicit port definitions.",
      "description_length": 460,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for constructing and manipulating 2D memory write ports with specific field widths. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/onehot selection, all while validating signal widths. Concrete use cases include building configurable memory interfaces where write port behavior must be specialized for fixed field widths and combined with control logic.",
      "description_length": 478,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module provides access to the names and widths of read ports specialized with a given memory configuration. It works with lists of string and integer pairs representing port names and their corresponding widths, along with separate lists for names and widths. Concrete use cases include inspecting memory interface properties to generate hardware descriptions or validating port configurations against target device constraints.",
      "description_length": 433,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating synchronous FIFO interfaces using combinational logic. It supports data types like `comb O.t` for representing structured interfaces and vectors, with functions for packing, unpacking, multiplexing, and validating signal widths. Concrete use cases include building hardware descriptions for FIFOs with precise bit-level control, validating interface consistency, and generating constant or multiplexed interface values.",
      "description_length": 485,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines port configurations for RAM instances by specifying signal names and their bit widths. It provides direct access to lists of port names, widths, and associated tags for memory interface generation. Useful for hardware synthesis flows where precise signal naming and sizing is required for integration with Xilinx primitives.",
      "description_length": 344,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines port names, widths, and associated tags for a synchronous FIFO interface. It provides direct access to lists of port names, their corresponding bit widths, and predefined tags used in FIFO signal handling. It is used to configure and manage signal interfaces in Xilinx-based FIFO implementations within Hardcaml workflows.",
      "description_length": 342,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively lifting the monad outside the structure. It operates on records of type `'a M.t O.t`, where `O` is a module defining an interface, and `M` is a monad. A concrete use case is combining multiple signal wires wrapped in a monad (e.g., `Simulation.t`) into a single monadic value representing the entire interface state.",
      "description_length": 432,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D write ports for specialized memory configurations using bit-level representations. It supports functions like packing/unpacking interfaces into vectors, multiplexing, concatenation, and selecting between memory port configurations using priority or one-hot encoding. Concrete use cases include building configurable memory blocks with specific field widths and validating signal widths for synthesis in FPGA targets like Xilinx devices.",
      "description_length": 499,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D write port interfaces using signals, including packing, unpacking, multiplexing, and concatenation to manage data flow. It operates on `Of_signal.t` values representing hardware signal interfaces, enforcing correct field widths and constant assignments during signal wiring. These capabilities are used in memory implementations to handle register pipelining, input/output wire creation, and customized signal naming for hardware description.",
      "description_length": 505,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block, specifically for 2D memory write ports. It supports operations like assigning signals to variables, extracting signal values, and applying naming conventions to interface fields. Concrete use cases include building memory interfaces with controlled signal initialization and register enable conditions in FPGA designs.",
      "description_length": 426,
      "index": 55,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to manipulate synchronous FIFO interfaces using bit vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing between interface values, concatenation, and validation of signal widths. These functions are used to build and verify hardware structures like FIFOs in digital design workflows.",
      "description_length": 354,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D read port interfaces specialized for a given combinational logic type. It supports concrete operations like packing/unpacking interfaces into vectors, multiplexing, concatenation, and priority/one-hot selection, all while ensuring correct signal widths. Use cases include building memory read ports with precise bit-level control and implementing selection logic for memory-mapped registers.",
      "description_length": 454,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly maps 1D write port configurations to specialized implementations based on field names in an association list. It operates on `'a t` structures representing write ports and uses string-keyed lists to associate each port with its corresponding configuration. This enables precise, name-based customization of memory write behavior when building mixed-technology memories, such as assigning specific write logic to URAM or BRAM sections.",
      "description_length": 455,
      "index": 58,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D read ports for memory interfaces using bit-level representations. It supports creating constant ports, packing/unpacking ports to vectors, multiplexing and selecting between ports with priority or one-hot encoding, and validating port widths. Concrete use cases include configuring memory read paths with specific bit widths and implementing selection logic for memory access in hardware designs.",
      "description_length": 459,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bit-level memory interfaces with dynamic resizing capabilities. It works with types representing bit vectors (`comb`) and structured memory interfaces (`t`), enabling precise control over signal widths and layouts. Concrete use cases include packing/unpacking memory interfaces into bit vectors, multiplexing between multiple memory configurations, and validating signal widths during synthesis to ensure correctness.",
      "description_length": 483,
      "index": 60,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating synchronous FIFO interfaces using combinational logic. It supports data types like `comb I.t` for representing structured interfaces and vectors for packed representations. Use cases include packing/unpacking interfaces to/from bit vectors, multiplexing and selecting between interface values, validating signal widths, and constructing constant or concatenated interface values.",
      "description_length": 428,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinators for constructing, transforming, and validating signal interfaces with valid bits, including operations for packing, concatenation, multiplexing, and register control. It works with signal interfaces represented as `t` values, enabling synthesis and simulation workflows where synchronous FIFO behavior must be modeled with precise width management and signal assignment. Specific use cases include hardware design tasks like pipelining data paths, connecting input/output wires with customizable naming, and ensuring correctness through width validation during simulation.",
      "description_length": 605,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between a structured interface and an association list indexed by field names. It supports serialization and deserialization of interface values using string keys. Useful for dynamic field access or mapping interface data to and from external representations like configuration files or network payloads.",
      "description_length": 313,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines port names, widths, and associated tags for a synchronous FIFO interface. It provides direct access to lists of port names, their corresponding bit widths, and a list of tags associated with the interface. Concrete use cases include generating signal declarations, wiring connections, and validating interface compatibility in hardware descriptions targeting Xilinx FPGAs.",
      "description_length": 392,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to manipulate synchronous FIFO interfaces using the Always API, specifically for Xilinx targets. It supports operations like assigning signals to interface variables, creating registers and wires with optional naming conventions. Use cases include building and connecting FIFO interfaces in hardware descriptions with named signals and controlled assignments.",
      "description_length": 390,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a nested structure of computations, where each element is wrapped in a monadic type `M`, into a single monadic value containing a collection of results. It works with 2D write port structures configured under a specific memory implementation. Use it to sequence memory write operations across a grid of ports, aggregating their results into a unified monadic context.",
      "description_length": 421,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between a custom data structure and an association list mapping string keys to values. Works directly with lists of key-value pairs and a module's internal representation. Useful for serializing or inspecting port-based configurations where each entry corresponds to a named port.",
      "description_length": 289,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D write ports specialized for bit-level signals. It supports concrete operations like packing/unpacking interfaces into vectors, multiplexing, concatenation, and priority/one-hot selection with valid signals. Use cases include building memory write interfaces with precise bit-width control, validating port configurations, and composing memory access logic in hardware designs.",
      "description_length": 439,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines port names, widths, and associated tags for RAM components with resizing capabilities. It provides direct access to lists of port names, their corresponding bit widths, and a list of tags identifying the ports. It is used to configure and generate RAM instances with specific port configurations in hardware designs.",
      "description_length": 336,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between an interface type and an association list indexed by field names. It supports data types that can be represented as key-value pairs, such as records with named fields. Useful when mapping hardware interface signals to a list of named values for inspection or configuration.",
      "description_length": 290,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that combines a collection of monadic values within a 1D read port structure, lifting the monad outside the port interface. It operates on types structured as `'a M.t t`, where `t` represents a 1D read port and `M` is a monadic context. A concrete use case is aggregating multiple register-read operations within a memory interface into a single monadic computation, enabling sequential memory access patterns.",
      "description_length": 448,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for constructing and manipulating 2D memory read ports with a specialized configuration. It supports operations like packing/unpacking interfaces into vectors, multiplexing, concatenation, and priority/onehot selection, while validating signal widths. It works with a configured combinational type `comb` and structured memory port types, enabling precise control over memory interface behavior in hardware designs.",
      "description_length": 467,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines port names, widths, and associated tags for hardware components. It provides direct access to lists of port names, widths, and predefined tags for use in hardware description and configuration. Concrete use cases include specifying interface signals for FPGA primitives or generating signal documentation.",
      "description_length": 325,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to construct and manipulate 2D write ports using the Always API, enabling direct assignment, registration, and naming of signals within an interface. It works with `Always.Variable.t` and `Signal.t` types, specifically tailored for memory configurations that mix storage elements like URAM and BRAM. Concrete use cases include defining write port logic in an `always` block, creating register or wire variables for memory fields, and applying signal names with custom prefixes or suffixes.",
      "description_length": 520,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module provides direct conversions between its structured type and association lists indexed by field names, enabling programmatic access and construction of memory read port configurations using string keys. It operates on data structures that map string identifiers to arbitrary values, specifically tailored for interfacing with 2D memory read ports. Concrete use cases include dynamically generating or inspecting memory port configurations based on named fields, such as mapping specific memory regions to their respective implementations.",
      "description_length": 549,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to manipulate and assign signals within an always block using a structured interface. It supports creating registers and wires with specified properties, and applying naming conventions to interface fields. Concrete use cases include building and connecting hardware components like memory blocks or state machines with precise signal handling and naming control.",
      "description_length": 395,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for constructing and manipulating 1D write ports with specific field widths. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/one-hot selection with valid signals. Concrete use cases include building memory write ports with fixed or dynamic field widths for FPGA implementations using Xilinx primitives.",
      "description_length": 426,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing combinational logic (e.g., multiplexing, concatenation, packing), signal conversion from integers, and instantiating registers or pipelines, while supporting imperative-style signal assignment and hierarchical naming. It works with hardware signals represented as `Hardcaml.Signal.t` and `I.Of_signal.t`, enabling precise control over signal routing and state elements in digital circuits. Typical use cases include implementing data path control logic, pipelined datapaths, and structured signal management in FPGA designs targeting Xilinx devices.",
      "description_length": 598,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between a structured interface and an association list indexed by field names. Works with any record-like structure where fields are identified by strings. Useful for dynamically inspecting or constructing interfaces based on named fields, such as mapping hardware ports to values.",
      "description_length": 290,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.All",
      "library": "hardcaml_xilinx",
      "description": "This module combines monadic values within an interface structure, lifting the monad outside the interface. It operates on interface types parameterized by a monad, allowing the composition of multiple monadic interface elements into a single interface with a combined monadic result. A concrete use case is aggregating multiple register or signal updates in a hardware description into a single monadic action that can be executed or simulated together.",
      "description_length": 454,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to manipulate and assign values to hardware description primitives in a hardware construction context. It works with types like `Hardcaml.Always.Variable.t`, `Hardcaml.Signal.t`, and `Hardcaml.Reg_spec.t`, enabling direct signal assignment, register creation, and naming customization. Concrete use cases include building synchronous logic with registers, creating combinational signals, and applying hierarchical names to signals for debugging and synthesis.",
      "description_length": 491,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides structural operations for signal manipulation, including concatenation, multiplexing, register creation, and interface packing/unpacking, alongside utilities for connecting signals and defining hierarchical wire interfaces. It operates on signal types (`t`) and interface descriptions, supporting named input/output declarations and name transformations to enforce design conventions. These capabilities are used to construct and validate hardware components during synthesis, simulate signal behavior, and manage complex interface hierarchies in digital circuit designs.",
      "description_length": 592,
      "index": 82,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a nested structure of computations into a single combined computation. It works with types that represent read ports and monadic values. A concrete use case is combining multiple read port operations into a unified operation when building memory circuits.",
      "description_length": 309,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D write port interfaces using signal-based wiring, focusing on memory configuration specialization. It works with `Signal.t` values and memory configurations to enable tasks like signal concatenation, multiplexing, register insertion, and validated width transformations, while enforcing naming conventions for clarity in hardware descriptions. Typical use cases include implementing memory interfaces with mixed storage elements (e.g., URAM/BRAM splits) and ensuring correct signal routing with pipelined or registered data paths.",
      "description_length": 592,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between a custom data structure and an association list mapping string keys to values. Works directly with lists of key-value pairs and a module-specific type `'a I.t`. Useful for serializing or deserializing port-based configurations where each port name is associated with a value.",
      "description_length": 292,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to construct and manipulate 1D read port interfaces using the Always API, specifically for memory configurations that combine URAM and BRAM resources. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Concrete use cases include implementing memory read ports with customizable storage backends and generating named signal interfaces for hardware description.",
      "description_length": 461,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to manipulate interface containers of variables within an `Always` block. It supports creating registers, wires, assigning signals, and naming variables with optional prefixes or suffixes. Concrete use cases include building and connecting hardware components like RAMs or state machines using structured interfaces.",
      "description_length": 348,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating hardware signals, focusing on combinational logic, multiplexing (including priority and one-hot selection), register instantiation, and pipeline creation. It works with `Hardcaml.Signal.t` values, offering utilities for signal assignment (`<==`), input/output access, and renaming signals with customizable strategies. These capabilities are used to design digital circuits, manage signal flow in synchronous logic, and organize hierarchical designs through structured naming conventions.",
      "description_length": 554,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D write ports specialized with a memory configuration, working with combinatorial logic types. It supports concrete tasks like packing/unpacking interfaces to vectors, multiplexing, concatenation, and priority/one-hot selection with valid signals. Use cases include building configurable memory write ports with precise bit-width control and routing logic for FPGA implementations.",
      "description_length": 442,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D read port interfaces specialized to specific bit widths. It supports constant initialization, packing/unpacking, multiplexing, concatenation, and selection operations tailored for memory configurations using concrete `Bits.t` types. Use cases include building and validating memory read ports with precise width constraints, enabling efficient hardware description for synthesis.",
      "description_length": 442,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D write ports for specialized memory configurations using bit-level signals. It supports concrete tasks like packing/unpacking interfaces into vectors, multiplexing, concatenation, and priority/one-hot selection with validation of signal widths. Use cases include implementing memory write logic with configurable storage elements and signal routing in hardware designs.",
      "description_length": 431,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for creating and manipulating hardware description constructs such as registers, wires, and signal assignments. It works with types like `Always.Variable.t`, `Signal.t`, and `Reg_spec.t`, enabling direct circuit description within an `Always` block. Concrete use cases include defining synchronous register updates with `reg`, assigning combinational logic with `assign`, and creating named signals using `apply_names`.",
      "description_length": 451,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bit vector signals with a focus on hardware description tasks such as signal routing, selection, and width validation. It works directly with bit vectors (`Bits.t`) and structured signal types (`t`), supporting operations like packing/unpacking, multiplexing, concatenation, and priority/one-hot selection. Concrete use cases include building register files, control logic, and bus multiplexers in digital circuit designs.",
      "description_length": 488,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for structural signal composition, register pipelining, and hierarchical signal naming in hardware designs. It works with combinational logic signals (`comb`) and registered signal interfaces (`t`), enabling tasks like multiplexing, concatenation, and name-scoped IO wire creation. Specific use cases include constructing register pipelines, defining hierarchical hardware modules with transformed signal names, and managing complex signal routing through structural combinational logic.",
      "description_length": 519,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides signal-level manipulation and wiring utilities for 1D memory read port interfaces, enabling operations like validation, multiplexing, concatenation, and pipeline register insertion while enforcing bit-width correctness. It works with `Read_port_1d.t` configurations and `Of_signal`-wrapped types to model RTL signal transformations, with use cases in constructing memory-mapped hardware interfaces, connecting signals via named ports, and generating synthesizable register pipelines for timing-critical paths.",
      "description_length": 530,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines signal names, widths, and associated tags for hardware ports in a Xilinx Sysmone1 component. It provides direct access to lists of port names, widths, and precomputed tags for use in signal mapping and hardware description. These values are used to configure and connect analog-to-digital conversion interfaces in FPGA designs.",
      "description_length": 347,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating synchronous FIFO interfaces with valid signals represented as bit vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing and concatenating interface values, and validation of signal widths. Concrete use cases include constructing and validating hardware interfaces for Xilinx FIFOs, selecting between multiple interface options with priority or one-hot encoding, and converting between integer values and bit-level representations.",
      "description_length": 517,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Signed",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with signed binary vectors, including arithmetic operations like addition, subtraction, and multiplication, which return results with appropriate bit-width extensions to prevent truncation. It supports comparison operations between signed vectors of differing widths and includes a resize function to adjust vector widths with correct sign extension. These capabilities are used for implementing bit-accurate signed integer arithmetic and comparisons in hardware description code targeting Xilinx FPGAs.",
      "description_length": 547,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Uop",
      "library": "hardcaml_xilinx",
      "description": "This module implements unsigned arithmetic and comparison operations on bit vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It operates directly on `t` values, which represent hardware signals or bit vectors, and handles automatic width extension during operations. Use cases include building combinational logic circuits such as ALUs, counters, and control logic where precise bit-level manipulation and arithmetic are required.",
      "description_length": 481,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for specializing 2D write port configurations through width-based refinement, supporting transformations like mapping, folding, and associative lookups over tagged memory port representations. It works with tuples of write ports, bit vectors, signals, and always blocks, enabling structured manipulation of multi-field memory interfaces. Key use cases include FPGA memory synthesis with mixed storage elements (e.g., URAM/BRAM), width-aware signal packing/unpacking, and monadic aggregation of port metadata under strict naming and bit-width constraints.",
      "description_length": 586,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for transforming and combining synchronous FIFO interfaces in FPGA designs, including multi-input mapping, zipping, folding, and conversions between interface structures and lists or bit vectors. It works with polymorphic interface data structures representing hardware ports with names and widths, enabling dynamic traversal, signal declaration, and validation workflows. Key use cases include structured register/wire manipulation in always blocks, metadata-driven interface construction, and monadic validation of signal topologies for Xilinx targets.",
      "description_length": 586,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module implements bit-level operations for constructing and manipulating Xilinx ICAP3 configurations using `Bits.t` values. It provides functions to pack and unpack values, perform multiplexing (including priority and one-hot selection), and validate signal widths. Concrete use cases include assembling configuration commands for FPGA reprogramming and decoding status responses from the ICAP3 interface.",
      "description_length": 410,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M",
      "library": "hardcaml_xilinx",
      "description": "This module defines a type abbreviation for 2D write ports parameterized by a module `M`, enabling concise type signatures when working with 2D memory configurations. It operates on `Hardcaml_xilinx.Memory_builder.Write_port_2d.t`, which represents write ports for 2D memory structures. Use this to declare and manipulate 2D memory write ports with specific underlying types, such as when configuring mixed memory implementations (e.g., URAM and BRAM) across different bit ranges.",
      "description_length": 480,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Unsigned",
      "library": "hardcaml_xilinx",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors in the Xilinx Unisim library. It provides addition, subtraction, multiplication, and comparisons like less than or equal, directly on `v` type vectors, which are derived from `Comb.t` signals. Use cases include building custom digital logic circuits where operations on unsigned binary values are required, such as counters, arithmetic units, or control logic in FPGAs.",
      "description_length": 454,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Unsigned",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with unsigned binary vectors in hardware description code. It supports arithmetic operations like addition, subtraction, and multiplication, with automatic bit-width extension to prevent truncation, along with comparison operators for equality and ordering. These operations are used to model and synthesize digital circuits involving unsigned integer signals, such as counters, arithmetic logic units, and control logic.",
      "description_length": 465,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.All",
      "library": "hardcaml_xilinx",
      "description": "Reorders nested module structures by flipping the order of two applicative layers. Works with nested tuples of hardware description types, specifically transforming a structure containing a tuple of modules into a tuple of structures. Useful for reorganizing hardware interface descriptions when mapping between different abstraction layers.",
      "description_length": 341,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for transforming structured hardware descriptions, combining signals through combinational logic, and mapping hierarchical designs to Xilinx primitives. It primarily works with hardware signals (`O.t`), association lists, and port configurations, enabling manipulation of synchronous circuits via register blocks and conversion between structured types and signal lists. Key use cases include constructing FPGA designs with ADC interfaces, synthesizing digital circuits, and managing low-level signal mappings with tagged port definitions.",
      "description_length": 571,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for creating and manipulating hardware description constructs such as registers, wires, and named signals within an always block. It supports data types like `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t`, specifically for building synchronous and combinational logic. Concrete use cases include defining register transfers, assigning signals to variables, and applying naming conventions to signals for clarity in generated hardware descriptions.",
      "description_length": 485,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config",
      "library": "hardcaml_xilinx",
      "description": "This module supports transforming and wiring 1D read port interfaces specialized with memory configurations through operations like zipping, mapping, and combinatorial logic, while managing bit-level precision and field metadata. It operates on structured configurations of type `Read_port_1d.t`, association lists, and signal-level representations to enforce type-safe memory read path construction. Specific use cases include modeling RTL memory hierarchies with mixed implementations (e.g., URAM/BRAM splits), validating port configurations, and generating bit-width-aware memory interfaces for FPGA synthesis.",
      "description_length": 613,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module supports constructing and manipulating Xilinx ICAP3 interface signals through operations like signal conversion (`of_int`, `pack`/`unpack`), multiplexing (`mux`, `priority_select`), register/pipeline creation (`reg`, `pipeline`), and structural wiring (`concat`, `assign`). It operates on signal types representing ICAP3 interface fields, which model combinational logic and register specifications. These capabilities are used in FPGA configuration logic, ICAP3 interface implementation, and hardware verification testbenches requiring precise register transfers or hierarchical signal naming.",
      "description_length": 606,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Sop",
      "library": "hardcaml_xilinx",
      "description": "This module implements signed arithmetic and comparison operations for bit vectors or signals, including addition, subtraction, multiplication, and comparisons like less than or equal. It supports operations on `t` values, automatically handling sign extension and resizing to prevent truncation. Use this module to perform low-level signed computations directly on hardware signals in Xilinx synthesis flows.",
      "description_length": 409,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize",
      "library": "hardcaml_xilinx",
      "description": "The module provides polymorphic operations and combinators for manipulating 1D memory write ports with fixed field widths, supporting transformations like zipping, folding, and monadic sequencing. It works with dynamically constructed collections of named write ports (`'a t`) and interfaces expressed as bit-level, signal-level, or always-block-based representations. These utilities are specifically used to generate optimized Xilinx FPGA memory ports with precise width handling, enabling tasks like pipelining, multiplexing, and signal naming in hardware designs.",
      "description_length": 567,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a nested module structure into a flattened representation, enabling traversal and manipulation of nested hardware description components. It operates on data types involving nested tuples or records within a module type `M`. A concrete use case includes simplifying hierarchical hardware designs for simulation or synthesis by collapsing nested signal structures into a single level.",
      "description_length": 437,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to specialize 1D write port configurations for mixed-technology memories (e.g., URAM, BRAM), enabling operations like mapping, zipping, and per-port configuration via association lists. It works with `Write_port_1d.t` types, tuples, and Xilinx-specific memory configurations to handle tasks such as combinatorial logic manipulation, bit vector transformations, and strict width validation. Specific use cases include constructing memories with heterogeneous storage elements (e.g., assigning different bit ranges to URAM vs. BRAM) and implementing pipelined write operations with precise hardware constraints.",
      "description_length": 640,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with always blocks in the context of Xilinx ICAP3 primitives. It supports creating and manipulating registers, wires, and signal assignments with naming conventions applied to signals. Concrete use cases include implementing synchronous logic with enable conditions, connecting signals in a structured way, and applying consistent naming to generated hardware signals for synthesis and debugging.",
      "description_length": 440,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M",
      "library": "hardcaml_xilinx",
      "description": "This module defines a 1D write port type for memory implementations, parameterized by a module `X` that determines the underlying data representation. It provides a type alias `'a t` that simplifies the use of `Hardcaml_xilinx.Memory_builder.Write_port_1d.t` in type signatures when working with custom data types. It is used to construct and manipulate memory write ports with specific configurations in type declarations.",
      "description_length": 423,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I",
      "library": "hardcaml_xilinx",
      "description": "This module enables structured manipulation of hardware interfaces for RAM components with resizing support, using named ports, bitvectors, and signals. It provides operations like mapping, zipping, folding, and converting interfaces to association lists, alongside combinational logic and signal assignment tools. These features are used to define configurable RAM instances, register files, and validate digital circuits through dynamic port configurations and tagged signal transformations.",
      "description_length": 493,
      "index": 117,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Signed",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with signed fixed-width bit vectors, including arithmetic operations like addition, subtraction, and multiplication, which return results with extended width to prevent truncation. It supports comparison operations between vectors of differing widths and includes a resize function for adjusting vector width with appropriate sign extension. These operations are used for implementing low-level digital circuit logic where signed integer behavior is required, such as in arithmetic logic units or control logic in FPGAs.",
      "description_length": 564,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module enables the construction and transformation of signal-based interfaces for hardware designs, offering operations like multiplexing, signal conversion, and register pipeline creation. It operates on structured signal types aligned with Xilinx ICAP port layouts, facilitating tasks such as FPGA configuration control and I/O interface synthesis. Use cases include implementing hardware control logic, routing signals in programmable devices, and managing register-based data paths.",
      "description_length": 491,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module implements combinational logic operations for a specific hardware description type, supporting values of type `comb` and structured records of type `t`. It provides functions for packing/unpacking, multiplexing (including 2-way and priority-encoded), concatenation, and one-hot selection, along with validation and width manipulation. Use cases include building and transforming register-transfer level (RTL) descriptions for FPGA configurations, particularly for Xilinx devices using the ICAP interface.",
      "description_length": 516,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Uop",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for performing arithmetic and comparison on unsigned bit vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with `t` values, which represent bit vectors, and includes resizing and width-aware operations to prevent truncation. Concrete use cases include implementing digital circuits with precise bit-level control, such as arithmetic logic units or comparators in hardware designs.",
      "description_length": 480,
      "index": 121,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinators for constructing and transforming synchronous FIFO interfaces with valid signaling, supporting tuple operations (`zip5`, `mapN`), list conversions (`of_interface_list`, `to_interface_list`), and monadic aggregation (`All`, `or_error_all`). It operates on typed interface structures with named ports and bit widths, alongside bits, signals, and registers, leveraging modules like `Make_comb` for combinational logic and `Of_always` for register/wire creation. Designed for Xilinx-targeted hardware, it facilitates tasks like pipeline control, multiplexing, and dynamic field access in FIFO-based dataflow pipelines.",
      "description_length": 647,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module implements combinational logic operations for a specific hardware description type, supporting value conversion, width validation, and bit-level manipulation. It provides functions for packing/unpacking values, multiplexing, concatenation, and priority/one-hot selection with typed combinational signals. Use cases include constructing and validating register-transfer level (RTL) descriptions for Xilinx ICAP interfaces with precise bit-width control.",
      "description_length": 464,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between a structured record type and an association list mapping string names to values. It operates on records containing port data, enabling direct access and manipulation of port values by name. This is useful for dynamically inspecting or constructing port configurations in hardware descriptions.",
      "description_length": 310,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O",
      "library": "hardcaml_xilinx",
      "description": "This module provides structured manipulation of hardware interfaces through operations like mapping, zipping, and folding over signal tuples, with support for dynamic resizing and monadic transformations. It works with bit vectors, signal interfaces, and records of monadic values, emphasizing structured signal processing and combinational logic. Key use cases include configuring Xilinx RAM ports with explicit naming and width handling, transforming signal containers in synchronous logic blocks, and building hierarchical hardware descriptions with type-safe composition.",
      "description_length": 575,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Uop",
      "library": "hardcaml_xilinx",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors, supporting addition, subtraction, multiplication, and comparisons between values of differing widths. It operates directly on types like `Bits.t` and `Signal.t`, providing functions to convert between them and perform width-aware resizing. These operations are used to model low-level Xilinx combinational logic where precise control over bit widths and overflow behavior is required.",
      "description_length": 470,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between a structured interface and an association list mapping port names to values. Works with any interface type `'a t` that represents a collection of named ports. Useful for serializing or inspecting interface signals by name, such as for debugging or configuration.",
      "description_length": 279,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bit-level representations of output configurations, primarily using `comb` and `t` types. It includes functions for packing/unpacking values, multiplexing, concatenation, and selection operations with support for validity signals and branching factors. Concrete use cases include building configurable output logic for hardware blocks, selecting between multiple output sources, and converting between integer and bit-level representations.",
      "description_length": 506,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Sop",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for performing arithmetic and comparison on signed bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It supports data types `Bits.t` and `Signal.t`, with automatic sign extension handled during operations. Use cases include implementing fixed-point arithmetic and building conditional logic based on signed value comparisons in hardware descriptions.",
      "description_length": 435,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize",
      "library": "hardcaml_xilinx",
      "description": "This module supports specialized manipulation of 1D memory read ports through bit-width-aware transformations, enabling operations like mapping, zipping, and converting between interface lists and bit-level representations. It works with fixed-width signals, named port configurations (`Read_port_1d.t`), and association lists to facilitate dynamic memory interface inspection, signal routing, and structural composition (e.g., combinational logic or register insertion). Key use cases include constructing Xilinx memory hierarchies with mixed URAM/BRAM primitives, defining port naming conventions, and handling width-specific signal alignment in hardware designs.",
      "description_length": 665,
      "index": 130,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines lists of port names and widths for hardware description in Xilinx ICAP v3 configurations. It includes separate accessors for names, widths, and associated tags. Useful for generating or analyzing interface signals in FPGA configuration logic.",
      "description_length": 262,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to specialize 2D write port configurations for memory implementations, supporting structured manipulation of tagged memory interfaces through mapping, folding, and combinators for zipping or sequencing operations. It works with record-shaped, tuple-based, and signal-valued data structures, enabling use cases like configurable memory interface generation with multiplexing, register insertion, and bit-level signal packing, while handling named field associations and error propagation during memory configuration.",
      "description_length": 547,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O",
      "library": "hardcaml_xilinx",
      "description": "This module enables structured manipulation of synchronous FIFO interfaces through operations like mapping, zipping, and folding over hardware port values (`'a O.t`), which encapsulate tagged, named signals with explicit widths. It supports bit-level transformations, signal routing, and dynamic field access via association lists, underpinning tasks like RTL configuration, interface serialization, and FPGA design validation. Key applications include multiplexing, packing/unpacking signals, and generating register logic in ASIC workflows using constructs like always blocks.",
      "description_length": 578,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for combining and transforming 2D memory read ports through zipping, mapping, folding, and scanning, along with utilities to convert between interface lists and structured port representations. It works with typed memory port configurations that associate named signals to bit-widths, often embedded in monadic contexts like `Or_error`, and supports mixed-resource FPGA memory implementations (e.g., URAM/BRAM) by enabling precise signal routing and register/wire management in synchronous blocks. Specific use cases include synthesizing memory ports with heterogeneous storage backends and automating port configuration for complex memory hierarchies.",
      "description_length": 684,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Signed",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with signed binary vectors, including arithmetic operations like addition, subtraction, and multiplication, which automatically handle sign extension and avoid truncation by returning results one bit wider. It supports comparison operations between signed vectors of differing widths and includes a resize function for adjusting vector widths with proper sign extension. These capabilities are used to model Xilinx primitives for signed arithmetic in hardware synthesis contexts.",
      "description_length": 523,
      "index": 135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Sop",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for performing signed arithmetic and comparisons on bit vectors, including addition, subtraction, multiplication, and resizing, with automatic sign extension. It supports `Bits.t` and `Signal.t` types, enabling direct manipulation of hardware signals in a combinational context. Concrete use cases include implementing arithmetic logic units (ALUs) and comparison-based control logic in Xilinx FPGAs.",
      "description_length": 432,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines lists of port names and widths for Xilinx ICAP3 interface signals, along with associated tags. It provides direct access to signal metadata used in hardware description, specifically for configuring and interacting with the ICAP3 primitive in Xilinx FPGAs. Use cases include generating signal declarations and mapping hardware interface properties during design elaboration.",
      "description_length": 394,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Unsigned",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with unsigned binary vectors, including arithmetic (addition, subtraction, multiplication) and comparison (less than, greater than, equality). It supports conversions to and from `Comb.t` signals and allows resizing vectors to specified widths with proper zero extension. These operations are used to model Xilinx primitive components in a synthesizable hardware description.",
      "description_length": 419,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I",
      "library": "hardcaml_xilinx",
      "description": "This module enables structured manipulation of hardware interfaces with named ports, supporting combinational logic synthesis through multi-input mapping, folding, and bit-level operations on signals. It provides register-level abstractions for sequential logic within always blocks and metadata utilities for port naming and width declarations. These capabilities target FPGA design tasks like RTL construction, signal transformation, and configuration with typed circuit representations.",
      "description_length": 489,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d",
      "library": "hardcaml_xilinx",
      "description": "This module defines 2D write ports for memory configurations, supporting operations like mapping over write data and enabling conditional writes via an enable signal. It works with `Hardcaml.Signal.t` for addresses and enables, and user-defined data types for write data. Use it to construct and manipulate 2D memory write ports in mixed memory implementations, such as when combining URAM and BRAM across different bit ranges.",
      "description_length": 427,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for manipulating RAM port interfaces with a clear state. It supports construction from integers, packing/unpacking to bit vectors, multiplexing, concatenation, and priority/one-hot selection across lists of interfaces. These operations are used to implement control logic for RAM port arbitration and data path selection in FPGA designs.",
      "description_length": 389,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.M",
      "library": "hardcaml_xilinx",
      "description": "This module constructs memory implementations with a specified configuration, supporting 1D and 2D memory layouts. It works with `Hardcaml.Signal.t` values and configuration types to define memory behavior, such as choosing URAM or BRAM for specific bit ranges. Use it to build custom memory blocks tailored to hardware targets like FPGAs, where precise control over memory resources is required.",
      "description_length": 396,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Port_label",
      "library": "hardcaml_xilinx",
      "description": "This module defines labels for memory ports, supporting operations to convert values to S-expressions, compare port labels, and retrieve all defined labels. It works with the `t` type, which represents port identifiers as enumerated values `A` and `B`. Concrete use cases include labeling memory ports during memory configuration and enabling comparison and serialization for use in memory implementation selection logic.",
      "description_length": 421,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating RAM port interfaces using combinational logic, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection functions. It works with `t` values representing RAM port signals and supports concrete operations like width validation, constant assignment, and priority/one-hot selection. Use cases include building and validating RAM port configurations, selecting between multiple RAM port sources, and converting structured port data to compact vector representations for hardware synthesis.",
      "description_length": 568,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d",
      "library": "hardcaml_xilinx",
      "description": "This module defines a 1D write port type for memory implementations, parameterized by a module `X` that determines the underlying data representation. It provides functions to construct and manipulate write ports, specifically supporting type declarations with custom data types via the `M` submodule. Use cases include defining memory write operations in hardware descriptions where precise control over data storage and updates is required.",
      "description_length": 442,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Lut4",
      "library": "hardcaml_xilinx",
      "description": "Represents and manipulates 4-input lookup tables (LUTs) for Xilinx FPGA synthesis. Provides a constant `max_lut` indicating the maximum number of LUTs available in the target device. Useful for optimizing and validating circuit designs within hardware constraints.",
      "description_length": 264,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface",
      "library": "hardcaml_xilinx",
      "description": "This module implements synchronous FIFO primitives for Xilinx FPGAs with configurable parameters like capacity, latency, and memory type. It provides typed interfaces for dataflow pipelines, supporting operations such as hierarchical instantiation, signal routing, and validation of FIFO topologies. Concrete use cases include building pipelined datapaths, managing flow control with valid/ready handshakes, and generating XPM FIFO instances with custom signaling and buffering strategies.",
      "description_length": 489,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives",
      "library": "hardcaml_xilinx",
      "description": "This module provides bit-level manipulation, combinational arithmetic, and logical operations for fixed-width digital signals, primarily targeting Xilinx FPGA synthesis tasks like constant generation, bit vector resizing, and priority-encoded selection. It operates on hardware signals (`t`) representing signed/unsigned bit vectors, supporting operations such as logical reductions, tree-based computations, endianness-aware conversions, and arithmetic primitives like combinational multipliers. Specific use cases include modeling LUTs, implementing onehot/binary conversions, and handling signal truncation/extension with explicit sign control during FPGA synthesis.",
      "description_length": 669,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating RAM port interfaces represented as bit vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing and selecting between multiple interfaces, and validating signal widths. These functions are used to construct and manage RAM port configurations in hardware descriptions where each field corresponds to a specific bit width.",
      "description_length": 404,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_sequential_primitives",
      "library": "hardcaml_xilinx",
      "description": "Implements Xilinx-specific sequential primitives for FPGA synthesis, targeting signals and registers. Provides functions for D-type flip-flops with enable (fdce), D-type flip-flops with preset (fdpe), and single-port RAM (ram1s). Useful for modeling hardware behavior directly mapped to Xilinx FPGA elements in digital design workflows.",
      "description_length": 336,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.P",
      "library": "hardcaml_xilinx",
      "description": "This module provides preinitialized bit vectors and configuration parameters for setting up Xilinx SysMon hardware modules, primarily targeting FPGA calibration, temperature/voltage monitoring, and simulation settings. It operates on `Hardcaml.Logic.Bit_vector.t` values to define register initialization patterns, clock inversion flags, and mappings for user-defined monitoring logic. Specific use cases include configuring calibration registers, enabling hardware diagnostics, and specifying simulation file outputs for analog signal monitoring.",
      "description_length": 547,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives",
      "library": "hardcaml_xilinx",
      "description": "This module supports bit-level manipulation, arithmetic operations, and logical primitives for FPGA synthesis targeting Xilinx devices. It operates on fixed-width bit vector signals (`t`), enabling tasks like concatenation, comparison, and arithmetic computations while providing utilities for constant generation, endianness control, and signal conversion. Specific applications include implementing combinational circuits, arithmetic logic units, and custom data path components in hardware designs.",
      "description_length": 501,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines lists of port names paired with their bit widths, along with separate lists of just names and widths. It works with string and integer data types to describe memory port configurations. Use this module to retrieve structured port metadata for Xilinx RAM primitives, such as when generating HDL code or validating port connections.",
      "description_length": 350,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_comb_primitives",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic synthesis operations for constructing and transforming hardware signals, including bitwise operations (AND/OR/XOR/NOT), arithmetic (addition, subtraction, signed/unsigned multiplication), and comparisons (equality, less-than). It operates on a signal type `t`, enabling use cases like arithmetic logic unit design, control circuit implementation, and bit-level manipulation in FPGA-targeted hardware description workflows. Key primitives support hierarchical composition through concatenation, bit selection, and multiplexer generation.",
      "description_length": 577,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.All",
      "library": "hardcaml_xilinx",
      "description": "Lifts monadic values within a RAM port structure, transforming a port containing monadic values into a monad containing a port value. Works with RAM port types parameterized over a monad. Useful for sequencing memory operations in a monadic context while preserving port structure.",
      "description_length": 281,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make",
      "library": "hardcaml_xilinx",
      "description": "This module implements primitives for instantiating and configuring Xilinx System Monitor components, providing operations to create and manipulate analog-to-digital converter (ADC) interfaces. It works with hardware signals, port configurations, and attribute lists to define and synthesize monitoring circuits for FPGA-based systems. Concrete use cases include integrating on-chip temperature and voltage sensing into hardware designs and generating corresponding RTL instances with custom parameters and attributes.",
      "description_length": 518,
      "index": 156,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Maps between a RAM port interface and an association list where each entry corresponds to a port signal by name. Converts structured port configurations to string-keyed lists and reconstructs port configurations from such lists. Useful for serializing or dynamically configuring RAM port settings using named fields.",
      "description_length": 316,
      "index": 157,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_sequential_primitives",
      "library": "hardcaml_xilinx",
      "description": "Implements Xilinx Unisim sequential primitives for FPGA synthesis. Provides `fdce`, `fdpe`, and `ram1s` functions to model flip-flops with enable/clear and single-port RAM behaviors, operating on `Hardcaml.Signal.t` values. Used to directly map hardware descriptions to Xilinx FPGA primitives during synthesis.",
      "description_length": 310,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that lifts monadic values within a RAM port interface, combining them into a single monadic result. It operates on data structures of type `'a Ram_port_with_clear.t`, which represent RAM port configurations with a clearing mechanism. A concrete use case is sequencing multiple RAM port operations into a single transaction while preserving the port's state behavior.",
      "description_length": 404,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Config",
      "library": "hardcaml_xilinx",
      "description": "This module defines configuration options for building memories with specific RAM instantiations, such as XPM or inferred RAMs, and specifies memory dimensions, read latency, and output behavior. It works with records containing memory parameters like data width, cascade height, and instantiation methods, along with helper functions to compute derived values such as index widths and total read latency. Concrete use cases include creating 1D memory configurations with a specified depth and bit width, or combining multiple RAM architectures for different memory regions in a 2D layout.",
      "description_length": 589,
      "index": 160,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines and exposes the names and widths of RAM ports used in a state machine for clearing a RAM via one of its ports. It provides direct access to port metadata as lists of strings, integers, and tags. This data supports logic that dynamically handles port configurations during RAM initialization or reset sequences.",
      "description_length": 330,
      "index": 161,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to construct memory implementations with configurable storage elements like URAM or BRAM, supporting 1D and 2D memory layouts. It operates on configuration types that specify memory instantiation strategies and works with signals and scopes for integration into hardware designs. Concrete use cases include building pipelined memory blocks with specified latencies and resource allocations for FPGA targets.",
      "description_length": 438,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.For_deriving",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions for building and configuring memory structures with support for 1D and 2D memory layouts. It works with memory configurations that specify storage elements like URAM and BRAM for different bit ranges. Use this module to define custom memory implementations tailored to specific hardware constraints and access patterns.",
      "description_length": 350,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_sequential",
      "library": "hardcaml_xilinx",
      "description": "Implements sequential logic elements for synthesis, providing a `reg` function to create clocked registers with enable control. Works with `Hardcaml.Signal.t` values to represent register inputs, outputs, and control signals. Used to model synchronous storage elements in hardware designs targeting Xilinx FPGAs.",
      "description_length": 312,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Lut6",
      "library": "hardcaml_xilinx",
      "description": "This module defines a constant `max_lut` representing the maximum number of LUT6 elements available in a Xilinx FPGA target. It is used to constrain and optimize hardware synthesis by limiting the number of lookup tables used in circuit design. This value is essential for resource estimation and ensuring designs fit within specific FPGA device limits.",
      "description_length": 353,
      "index": 165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to manipulate and validate a RAM port interface with clearing functionality, using bit vectors. It supports constructing, packing, unpacking, and multiplexing interfaces, along with setting constant values and checking signal widths. Concrete use cases include configuring RAM ports with predefined constants, validating port signal widths during simulation, and selecting between multiple RAM port configurations using multiplexers.",
      "description_length": 465,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Lut_equation",
      "library": "hardcaml_xilinx",
      "description": "This module represents Boolean expressions for generating LUT initialization values in Xilinx synthesis. It provides logical operators to construct expressions from input variables (i0-i5) and constants (gnd, vdd), and evaluates them to 64-bit integers. Use it to define custom LUT contents for FPGA synthesis directly from OCaml code.",
      "description_length": 335,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make",
      "library": "hardcaml_xilinx",
      "description": "This module implements configurable RAM components with independent read and write address/data widths, supporting dynamic resizing and structured signal manipulation. It operates on bitvectors, signal interfaces, and hardware description records to enable precise control over Xilinx RAM port configurations. Concrete use cases include building register files with mismatched port widths, transforming signal containers in synchronous logic, and validating digital circuits through dynamic interface reconfiguration.",
      "description_length": 517,
      "index": 168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module suite supports operations for packing, unpacking, muxing, and concatenating RAM port interfaces represented as combinational signals, alongside utilities for creating register pipelines and managing signal hierarchies. It works with Xilinx-specific RAM port abstractions that include clear functionality, enabling precise control over signal routing, naming conventions, and state machine integration. These tools are particularly useful for FPGA development tasks requiring fine-grained RAM port management, such as implementing memory initialization sequences or synchronizing clear operations in hardware designs.",
      "description_length": 628,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D memory read ports, supporting typed signal routing and transformation through functions like map, fold, and zip. It works with structured port configurations that define named signals and bit-widths, often used in monadic contexts for error handling during memory synthesis. Concrete use cases include configuring memory ports that span multiple FPGA resources (e.g., URAM and BRAM) and automating the generation of complex, hierarchical memory interfaces with precise control over register and wire placement.",
      "description_length": 573,
      "index": 170,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module enables the construction and manipulation of RAM port interfaces using signal-based combinational logic, supporting operations like constant assignment, bit vector conversion, multiplexing, concatenation, and priority/one-hot selection. It works with signal representations of RAM ports to facilitate hardware description tasks such as register and wire creation, named signal wiring, and interface connectivity. Specific applications include modeling FPGA RAM primitives in HardCaml designs, managing complex signal routing with customizable naming, and synthesizing valid hardware descriptions for simulation or synthesis workflows.",
      "description_length": 646,
      "index": 171,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between RAM port records and association lists indexed by field names, enabling direct mapping of port fields to key-value pairs. Works with polymorphic RAM port types and string-keyed lists. Useful for inspecting or constructing RAM interfaces programmatically, such as during configuration or serialization tasks.",
      "description_length": 324,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to manipulate and assign signals within an always block for a RAM port interface. It supports creating register and wire variables, assigning values to them, and applying naming conventions to signal fields. Use cases include constructing and managing synchronous or combinational logic for RAM ports in hardware descriptions.",
      "description_length": 357,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d",
      "library": "hardcaml_xilinx",
      "description": "This module implements 1D read port interfaces for memory configurations, supporting operations like mapping, zipping, and signal routing over fixed-width signals and named port configurations. It works directly with association lists, bit-level representations, and memory configuration metadata to enable type-safe construction of memory read paths. Concrete use cases include building Xilinx memory hierarchies with mixed URAM/BRAM implementations, enforcing signal alignment, and generating synthesis-ready memory interfaces with precise bit-width handling.",
      "description_length": 561,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to manipulate and assign signals within an always block for a RAM port interface that includes a clear mechanism. It supports operations like registering signals with optional enables, creating wire variables, and assigning values while applying naming conventions to signals. Use cases include defining synchronous logic for RAM ports with reset behavior in hardware designs.",
      "description_length": 407,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Simple_dual_port_ram",
      "library": "hardcaml_xilinx",
      "description": "Implements a Xilinx-compatible simple dual-port RAM with separate read and write ports. It supports configurable read latency, memory architecture, byte-write width, and cascade height for synthesis optimization. This module is used to generate hardware descriptions for FPGA memories where independent read and write operations are required.",
      "description_length": 342,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Byte_write_width",
      "library": "hardcaml_xilinx",
      "description": "This module defines byte write width configurations for memory operations, supporting 8-bit, 9-bit, or full bus width. It is used to specify the granularity of write operations in memory interfaces, particularly when aligning with hardware constraints. Concrete use cases include configuring memory controllers and managing data alignment in FPGA-based systems.",
      "description_length": 361,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1",
      "library": "hardcaml_xilinx",
      "description": "This module provides preinitialized bit vectors and configuration parameters for Xilinx SysMon hardware modules, targeting FPGA calibration, temperature/voltage monitoring, and simulation settings. It operates on `Hardcaml.Logic.Bit_vector.t` values to define register initialization, clock inversion flags, and user monitoring mappings. Use cases include configuring calibration registers, enabling diagnostics, and specifying simulation outputs for analog signals.",
      "description_length": 466,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port",
      "library": "hardcaml_xilinx",
      "description": "This module provides structured manipulation of RAM port interfaces through operations like mapping, zipping, iteration, and conversion to association lists, operating on values containing metadata such as port names, bit widths, and tags. It supports bit-level transformations, signal-based logic, and monadic sequencing for modeling synchronous or combinational FPGA circuits, with utilities to validate configurations and aggregate port widths for HDL generation. Use cases include synthesizing memory ports in hardware designs and managing signal assignments within always blocks for Xilinx-targeted FPGA workflows.",
      "description_length": 619,
      "index": 179,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational and sequential logic primitives tailored for Xilinx FPGA synthesis. It includes modules for constructing LUT initialization values, implementing bit-level operations, arithmetic logic, and modeling Xilinx-specific flip-flops and RAMs. Use cases include defining custom LUT contents, implementing arithmetic units, and modeling synchronous storage elements directly mapped to FPGA hardware.",
      "description_length": 424,
      "index": 180,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_arch",
      "library": "hardcaml_xilinx",
      "description": "This module defines types and conversions for specifying Xilinx RAM primitive architectures, including distributed RAM, block RAM with configurable collision modes, and UltraRAM. It supports operations to convert these types to S-expressions and XPM parameter strings. Concrete use cases include configuring RAM behavior in XPM macro instantiations for FPGA synthesis and simulation.",
      "description_length": 383,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.True_dual_port_ram",
      "library": "hardcaml_xilinx",
      "description": "This module implements a true dual-port RAM with independent clocks for each port, supporting simultaneous read and write operations. It works with signal types for clocks, clears, and memory ports, and configures memory behavior through parameters like latency, architecture, and byte write width. Use it to model Xilinx dual-port block RAMs in FPGA designs, such as for buffering data between clock domains or implementing independent memory access in hardware pipelines.",
      "description_length": 473,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3",
      "library": "hardcaml_xilinx",
      "description": "This module directly instantiates a Xilinx Versal ICAP (Internal Configuration Access Port) primitive for low-level FPGA configuration control. It provides signal mappings for configuration commands, status flags, and data transfer with bit-level precision, targeting use cases like partial reconfiguration, bitstream loading, and hardware debugging on Xilinx FPGAs.",
      "description_length": 366,
      "index": 183,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_async",
      "library": "hardcaml_xilinx",
      "description": "Implements an asynchronous FIFO with configurable capacity, supporting independent read and write clocks, clear control, and data input/output signals. Works with `Signal.t` for control and data lines, and uses `Fifo_memory_type` to specify storage behavior. Useful for cross-clock domain data buffering in hardware designs, such as communication between modules operating on different clock frequencies.",
      "description_length": 404,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_memory_type",
      "library": "hardcaml_xilinx",
      "description": "This module defines types and conversions for specifying FIFO memory implementations in Xilinx FPGAs. It supports selecting between Auto, Block, Distributed, and Ultra memory types, and provides functions to convert these types to S-expressions and XPM parameter strings. It is used to configure memory backends for FIFOs in hardware descriptions targeting Xilinx devices.",
      "description_length": 372,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing",
      "library": "hardcaml_xilinx",
      "description": "This module implements configurable RAM components with independent read and write address/data widths, enabling dynamic resizing and structured signal manipulation. It operates on bitvectors, signal interfaces, and hardware description records to provide precise control over Xilinx RAM port configurations. Use cases include building register files with mismatched port widths, transforming signal containers in synchronous logic, and validating digital circuits through dynamic interface reconfiguration.",
      "description_length": 507,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Cascade_height",
      "library": "hardcaml_xilinx",
      "description": "This module defines the height of BRAM cascade chains, either inferred automatically or explicitly set to an integer value. It provides a function to convert the cascade height into arguments for XPM memory modules and supports serialization to S-expressions. It is used to control BRAM cascade behavior in Xilinx FPGA designs to improve timing closure.",
      "description_length": 353,
      "index": 187,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync",
      "library": "hardcaml_xilinx",
      "description": "Implements synchronous FIFO primitives for Xilinx FPGAs with configurable capacity, latency, and memory type. Provides typed interfaces for dataflow pipelines, supporting hierarchical instantiation, signal routing, and validation of FIFO topologies. Used for building pipelined datapaths, managing flow control with valid/ready handshakes, and generating XPM FIFO instances with custom buffering strategies.",
      "description_length": 407,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Collision_mode",
      "library": "hardcaml_xilinx",
      "description": "Represents and converts between collision resolution modes for memory operations. It supports conversion to S-expressions and XPM parameter strings. Used to specify behavior during memory read/write collisions in hardware descriptions.",
      "description_length": 235,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Dual_port_ram",
      "library": "hardcaml_xilinx",
      "description": "This module implements a dual-port RAM with a single clock domain, supporting simultaneous read and write operations on two independent ports. It works with signals and memory ports configured for Xilinx FPGA targets, allowing control over parameters like read latency, byte write width, and memory optimization. It is used to model on-chip memory blocks in hardware designs where concurrent access from two sources is required, such as in datapath or buffer implementations.",
      "description_length": 475,
      "index": 190,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for configuring and controlling RAM ports with integrated clearing mechanisms, focusing on state machine-driven initialization and synchronization. It works with structured representations of RAM ports, including tagged tuples and association lists, to manage metadata like names, widths, and control signals while enabling traversal, serialization, and logic synthesis. Specific use cases include FPGA designs requiring precise RAM reset behavior, such as synchronous memory initialization or dynamic port reconfiguration in hardware pipelines.",
      "description_length": 577,
      "index": 191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Clocking_mode",
      "library": "hardcaml_xilinx",
      "description": "This module defines clocking modes for hardware configurations, specifically supporting common and independent clock domains. It provides functions to convert clocking modes to S-expressions and XPM synthesis arguments. This is used to specify clocking behavior in Xilinx FPGA primitives during hardware compilation.",
      "description_length": 316,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder",
      "library": "hardcaml_xilinx",
      "description": "This module builds configurable 1D and 2D memory structures using Xilinx storage elements like URAM and BRAM, supporting mixed memory implementations across bit ranges. It defines port interfaces for reading and writing, with functions to set specialized read/write ports and compute memory characteristics like read latency. Use it to construct FPGA-optimized memory blocks with precise control over memory hierarchy, access patterns, and synthesis attributes.",
      "description_length": 461,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx",
      "library": "hardcaml_xilinx",
      "description": "This module provides hardware implementations of memory primitives optimized for Xilinx FPGAs, including dual-port RAMs, FIFOs, and memory configuration utilities. It operates on signal types and bitvectors to enable precise control over memory behavior in hardware descriptions, supporting features like byte write widths, cascade heights, and clocking modes. Concrete use cases include building on-chip memory blocks, managing cross-clock buffering, and configuring synthesis attributes for FPGA memory primitives.",
      "description_length": 516,
      "index": 194,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 198,
    "meaningful_modules": 195,
    "filtered_empty_modules": 3,
    "retention_rate": 0.9848484848484849
  },
  "statistics": {
    "max_description_length": 684,
    "min_description_length": 235,
    "avg_description_length": 450.85128205128206,
    "embedding_file_size_mb": 2.8263473510742188
  }
}