{
  "package": "hardcaml_xilinx",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 301,
  "creation_timestamp": "2025-07-16T00:16:50.645122",
  "modules": [
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating synchronous FIFO interfaces with valid signals, including packing/unpacking to vectors, multiplexing, concatenation, and selection functions like priority and one-hot encoding. It works with combinational logic types (`comb`) and structured interface types (`X_with_valid.t`) that carry valid bits. Concrete use cases include building and validating hardware pipelines, routing data between modules, and constructing complex signal routing logic in a synchronous design.",
      "description_length": 519,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module provides access to the names and widths of read ports configured for a 1D memory implementation, derived from a given memory configuration. It exposes lists of port names, port widths, and associated tags, enabling direct inspection and use of port metadata. Concrete use cases include generating signal names for synthesis, validating port configurations, and mapping memory ports to hardware resources.",
      "description_length": 416,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating synchronous FIFO interfaces using combinational logic. It supports packing and unpacking interfaces to and from bit vectors, multiplexing and concatenating interface values, and validating signal widths. These functions are used to build and verify hardware structures like data path multiplexers, constant initialization, and priority-encoded selections in FPGA designs.",
      "description_length": 420,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate write ports using the Always API, specifically for 2D memory configurations. It works with interfaces containing `Always.Variable.t` values, allowing registration, wiring, and assignment operations. Concrete use cases include building register or wire-based write ports with customizable enable signals and naming conventions.",
      "description_length": 382,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module provides direct conversions between a structured interface with valid signals and an association list indexed by field names. It operates on tuples of data and valid signals, mapping each field to its corresponding value. These functions are useful for dynamically constructing or inspecting interfaces from named data sources, such as configuration inputs or debug outputs.",
      "description_length": 386,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D read ports for specialized memory configurations using bit-level signals. It supports functions like packing/unpacking interfaces into vectors, multiplexing, concatenation, and selection operations with valid signals. These capabilities enable precise control over memory port behavior in hardware designs with mixed memory implementations.",
      "description_length": 403,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a list of monadic values into a monadic value of a list, effectively lifting the monad outside the structure. It operates on 1D read ports specialized for specific widths, working with `'a M.t t` and returning `'a t M.t`. Use this to sequence memory read operations across multiple ports where each port's result is wrapped in a monad, such as when handling effectful or deferred computations.",
      "description_length": 447,
      "index": 6,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly converts between an interface type and an association list mapping field names to values. It enables reading and writing interface fields by string key without type-safe guarantees. Useful for dynamic interface manipulation, such as parsing configurations or generating signal mappings from external data sources.",
      "description_length": 334,
      "index": 7,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block, specifically for 1D read port interfaces. It supports operations like assigning signals to variables, extracting signal values, and applying naming conventions to interface fields. Concrete use cases include building memory read ports with named, zero-initialized wires or registered signals under a given enable condition.",
      "description_length": 431,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines port configurations for RAM instances by specifying signal names and widths. It provides direct access to lists of port names, widths, and associated tags for memory interface generation. Useful for creating consistent signal mappings when integrating with synthesis tools or simulation environments.",
      "description_length": 320,
      "index": 9,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to construct and manipulate 1D write ports using Xilinx memory configurations, specifically within the Always API. It supports operations like assigning signals to variables, creating registers and wires with specified behaviors, and applying naming conventions to signals. Concrete use cases include defining memory write ports with precise timing and storage characteristics, such as implementing register files or memory-mapped I/O with BRAM or URAM backends.",
      "description_length": 493,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides signal-level operations for constructing and manipulating memory read port interfaces, including multiplexing, concatenation, selection, and pipeline register insertion. It operates on `Of_signal.t` and `Of_signal.comb t` types, enforcing bit-width correctness and enabling structured wiring of inputs, outputs, and named signals. These capabilities are used to implement specialized memory hierarchies with mixed storage elements (e.g., URAM-backed and BRAM-backed regions) as defined by configuration-driven specialization.",
      "description_length": 546,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module provides direct conversions between a record-like structure and an association list indexed by field names, enabling programmatic access and manipulation of memory read port configurations using string keys. It operates on types that represent memory read ports with named fields, allowing each field to be associated with a specific value in the list. Use this to dynamically construct or inspect memory port configurations based on runtime-known field names.",
      "description_length": 472,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module provides concrete names and widths for read ports in a 1D memory configuration. It defines lists of port names, widths, and tags used to specialize memory read interfaces based on bit ranges. Use this module when generating or customizing memory instances that require precise control over port layout and width, such as when targeting specific Xilinx memory primitives like BRAM or URAM.",
      "description_length": 400,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module provides concrete values for port names, widths, and tags derived from a specialized 2D write port configuration. It works with lists of strings, integers, and a `tag` type to represent memory port metadata. Use it to extract structured information about memory port configuration for code generation or verification tasks.",
      "description_length": 335,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly maps 2D write port configurations to specific memory implementations using field names as keys. It operates on association lists pairing string field names with memory configuration data, enabling precise per-port customization. Use it to define or extract memory configurations for 2D write ports by associating each port with its respective implementation settings.",
      "description_length": 388,
      "index": 15,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and transforming 2D write port interfaces using hardware signals, supporting tasks like constant assignment, signal routing, and pipeline insertion. It operates on combinatorial (`comb`) and registered (`t`) signal types to model memory write behavior with configurable data paths and port connectivity. Specific use cases include implementing memories with heterogeneous storage elements (e.g., URAM for wide data, BRAM for narrow metadata) and synthesizing write ports with structured naming conventions for tool integration.",
      "description_length": 576,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.S-Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D write port interfaces for memory systems, working with bit vectors and typed records. It supports concrete tasks like packing/unpacking interfaces, multiplexing between port configurations, and validating signal widths for correct memory mapping. Use cases include building configurable memory blocks with mixed storage backends like URAM and BRAM, and managing write operations with precise bit-level control.",
      "description_length": 473,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.S-Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and managing 1D memory write ports using signal interfaces, including constant assignment (`of_int`, `of_ints`), signal wiring (`wires`, `assign`), register insertion (`reg`, `pipeline`), and multiplexing (`mux`, `priority_select`). It operates on `Of_signal.comb t` and `Of_signal.t` types, which represent memory write port interfaces, and supports use cases such as building pipelined memory architectures, connecting signals with named ports (`<==`, `inputs`, `outputs`), and applying hierarchical naming conventions to signal fields. These utilities are particularly useful for implementing configurable memory systems with mixed storage elements like URAM and BRAM.",
      "description_length": 720,
      "index": 18,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module supports constructing and validating 1D read port interfaces by specializing signal-based memory operations, such as constant assignment, multiplexing, concatenation, and priority-encoded selection. It operates on `Of_signal.t` and `Of_signal.comb t` types, which represent hardware signal interfaces with strict width constraints enforced through validation functions. These capabilities are used to build memory subsystems where precise signal management, interface naming, and width-correct data transformations are required, such as in memory-mapped register files or pipelined data paths.",
      "description_length": 605,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bitvector combinational logic, including packing/unpacking integers, multiplexing, concatenation, and priority/one-hot selection. It works with types representing bitvectors and structured combinations of signals, supporting concrete tasks like decoding control signals or routing data paths. Use cases include implementing ALUs, control units, and data routing logic in hardware designs.",
      "description_length": 454,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a value containing nested module structures into a new structure with the same shape but with the inner and outer modules swapped. It works with data types that combine a module `M` and a type `'a I.t`, where `I` represents some internal structure or interface. A concrete use case is reorganizing hardware description components to facilitate different stages of circuit compilation or analysis.",
      "description_length": 450,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.S-All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a single operation, `all`, which lifts a list of monadic values into a monadic value of a list, preserving the structure. It works with types that have a monadic structure and are parameterized over a module `M`. A concrete use case is combining multiple signal write operations into a single action when constructing 2D memory write ports in Hardcaml hardware descriptions.",
      "description_length": 395,
      "index": 22,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for specialized 1D write ports configured with a specific memory implementation. It supports construction and validation of memory interfaces, packing/unpacking to vectors, multiplexing, concatenation, and selection operations with concrete bit widths. Use cases include implementing memory write paths with configurable storage elements like URAM or BRAM, and building multiplexed or constant-driven write interfaces.",
      "description_length": 470,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for constructing and manipulating 1D memory write ports with fixed field widths. It supports data types like vectors and records of integers, enabling concrete use cases such as packing/unpacking memory interfaces, multiplexing between write port configurations, and validating signal widths during synthesis. Functions like `mux`, `concat`, and `priority_select` allow precise control over memory write behavior in hardware descriptions.",
      "description_length": 490,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for constructing and manipulating 1D memory write ports with specific field widths. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/onehot selection, all while validating signal widths. Concrete use cases include building memory-mapped register files with fixed field widths and implementing control logic for memory write operations using constants, muxes, or dynamic selection.",
      "description_length": 503,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.S-Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating 2D memory write ports using signal interfaces, including signal packing/unpacking, muxing, concatenation, priority encoding, validation, and pipeline creation. It operates on combinational and registered memory port signals (`Of_signal.comb t` and `Of_signal.t`), enabling use cases such as implementing memory configurations with mixed storage resources (e.g., BRAM/URAM) and managing complex signal routing in hardware designs with priority-encoded write paths.",
      "description_length": 529,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly associates write port fields with string keys in an unsafe manner, enabling conversion between write port records and association lists. It operates on write port data structures, specifically translating record fields into key-value pairs. Use this when mapping hardware write ports to named configurations or dynamically constructing write ports from named value lists.",
      "description_length": 392,
      "index": 27,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating synchronous FIFO interfaces using combinational logic. It supports data types like `comb O.t` for representing structured interfaces and vectors for signal manipulation. Use cases include packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating interfaces, and implementing selection logic like priority or one-hot encoded selectors.",
      "description_length": 423,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to manipulate and assign signals within an always block using a structured interface. It supports creating registers and wires with customizable naming, enabling precise control over signal behavior in hardware descriptions. Concrete use cases include building and connecting register files, memory elements, or control logic with named fields directly in an always block.",
      "description_length": 404,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between an interface and an association list indexed by field names. Works with any interface type `'a I.t` and string-keyed lists of values. Useful for dynamically inspecting or constructing interfaces from named fields, such as in simulation or testbench generation.",
      "description_length": 277,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a list of monadic values into a monadic list, effectively lifting the monad outside. It operates on lists of monadic types, enabling composition of sequences where each element depends on the same monadic context. A typical use case is combining multiple signal reads in a circuit description, where each read depends on a shared configuration or state.",
      "description_length": 407,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to manipulate and assign values to synchronous FIFO interfaces using the Always API. It works with interface types containing register and wire variables, enabling direct signal assignments and naming conventions within always blocks. Concrete use cases include creating and managing register or wire interfaces for hardware description, such as initializing FIFO control signals or assigning computed values to interface fields.",
      "description_length": 460,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D write port interfaces for memory systems using signal-backed representations. It works with `comb` and `t` types that encode memory port fields with explicit bit-width constraints, enabling tasks like constant assignment, multiplexing, concatenation, and pipelining. These capabilities are used to model Xilinx memory primitives (e.g., BRAM, URAM) in FPGA designs, where signal connectivity, naming conventions, and hardware-specific transformations are critical for synthesis and verification.",
      "description_length": 557,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and transforming signal-based hardware interfaces through concatenation, multiplexing, register insertion, and structural validation. It works with signal interfaces (`I.Of_signal.t`), enabling precise control over signal connections, naming conventions, and hierarchical composition. These capabilities are particularly useful for FPGA development tasks requiring rigorous synthesis compatibility and simulation fidelity, such as implementing pipelined data paths or standardized bus interfaces.",
      "description_length": 545,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a 2D write port structure containing monadic values into a monadic value containing a 2D write port structure. It works with 2D write ports and is used to lift monadic computations to operate over the entire memory interface. A concrete use case is combining multiple memory write operations within a monadic context, such as propagating error handling or state changes across all ports simultaneously.",
      "description_length": 456,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bitvector interfaces using a combinatorial logic representation. It supports functions like packing/unpacking interfaces to vectors, multiplexing, concatenation, and selection operations such as priority and one-hot encoding. Concrete use cases include building custom register interfaces, implementing control logic, and managing signal routing in hardware designs.",
      "description_length": 432,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module enables constructing and manipulating hardware interfaces using signals (`O.Of_signal.t`) through operations like constant assignment, multiplexing, concatenation, and register pipelines, with a focus on signal-width validation and structural composition. It supports named wires, RTL attributes, and combinational logic at the interface level, working with typed signal representations and hierarchical interface structures. It is particularly useful for tasks like building register pipelines, multiplexers, or named signal hierarchies in synthesizable RTL designs.",
      "description_length": 579,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.S",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for transforming and combining 2D memory write port configurations, supporting iteration, mapping over tag-indexed port definitions, and structural manipulations like zipping or flattening nested collections. It operates on tuples of signals for combinational logic, association lists for named port groupings, and bit-level width specifications, enabling precise RTL synthesis of memories with heterogeneous storage elements (e.g., URAM/BRAM mixes). Key use cases include constructing write ports from procedural code blocks, converting between list-based and signal-based interface representations, and managing error-aware signal pipelines in hardware designs.",
      "description_length": 695,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between an interface type and an association list indexed by field names. Works with any interface type `'a I.t` and strings as keys. Useful for dynamically inspecting or constructing interfaces by name, such as in debugging or configuration-driven setups.",
      "description_length": 265,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bitvector interfaces using a combinatorial logic representation. It supports operations like packing/unpacking interfaces to/from bitvectors, multiplexing, concatenation, and priority/one-hot selection, with validation of signal widths. Concrete use cases include building custom register files, memory interfaces, and control logic with precise bit-level specifications.",
      "description_length": 437,
      "index": 40,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating synchronous FIFO interfaces using a combinational logic type. It supports data types including vectors, interfaces with typed fields, and multiplexed or concatenated structures. Concrete use cases include packing and unpacking FIFO signals, validating signal widths, and implementing priority or one-hot selection logic for interface multiplexing.",
      "description_length": 413,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for defining and manipulating registers and wires within an always block, specifically handling signal assignments and variable declarations. It works with data types such as `Hardcaml.Always.Variable.t`, `Hardcaml.Signal.t`, and `Hardcaml.Reg_spec.t`, enabling precise control over hardware behavior. Concrete use cases include creating named wires, applying register specifications with optional enable signals, and assigning signal values in a hardware description context.",
      "description_length": 508,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines the names and widths of read ports for 2D memory configurations. It provides direct access to port names, their corresponding data widths, and associated tags for identification. It is used to specify and retrieve the structure of read ports when building or analyzing memory systems with mixed storage implementations.",
      "description_length": 339,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between a custom data structure and an association list mapping string keys to values. It operates on types that can be represented as key-value pairs, where keys are port names. This is useful for serializing or deserializing hardware description data to and from a list format for inspection or configuration.",
      "description_length": 320,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating hardware signals with validity indicators in synchronous FIFO interfaces, including multiplexing, concatenation, priority selection, and pipeline register insertion. It operates on `X_with_valid.Of_signal.t` values, which bundle data signals with validity flags, enabling structured wiring and hierarchical naming through prefix/suffix customization. These utilities are used to implement robust signal routing and synchronization in FPGA or ASIC designs, ensuring correct data flow and clock domain crossing.",
      "description_length": 558,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly maps 1D write port fields to string keys in an association list, enabling direct conversion between record-like structures and key-value lists. It operates on `Write_port_1d.t` values, transforming them to and from `(string * 'a) list` representations. Use this when serializing or deserializing memory write ports using field names as identifiers, such as in configuration parsing or dynamic port assembly.",
      "description_length": 428,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.S-All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a single operation, `all`, which lifts monadic values from within a structure to the outer monadic context, similar to `Monad.all` for lists. It operates on types of the form `'a M.t t`, where `t` is a structure containing monadic elements parameterized by `M`. A concrete use case is combining multiple monadic computations embedded within a fixed structure into a single monadic result that contains the fully computed structure.",
      "description_length": 452,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to manipulate synchronous FIFO interfaces using the Always API, specifically for register and wire variable creation, signal assignment, and naming. It operates on `X_with_valid` interface structures containing `Always.Variable.t` values, supporting concrete operations like value extraction, signal binding, and register specification. Use this when implementing synchronous FIFO logic with named signals and structured assignments in an always block.",
      "description_length": 483,
      "index": 48,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bit vector signals, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with types like `comb` representing bit vectors and `t` for structured signal representations. Use cases include building digital circuits with multiplexers, priority encoders, and signal routing logic.",
      "description_length": 380,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D write ports specialized for bit-level memory interfaces. It supports concrete operations like packing/unpacking signals, multiplexing, concatenation, and selection logic (priority, one-hot) for memory configurations. Use cases include defining memory write ports with precise bit widths, validating signal widths, and building complex memory control logic with constant or dynamic inputs.",
      "description_length": 451,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides the `all` function, which combines values within an `X_with_valid` interface structure, lifting the monadic context outside. It operates on data types that include both a value and a validity signal, structured through the `X_with_valid` type. A concrete use case involves aggregating multiple monadic computations with validity signals into a single computation, ensuring all values are valid before proceeding.",
      "description_length": 433,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D read port interfaces specialized for a given combinational logic type. It supports concrete operations like packing/unpacking interfaces into vectors, multiplexing, concatenation, and priority/onehot selection, all validated against specified bit widths. Use cases include building memory read ports with precise width control and implementing selection logic for memory-mapped register interfaces.",
      "description_length": 461,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bitvector signals using a fixed-width interface. It supports functions like packing/unpacking bitvectors, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. Use cases include hardware description tasks such as signal routing, data path construction, and control logic implementation.",
      "description_length": 382,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines port metadata for a synchronous FIFO interface, including names and widths of ports, as well as associated tags. It provides direct access to lists of port names, port widths, and tag values as defined in the interface specification. Useful for generating register or signal declarations in hardware description code based on interface definitions.",
      "description_length": 368,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines port names, widths, and associated tags for a synchronous FIFO interface. It provides direct access to lists of port names, their corresponding bit widths, and predefined tags for signal identification. Useful for generating or analyzing FIFO interface signals in hardware descriptions.",
      "description_length": 306,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.S-Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating 2D memory write ports using a combinatorial interface. It supports data types involving 2D memory configurations with functions for packing/unpacking, multiplexing, concatenation, and priority/onehot selection on combinatorial signals. Concrete use cases include building configurable memory interfaces with dynamic field width validation and signal routing for FPGA implementations.",
      "description_length": 449,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating synchronous FIFO interfaces with valid signals in a hardware description context. It supports packing and unpacking interfaces to and from vectors, multiplexing between multiple interfaces, concatenation, and priority or one-hot selection based on valid signals. Concrete use cases include building and validating control logic for data pipelines, managing input selection in register files, and constructing constant-driven test stimuli for simulation.",
      "description_length": 502,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a signal of a composite type into a composite type of signals, effectively distributing the signal structure across its components. It operates on data types involving signals (`'a M.t O.t`) and restructures them into a form where each component is a signal (`'a O.t M.t`). This is particularly useful when handling complex data structures in hardware description, enabling individual manipulation of each signal within a composite value.",
      "description_length": 492,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.S",
      "library": "hardcaml_xilinx",
      "description": "This module enables structured creation and transformation of 1D memory write ports with named, tagged fields, supporting operations like mapping, zipping, and conversion between list-based and interface-based representations. It works with parameterized types `'a t` encoding port metadata (names, widths, tags), tuples of signals (up to 5 elements), and bit-level constructs, while providing combinators for folding and error aggregation. These features are used to build Xilinx memory implementations from always blocks, define signal port",
      "description_length": 542,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to manipulate interface containers using the Always API, including assigning signals to variables, creating registers and wires, and applying names to interface fields. It works with `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` values within an `O.t` interface structure. Concrete use cases include building and wiring hardware descriptions with named signals, conditional assignments, and register pipelines directly inside always blocks.",
      "description_length": 479,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a record of monadic values into a monadic record, effectively lifting the monad outside. It works with any monad `M` and records `'a O.t` where each field is wrapped in `M`. A concrete use case is combining multiple signal wires in a circuit description, where each wire is in a monadic context, into a single structured result.",
      "description_length": 382,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.S-Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating 1D write ports with combinational logic. It supports data types involving vectors and records of fixed bit widths, enabling tasks like packing/unpacking interfaces, multiplexing signals, concatenation, and priority/one-hot selection. Concrete use cases include building memory write ports with precise control over signal widths and combinational logic behavior.",
      "description_length": 428,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D read port interfaces specialized with a combinational logic type. It supports concrete operations such as packing/unpacking interfaces into vectors, multiplexing, concatenation, and selection logic (priority and one-hot). Use cases include building memory read ports with configurable field widths and implementing selection logic for memory access in hardware designs.",
      "description_length": 432,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D read ports specialized for bit-level interfaces, supporting constant assignment, packing/unpacking, multiplexing, concatenation, and selection logic. It works directly with `Of_bits.comb t` interfaces, representing memory fields with fixed bit widths. Concrete use cases include building memory read paths with precise bit-level control, validating port widths, and implementing priority or one-hot multiplexing for memory outputs.",
      "description_length": 494,
      "index": 64,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.All",
      "library": "hardcaml_xilinx",
      "description": "Lifts monadic values within an interface structure, transforming a collection of monadic interface elements into a single monadic interface. Works with interface types parameterized by a monad. Useful for composing hardware description components where each field is constructed in a monadic context.",
      "description_length": 300,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate write ports using the Always API, specifically for 2D memory configurations. It supports data types like `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t`, enabling direct assignment, register instantiation, and naming of signals within an interface. Concrete use cases include building memory write ports with custom signal initialization and structured naming in hardware descriptions.",
      "description_length": 446,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.S-module-type-Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for constructing and manipulating 2D memory write ports with fixed bit-width fields. It supports data types like vectors and records of constant or variable bit widths, enabling operations such as packing/unpacking, multiplexing, concatenation, and priority/one-hot selection. Concrete use cases include building configurable memory interfaces with mixed storage elements (e.g., URAM and BRAM) and validating signal widths during synthesis.",
      "description_length": 492,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.All",
      "library": "hardcaml_xilinx",
      "description": "Lifts monadic values within an interface to a monad containing the interface. Works with any monad `M` and interface type `'a I.t`. Useful for combining multiple monadic computations over an interface into a single computation.",
      "description_length": 227,
      "index": 68,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D read port interfaces specialized for combinational logic. It supports data types like `comb t` for representing structured memory fields and vectors for packing/unpacking. Concrete use cases include constant initialization, multiplexing, concatenation, and priority/one-hot selection on memory read ports.",
      "description_length": 368,
      "index": 69,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines port names, widths, and associated tags for RAM components with resizing capabilities. It provides direct access to lists of port names, their corresponding bit widths, and a list of tags that identify specific RAM configuration aspects. These values are used to describe and configure RAM interfaces in hardware designs targeting Xilinx FPGAs.",
      "description_length": 364,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating 2D read port configurations using combinational logic. It works with data types representing memory interfaces, specifically `comb t`, where each field has defined bit widths. Concrete use cases include packing/unpacking interfaces into vectors, multiplexing multiple interfaces, concatenating interfaces, and selecting between one-hot or priority-encoded inputs with optional branching factors.",
      "description_length": 461,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines lists of port names and widths for hardware simulation components, along with associated tags. It provides direct access to these lists through values like `port_names_and_widths`, `port_names`, `port_widths`, and `tags`. These values are used to specify and access port configurations in hardware descriptions, particularly when interfacing with simulation tools or generating testbenches.",
      "description_length": 410,
      "index": 72,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module provides direct conversions between a record-like structure and association lists indexed by field names, specifically for read port configurations in a memory system. It enables programmatic manipulation of read port fields using string keys, ensuring safe access and construction from key-value pairs. This is useful when dynamically configuring or inspecting individual read ports based on named fields in a memory hierarchy.",
      "description_length": 440,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.S-Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines the names and widths of write ports for 1D memory configurations. It provides direct access to lists of port names, port widths, and associated tags, enabling precise memory interface definitions. Use this when specifying memory write port layouts for hardware generation targeting Xilinx FPGAs.",
      "description_length": 315,
      "index": 74,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module provides access to the names and widths of write ports generated for a specialized 1D memory configuration. It exposes operations to retrieve port names, widths, and associated tags as lists. These values are used to inspect and wire up memory ports in hardware descriptions based on the selected memory implementation strategy.",
      "description_length": 340,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D read port interfaces specialized with a memory configuration. It supports data types like `comb t` for representing memory port signals, offering functions for packing/unpacking, multiplexing, concatenation, and selection logic. Concrete use cases include building memory read ports with specific bit widths and implementing control logic for memory access in hardware designs.",
      "description_length": 440,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "Implements combinational logic operations for 2D write ports specialized with memory configurations. Works with `comb` typed interfaces, supporting operations like packing, unpacking, muxing, concatenation, and priority/onehot selection. Used to construct and validate memory write port logic with specific bit widths and branching factors.",
      "description_length": 340,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines port names, widths, and associated tags for hardware components. It provides direct access to lists of port names, their corresponding widths, and a list of tags used for annotation or identification. Concrete use cases include configuring and generating hardware descriptions where precise port definitions and metadata are required for synthesis or simulation.",
      "description_length": 382,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.S-Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate register and wire variables within an `Always` block, specifically for use with memory write ports in a 2D configuration. It supports operations like assigning signals to variables, extracting signal values, and applying naming conventions to signals within an interface. Concrete use cases include constructing and managing write port logic for memories using Xilinx primitives like BRAM or URAM, where precise control over signal naming and register/wire assignment is required.",
      "description_length": 536,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a 2D write port of monadic values into a monadic 2D write port, effectively lifting the monad outside the port structure. It operates on 2D write ports parameterized by a module `M` that implements a monadic structure. A concrete use case is combining multiple write operations within a monadic context, such as accumulating state or handling side effects during memory configuration.",
      "description_length": 438,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating synchronous FIFO interfaces using bit vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing and concatenating interfaces, and validation of signal widths. Concrete use cases include constructing and validating hardware interfaces for FIFOs with specific bit-width requirements.",
      "description_length": 364,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module implements combinational logic operations for bit vectors, including packing/unpacking integers, multiplexing, concatenation, and priority/one-hot selection. It works with `comb` types representing hardware signals and structured types like `t` for grouped signals. Use it to build logic circuits for FPGA targeting Xilinx devices, such as routing control signals or decoding instruction fields.",
      "description_length": 407,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly maps write port configurations to specific memory implementations using string-based field names. It operates on association lists pairing string keys with memory configuration values, enabling precise per-field specialization of 1D write ports. Use this to define or extract memory configurations for individual write ports by name, such as mapping \"data\" or \"enable\" signals to BRAM or URAM implementations.",
      "description_length": 430,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.S-module-type-Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for constructing and manipulating 1D memory write ports with fixed bit-width fields. It supports data types like `comb` and `t` to represent memory interfaces, enabling operations such as packing/unpacking vectors, multiplexing, concatenation, and priority/onehot selection. Concrete use cases include building configurable memory write ports with validation, constant initialization, and signal routing in hardware descriptions.",
      "description_length": 481,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D write ports for specialized memory configurations using bit-level representations. It supports functions like packing/unpacking interfaces into vectors, multiplexing, concatenation, and priority/one-hot selection for precise control over memory writes. Concrete use cases include implementing custom memory interfaces with specific width requirements and synthesizing memory control logic for FPGAs using Xilinx primitives.",
      "description_length": 486,
      "index": 85,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of bit vectors. It supports constant creation, packing/unpacking, multiplexing, concatenation, and selection operations on interfaces with defined field widths. Use cases include building register files, memory interfaces, and control logic where precise bit-level manipulation and dynamic resizing are required.",
      "description_length": 407,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.S-Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate write ports using the Always API, specifically for interfacing with memory structures. It supports operations like assigning signals to variables, creating registers and wires, and applying naming conventions to signals within an interface. These functions are used to implement memory write operations in hardware descriptions, such as connecting register files or memory blocks to control logic.",
      "description_length": 453,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating 2D write port interfaces specialized with memory configurations, focusing on signal-level wiring, port creation, and structural composition. It operates on `Hardcaml.Signal.t` values and `Write_port_2d.t` structures, enabling tasks like width validation, register insertion, and multiplexer generation. Specific use cases include hardware interface wiring, pipeline stage creation, and ensuring compatibility between memory configurations and signal hierarchies in FPGA designs.",
      "description_length": 544,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D memory write ports with concrete bit-level signals. It supports creating constant ports from integers, packing/unpacking ports to vectors, multiplexing and concatenating ports, and validating port widths against a memory configuration. These operations are used to implement memory interfaces with specific width requirements in hardware designs.",
      "description_length": 409,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bit-level representations of hardware signals using a fixed-width combinational logic interface. It supports values of type `t` built from `comb` (bits), enabling bitwise operations, multiplexing, concatenation, and priority/one-hot selection with explicit width validation. Concrete use cases include implementing register encodings, bus multiplexers, and hardware control logic where precise bit-level manipulation and signal routing are required.",
      "description_length": 515,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly associates 2D write ports with field names using unsafe operations. It converts port configurations to and from association lists, where each key is a string field name. Use this when mapping memory write ports to named fields dynamically, such as when instantiating memories with complex, runtime-defined port structures.",
      "description_length": 343,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and managing 2D memory read ports using hardware signal interfaces, focusing on tasks like signal validation, multiplexing, concatenation, and register pipeline creation. It operates on `Of_signal.t` and `Of_signal.comb t` types, which represent combinational and registered signal interfaces, and includes utilities for port creation, signal naming with customizable prefixes/suffixes, and interface connectivity. It is particularly useful in FPGA memory design scenarios requiring precise control over signal routing and port configurations, such as implementing mixed memory architectures (e.g., URAM/BRAM splits) with tailored data path optimizations.",
      "description_length": 704,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module provides concrete values for port names, widths, and tags derived from a specialized 1D write port configuration. It works with lists of strings, integers, and a custom `tag` type to describe memory port properties. These values are used to generate memory instance ports in hardware descriptions targeting Xilinx FPGAs.",
      "description_length": 332,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D write ports specialized with a memory configuration, working with `comb` and `t` types representing bit vectors and structured interfaces. It supports concrete tasks like packing/unpacking interfaces into vectors, multiplexing, concatenation, and validation of port widths against expected configurations. Specific use cases include building configurable memory write ports with precise bit-level control, such as setting fields to constant integers or selecting between multiple write paths using priority or one-hot encodings.",
      "description_length": 591,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D write port configurations using combinational logic. It supports data types like `comb t` for representing memory interfaces with bit-level precision, and includes functions for packing/unpacking, multiplexing, concatenation, and priority/one-hot selection. Concrete use cases include defining memory write ports with specific bit widths, validating signal widths, and building complex memory control logic using combinational primitives.",
      "description_length": 501,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module enables the creation and management of synchronous FIFO interfaces through operations like signal connection (`<==`), interface packing/unpacking, multiplexing, and pipeline insertion. It works with structured signal interfaces (`I.Of_signal.t`) and signal vectors (`Hardcaml.Signal.t`) to facilitate tasks such as input/output port generation, signal naming, and validation in hardware designs. Specific applications include constructing register pipelines, implementing priority-encoded selections, and ensuring proper signal routing in synchronous systems.",
      "description_length": 571,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines port names, widths, and tags for a synchronous FIFO interface with valid signaling. It provides direct access to lists of port names, their corresponding bit widths, and a list of tags associated with the interface. These values are used to describe the structure of the FIFO interface in hardware design contexts, such as generating Verilog or connecting signals in a hardware description.",
      "description_length": 410,
      "index": 97,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for manipulating bit vectors, including packing/unpacking, multiplexing, concatenation, and selection functions. It works with types `comb` and `t` representing hardware signals and their structured combinations. Use cases include building custom digital circuits, implementing control logic, and handling data routing in hardware designs.",
      "description_length": 391,
      "index": 98,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between a custom data structure and an association list mapping string keys to values. It specifically operates on types represented by the `O.t` module, enabling direct lookups by port name. This is useful for hardware description tasks where port names need direct association with their corresponding values.",
      "description_length": 320,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module provides direct conversions between a specialized 1D read port structure and association lists indexed by field names. It operates on types that represent memory read ports with fixed widths, enabling named field access. Use this to serialize or deserialize memory port configurations using string keys, such as mapping port names to values for inspection or dynamic construction.",
      "description_length": 392,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module supports constructing and manipulating 1D write port interfaces specialized with memory configurations through signal-based operations like assignment, packing/unpacking, multiplexing, and selection logic. It operates on 1D write port interfaces and memory configurations, enabling use cases such as optimizing memory implementations by combining heterogeneous storage elements (e.g., URAM for specific bit ranges, BRAM for others) and applying signal transformations in hardware pipelines. Utilities for signal naming, port creation, and register/wire instantiation further streamline hardware description workflows.",
      "description_length": 629,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for creating and manipulating hardware description primitives such as registers, wires, and signal assignments in a hardware description context. It works with data types like `Hardcaml.Always.Variable.t`, `Hardcaml.Signal.t`, and `Hardcaml.Reg_spec.t`, enabling direct construction of combinational and sequential logic. Concrete use cases include defining clocked registers with optional enables, creating internal wires with dynamic signal generation, and assigning signal values to variables within always blocks.",
      "description_length": 549,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a 1D write port containing monadic values into a monadic value containing a 1D write port, effectively combining the structure and the monadic context. It operates specifically on 1D write ports configured with a memory implementation, such as those built using BRAM or URAM. A concrete use case involves aggregating multiple memory write operations into a single monadic structure, enabling sequential or conditional memory configuration logic.",
      "description_length": 499,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate write ports using the Always API, specifically for interfacing with memory structures. It supports operations like assigning signals to variables, creating registers and wires with specified behaviors, and applying naming conventions to signal fields. These functions are used to implement memory write logic with precise control over signal initialization and assignment within an always block.",
      "description_length": 451,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that takes a list of monadic values within an interface and combines them into a single monadic interface value. It works with data types involving interfaces (`I.t`) and monads (`M.t`). A concrete use case is aggregating multiple signal computations in a hardware description into a single result while preserving their monadic context.",
      "description_length": 375,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D write port configurations with concrete bit-level representations. It supports values of type `comb t`, which represent hardware signals, and includes functions for packing, unpacking, multiplexing, concatenation, and priority/onehot selection of these signals. Use cases include defining memory write ports with specific bit widths, validating signal integrity, and building complex memory control logic using combinational circuits.",
      "description_length": 497,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions for constructing and manipulating structured signal bundles in hardware designs, including operations like packing/unpacking, multiplexing, pipeline creation, and signal interface connectivity. It works with types representing combinations of signals (`comb O.t`) and their transformations, supporting validation, constant assignment, and hierarchical naming conventions. These tools are used to build hardware interfaces, validate signal structures, and apply naming strategies for readability in synchronous circuit development.",
      "description_length": 561,
      "index": 107,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bit-vector interfaces with fixed or dynamic widths, including packing/unpacking to and from vectors, multiplexing, concatenation, and selection functions like priority or one-hot encoding. It works with types representing bit vectors and structured interfaces, enabling precise width validation and signal routing in hardware descriptions. Concrete use cases include defining register interfaces with specific bit widths, dynamically selecting between multiple signal sources, and converting structured data to flat bit vectors for serialization or bus interfacing.",
      "description_length": 631,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a 2D structure of monadic values into a monadic 2D structure, effectively lifting the monad outside. It operates on nested types where an outer structure contains inner monadic values, consolidating them into a single monadic result. A concrete use case is combining multiple memory read operations, each returning a monadic value, into a unified read port interface.",
      "description_length": 421,
      "index": 109,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module supports combinational logic, register instantiation, and signal manipulation through operations like multiplexing, priority selection, signal conversion, and hierarchical naming transformations, operating on hardware signals represented by `Hardcaml.Signal.t` and `O.Of_signal.t`. It enables constructing digital circuits, managing input/output ports, and organizing signal hierarchies for simulation clarity and synthesis efficiency. Specific use cases include building register pipelines, implementing one-hot multiplexing, and handling bit-level signal manipulations with precise naming control.",
      "description_length": 611,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between a structured interface and an association list indexed by field names. Works with any interface type `'a O.t` where values can be associated with string keys. Useful for dynamically inspecting or constructing interfaces by name, such as in simulation environments or configuration systems.",
      "description_length": 306,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D read ports specialized with a memory configuration using combinational logic. It supports values of type `comb t`, representing structured memory interfaces, and offers functions for packing, unpacking, multiplexing, concatenation, and selection operations tailored to memory access patterns. Concrete use cases include implementing memory read logic with configurable field widths and routing signals through combinational logic for FPGA-based memory systems.",
      "description_length": 523,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to manipulate synchronous FIFO interfaces using the Always API, including assigning signals to variables, creating registers, and naming interface fields. It works with interface containers that hold `Always.Variable.t` values, allowing structured signal assignment and naming within always blocks. Concrete use cases include building and managing synchronous FIFO logic with named signals, such as registering interface fields or wiring default-valued signals.",
      "description_length": 492,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D write port configurations specialized with a given memory configuration. It supports data types involving 2D memory interfaces with combinational logic, including packing, unpacking, multiplexing, and concatenation of signals. Concrete use cases include defining memory write ports with precise bit-widths, validating signal widths against expected interfaces, and building complex memory access patterns using combinational logic.",
      "description_length": 494,
      "index": 114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block for a 1D read port interface. It supports operations like assigning signals to variables, extracting signal values, and applying naming conventions to interface fields. Concrete use cases include building clocked memory read ports with named signals and default values.",
      "description_length": 376,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module handles bit-level manipulation and validation of a synchronous FIFO interface with valid signals. It provides operations for packing and unpacking interface signals into bit vectors, multiplexing and concatenating interfaces, and performing selection operations with priority or one-hot encoding. Concrete use cases include constructing and validating hardware interfaces for data paths, managing signal widths, and implementing control logic for FIFOs in digital circuits.",
      "description_length": 485,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module provides concrete values for port names, widths, and tags derived from a specialized 2D write port configuration. It works with lists of strings, integers, and a `tag` type to describe memory port attributes. These values are used to generate memory instance ports in hardware descriptions, enabling precise signal naming and width assignments during synthesis.",
      "description_length": 373,
      "index": 117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D read ports for specialized memory configurations using bit-level signals. It supports functions like packing/unpacking interfaces into vectors, multiplexing, concatenation, and priority/one-hot selection with valid signals, ensuring correct port widths via validation. Concrete use cases include implementing memory read logic with configurable storage elements and handling dynamic selection of memory outputs based on control signals.",
      "description_length": 499,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that combines a collection of monadic values within a write port structure, lifting the monad outside the interface. It operates on types structured as `'a M.t t`, where `M` is a monad, enabling aggregation of effects across write ports. A concrete use case involves collecting results from multiple memory write operations into a single monadic context for coordinated handling of side effects or dependencies.",
      "description_length": 449,
      "index": 119,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic primitives like multiplexing and concatenation, sequential elements such as registers and pipelines, and signal transformation utilities for packing/unpacking bit-level representations. It operates on hardware signals (`Signal.t`) and wrapper types to model digital circuits with precise control over signal assignment, name propagation, and hierarchical composition. Typical applications include constructing FPGA primitives, implementing register-transfer level designs, and building testbenches with named signal tracing.",
      "description_length": 565,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate register and wire variables within an always block, specifically for 2D read port memory configurations. It supports data types like `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t`, enabling direct assignment and naming operations. Concrete use cases include defining register interfaces with optional enables, creating wire interfaces with default signal values, and applying naming conventions to signal fields within memory circuits.",
      "description_length": 497,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D write port interfaces specialized for a given combinational logic type. It supports values of type `comb t`, representing structured memory write ports, and offers functions for packing, unpacking, multiplexing, concatenation, and selection operations. Concrete use cases include building configurable memory write paths with precise bit-level control, validating signal widths, and constructing constant or muxed write port inputs for hardware synthesis.",
      "description_length": 518,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.S-Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines the names, widths, and tags for 2D write ports in memory configurations. It provides direct access to lists of port names, their corresponding bit widths, and associated tags. These values are used to specify and differentiate multiple write ports when building complex memory structures with varying port configurations.",
      "description_length": 341,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.S-Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D write port interfaces for memory implementations with bit-level representations. It supports concrete operations such as packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection logic (priority and one-hot). Use cases include defining memory write ports with precise bit widths and implementing control logic for memory access in hardware designs.",
      "description_length": 446,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to manipulate synchronous FIFO interfaces represented as bit vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing between multiple interfaces, concatenation, and selection operations including priority and one-hot encoded selects. Concrete use cases include constructing and validating FIFO control logic, routing data paths based on select signals, and converting between structured interfaces and flat bit vectors for serialization or hardware synthesis.",
      "description_length": 527,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating synchronous FIFO interfaces as packed vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing and concatenating interfaces, and selecting between interfaces using priority or one-hot encoding. These functions are used to build and validate hardware structures with fixed-width fields, such as control logic or data path units in FPGA designs.",
      "description_length": 427,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bit-level interfaces, primarily for hardware description tasks. It supports values of type `t`, which represent structured interfaces composed of `Bits.t` signals, and includes functions for packing/unpacking, multiplexing, concatenation, and validation of signal widths. Concrete use cases include assembling register interfaces, routing data paths, and ensuring correctness of bit-widths in memory-mapped logic.",
      "description_length": 479,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating combinatorial logic interfaces, specifically handling signal packing, unpacking, multiplexing, concatenation, and validation. It works with fixed-width bit vectors and structured interfaces composed of multiple fields. Concrete use cases include building register files, memory interfaces, and control logic where precise bit-level manipulation and selection between multiple signal sources are required.",
      "description_length": 470,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Maps between a structured write port and an association list indexed by field names. Converts a write port into a list of key-value pairs or constructs a write port from such a list. Useful for dynamically inspecting or assembling write ports by name, especially when the exact structure is not known at compile time.",
      "description_length": 317,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and transforming structured hardware signals with fixed bit-widths, focusing on tasks like multiplexing, constant generation, register insertion, and signal assignment. It works with signal-labeled records (`t`, `comb`) to model hardware outputs, enabling validation of bit-width constraints and hierarchical interface manipulation. Specific use cases include connecting signal ports via assignment operators, applying naming transformations to interfaces, and building pipelined or combinatorial logic networks for Xilinx ICAP output configurations.",
      "description_length": 599,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.S-module-type-Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for constructing and manipulating 2D memory write ports with fixed bit-width fields. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and priority/onehot selection with valid signals. Concrete use cases include building configurable memory interfaces where write ports are dynamically selected or combined based on control signals.",
      "description_length": 441,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.All",
      "library": "hardcaml_xilinx",
      "description": "Reorganizes a nested hardware description structure by lifting values from a monomorphic module into a polymorphic context. It operates on hardware description types that are parameterized by a module `M`, transforming a value of type `'a M.t` into a `'a` value within the `M` context. This is useful when extracting or manipulating hardware components that are encapsulated within a module-specific interface.",
      "description_length": 410,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module provides direct conversions between write port records and association lists indexed by field names. It operates on 2D write port types, enabling programmatic access and construction using string-keyed data. Use this to dynamically generate or inspect write port configurations from external data sources like configuration files or runtime inputs.",
      "description_length": 360,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config",
      "library": "hardcaml_xilinx",
      "description": "This module transforms and analyzes 1D write ports in the context of memory configurations, supporting operations like mapping, zipping, and converting between structured interfaces and lists. It works with memory configuration data, hardware signal vectors, and multi-field structures to generate port-specific logic, enabling tasks like bit-range specialization, signal assignment, and error handling. Child modules provide combinational logic, naming utilities, field-based configuration, and monadic transformations, allowing precise control over memory implementations such as BRAM or URAM. Examples include building register files, multiplexing write paths, validating port widths, and aggregating memory operations into monadic structures.",
      "description_length": 746,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.S-module-type-Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating 1D read ports with combinational logic in a memory interface. It supports data types like `comb t`, representing structured memory fields, and `comb`, representing individual signals. Concrete use cases include packing/unpacking memory fields into vectors, multiplexing between multiple read ports, and selecting values based on priority or one-hot encoding.",
      "description_length": 424,
      "index": 135,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.S-Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to construct and manage 1D memory write ports using signal-based interfaces, enabling operations like signal assignment (`<==`), multiplexing, concatenation, and pipelining. It operates on `Hardcaml.Signal.t` values with strict width validation and field-level control, while also supporting interface creation (inputs/outputs) and signal naming for hierarchical design clarity. It is particularly used to implement memory blocks with mixed storage configurations (e.g., URAM for wider data segments, BRAM for narrower sections) and to ensure correct signal connectivity and timing in FPGA memory subsystems.",
      "description_length": 639,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bit-level representations of configuration data using a structured record type. It supports functions for packing and unpacking values, multiplexing, concatenation, and priority/one-hot selection, all working with `comb` values representing hardware bits. Concrete use cases include assembling configuration packets, decoding instruction fields, and implementing register file selection logic in FPGA configuration interfaces.",
      "description_length": 492,
      "index": 137,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.S",
      "library": "hardcaml_xilinx",
      "description": "This module provides functional transformations and metadata manipulation for 1D memory read port collections, including mapping, zipping, and aggregation operations over named, width-tagged port data. It operates on structured types like `'a t` (representing port configurations), tuples of signals (up to five elements), and nested interface lists, while supporting bit-level composition and error propagation. Key use cases include synthesizing read ports from `always` blocks in hardware descriptions and enforcing consistent signal naming and width definitions during memory interface generation.",
      "description_length": 601,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Config.S",
      "library": "hardcaml_xilinx",
      "description": "This module defines configuration options for building memories using Xilinx primitives, specifying parameters like memory depth, width, and storage type (e.g., BRAM, URAM). It supports configuring 1D and 2D memory layouts with precise control over bit ranges and addressing modes. Use this to customize memory implementations in hardware designs targeting Xilinx FPGAs, such as configuring a 72-bit wide memory using URAM and extending with BRAM for additional bits.",
      "description_length": 467,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config",
      "library": "hardcaml_xilinx",
      "description": "This module transforms 2D write ports based on memory configurations, supporting operations like zipping, mapping, and combinational logic integration. It works with hardware signals and memory settings to generate bit-level or constant-based ports aligned with implementations such as URAM or BRAM. The child modules enable structured metadata extraction, per-port configuration mapping, monadic lifting of memory operations, and signal-level wiring with the Always API. They also support combinational logic construction, port width validation, and bit-level port manipulation, enabling tasks like pipeline creation, error propagation, and FPGA interface design.",
      "description_length": 664,
      "index": 140,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between a structured record type and an association list mapping string keys to values. Works directly with records containing port names and associated data. Useful for serializing or deserializing hardware configuration data where port names must map to specific values.",
      "description_length": 281,
      "index": 141,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O",
      "library": "hardcaml_xilinx",
      "description": "This module enables manipulation of hardware signals through iteration, mapping, folding, and scanning over structured data, while transforming signal lists and managing port metadata. It supports combinational logic synthesis, hierarchical signal restructuring, and conversion between custom data and port-based associations. Key data types include `'a t` for signals, `comb` for bitvectors, and structured types for grouped signals and ports. Examples include synthesizing pipelines, building ALUs with multiplexers, reordering port metadata, and converting composite signal types for simulation or synthesis.",
      "description_length": 611,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module implements combinational logic operations for a specific hardware description structure, supporting value packing/unpacking, multiplexing, concatenation, and selection operations. It works with a custom `comb` type and structured data of type `t` containing fields of that `comb` type, enabling bit-level manipulation and routing logic. Concrete use cases include building register file outputs, implementing control signal routing, and constructing configurable logic blocks in FPGA-like designs.",
      "description_length": 509,
      "index": 143,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.S-Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module implements 1D read port logic for memory interfaces with combinational signal handling. It provides operations for constructing, validating, and manipulating memory read interfaces using a `comb` type for signal representation. Key functions include packing/unpacking fields, multiplexing, concatenation, and selection logic for memory access control.",
      "description_length": 363,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.S-Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate read port interfaces using the Always API, specifically for 1D memory configurations. It supports data types like `Always.Variable.t t` and `Signal.t t`, enabling operations such as assignment, register creation, and wire initialization. Concrete use cases include building named, configurable read ports with registered or combinational signals, such as initializing memory outputs with default values or applying signal names for debugging.",
      "description_length": 498,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.S-Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D write ports for memory interfaces using bit-level representations. It supports concrete operations such as packing/unpacking interfaces to/from bit vectors, multiplexing, concatenation, and selection logic (priority and one-hot), with validation of field widths and constant initialization. Use cases include defining memory write ports with precise bit-level control, enabling synthesis-friendly memory construction in hardware designs.",
      "description_length": 500,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bitvector-like values with specific width constraints, including packing/unpacking, concatenation, and multiplexing. It works with the `comb` type representing combinational logic values and `t` as a structured collection of these values. Concrete use cases include building custom digital circuits, implementing control logic, and managing data paths with precise bit-level control.",
      "description_length": 449,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines lists of port names and widths for Xilinx ICAP3 interface signals, along with associated tags. It provides direct access to signal metadata used in hardware description and configuration. Useful for generating signal declarations or validating interface connections in FPGA designs.",
      "description_length": 302,
      "index": 148,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Typed_math",
      "library": "hardcaml_xilinx",
      "description": "This module provides arithmetic and comparison operations on bit vectors represented by the `v` type, specifically tailored for Xilinx Unisim combinational primitives. It supports addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality, with automatic width extension to preserve precision. These operations are used to model and synthesize digital circuits where precise bit-level control and correct width handling are critical, such as in FPGA datapath components.",
      "description_length": 518,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.S-Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating 2D write port interfaces using a combinatorial logic representation. It supports data types involving vectors and records with field-level bit-width specifications, enabling precise control over memory port configurations. Concrete use cases include defining memory write ports with specific integer constants, multiplexing between multiple port configurations, and packing or unpacking port signals into vectors for efficient signal routing.",
      "description_length": 508,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.S-All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a single function `all` that transforms a list of monadic values into a monadic list of values, effectively lifting the monad outside the structure. It operates on types of the form `'a M.t t`, where `t` represents a 1D write port interface and `M` is a monad. A concrete use case is collecting results from multiple asynchronous memory write operations into a single monadic structure for batch processing or error handling.",
      "description_length": 446,
      "index": 151,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a nested structure of type `'a M.t` into a structure of type `'a` by applying operations defined in the `M` module. It works with data types involving the `Hardcaml_xilinx.Icape3.O.t` wrapper, specifically handling computations or configurations related to Xilinx ICAP3 operations. A concrete use case includes aggregating or flattening ICAP3 configuration outputs across multiple instances or layers in hardware description code.",
      "description_length": 484,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.S-Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines the names and widths of read ports for 1D memory configurations. It provides access to individual port names, their respective widths, and a list of tags associated with each port. Use this module to inspect or configure memory read port layouts when building memory systems targeting Xilinx FPGAs.",
      "description_length": 318,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to manipulate and assign signals within an `Always` block for a specific hardware interface. It supports creating registers, wires, and named signal assignments, working with types like `Signal.t`, `Always.Variable.t`, and `Reg_spec.t`. Concrete use cases include building synchronous logic and structured signal assignments for FPGA configurations.",
      "description_length": 381,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I",
      "library": "hardcaml_xilinx",
      "description": "This module structures and transforms typed hardware interfaces with metadata, supporting operations like mapping, zipping, and converting between lists and structured interfaces while preserving field offsets. It handles error-aware data and port metadata (names, widths, tags) to model synchronous FIFOs, particularly for Xilinx IP integration, enabling always-block-based FIFOs, signal property extraction, and bit-width-accurate interface generation. Submodules support named field conversion, FIFO signal assignment with Always blocks, combinational logic construction, port metadata access, monadic interface lifting, bit vector manipulation, structured signal connection, and packed vector operations. Examples include dynamically building interfaces from field names, assigning register values in always blocks, packing signals into bit vectors, and generating FIFO control logic with priority encoding.",
      "description_length": 911,
      "index": 155,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M",
      "library": "hardcaml_xilinx",
      "description": "This module organizes a two-dimensional write port system for memory configurations, parameterized by an underlying memory implementation module `M`. It enables precise construction and manipulation of write ports with typed interfaces, supporting heterogeneous memory blocks that combine storage types like BRAM and URAM with distinct write behaviors. Key operations include signal packing/unpacking, multiplexing, priority encoding, and structural transformations over combinational or registered signals, with support for lifting monadic actions, named field associations, and bit-width validation. Concrete uses include synthesizing configurable memory interfaces, managing signal routing in hardware designs, and building error-aware pipelines with mixed storage elements.",
      "description_length": 777,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module provides direct conversions between 1D write port structures and association lists indexed by field names, enabling programmatic access and construction of memory write ports using string keys. It operates on 1D write port types (`'a t`) and string-keyed lists of values. Concrete use cases include dynamically generating memory write ports from configuration data or inspecting existing ports by their field names.",
      "description_length": 427,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Unsigned",
      "library": "hardcaml_xilinx",
      "description": "This module implements arithmetic and comparison operations for unsigned bit vectors, including addition, subtraction, multiplication, and comparisons like less-than or equal-to. It works with the `v` type representing unsigned vectors, supporting operations that handle width extension and resizing. Concrete use cases include building combinational logic circuits for Xilinx FPGAs where precise control over unsigned vector operations is required.",
      "description_length": 449,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines lists of port names and widths for hardware description in Xilinx ICAP devices. It includes explicit string names and integer widths for each port, along with a list of associated tags for identification. These values are used directly in generating or verifying hardware interfaces with specific signal requirements.",
      "description_length": 337,
      "index": 159,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Signed",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with signed binary vectors, including arithmetic operations like addition, subtraction, and multiplication, which return results with appropriate bit-width extensions to prevent truncation. It supports comparison operations between signed vectors of differing widths and offers a resize function to adjust vector widths with correct sign extension. These capabilities are used to model Xilinx primitives that require precise signed value handling in digital circuit design.",
      "description_length": 517,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config",
      "library": "hardcaml_xilinx",
      "description": "This module configures 1D memory read ports based on a memory implementation, supporting tagged collections of ports and signal tuples. It provides operations to map, zip, and fold over port data while generating synthesis-ready metadata such as port names and widths, enabling heterogeneous memory interfaces where different bit ranges use distinct storage elements. Child modules handle metadata inspection, bit-level signal manipulation, record-to-list conversions, and combinational logic construction, allowing tasks like packing/unpacking interfaces, multiplexing, concatenation, and pipeline register insertion. Specific uses include FPGA synthesis with mixed URAM and BRAM storage, dynamic port configuration via field names, and structured wiring of memory signals with bit-width correctness.",
      "description_length": 801,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M",
      "library": "hardcaml_xilinx",
      "description": "This module defines 1D write port abstractions for memory configurations, parameterized by data type and width through module X. It supports construction and manipulation of write ports using combinational logic, signal interfaces, and always blocks, with operations for assignment, multiplexing, register insertion, and bit-level manipulation. Child modules enhance this functionality by enabling structured naming, monadic lifting, record-to-association list conversion, and precise interface layout specification. Use cases include building pipelined memory architectures, mapping named configurations to hardware ports, and implementing Xilinx-specific memory blocks with mixed storage elements like URAM and BRAM.",
      "description_length": 718,
      "index": 162,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize",
      "library": "hardcaml_xilinx",
      "description": "This module transforms and queries 2D memory write port configurations using polymorphic combinators, enabling tasks like mapping signals, computing bit offsets, and folding interfaces. It operates on structured representations of memory ports as tagged polymorphic values, with metadata such as names, widths, and error states, and supports direct manipulation of signal structures and monadic transformations. Child modules extend this functionality by providing concrete operations for hardware signals, bit-level representations, and monadic lifting, enabling use cases like specializing memory ports for Xilinx primitives, generating signal mappings, and dynamically assembling or inspecting ports by field name. Specific capabilities include packing/unpacking interfaces, inserting pipelines, and lifting monadic effects over port structures.",
      "description_length": 848,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.S-Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines the names, widths, and tags for 2D write ports used in memory configurations. It provides direct access to lists of port names, their corresponding bit widths, and associated tags, enabling precise control over memory write port definitions. These values are used when constructing and identifying write ports with specific naming and sizing requirements in memory implementations.",
      "description_length": 401,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides bit-level operations for constructing and manipulating Xilinx ICAP3 output signals using `Bits.t` values. It supports signal packing, unpacking, multiplexing, concatenation, and selection operations with optional bit reversal. Concrete use cases include building custom ICAP3 command sequences, routing control signals, and handling register configurations in FPGA design flows.",
      "description_length": 399,
      "index": 165,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Sop",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for performing arithmetic and comparison on signed vectors, specifically supporting addition, subtraction, multiplication, and comparisons like less than or equal, greater than, etc. It works directly with types like `Bits.t` and `Signal.t`, allowing for width-aware operations and conversions between them. Use cases include implementing arithmetic logic units (ALUs) and comparison-based control logic in hardware descriptions targeting Xilinx FPGAs.",
      "description_length": 484,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.S-Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating 1D write ports of a memory interface using a combinatorial logic module. It supports data types involving vectors and records of fixed-width fields, enabling concrete use cases like packing/unpacking interfaces into vectors, multiplexing between multiple interfaces, and selecting signals based on priority or one-hot encoding. Specific functions include validation of field widths, constant initialization, and combinational logic for signal routing.",
      "description_length": 517,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.S",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and transforming 1D memory write port interfaces using combinational logic, always blocks, or direct signal mappings. It works with tagged collections of write ports (`'a t`), tuples of signals (up to 5 elements), and memory configuration data like port names and widths. Key use cases include synthesizing memory ports from behavioral descriptions (e.g., `Of_always`), converting between structured interfaces and flat signal lists, and generating HDL-ready port definitions with precise bit-width specifications.",
      "description_length": 563,
      "index": 168,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Uop",
      "library": "hardcaml_xilinx",
      "description": "This module implements low-level unsigned arithmetic and comparison operations on bit vectors and signals, including addition, subtraction, multiplication, and comparisons like less-than or equal-to. It supports data type conversions between vector and signal representations and provides resizing with proper bit extension. These operations are used to model Xilinx primitive components for hardware synthesis where precise control over bit-level behavior is required.",
      "description_length": 469,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating hardware interface signals, focusing on multiplexing, concatenation, register control, and signal assignment. It works with structured interface types and `Hardcaml.Signal.t` to manage low-level signal routing and hierarchical naming in FPGA configurations. These utilities are used for tasks like building Xilinx ICAPv3 interfaces, implementing priority-encoded signal selection, and managing pipelined register stages in hardware designs.",
      "description_length": 506,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module implements combinational logic operations for a specific hardware interface type, supporting values of type `t` composed with a `comb` type. It provides functions for packing/unpacking, multiplexing (including 2-way, priority, and one-hot selection), concatenation, and integer conversion, all operating on fixed-width bit-level representations. These operations are used to construct and manipulate register-transfer level circuits for hardware synthesis targeting Xilinx FPGAs.",
      "description_length": 491,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to manipulate and assign signals in a hardware description context. It supports creating registers, wires, and named signal assignments for a specific hardware interface. Concrete use cases include defining synchronous logic, connecting internal signals, and applying naming conventions to signals in FPGA designs.",
      "description_length": 346,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.S",
      "library": "hardcaml_xilinx",
      "description": "This module supports operations for constructing and manipulating 2D memory write ports with tagged, signal-based interfaces. It provides utilities to map, zip, fold, and convert between list and tuple representations of write port collections, while tracking metadata like port names and bit widths. These capabilities are used to build memory write logic from behavioral descriptions (e.g., always blocks), implement hardware with mixed memory primitives (BRAM/URAM), and manage combinational signal processing in circuit designs.",
      "description_length": 532,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Sop",
      "library": "hardcaml_xilinx",
      "description": "This module implements signed arithmetic and comparison operations on fixed-width bit vectors, supporting addition, subtraction, multiplication, and comparisons like less-than or equal-to. It works directly with `t` values representing hardware signals or bit vectors, allowing width-resizing and safe sign extension during operations. Concrete use cases include implementing synthesizable combinational logic for Xilinx FPGAs, such as ALUs, comparators, or data path components requiring signed integer behavior.",
      "description_length": 513,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Signed",
      "library": "hardcaml_xilinx",
      "description": "This module implements operations on signed binary vectors using Xilinx unisim primitives. It provides arithmetic operations like addition, subtraction, and multiplication with automatic sign extension, as well as comparison operators for ordering and equality. These operations are used to design and manipulate fixed-width signed signals in hardware description code targeting Xilinx FPGAs.",
      "description_length": 392,
      "index": 175,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Typed_math",
      "library": "hardcaml_xilinx",
      "description": "This module provides arithmetic and comparison operations for a custom signal type `v`, including addition, subtraction, multiplication, and comparisons like less than or equal, greater than, etc. It supports operations on fixed-width bit vectors, automatically handling sign extension and truncation during conversions and computations. Use cases include implementing synthesizable digital circuits where precise control over bit widths and overflow behavior is required.",
      "description_length": 472,
      "index": 176,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I",
      "library": "hardcaml_xilinx",
      "description": "This module enables functional manipulation and transformation of hardware interface types through mapping, folding, and zipping operations over tagged port data, supporting multi-argument combinators and conversions between bit vectors, signals, and lists. It provides core data types like `'a I.t` for representing structured port data, along with operations for error handling and structural reorganization, such as swapping nested module layers. Submodules enhance this foundation with bitvector arithmetic, combinational logic primitives, register and wire management in always blocks, and port configuration lists, enabling tasks like signal routing, control logic synthesis, and testbench generation. Specific capabilities include packing/unpacking bitvectors, defining register specifications with enable signals, converting hardware structures to association lists, and constructing multiplexers or pipelines with explicit width validation.",
      "description_length": 949,
      "index": 177,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid",
      "library": "hardcaml_xilinx",
      "description": "This module enables structural manipulation and functional transformation of hardware interface signals with validity flags, centered around the `X_with_valid.t` type that pairs data with valid signals. It supports key operations like mapping, zipping, folding, and scanning, while preserving validity semantics, and integrates with submodules that handle FIFO interface construction, signal packing/unpacking, and combinational logic. Submodules provide concrete functionality for converting interfaces to named field lists, inserting pipeline registers, defining port metadata, and bit-level manipulation, enabling tasks like control logic synthesis, signal routing, and synchronous FIFO design. Specific uses include building priority-encoded multiplexers, generating Verilog-ready interfaces, and validating data pipelines with structured validity tracking.",
      "description_length": 861,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.S-Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 1D read ports for memory interfaces using bit-level representations. It supports functions like packing/unpacking interfaces into vectors, multiplexing, concatenation, and priority/one-hot selection with valid signals, ensuring correct signal widths via validation. Concrete use cases include building configurable memory read ports with precise bit-level control for hardware synthesis targeting Xilinx FPGAs.",
      "description_length": 470,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.S-Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing 1D memory read ports using signal interfaces, enabling tasks like packing/unpacking, muxing, concatenation, and priority selection. It works with signal interfaces (`Of_signal.comb t`, `Of_signal.t`) and port wiring constructs to model hardware signals, memory layouts, and pipeline stages. Specific use cases include configuring memory implementations (e.g., URAM/BRAM partitioning), validating signal widths, inserting registers for timing closure, and generating named hardware ports for synthesis.",
      "description_length": 550,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.S-Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate write ports using the Always API, specifically for interfacing with memory structures. It supports operations like assigning signals to variables, creating registers and wires with customizable naming, and extracting signal values. Concrete use cases include building memory write ports with precise control over signal behavior and naming in hardware descriptions.",
      "description_length": 421,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.S-All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a single function `all` that transforms a 2D structure of monadic values into a monadic 2D structure, effectively lifting the monad outside. It operates on 2D write ports, which are used to construct memory configurations with multi-dimensional write capabilities. A concrete use case is combining multiple memory write operations across a 2D grid into a single monadic result, enabling sequential composition of memory writes dependent on monadic effects.",
      "description_length": 477,
      "index": 182,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bitvector values, including packing/unpacking, concatenation, and multiplexing. It works with types representing hardware signals and their combinations, specifically handling width validation and selection logic. Concrete use cases include building register files, implementing control logic, and managing data paths in hardware descriptions.",
      "description_length": 409,
      "index": 183,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Uop",
      "library": "hardcaml_xilinx",
      "description": "This module defines arithmetic and comparison operations for unsigned bit vectors, working directly with `t` values that represent either `Bits.t` or `Signal.t`. It supports addition, subtraction, multiplication, and comparisons (e.g., less than, equal to), with automatic bit-width extension to preserve precision. These operations are used to model Xilinx primitive logic for synthesis, enabling direct manipulation of digital signals in hardware descriptions.",
      "description_length": 462,
      "index": 184,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Unsigned",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating unsigned bit vectors, including arithmetic (addition, subtraction, multiplication), comparison (less than, greater than, equality), and resizing. It works with the `v` type representing unsigned vectors and supports conversions to and from `Comb.t` signals. Concrete use cases include implementing arithmetic logic units, comparators, and bit-width adjustments in hardware descriptions targeting Xilinx FPGAs.",
      "description_length": 458,
      "index": 185,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Sop",
      "library": "hardcaml_xilinx",
      "description": "This module implements arithmetic and comparison operations for signed bit vectors, supporting addition, subtraction, multiplication, and comparisons between values of potentially different widths. It provides functions to convert between bit vectors and combinational logic signals, along with resizing to target widths using appropriate sign extension. These operations are used to build low-level hardware components like accumulators, filters, and control logic in FPGA designs.",
      "description_length": 482,
      "index": 186,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Typed_math",
      "library": "hardcaml_xilinx",
      "description": "This module implements arithmetic and comparison operations for bit vectors in a Hardcaml-based Xilinx synthesis context. It supports addition, subtraction, multiplication, and comparisons between bit vectors of different widths, with automatic sign extension and resizing. These operations are used to model low-level hardware behavior directly in OCaml, particularly for combinational logic circuits targeting Xilinx FPGAs.",
      "description_length": 425,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I",
      "library": "hardcaml_xilinx",
      "description": "This module enables transformation, combination, and analysis of structured hardware interfaces, supporting operations like mapping, zipping, and multi-argument combinational logic while managing conversions between interface lists and list-valued interfaces. It centers around the `I.t` type, which represents structured hardware interfaces, and integrates with submodules that handle signal assignment, bitvector manipulation, RAM port configuration, and dynamic interface construction. For example, it can synthesize RAMs with dynamic resizing, build pipelined data paths with precise bit-width control, or aggregate multiple signal computations into a unified interface. Submodules extend its core functionality with specialized capabilities like always-block signal manipulation, bitvector combinators, and interface-to-alist conversion for configuration-driven design.",
      "description_length": 874,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Signed",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with signed binary vectors in hardware description code. It supports arithmetic operations like addition, subtraction, and multiplication with automatic sign extension, and comparison operations between vectors of differing widths. The module is used to model and manipulate fixed-width signed integer signals in digital circuit designs, such as in ALUs or control logic.",
      "description_length": 415,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O",
      "library": "hardcaml_xilinx",
      "description": "This module organizes structured hardware interfaces using tagged port representations (`O.t`) and supports transformation, combination, and inspection of synchronous FIFOs and signal groups. It enables operations like mapping field names to bit widths, packing and unpacking interfaces, multiplexing signals, and defining FIFOs with precise signal naming and synchronization. Concrete tasks include building data path multiplexers, validating signal widths, converting interfaces to bit vectors, and dynamically manipulating field values through string keys. Submodules extend these capabilities with monadic composition, always-block signal assignment, and structured pipeline and bundle manipulation for FPGA design workflows.",
      "description_length": 729,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Uop",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for performing arithmetic and comparisons on unsigned bit vectors, supporting addition, subtraction, multiplication, and comparisons like less than or equal. It works directly with bit vectors (`Bits.t` or `Signal.t`) and handles width mismatches by extending inputs appropriately. Use it to implement low-level arithmetic circuits where precise control over bit widths and operations is required.",
      "description_length": 429,
      "index": 191,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.S-Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to construct and manipulate 2D memory write ports using bit-level representations. It supports functions like packing/unpacking interfaces into vectors, multiplexing, concatenation, and priority/one-hot selection for memory write control logic. Concrete use cases include implementing configurable memory write paths with specific bit-width constraints and routing logic for FPGA-based designs.",
      "description_length": 426,
      "index": 192,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between a structured interface and an association list mapping port names to values. Works with any interface type `'a t` by serializing or reconstructing its fields based on their port names. Useful for inspecting or dynamically configuring hardware interfaces using string-keyed data.",
      "description_length": 295,
      "index": 193,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.S-Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly maps 1D read port fields to named values in an association list, enabling straightforward conversion between structured memory port configurations and string-indexed lists. It operates on `t` and `alist` types, specifically handling named field associations for memory port data. Use this to serialize or deserialize memory port configurations using named fields, such as mapping port names to memory addresses or configuration parameters.",
      "description_length": 460,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Unsigned",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with unsigned binary vectors in hardware description contexts. It supports arithmetic operations like addition, subtraction, and multiplication, with automatic bit-width extension to prevent truncation, along with comparison operations between vectors of differing widths. These functions are used to model and manipulate digital signals in FPGA synthesis workflows, particularly for Xilinx targets.",
      "description_length": 443,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.S-Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating 2D memory write ports using signal interfaces, focusing on tasks like packing/unpacking, muxing, concatenation, and pipeline creation. It operates on `Of_signal.comb` and `Of_signal.t` types, which represent hardware signals with combinational and registered behavior, ensuring proper width validation and routing. These capabilities are particularly useful for implementing memory systems in hardware designs where precise control over signal naming, pipelining, and memory resource allocation (e.g., mixing URAM and BRAM) is required.",
      "description_length": 602,
      "index": 196,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O",
      "library": "hardcaml_xilinx",
      "description": "This module orchestrates the transformation and composition of structured hardware interfaces by mapping, zipping, and combining signals with metadata tracking, port configuration, and error propagation. It supports tuple manipulation up to five elements, conversion between interfaces and lists, and tagged signal handling for tasks like signal naming from always blocks and metadata management in compilation pipelines. Child modules specialize in RAM port definitions, bitvector combinators, signal-level interface construction, always-block variable assignment, monadic record lifting, dynamic bit-width handling, interface-to-alist conversion, and combinatorial logic transformations, enabling concrete use cases such as register pipeline construction, memory interface generation, and control logic implementation with precise width validation and signal routing.",
      "description_length": 869,
      "index": 197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.S-module-type-Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for constructing and manipulating 1D memory write ports with concrete bit-level interfaces. It supports data types like `comb` and `t`, enabling operations such as packing/unpacking bit vectors, multiplexing, concatenation, and priority/one-hot selection. Use cases include defining memory write behavior with precise bitwidth control, constant initialization, and signal routing in hardware descriptions.",
      "description_length": 457,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config",
      "library": "hardcaml_xilinx",
      "description": "This module orchestrates the construction and manipulation of 2D memory read port configurations, integrating structured signal tuples, interface lists, and memory primitives with combinational and sequential logic. It supports key operations like mapping, zipping, multiplexing, and error aggregation across port definitions, ensuring alignment and validation of bit widths, offsets, and port names\u2014particularly for mixed memory architectures like URAM/BRAM splits. Data types include signal tuples, `comb t` interfaces, and `Of_signal.t` representations, with operations to pack/unpack, concatenate, select, and pipeline memory outputs using priority or one-hot encoding. Submodules enable runtime configuration via field-name lookups, define port names and widths, lift monadic read operations into unified interfaces, and manage register and wire variables for precise signal control in FPGA memory designs.",
      "description_length": 911,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize",
      "library": "hardcaml_xilinx",
      "description": "This module specializes 1D memory read port configurations through transformation, mapping, and combinatorial operations like folding and scanning over port tuples, supporting bit-level struct manipulation and error handling. It works with collections of per-port data\u2014such as names, widths, and tags\u2014enabling static configuration and aggregation of port widths for generating Xilinx-targeted memory implementations using BRAM or URAM primitives. Functions like `all` sequence memory read operations across multiple ports with monadic effects, while submodules handle signal assignment, naming, and width validation for always blocks, combinational logic, and bit-level interfaces. Concrete use cases include building memory-mapped register files, pipelined data paths, and specialized signal-based memory designs with precise width and naming control.",
      "description_length": 852,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.S-Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to create and manipulate register and wire variables within an `Always` block, specifically for 2D memory write ports. It supports operations like assigning signals to variables, creating registers with optional enable signals, and applying naming conventions to signals. Concrete use cases include building memory write ports with structured signal naming and register/wire initialization in hardware description code.",
      "description_length": 450,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.S-Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines the names, widths, and associated tags for 1D write ports in memory configurations. It provides direct access to lists of port names, their respective bit widths, and a list of tags identifying the ports. These values are used to specify and differentiate memory write ports when generating or manipulating memory implementations.",
      "description_length": 350,
      "index": 202,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize",
      "library": "hardcaml_xilinx",
      "description": "This module specializes 1D write port configurations for memory interfaces by parametrizing operations over data widths and input types, supporting transformations like zipping, mapping, and bit-level signal composition while tracking port names, widths, and combinational logic. It works with parameterized collections of write ports (`'a t`) indexed by tags and includes submodules for constructing memory write interfaces using fixed field widths, signal-backed representations, bit-level operations, and association list mappings. Operations like `mux`, `concat`, and `priority_select` enable precise control over memory write behavior, while functions for packing/unpacking, validation, and naming conventions support synthesis and FPGA-specific modeling such as Xilinx BRAM or URAM primitives. Use cases include synthesizing memory write interfaces from heterogeneous signal sources, optimizing memory implementations through width-aware specialization, and serializing port configurations using field names as identifiers.",
      "description_length": 1029,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.S-All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a list of monadic values into a monadic list of values, effectively sequencing the effects of the monads. It operates on types that are both monads and lists, allowing for the combination of multiple monadic computations into a single structured result. A concrete use case is aggregating multiple memory read operations into a single computation, ensuring they are executed and their results collected in sequence.",
      "description_length": 469,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Combinational_primitives",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic primitives for bit-level arithmetic, bitwise operations, and signal transformations on digital signal type `t`. It supports both signed and unsigned interpretations of bit vectors, offering arithmetic operations (addition, multiplication, comparison), bit manipulation (concatenation, selection, shifting), and conversions to/from integers, strings, and boolean values. Specific use cases include hardware synthesis for Xilinx FPGAs, leveraging primitives like LUT-based logic, carry-chain operations (`muxcy`, `xorcy`), and specialized arithmetic utilities (`popcount`, `priority_select`) for low-level circuit design.",
      "description_length": 660,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-O-Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to manipulate interface containers with wire and register variables in an always block. It supports assigning signals to variables, extracting signal values, and naming interface fields with optional prefixes and suffixes. Concrete use cases include building and connecting register and wire interfaces in hardware descriptions, such as initializing signal interfaces to zero or applying consistent naming conventions during register or wire creation.",
      "description_length": 483,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d",
      "library": "hardcaml_xilinx",
      "description": "This module enables the creation and manipulation of 1D write ports for memory configurations, supporting polymorphic types with address and data fields. It provides operations for writing to memory locations, mapping, zipping, and converting between structured interfaces and bit vectors, with support for signal assignment, multiplexing, and monadic transformations. Concrete use cases include building register files, implementing pipelined memory architectures, and generating HDL-ready port definitions with mixed storage elements like BRAM and URAM. Submodules enhance functionality with combinational logic, naming utilities, field-based configuration, and conversions to and from association lists or signal vectors.",
      "description_length": 724,
      "index": 207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Lut_size",
      "library": "hardcaml_xilinx",
      "description": "This module defines the maximum size of a LUT (Look-Up Table) used in Xilinx FPGA synthesis. It provides a single value `max_lut` that represents the largest LUT size supported, typically used to constrain or optimize circuit designs during synthesis. This value is essential for ensuring generated hardware descriptions fit within target device limitations.",
      "description_length": 358,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_sequential",
      "library": "hardcaml_xilinx",
      "description": "Implements sequential logic elements for synthesis, providing a `reg` function to create clocked registers with enable control. Works with `Signal.t` values and register specifications to model hardware state elements. Useful for generating synthesizable register instances in FPGA designs targeting Xilinx devices.",
      "description_length": 315,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d",
      "library": "hardcaml_xilinx",
      "description": "This module enables construction and manipulation of 2D memory write ports with polymorphic signal interfaces, supporting operations like address/data routing, packing/unpacking into bit vectors, and multiplexing with valid signals. It provides core data types representing write ports as structured, typed interfaces with field names, bit widths, and memory implementation metadata, allowing concrete tasks such as defining FPGA memory systems with multiple write lines or dynamic port selection. Child modules extend this with combinational logic, monadic lifting, signal-based transformations, and bit-level routing, enabling use cases like pipeline creation, error-aware memory blocks, and configuration-driven port assembly. Specific operations include mapping over port fields, zipping signal structures, lifting effects, and generating hardware from behavioral descriptions with precise width and naming control.",
      "description_length": 919,
      "index": 210,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a RAM port interface with monadic values into a monadic value of a RAM port interface, effectively lifting the monad through the interface. It operates on types involving `Hardcaml_xilinx.Ram_port_with_clear.t` and is useful when sequencing operations across multiple RAM ports within a monadic context. A concrete use case is coordinating the simultaneous initialization or clearing of multiple RAM ports in a structured, compositional way.",
      "description_length": 495,
      "index": 211,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Port_label",
      "library": "hardcaml_xilinx",
      "description": "This module defines labels for memory ports, supporting operations to serialize, compare, and list port identifiers. It works with the `t` type, which represents port labels as `A` or `B`. Use this module when configuring dual-port memory interfaces, such as distinguishing read/write ports in BRAM or URAM implementations.",
      "description_length": 323,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-O",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for transforming and combining hardware interface port data structures (`O.t`) with tagged names and bit widths, including mapping, zipping, and conversions to lists or signal tuples. It supports advanced manipulation of signal groups through n-ary folds, scans, and bit offset calculations, alongside utilities for RAM port configuration and width aggregation. These capabilities enable use cases like synthesizing Xilinx RAM primitives from HDL code, optimizing multi-port memory interfaces, and managing complex signal hierarchies with precise bit-level control.",
      "description_length": 597,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-I",
      "library": "hardcaml_xilinx",
      "description": "This module specializes in functional transformations and structured manipulation of hardware interface values (`I.t`), offering operations like mapping, zipping, folding, and bit offset calculations across tuples (up to five elements) and lists of signals. It supports tasks such as inferring RAMs from HDL always blocks with clock-driven read/write logic, resolving port associations by tags or names, and ensuring consistent signal width configurations during FPGA synthesis. Key applications include synthesizing memory structures, managing hierarchical signal naming, and assembling design components with precise bit-level control.",
      "description_length": 637,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to manipulate and assign signals within an always block using the Always API, specifically for RAM port interfaces. It supports creating register and wire variables, assigning signals, and applying naming conventions to interface fields. Use cases include synthesizing clocked memory operations and managing signal declarations with precise control over naming and behavior.",
      "description_length": 405,
      "index": 215,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-I-Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between an interface type and an association list indexed by field names. Works with polymorphic interface values and string-keyed lists. Useful for dynamically inspecting or constructing interfaces from named components.",
      "description_length": 230,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_sequential_primitives",
      "library": "hardcaml_xilinx",
      "description": "Implements Xilinx Unisim sequential primitives for FPGA synthesis. Provides `fdce`, `fdpe`, and `ram1s` functions to model flip-flops with enable and set/reset controls, and single-port RAM behavior. These functions operate on `Hardcaml.Signal.t` values, representing hardware signals in a design, enabling direct mapping of sequential logic to Xilinx FPGA primitives for simulation and synthesis.",
      "description_length": 397,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-I-Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to manipulate and assign signal values within an always block using the Always API, specifically for register and wire variables. It supports operations on interface structures (`I.t`) containing `Hardcaml.Always.Variable.t` values, enabling direct assignment, registration, and naming of signals. Concrete use cases include building and wiring hardware descriptions with named registers and signals, such as creating clocked state elements or connecting interface signals with default values.",
      "description_length": 524,
      "index": 218,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_comb_primitives",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic primitives for constructing and manipulating digital signals, including bitwise operations, arithmetic operations (such as signed and unsigned multiplication), and comparisons (equality and less-than). It operates on the `t` type representing hardware signals or wires, enabling use cases like synthesizing arithmetic logic units, data path components, and comparator circuits.",
      "description_length": 418,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.P",
      "library": "hardcaml_xilinx",
      "description": "This module provides preinitialized bit vectors and configuration parameters for Xilinx Sysmone1 hardware components, including calibration data, register settings, and simulation flags. It operates on bit vectors, clock inversion indicators, voltage monitor mappings, and simulation metadata to configure analog-to-digital converters, calibration states, and FPGA monitoring systems. Specific use cases include ADC initialization, hardware simulation setup, and voltage monitoring in FPGA-based designs.",
      "description_length": 504,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_sequential_primitives",
      "library": "hardcaml_xilinx",
      "description": "Implements Xilinx-specific sequential primitives for FPGA synthesis, targeting common hardware structures like flip-flops and single-port RAM. Provides functions `fdce`, `fdpe`, and `ram1s` to model D-type flip-flops with enable, D-type flip-flops with preset, and single-port RAM blocks, respectively. These primitives directly map to Xilinx FPGA cells for accurate simulation and synthesis in hardware design flows.",
      "description_length": 417,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d",
      "library": "hardcaml_xilinx",
      "description": "This module defines 2D memory read ports that retrieve data from specified addresses in structured memory configurations, supporting specialized backends like URAM and BRAM for optimized resource use. It provides data types such as signal tuples, `comb t` interfaces, and `Of_signal.t` representations, with operations to map, zip, multiplex, and pipeline memory outputs using priority or one-hot encoding. Submodules handle configuration construction, signal alignment, error aggregation, and runtime field-name lookups, enabling precise control over register and wire variables in FPGA memory designs. Example uses include building memory read interfaces that combine multiple storage primitives for performance or area efficiency in hardware synthesis.",
      "description_length": 755,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Xilinx_primitives-Uop",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for performing arithmetic and comparison on unsigned bit vectors, including addition, subtraction, multiplication, and comparisons like less than or equal. It supports data types `Bits.t` and `Signal.t`, allowing direct manipulation and conversion between them. These operations are used in hardware synthesis to build combinational logic circuits with precise control over bit widths and overflow behavior.",
      "description_length": 439,
      "index": 223,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives",
      "library": "hardcaml_xilinx",
      "description": "This module combines fixed-width bit vector operations with specialized FPGA synthesis features to enable precise hardware modeling and circuit construction. It supports arithmetic, bitwise, and logical operations on both signed and unsigned bit vectors, with automatic sign and zero extension, resizing, and width-aware computations through dedicated submodules. Main data types include bit vectors (`t`, `v`) representing hardware signals, with operations for addition, multiplication, comparison, slicing, concatenation, and conversion to and from integers or strings. Examples include building arithmetic logic units (ALUs), implementing control logic, synthesizing carry-aware adders, and optimizing combinatorial logic using LUT-based reductions tailored for Xilinx FPGAs.",
      "description_length": 778,
      "index": 224,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module enables the construction and transformation of RAM port interfaces using signal combinators, supporting operations like constant assignment, multiplexing, concatenation, pipelining, and field registration. It operates on RAM port signals represented as first-class combinators, allowing precise hardware description through input/output wiring, name customization, and signal assignment via the `<==` operator, particularly suited for FPGA designs requiring structured RAM interface manipulation in Xilinx-targeted workflows.",
      "description_length": 537,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations to manipulate and validate a RAM port interface with clearing functionality, using bit vectors. It supports construction from integers, packing/unpacking to and from bit vectors, multiplexing, concatenation, and selection operations with priority or one-hot encoding. These functions are used to implement and verify control logic for RAM ports during hardware compilation or simulation.",
      "description_length": 419,
      "index": 226,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.For_deriving",
      "library": "hardcaml_xilinx",
      "description": "This module enables the construction and configuration of memory implementations with support for 1D and 2D layouts, allowing per-bit-range specification of storage types like URAM or BRAM. It provides operations to define custom memory structures optimized for hardware targets such as FPGAs by selecting appropriate primitives based on performance and resource constraints. The main data types include memory configuration descriptors and layout specifications, which are used to instantiate and parameterize memory blocks. Example usage includes defining a 2D memory with mixed storage types where specific bit ranges are mapped to URAM for speed and others to BRAM for density.",
      "description_length": 681,
      "index": 227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Xilinx_primitives-Unsigned",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with unsigned bit vectors, including arithmetic operations like addition, subtraction, and multiplication, with automatic bit-width extension to prevent truncation. It supports comparison operations between vectors of differing widths and allows resizing of vectors to specified bit widths. These capabilities are used for hardware synthesis tasks involving unsigned integer values in digital circuit design.",
      "description_length": 452,
      "index": 228,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d",
      "library": "hardcaml_xilinx",
      "description": "This module defines 1D read port configurations for memory implementations targeting Xilinx storage resources, supporting precise control over address width, data output, and signal naming. It provides core data types like `comb t`, `Always.Variable.t t`, and `Signal.t t`, enabling operations such as packing/unpacking fields, multiplexing, concatenation, and priority selection with combinational or registered signals. Child modules enhance this functionality with mapping, zipping, and aggregation over named, width-tagged port data, supporting synthesis-ready metadata generation and bit-level composition. Use cases include configuring FPGA memory systems with mixed URAM/BRAM storage, building pipelined memory interfaces, and generating named, width-validated ports for synthesis and debugging.",
      "description_length": 802,
      "index": 229,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Xilinx_primitives-Signed",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with signed binary vectors in hardware description contexts. It supports arithmetic operations like addition, subtraction, and multiplication with automatic sign extension, as well as comparison operations between vectors of differing widths. Concrete use cases include implementing arithmetic logic units (ALUs) and control logic that require precise handling of signed values during synthesis.",
      "description_length": 439,
      "index": 230,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines the names and widths of ports used in a RAM-clearing state machine. It provides direct access to port identifiers, their bit widths, and associated tags for hardware synthesis. It is used to configure and generate correct port mappings when instantiating RAM-clearing logic in FPGA designs.",
      "description_length": 310,
      "index": 231,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Combinational_primitives-module-type-Typed_math",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for performing arithmetic and comparison on bitvector values, including addition, subtraction, multiplication, and comparisons like less-than or equal-to. It works with a bitvector type `v` that supports dynamic width adjustments through sign or zero extension during operations. These functions are used to model and synthesize digital circuits where precise bit-level control and arithmetic behavior are required.",
      "description_length": 447,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Combinational_primitives-Unsigned",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with unsigned binary vectors in a hardware description context. It supports arithmetic operations like addition, subtraction, and multiplication, with automatic bit-width extension to preserve precision. It also includes comparison operators and a resize function for adjusting vector widths, making it suitable for tasks like register transfer level (RTL) design and digital signal processing.",
      "description_length": 438,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for manipulating RAM port interfaces with a clear state. It supports multiplexing, packing/unpacking, concatenation, and selection operations on a structured interface composed of signal vectors. Use it to build complex signal routing or control logic for RAM access in hardware designs.",
      "description_length": 339,
      "index": 234,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Lut_equation",
      "library": "hardcaml_xilinx",
      "description": "This module represents Boolean expressions for generating LUT initialization values in Xilinx FPGAs. It provides logical operators to construct expressions from input variables (i0-i5), constants (gnd, vdd), and supports evaluation of these expressions for specific input combinations. Use this to programmatically define and evaluate LUT contents during hardware synthesis.",
      "description_length": 374,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Combinational_primitives-Signed",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for working with signed binary vectors in a hardware description context. It supports arithmetic operations like addition, subtraction, and multiplication, with automatic sign extension and widening to prevent truncation. It also includes comparison operators for signed vectors of differing widths and a resize function for explicit width adjustment. These operations are used when designing and synthesizing digital circuits that require signed integer arithmetic, such as DSP components or control logic.",
      "description_length": 539,
      "index": 236,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make",
      "library": "hardcaml_xilinx",
      "description": "This module implements parameterized RAM structures with independent read/write port widths and enables dynamic configuration of memory interfaces through structured signal manipulation. It provides core operations for defining memory ports, transforming interfaces with mapping and zipping combinators, and synthesizing hardware with precise bit-width control. Users can build pipelined memory systems, aggregate signal computations into typed interfaces, or generate configuration-driven RAM instances with varying depths and widths. Submodules extend these capabilities with bitvector logic, always-block signal assignment, and metadata-aware transformations for constructing complex hardware pipelines and control units.",
      "description_length": 724,
      "index": 237,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Lut6",
      "library": "hardcaml_xilinx",
      "description": "This module provides a value `max_lut` representing the maximum number of LUT6 elements available in a Xilinx FPGA synthesis context. It is used to define or constrain the number of lookup tables available for hardware compilation targeting Xilinx devices. Concrete use cases include resource estimation and optimization during the synthesis of digital circuits in Hardcaml workflows.",
      "description_length": 384,
      "index": 238,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Config",
      "library": "hardcaml_xilinx",
      "description": "This module configures memory builders with parameters like data width, latency, and instantiation method, supporting 1D and 2D memory layouts using components such as BRAM or URAM. It allows specifying cascade heights, simulation names, and bit ranges to tailor memory blocks for FPGA designs. The child module extends this functionality by providing Xilinx-specific configurations, enabling precise control over memory depth, width, and storage type. For example, it can define a 72-bit memory using URAM with additional BRAM for wider bit ranges, or set read latencies and addressing modes in a 2D layout.",
      "description_length": 608,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-I-Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating bit-level interfaces, primarily through packing, unpacking, multiplexing, and concatenation of signal vectors. It works with fixed-width bit vectors and structured interfaces composed of these vectors, enabling precise control over signal widths and layouts in hardware descriptions. Concrete use cases include assembling register files, defining memory interfaces, and managing signal routing in digital circuits where bit-level precision is required.",
      "description_length": 518,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-O-Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between a structured interface and an association list mapping field names to values. Works with any polymorphic type `'a O.t` representing a hardware description interface. Useful for dynamically inspecting or constructing hardware modules from named field-value pairs, such as during configuration or serialization tasks.",
      "description_length": 332,
      "index": 241,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Lut4",
      "library": "hardcaml_xilinx",
      "description": "This module defines a maximum LUT (Look-Up Table) value for Xilinx synthesis, typically used to constrain logic synthesis to 4-input LUTs. It works with integer values representing LUT sizes and is used in contexts where hardware description needs to align with Xilinx FPGA architecture limitations. Concrete use cases include setting synthesis constraints for combinational logic blocks in FPGA designs.",
      "description_length": 404,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-I-Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module implements combinational logic operations for manipulating structured interfaces, including packing/unpacking to/from bit vectors, multiplexing, concatenation, and selection functions like priority and one-hot encoding. It works with interfaces parameterized over a combinational logic type, supporting operations that ensure correct signal widths and enable hardware construction patterns. Concrete use cases include building register files, control logic, and data path circuits where structured signal manipulation is required.",
      "description_length": 542,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create",
      "library": "hardcaml_xilinx",
      "description": "This module constructs memory implementations with configurable storage elements and latencies. It supports creating 1D memory arrays with specified depth, clocking, and reset behavior, using configurations to select memory types like URAM or BRAM. Use it to instantiate hardware memories in FPGA designs where specific resource allocation and timing are required.",
      "description_length": 364,
      "index": 244,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-O-Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module implements combinational logic operations for manipulating structured data interfaces, including packing/unpacking to vectors, multiplexing, concatenation, and selection operations. It works with typed signal interfaces (`comb O.t`) and bit vectors (`comb`), supporting width validation and constant initialization. Concrete use cases include building register files, decoding instruction fields, and constructing finite state machines with encoded signal routing.",
      "description_length": 476,
      "index": 245,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-I-All",
      "library": "hardcaml_xilinx",
      "description": "Lifts monadic values within an interface to the top level by combining them into a single monadic interface. Works with any monad `M` and interface `I` containing monadic values. Useful for constructing hardware descriptions where multiple monadic computations need to be sequenced into a single interface.",
      "description_length": 306,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module implements combinational logic operations for manipulating RAM port interfaces in hardware designs. It supports operations like packing/unpacking interfaces to/from bit vectors, multiplexing and concatenating port signals, and priority/one-hot selection with optional branching factors. These functions are used to build complex control logic for memory access in FPGA designs targeting Xilinx devices.",
      "description_length": 414,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Config",
      "library": "hardcaml_xilinx",
      "description": "This module defines configuration parameters for RAM instances, including memory size, word width, port scaling, read latency, and optional behaviors like collision handling, byte writes, and clocking modes. It is used to specify hardware characteristics when generating RAM components in FPGA designs. Concrete use cases include configuring dual-port RAMs with specific access patterns and resource constraints.",
      "description_length": 412,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Sequential_primitives",
      "library": "hardcaml_xilinx",
      "description": "Implements Xilinx-specific sequential primitives for FPGA synthesis. Provides `fdce` and `fdpe` for D-type flip-flops with clear and preset controls, and `ram1s` for modeling single-port RAM. These functions operate on `Signal.t` values to directly map to hardware registers and memory elements in Xilinx FPGAs.",
      "description_length": 311,
      "index": 249,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating RAM port interfaces using combinational logic. It supports values of type `comb` and structured RAM port types, enabling tasks like packing/unpacking signals, multiplexing, concatenation, and selection from one-hot or priority-encoded inputs. Concrete use cases include building memory interface pipelines, selecting between multiple RAM ports based on control signals, and validating signal widths during design elaboration.",
      "description_length": 491,
      "index": 250,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Combinational_primitives-Uop",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for performing unsigned arithmetic and comparisons on bit vectors, including addition, subtraction, multiplication, and resizing, with automatic bit-width extension to prevent truncation. It supports data types like `Bits.t` and `Signal.t`, enabling direct manipulation of digital signals in hardware descriptions. Concrete use cases include implementing arithmetic logic units (ALUs), comparators, and bit-width adjustments in FPGA designs.",
      "description_length": 473,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O",
      "library": "hardcaml_xilinx",
      "description": "This module orchestrates the construction and transformation of structured hardware signals with fixed bit-widths, combining core operations with specialized submodules to model combinatorial logic, signal routing, and register manipulation. It centers around data types like `t` and `comb`, which represent structured signal collections and combinational logic values, respectively, enabling bit-level manipulation through operations such as multiplexing, concatenation, and assignment. Submodules handle tasks like converting records to association lists, defining port interfaces, generating ICAP3 signals, and flattening nested configurations, supporting concrete applications such as FPGA control logic, pipeline construction, and interface serialization.",
      "description_length": 760,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-O-module-type-Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of bit vectors. It supports constant creation, packing/unpacking, multiplexing, concatenation, and selection operations on signal interfaces with defined bit widths. Use cases include building and validating digital circuit components like multiplexers, priority encoders, and fixed-width data paths in hardware designs.",
      "description_length": 415,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-I-module-type-Comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating hardware interfaces with combinational logic, specifically handling vector packing, unpacking, multiplexing, and concatenation. It works with bit vectors and structured interfaces where each field has a defined width. Concrete use cases include building register files, implementing data path logic, and managing signal routing in FPGA designs targeting Xilinx devices.",
      "description_length": 435,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Combinational_primitives-Sop",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for performing signed arithmetic and comparisons on bit vectors, including addition, subtraction, multiplication, and resizing, with automatic sign extension. It supports the `t` type, representing signed values, and allows direct conversion to and from combinational logic signals. Concrete use cases include implementing arithmetic logic units (ALUs) and comparison-based control logic in hardware designs.",
      "description_length": 440,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives",
      "library": "hardcaml_xilinx",
      "description": "This module provides bitvector operations for modeling Xilinx FPGA primitives, combining direct arithmetic, bitwise, and conversion functions with specialized submodules for signed and unsigned semantics. The core functionality centers on fixed-width bitvectors (`t`, `v`, `Bits.t`, `Signal.t`), supporting addition, multiplication, comparisons, shifting, resizing, and priority encoding with correct width handling. Signed and unsigned submodules enable width-aware arithmetic and comparisons, with sign extension and truncation control for precise hardware modeling. Examples include synthesizing ALUs, implementing comparators, and transforming signal widths in combinational circuits targeting Xilinx FPGAs.",
      "description_length": 711,
      "index": 256,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic primitives for manipulating fixed-width bit vectors, supporting arithmetic, bitwise, and comparison operations on both signed and unsigned values. It includes data types like `t` and `v` to represent bit vectors, with operations for addition, multiplication, comparison, bit slicing, concatenation, and sign-aware resizing, enabling precise control over bit-level behavior. Submodules specialize in arithmetic for signed and unsigned vectors, offering operations such as addition, subtraction, and comparison with proper width handling, used for building ALUs, control logic, and FPGA datapath components. Examples include synthesizing adders with automatic sign extension, implementing comparators for unsigned values, and constructing multiplexed data paths with explicit bit ordering and resizing semantics.",
      "description_length": 851,
      "index": 257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating combinatorial signal interfaces that control Xilinx RAM port behavior, including constant initialization, signal wiring, register pipelining, and multiplexing. It operates on structured signal types representing RAM port connections, enabling tasks like routing control signals, applying priority or one-hot selection logic, and managing signal naming conventions. These capabilities are used to implement memory control circuits, such as initializing RAM contents, sequencing port operations, or building configurable memory-mapped interfaces on Xilinx FPGAs.",
      "description_length": 626,
      "index": 258,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Xilinx_primitives-module-type-Typed_math",
      "library": "hardcaml_xilinx",
      "description": "This module provides arithmetic and comparison operations on a custom type `v`, which represents hardware signals with bit-level precision. It supports addition, subtraction, multiplication, and comparisons like less than or equal, greater than, and equality, with automatic width extension to preserve precision. These operations are used to model and manipulate digital signals in hardware description workflows, particularly for FPGA synthesis targeting Xilinx devices.",
      "description_length": 472,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I",
      "library": "hardcaml_xilinx",
      "description": "This module enables structural manipulation and introspection of hardware interfaces through higher-order operations like mapping, folding, and zipping over parameterized interface types, port metadata, and signals. It supports transformations between structured and list-based representations, error propagation, and synthesis metadata handling, with utilities for managing bit-widths and always-asserted signals in FPGA workflows. Submodules provide specialized functionality such as lifting monomorphic values into polymorphic contexts, packing and unpacking bit-level data, defining Xilinx ICAP3 port metadata, and constructing combinational logic, registers, and signal assignments. Examples include assembling configuration packets, building priority-encoded multiplexers, generating signal declarations, and implementing pipelined register stages using structured interface types and signal routing.",
      "description_length": 906,
      "index": 260,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-O-Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines a list of memory port names and their corresponding widths, along with a list of tags for memory port annotations. It provides direct access to these lists individually, including separate extractions for names and widths. This is used to describe memory interface configurations in a hardware design context, specifically for mapping to Xilinx RAM primitives with precise port sizing and identification.",
      "description_length": 424,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-O-All",
      "library": "hardcaml_xilinx",
      "description": "This module provides a function `all` that transforms a structure containing monadic values into a monadic structure of values, effectively sequencing the monads while preserving the outer structure. It operates on data types that combine a monad `M` with a structure `O`, such as lists or options wrapped in monadic contexts. A concrete use case is combining multiple signal wires in a hardware description, where each wire is in a monadic context representing construction state, into a single structured result.",
      "description_length": 514,
      "index": 262,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Widths_2d",
      "library": "hardcaml_xilinx",
      "description": "This module defines the index and dimension parameters for constructing 2D memories, where `vertical_index_width` specifies the bit width of the vertical address and `horizontal_dimension` defines the number of horizontal memory segments. It supports precise configuration of memory layouts by allowing separate control over vertical addressing and horizontal structure. Concrete use cases include setting up multi-ported or segmented memory architectures with specific width and depth requirements.",
      "description_length": 499,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S",
      "library": "hardcaml_xilinx",
      "description": "This module defines a hardware description for a RAM block with independent read and write address/data widths, supporting configurable bit widths for addresses, data, and write enables. It provides `create` and `hierarchical` functions to instantiate the RAM within a hardware scope using specified input/output interfaces. Concrete use cases include implementing memory blocks in FPGA designs where asymmetric read/write ports or bit-width conversions are required.",
      "description_length": 467,
      "index": 264,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Of_always",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to manipulate and assign signals within an always block for a RAM port interface that supports clearing. It includes operations to create register or wire variables, assign values to interface fields, and apply naming conventions to signals. Use this when implementing state machines or control logic that requires initializing or resetting RAM ports during simulation or synthesis.",
      "description_length": 413,
      "index": 265,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-O-Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and manipulating hardware interfaces composed of bit vectors. It supports constant initialization, packing/unpacking to and from vectors, multiplexing, concatenation, and selection operations with support for validity signals. These functions are used to build complex digital circuits with well-defined signal widths and behaviors.",
      "description_length": 381,
      "index": 266,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.All",
      "library": "hardcaml_xilinx",
      "description": "Lifts monadic values within a RAM port structure, transforming a RAM port containing monadic values into a monad containing a RAM port of pure values. Works with any monad `M` and `Hardcaml_xilinx.Ram_port.t` structures. Useful for handling effectful computations across RAM port fields while preserving their hardware description context.",
      "description_length": 339,
      "index": 267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-I-Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines a list of memory port names paired with their bit widths, along with separate lists for port names and widths. It also includes a list of tags associated with the ports. This structure is used to describe the interface of a RAM block with resizing capabilities, specifically for code generation and simulation in hardware design flows.",
      "description_length": 355,
      "index": 268,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make",
      "library": "hardcaml_xilinx",
      "description": "This module provides a hardware abstraction for Xilinx's SysMONE1 primitive, enabling configuration and instantiation of analog monitoring and temperature sensing features with defined input and output signal interfaces. It supports direct manipulation of hardware signals and structured port data through combinational logic synthesis, signal transformation, and hierarchical restructuring, using key types like `'a t`, `comb`, and `'a I.t` for structured port associations. You can use it to build pipelines, ALUs, and control logic while integrating voltage, temperature, and current measurement capabilities into FPGA designs targeting Xilinx devices, with support for bitvector arithmetic, register management, and explicit width validation. Examples include synthesizing logic with multiplexers, converting composite signal types, reordering port metadata, and defining register specifications with enable signals for simulation or synthesis.",
      "description_length": 948,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface",
      "library": "hardcaml_xilinx",
      "description": "This module implements a synchronous FIFO with interface signaling for data transfer, supporting push and pop operations alongside configurable capacity and memory behavior. It structures and transforms typed hardware interfaces with metadata, enabling operations like mapping, zipping, and converting between structured interfaces and lists while preserving field offsets and handling error-aware data. It pairs data with valid signals, supporting mapping, folding, and combinational logic while maintaining validity semantics for tasks like pipeline insertion and FIFO control logic. Specific uses include building bit-width-accurate FIFOs, generating Verilog interfaces, and synthesizing control logic with priority encoding and signal packing.",
      "description_length": 747,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Widths_1d",
      "library": "hardcaml_xilinx",
      "description": "This module computes address and data widths for 1D memory configurations based on the target memory type and capacity. It works with integer values to determine how memory bits are distributed across addressable units. Use it to configure memory layouts when implementing custom memory blocks using Xilinx primitives like BRAM or URAM.",
      "description_length": 336,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Names_and_widths",
      "library": "hardcaml_xilinx",
      "description": "This module defines a list of memory port names paired with their bit widths, along with separate lists of port names and widths. It works with basic types like strings, integers, and lists, specifically tailored for describing RAM port configurations. Concrete use cases include generating signal names and widths for hardware description in Xilinx RAM primitives.",
      "description_length": 365,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-I-Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for constructing and transforming hardware signal interfaces, focusing on signal assignment, interface composition, and naming conventions. It works with structured signal vectors (`I.Of_signal.comb I.t`) and field-width-defined interfaces, enabling tasks like register creation, multiplexing, and hierarchical signal packing. These capabilities are used to define FPGA hardware blocks with precise signal routing and named input/output ports for synthesis and simulation workflows.",
      "description_length": 514,
      "index": 273,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Make_comb",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational logic operations for manipulating RAM port interfaces with a clear state. It supports construction from integers, packing/unpacking to bit vectors, multiplexing, concatenation, and selection operations with priority or one-hot encoding. The operations apply to RAM port signals with defined bit widths, enabling precise control over memory port behavior in hardware designs.",
      "description_length": 409,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.S-O-Of_signal",
      "library": "hardcaml_xilinx",
      "description": "This module provides structural transformations for hardware signals, including packing/unpacking, multiplexing, concatenation, and register creation, alongside utilities for signal assignment and interface management. It operates on combinational (`comb`) and registered (`t`) signal types, enabling type-safe manipulation and hierarchical interface construction. These capabilities are particularly useful in FPGA or ASIC design flows for organizing complex datapaths and ensuring signal integrity through precise naming and structural decomposition.",
      "description_length": 552,
      "index": 275,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Of_bits",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for manipulating RAM port interfaces represented as bit vectors. It supports packing and unpacking interfaces to and from bit vectors, multiplexing and concatenating multiple interfaces, and validating signal widths. These functions are used to construct and manage memory port configurations with specific bit-level representations for hardware synthesis.",
      "description_length": 388,
      "index": 276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.M",
      "library": "hardcaml_xilinx",
      "description": "This module provides functions to construct and manipulate memory implementations with support for 1D and 2D configurations. It works with `Hardcaml.Signal.t` values and user-defined memory configurations via the `Config.t` type. Concrete use cases include defining memories that use specific hardware resources like URAM or BRAM for different bit ranges.",
      "description_length": 355,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Xilinx_primitives-Sop",
      "library": "hardcaml_xilinx",
      "description": "This module provides operations for performing signed arithmetic and comparisons on bit vectors, including addition, subtraction, multiplication, and resizing. It supports data types like `t` representing bit vectors, and allows conversion to and from combinational logic signals. Concrete use cases include implementing fixed-point arithmetic circuits and comparison logic in hardware designs.",
      "description_length": 394,
      "index": 278,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Xilinx_primitives",
      "library": "hardcaml_xilinx",
      "description": "This module enables constructing and manipulating hardware signals (`t`) through bit-level operations, arithmetic, and logical functions tailored for Xilinx FPGA synthesis. It operates on bitvectors, signed/unsigned integers, and constants (e.g., VDD, GND), supporting tasks like carry propagation, LUT-based logic, and bitwidth optimization. Key use cases include digital circuit design, signal resizing, priority encoding, and efficient arithmetic implementations with precise control over bit-level layout and signedness.",
      "description_length": 524,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "Converts between RAM port records and association lists indexed by field names, enabling direct mapping of port fields to key-value pairs. Works with `Hardcaml_xilinx.Ram_port.t` values and string-keyed lists of arbitrary data. Useful for inspecting or constructing RAM port interfaces from named components, such as when parsing or serializing configuration data.",
      "description_length": 364,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Unsafe_assoc_by_port_name",
      "library": "hardcaml_xilinx",
      "description": "This module directly maps RAM port operations to string keys, enabling dynamic access and manipulation of RAM port states by name. It supports conversion between a structured RAM port interface and an association list, where each entry pairs a port name with its corresponding value. Use this to programmatically manage RAM port configurations or clear states using string-based identifiers.",
      "description_length": 391,
      "index": 281,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Clocking_mode",
      "library": "hardcaml_xilinx",
      "description": "This module defines clocking modes for hardware configurations, specifically supporting common and independent clock domains. It provides serialization to S-expressions and conversion to XPM-compatible string arguments. Use this module to specify clocking behavior in FPGA designs that require distinct or shared clock domains for memory or register blocks.",
      "description_length": 357,
      "index": 282,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis",
      "library": "hardcaml_xilinx",
      "description": "This module provides combinational and sequential primitives tailored for Xilinx FPGA synthesis, centered around LUT-based logic, carry chains, and Hardcaml/Unisim-compatible components. It supports bitvector types (`t`, `v`, `Signal.t`, `Bits.t`) with signed and unsigned arithmetic, bitwise operations, comparisons, and width-aware resizing, enabling precise control over digital circuit behavior. Key operations include LUT instantiation, carry-aware addition, popcount, priority selection, and register creation with enable/set/reset controls. Examples include synthesizing arithmetic logic units with carry logic, implementing state machines with clocked registers, and constructing RAM blocks or wide counters constrained by `max_lut` limits.",
      "description_length": 748,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Byte_write_width",
      "library": "hardcaml_xilinx",
      "description": "This module defines byte write width configurations for memory operations, supporting 8-bit, 9-bit, or full bus width. It is used to specify the granularity of write operations in memory interfaces, particularly when aligning with hardware constraints. Concrete use cases include configuring memory controllers or bus interfaces where precise control over write data width is required.",
      "description_length": 385,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1",
      "library": "hardcaml_xilinx",
      "description": "This module implements a Xilinx Sysmone1 primitive for reading temperature, voltage, and sensor data in Hardcaml designs, using `Signal.t` values to interface with hardware registers and control signals. It integrates preinitialized bit vectors and configuration parameters from its child modules to set up ADCs, calibration states, and simulation metadata, enabling FPGA monitoring systems with precise signal manipulation. The hardware abstraction layer allows structured port definitions, combinational logic synthesis, and register management, supporting operations like pipeline construction, signal transformation, and voltage monitoring. Specific capabilities include configuring analog monitoring features, synthesizing logic with multiplexers, and defining enable-controlled register specifications for simulation or synthesis.",
      "description_length": 836,
      "index": 285,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync",
      "library": "hardcaml_xilinx",
      "description": "This module provides a synchronous FIFO with push/pop signaling, configurable capacity, and support for overflow/underflow detection, nearly full/empty thresholds, and cascading. It operates on Hardcaml signals, enabling simulation or XPM-based synthesis, and structures hardware interfaces with metadata for mapping, zipping, and converting between typed interfaces and lists. Child modules enhance this functionality by pairing data with valid signals, enabling pipeline insertion, control logic synthesis with priority encoding, and generating bit-width-accurate FIFOs with Verilog-compatible interfaces. Examples include buffering data streams in communication interfaces, implementing pipeline stages with precise timing, and building error-aware FIFO control logic with combinational transformations.",
      "description_length": 806,
      "index": 286,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Cascade_height",
      "library": "hardcaml_xilinx",
      "description": "This module defines the height of BRAM cascade chains for Xilinx FPGA configurations, supporting two modes: inferred cascade height and explicitly specified heights. It provides conversion to XPM module arguments and S-expression serialization for configuration and debugging purposes. Useful for controlling BRAM cascade behavior in Vivado to meet timing constraints without unnecessary cascading.",
      "description_length": 398,
      "index": 287,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder",
      "library": "hardcaml_xilinx",
      "description": "This module builds configurable 1D and 2D memory structures using Xilinx primitives like URAM and BRAM, allowing fine-grained control over memory layout and implementation. It supports setting read and write ports with specific signal types, enforcing correct usage through typed interfaces and runtime checks. Concrete use cases include implementing memories with mixed storage types across bit ranges, or constructing 2D memories with atomic row writes and configurable dimensions. The module provides core data types for memory configurations, port labels, and signal interfaces, with operations to map, zip, and transform structured memory ports while ensuring correct bit-width and naming conventions. Submodules handle 1D and 2D write and read port construction, memory layout configuration, signal routing, and width computation, enabling tasks like building register files, pipelined memory interfaces, and FPGA memory systems with dynamic port selection and optimized resource allocation.",
      "description_length": 997,
      "index": 288,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Collision_mode",
      "library": "hardcaml_xilinx",
      "description": "Represents and converts collision resolution modes for memory operations. Supports conversion to S-expressions and XPM parameter strings. Used to specify behavior during memory read/write collisions in hardware descriptions.",
      "description_length": 224,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Simple_dual_port_ram",
      "library": "hardcaml_xilinx",
      "description": "Implements a Xilinx-compatible simple dual-port RAM with separate read and write ports. It supports configurable parameters like read latency, memory architecture, byte write width, and cascade height, tailored for FPGA synthesis. This module is used to model on-chip memory blocks in hardware designs where independent read and write operations are required.",
      "description_length": 359,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_async",
      "library": "hardcaml_xilinx",
      "description": "Implements an asynchronous FIFO with configurable capacity, supporting independent read and write clocks, clear control, and optional nearly full/empty thresholds. Works with hardware description signals for control and data paths. Used to buffer data between clock domains in FPGA designs, such as interfacing between a fast write pipeline and a slower read process.",
      "description_length": 367,
      "index": 291,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.True_dual_port_ram",
      "library": "hardcaml_xilinx",
      "description": "This module implements a true dual-port RAM with independent clocks for each port, supporting concurrent read and write operations. It works with signals and memory ports defined in the Hardcaml and Hardcaml_xilinx libraries, allowing configuration of parameters such as read latency, memory architecture, and clocking mode. It is used to model Xilinx FPGA block RAMs in both synthesis and simulation flows, enabling accurate hardware generation and behavioral simulation.",
      "description_length": 472,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_memory_type",
      "library": "hardcaml_xilinx",
      "description": "This module defines types and conversions for specifying FIFO memory implementations in Xilinx FPGAs. It supports selecting between automatic, block RAM, distributed RAM, and UltraRAM configurations. The `to_xpm_args` function maps each type to its corresponding XPM parameter string for use in hardware generation.",
      "description_length": 315,
      "index": 293,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear",
      "library": "hardcaml_xilinx",
      "description": "This module implements a state machine for systematically clearing RAM contents through its ports, combining functional transformations and list-like operations over port structures with integrated clearing logic. It operates on typed collections of ports annotated with names, widths, and tags, supporting combinators like map, zip, and fold alongside control logic for driving address and write-enable signals during initialization. Child modules enhance this functionality by enabling monadic sequencing, bit vector manipulation, signal routing, and dynamic name-based access to port states. Specific capabilities include coordinating multi-port initialization, validating control logic with bit vectors, generating correct port mappings for FPGAs, and dynamically converting structured interfaces to named value associations for simulation or synthesis.",
      "description_length": 857,
      "index": 294,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port",
      "library": "hardcaml_xilinx",
      "description": "This module structures RAM port interface manipulation through mapping, folding, and zipping over `Ram_port.t` values, which capture port metadata and signals. It supports conversions between structured interfaces, lists, and association lists, while submodules enable signal assignment within always blocks, combinational logic construction, bit-vector transformations, and monadic lifting of port fields. Key operations include signal combinators for multiplexing, concatenation, and field registration, along with utilities for naming, width validation, and mapping to RTL primitives. Use cases include synthesizing Xilinx-targeted RAM configurations, building memory pipelines, and managing signal declarations with precise bit-level control.",
      "description_length": 746,
      "index": 295,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Dual_port_ram",
      "library": "hardcaml_xilinx",
      "description": "Implements a dual-port RAM with a single clock domain, supporting simultaneous read and write operations on two independent ports. Works with signals and memory ports configured for Xilinx FPGA targets, allowing control over parameters like read latency, byte write width, and memory optimization. Useful for high-performance memory access in FPGA-based designs where concurrent data paths are required.",
      "description_length": 403,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3",
      "library": "hardcaml_xilinx",
      "description": "This module implements a Xilinx ICAP interface for FPGA configuration, allowing instantiation with custom parameters and interaction through structured signal types defined in its `I` and `O` submodules. It centers on data types like `t` and `comb` for modeling signal collections and combinational logic, supporting operations such as multiplexing, concatenation, and register manipulation. The module enables concrete tasks like assembling configuration packets, building multiplexers, and generating signal declarations, while submodules handle transformations, metadata, and bit-level packing. Together, it provides a structured way to model FPGA control logic, pipeline stages, and interface serialization with precise signal routing and port management.",
      "description_length": 759,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_arch",
      "library": "hardcaml_xilinx",
      "description": "This module defines RAM architecture types for Xilinx FPGAs, including distributed RAM, block RAM with configurable collision modes, and UltraRAM. It provides functions to convert these types to S-expressions and XPM parameter strings. Use this module to specify RAM primitives in hardware designs targeting Xilinx devices, ensuring correct synthesis and simulation behavior.",
      "description_length": 375,
      "index": 298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing",
      "library": "hardcaml_xilinx",
      "description": "This module implements parameterizable RAM structures with dynamic resizing, supporting arbitrary address reads and writes using bit vectors and hardware primitives. It provides core operations for defining memory ports, transforming interfaces with mapping and zipping combinators, and synthesizing hardware with precise bit-width control, enabling users to build pipelined memory systems or configuration-driven RAM instances. Submodules enhance these capabilities with signal assignment in always blocks, interface packing/unpacking, and combinational logic for multiplexing and concatenation, supporting tasks like synthesizing Xilinx RAM primitives, managing hierarchical signal naming, and constructing finite state machines. Specific use cases include FPGA synthesis of asymmetric memory blocks, register file construction, and signal routing with bit-level precision.",
      "description_length": 875,
      "index": 299,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx",
      "library": "hardcaml_xilinx",
      "description": "This module provides hardware description primitives and memory structures tailored for Xilinx FPGA synthesis, enabling precise control over clock domains, memory configurations, and signal manipulation. Core data types include signal representations (`Signal.t`, `Bits.t`), memory ports, FIFOs, and configuration parameters for RAM architectures, clocking modes, and collision resolution. Operations span LUT-based logic, carry-aware arithmetic, synchronous and asynchronous FIFOs, dual-port RAMs with independent clocks, and SysMon-based sensor interfaces, all supporting bit-width-aware transformations and synthesis-friendly constructs. Examples include building pipelined arithmetic units, configuring memory controllers with byte-level write granularity, implementing state machines with reset logic, and integrating temperature monitoring systems into FPGA designs.",
      "description_length": 872,
      "index": 300,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 302,
    "meaningful_modules": 301,
    "filtered_empty_modules": 1,
    "retention_rate": 0.9966887417218543
  },
  "statistics": {
    "max_description_length": 1029,
    "min_description_length": 224,
    "avg_description_length": 490.33554817275746,
    "embedding_file_size_mb": 1.0936346054077148
  }
}