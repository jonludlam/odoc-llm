{
  "package": "hardcaml_xilinx",
  "embedding_model": "BAAI/bge-base-en-v1.5",
  "embedding_dimension": 1024,
  "total_modules": 462,
  "creation_timestamp": "2025-06-18T17:13:49.796805",
  "modules": [
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is particularly useful for writing concise, readable code in contexts involving option, result, or other monadic types.",
      "description_length": 426,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is typically used to simplify code that involves monadic structures like option, list, or result.",
      "description_length": 404,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is typically used to simplify code that involves monadic structures like option, result, or async.",
      "description_length": 405,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is particularly useful for writing concise, readable code in contexts involving option types, results, or other monadic structures.",
      "description_length": 438,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. While no concrete data types or functions are defined, it serves as a foundation for integrating domain-specific notations. Developers can use its syntax to write more expressive and concise code when working with effectful computations.",
      "description_length": 437,
      "index": 4,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic types such as 'unit' and 'option' are supported through simplified expression forms. Users can write more concise and expressive code by leveraging these syntactic conveniences.",
      "description_length": 383,
      "index": 5,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. While no concrete data types or functions are defined, it serves as a foundation for integrating domain-specific notations. Developers can use its syntax to write more expressive and concise code when working with effectful computations.",
      "description_length": 437,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations include `let%` and `and%` for inline bindings, and `return` for embedding values. It is typically used to simplify code that relies on monadic interfaces like `Option` or `List`.",
      "description_length": 395,
      "index": 7,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. While no concrete data types or functions are defined, it serves as a foundation for extending syntax in compatible modules. Developers can use its notation to write more expressive and concise code when combined with other modules.",
      "description_length": 432,
      "index": 8,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and returning values within monadic contexts. Operations include `let%` and `and%` for sequencing computations. This enables cleaner, more readable code when handling effectful or nested operations.",
      "description_length": 327,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is particularly useful for writing concise, readable code in contexts involving option types, results, or other monadic structures.",
      "description_length": 438,
      "index": 10,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. While no concrete data types or functions are defined, it serves as a foundation for integrating domain-specific notations. Developers can use its syntax to write more expressive and concise code when combined with other modules.",
      "description_length": 429,
      "index": 11,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations include `let%bind` and `let%return`, which simplify chaining of monadic actions. It is particularly useful for writing clean, imperative-style code in a functional context.",
      "description_length": 389,
      "index": 12,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is particularly useful for writing concise and expressive code in contexts involving option, result, or other monadic types.",
      "description_length": 431,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is particularly useful for writing concise, readable code in contexts involving option types, results, or other monadic structures.",
      "description_length": 438,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values of arbitrary width. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 311,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise control over signed integer operations in hardware description or low-level numeric computations.",
      "description_length": 319,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bit vectors or signals, allowing for width-aware operations and conversions. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 349,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or verification contexts.",
      "description_length": 335,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that support binding and lifting. Enables chaining of effectful operations and transformation of wrapped values in a concise syntax.",
      "description_length": 248,
      "index": 19,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of effectful computations through constructs like `let%bind` and `let%map`. Supports sequencing and binding within monadic contexts, simplifying workflows involving option, result, or similar types. Allows for more readable and structured code when chaining operations that carry computational effects. Example: binding values from a list of options or transforming results in a monadic pipeline.",
      "description_length": 471,
      "index": 20,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values of arbitrary width. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 311,
      "index": 21,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Make_comb.Signed",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing signed binary vectors. Resizes vectors to specified widths while preserving sign extension, useful in hardware description and digital logic design.",
      "description_length": 325,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over bit-width and extension. Resizes vectors to specified widths while maintaining numerical integrity during operations.",
      "description_length": 351,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and resizing with sign extension. Operates on data types representing bit vectors or signals, ensuring results are widened to prevent overflow. Used to implement precise arithmetic logic in hardware description or verification contexts.",
      "description_length": 350,
      "index": 24,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, result, or list. Enables chaining of effectful operations and value transformations in a concise, readable manner.",
      "description_length": 284,
      "index": 25,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of effectful computations through constructs like `let%bind` and `let%map`. Supports sequencing and binding within monadic contexts, simplifying workflows involving types such as option, list, or result. Allows for more readable and structured code when chaining operations that involve side effects or multiple outcomes. Example: binding a series of optional values without nested pattern matching.",
      "description_length": 474,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Operates on a custom type `v` representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 277,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Make_comb.Signed",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and relational checks with bit-width handling. Works with a custom `v` type representing signed binary values. Resizes vectors to specified widths while preserving sign during conversions.",
      "description_length": 302,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise width management. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 331,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing signals or bits, ensuring overflow handling through widened results. Enables precise manipulation of binary values in hardware description or digital logic contexts.",
      "description_length": 325,
      "index": 30,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, result, or list. Enables chaining of effectful operations and value transformations in a concise, readable manner.",
      "description_length": 284,
      "index": 31,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Operates on a custom `v` type representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity during conversions.",
      "description_length": 296,
      "index": 32,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Make_comb.Signed",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing signed binary vectors. Resizes vectors to specified widths while preserving sign, and converts between `v` and `Comb.t` for hardware description integration.",
      "description_length": 334,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over width and extension. Resizes vectors to specified widths while maintaining numerical integrity during operations.",
      "description_length": 347,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing signals or bits, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.All.Monad_infix",
      "description": "Sequences monadic computations with bind and maps results through a function within a monadic context. Operates on type 'a t, enabling chaining of effectful operations. Used to handle asynchronous tasks or stateful computations by transforming and combining values within a monadic structure.",
      "description_length": 292,
      "index": 36,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of effectful computations through constructs like `let%bind` and `let%map`. Supports sequencing and binding within monadic contexts, simplifying code that manipulates values wrapped in structures such as option, result, or async. Allows for more readable and maintainable code when chaining operations that involve side effects or error handling. For example, it lets you write nested `let%bind` expressions to process a series of optional values without deep nesting.",
      "description_length": 543,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is typically used to simplify code that involves monadic structures like option, result, or async.",
      "description_length": 405,
      "index": 38,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. While no concrete data types or functions are defined, it serves as a foundation for integrating domain-specific notations. Developers can use its syntax to write more expressive and concise code when working with effectful computations.",
      "description_length": 437,
      "index": 39,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is particularly useful for writing concise and expressive code in contexts involving option types, lists, or other monadic structures.",
      "description_length": 441,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. While no concrete data types or functions are defined, it serves as a foundation for integrating domain-specific notations. Users can leverage its syntax to write more expressive and concise code when combined with other modules.",
      "description_length": 429,
      "index": 41,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Make_comb.Unsigned",
      "description": "Converts between signed and unsigned representations, performs arithmetic and comparison operations on unsigned vectors, and resizes vectors to specified bit widths. Operates on a custom vector type representing unsigned binary values. Used for precise arithmetic in hardware description or low-level bit manipulation tasks.",
      "description_length": 324,
      "index": 42,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Supports precise addition, subtraction, multiplication, and comparison with overflow prevention, useful in hardware description and digital logic design.",
      "description_length": 359,
      "index": 43,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over width and extension. Resizes vectors to specified widths while maintaining numerical integrity during operations.",
      "description_length": 347,
      "index": 44,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, list, or result. Enables chaining of effectful operations like handling optional values or accumulating results in a pipeline.",
      "description_length": 296,
      "index": 46,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of effectful computations through constructs like `let%bind` and `let%map`. Supports sequencing and binding within monadic contexts, simplifying workflows involving option types, results, or other monadic structures. Allows for more readable and structured code when working with nested or chained operations. Example: chaining multiple `let%bind` steps to process a series of optional values without deep nesting.",
      "description_length": 489,
      "index": 47,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is particularly useful for writing concise and expressive code in contexts involving option, result, or other monadic types.",
      "description_length": 431,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 272,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise arithmetic in hardware description, such as adding or multiplying vectors of different widths without loss of precision.",
      "description_length": 342,
      "index": 50,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bit vectors or signals, allowing for width-aware operations. Resizes vectors to specified widths while preserving value integrity during conversions.",
      "description_length": 332,
      "index": 51,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.All.Monad_infix",
      "description": "Sequences monadic computations with bind and transforms their results with map, enabling chained operations on values wrapped in a monadic context. Works with any type constructor that supports the monadic interface, such as option, list, or result. Used to handle asynchronous workflows or error-prone operations by composing steps that propagate values or errors.",
      "description_length": 365,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.All.Let_syntax",
      "description": "Introduces custom syntax for binding and sequencing monadic operations, enabling more readable and expressive code for effectful computations. It supports a range of monadic patterns through lightweight extensions without defining new data types. Users can write nested binds and do-notation-style expressions to manage side effects cleanly. This allows for clearer handling of asynchronous operations, state transformations, and error propagation.",
      "description_length": 448,
      "index": 54,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 272,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise control over signed integer operations in hardware description or low-level numeric computations.",
      "description_length": 319,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Operates on custom types representing bit vectors or signals, allowing for width-aware computations. Resizes values to specified bit widths while maintaining numerical integrity during conversions.",
      "description_length": 338,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of numeric values in hardware description or digital logic contexts.",
      "description_length": 324,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, list, or result. Enables chaining of effectful operations and value transformations in a concise, readable manner.",
      "description_length": 284,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner and more readable code for sequencing and binding. Supports basic types like 'unit' and 'option' with simplified expressions. Users can chain operations more naturally, such as binding values from a list or handling optional results. Examples include simplifying nested 'bind' calls and writing monadic pipelines with a more imperative style.",
      "description_length": 408,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Operates on a custom `v` type representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 277,
      "index": 61,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Make_comb.Signed",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing signed binary vectors. Resizes vectors to specified widths while preserving sign during conversion.",
      "description_length": 276,
      "index": 62,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over bit-width. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 337,
      "index": 63,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or verification contexts.",
      "description_length": 335,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that support binding and lifting. Enables chaining of effectful operations and transformation of wrapped values in a concise manner.",
      "description_length": 248,
      "index": 65,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.All.Let_syntax",
      "description": "Introduces custom syntax for binding and sequencing monadic operations, enabling more readable and expressive code for effectful computations. It relies on underlying monadic structures but does not define new data types or functions itself. Developers can use this syntax to chain operations in a more natural, imperative style. For example, it allows writing nested `let%bind` expressions that resemble traditional imperative code.",
      "description_length": 433,
      "index": 66,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` are available to simplify nested function calls. This enables more concise and expressive code when handling effectful computations.",
      "description_length": 382,
      "index": 67,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 272,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Make_comb.Signed",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing signed binary vectors. Resizes vectors to specified widths while preserving sign during conversion.",
      "description_length": 276,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bit vectors or signals, allowing for precise width management. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 338,
      "index": 70,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of vector widths in digital design contexts, such as adjusting signal sizes before arithmetic operations.",
      "description_length": 361,
      "index": 71,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, list, or result. Enables chaining of effectful operations like error handling, state manipulation, or asynchronous tasks.",
      "description_length": 291,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.All.Let_syntax",
      "description": "Introduces custom syntax for monadic workflows, enabling cleaner binding and sequencing with `let%` and `and%`, and embedding values via `return`. Supports monadic interfaces such as `Option` and `List`, allowing for more readable and structured code. Operations include chaining computations and managing side effects within a monadic context. For example, `let%` can bind the result of an `Option.t` computation inline, while `return` wraps a value into the monadic type.",
      "description_length": 473,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 272,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Make_comb.Signed",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with a custom `v` type representing signed binary vectors. Resizes vectors to specified widths while preserving sign extension.",
      "description_length": 272,
      "index": 75,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise width management. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 331,
      "index": 76,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing signals or bits, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.All.Monad_infix",
      "description": "Sequences monadic computations using bind and maps values within a monadic context. Operates on types wrapped in a monad, such as option, list, or result. Enables chaining of operations that produce side effects or handle failure, like processing a list of optional values or composing error-prone computations.",
      "description_length": 311,
      "index": 78,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner and more readable code when working with monadic workflows. It supports binding and sequencing through specialized notations, allowing developers to express complex computations with greater clarity. Though no data types are defined, it integrates with other modules to enhance their expressiveness. For example, it simplifies chaining of operations in a monadic context, such as handling option or list computations with intuitive syntax.",
      "description_length": 505,
      "index": 79,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. While no concrete data types or functions are defined, it serves as a foundation for integrating domain-specific notations. Developers can use its syntax to write more expressive and concise code when working with effectful computations.",
      "description_length": 437,
      "index": 80,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 272,
      "index": 81,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed vectors with specific bit widths. Enables precise arithmetic in hardware description or fixed-point calculations, such as adding or comparing vectors of different widths without loss of precision.",
      "description_length": 386,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise width management. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 331,
      "index": 83,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and resizing with proper sign extension. Operates on data types representing bit vectors or signals, ensuring results are widened to prevent overflow. Used to implement precise arithmetic logic in hardware description or verification contexts.",
      "description_length": 357,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, result, or list. Enables chaining of effectful operations and value transformations in a concise, readable manner.",
      "description_length": 284,
      "index": 85,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.All.Let_syntax",
      "description": "Introduces custom syntax for sequencing and binding monadic operations, enhancing readability of effectful code. Provides `let%` and `and%` to chain computations cleanly. Supports nested or sequential monadic workflows with intuitive syntax. Enables concise handling of asynchronous, stateful, or error-prone operations.",
      "description_length": 320,
      "index": 86,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Operates on a custom `v` type representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity during conversions.",
      "description_length": 296,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Make_comb.Signed",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing signed binary vectors. Resizes vectors to specified widths while preserving sign during conversion.",
      "description_length": 276,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bit vectors or signals, allowing for precise width management. Resizes values to specified bit widths while maintaining numerical integrity during conversions.",
      "description_length": 342,
      "index": 89,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, result, or list. Enables chaining of effectful operations and value transformations in a concise, readable manner.",
      "description_length": 284,
      "index": 91,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of effectful computations through constructs like `let%bind` and `let%map`. Supports sequencing and binding within monadic contexts, simplifying workflows involving option types, results, or other monadic structures. Allows for more readable and structured code when working with nested or chained operations. Example: chaining multiple `let%bind` steps to process a series of optional values without deep nesting.",
      "description_length": 489,
      "index": 92,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic types such as 'unit' and 'option' are supported through simplified expression forms. Users can write more concise and expressive code by leveraging these syntactic improvements.",
      "description_length": 383,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with a custom `v` type representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity during conversions.",
      "description_length": 295,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise arithmetic in hardware description and digital logic design, such as adding or comparing fixed-width signals without overflow.",
      "description_length": 348,
      "index": 95,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over width and extension. Resizes vectors to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 348,
      "index": 96,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 97,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.All.Monad_infix",
      "description": "Sequences monadic computations with bind and transforms their results with map, enabling chained operations on values wrapped in a monadic context. Works with any type constructor that supports the monadic interface, such as option, list, or result. Used to handle asynchronous workflows or error-prone operations by composing steps that propagate values or failures.",
      "description_length": 367,
      "index": 98,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner and more readable code when working with sequential computations. It relies on underlying monadic structures but does not define new data types or functions itself. Users can chain operations using the provided notation, such as `let%bind` or `let%map`, to simplify nested monadic expressions. This syntax is particularly useful when working with effectful or asynchronous code.",
      "description_length": 444,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Make_comb.Unsigned",
      "description": "Converts between signed and unsigned representations, performs arithmetic and comparison operations on unsigned vectors, and resizes vectors to specified widths. Operates on a custom vector type `v` with bitwise and numeric operations. Used for precise control over binary data in hardware description or low-level numerical computations.",
      "description_length": 338,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed vectors with explicit width. Supports precise addition, subtraction, multiplication, and comparisons, with results dynamically adjusted to prevent overflow.",
      "description_length": 346,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over width and extension. Resizes vectors to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 348,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 103,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, result, or list. Enables chaining of effectful operations and value transformations in a concise, readable manner.",
      "description_length": 284,
      "index": 104,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.All.Let_syntax",
      "description": "Introduces custom syntax for monadic composition, enabling imperative-style coding with `let%bind` and `let%return` to chain operations. Supports sequential execution and value binding within monadic contexts, simplifying error handling and state management. Allows for concise expression of complex workflows, such as parsing or asynchronous operations. Examples include chaining database queries or handling optional values with clear, nested structures.",
      "description_length": 456,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with a custom `v` type representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 276,
      "index": 106,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Make_comb.Signed",
      "description": "Provides arithmetic and comparison operations for signed vectors, including addition, subtraction, multiplication, and relational checks, with automatic bit-width extension. Works with a custom `v` type representing signed vectors. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 301,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over width and extension. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 347,
      "index": 108,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of numeric values in hardware description or verification contexts.",
      "description_length": 323,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that support binding and lifting. Enables chaining of effectful operations and value transformations in a concise manner.",
      "description_length": 237,
      "index": 110,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.All.Let_syntax",
      "description": "Introduces custom syntax for monadic composition, enabling cleaner handling of effectful operations through constructs like `let%bind` and `let%map`. Supports sequencing and transformation of values within monadic contexts, such as option and result. Allows for more readable and structured code when chaining operations that involve side effects or error propagation. Example: binding a series of optional values without explicit nested pattern matching.",
      "description_length": 455,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values of arbitrary width. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 311,
      "index": 112,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Make_comb.Signed",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing signed binary vectors. Resizes vectors to specified widths while preserving sign during conversions.",
      "description_length": 277,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over width and extension. Resizes vectors to specified widths while maintaining value integrity during conversions between signal and vector representations.",
      "description_length": 386,
      "index": 114,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or verification contexts.",
      "description_length": 335,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.All.Monad_infix",
      "description": "Sequences monadic computations with bind and transforms their results with map, enabling fluent chaining of operations that encapsulate side effects or asynchronous behavior. Works with any type wrapped in a monadic context, such as option, list, or result. Used to handle error propagation in pipelines or manage stateful transformations in a declarative way.",
      "description_length": 360,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of effectful computations through constructs like `let%bind` and `let%map`. Supports sequencing and binding within monadic contexts, simplifying workflows involving option types, results, or other monadic structures. Allows for more readable and structured code when working with nested or chained operations. Example: chaining multiple `let%bind` steps to process a series of optional values without deep nesting.",
      "description_length": 489,
      "index": 117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. While no concrete data types or functions are defined, it serves as a foundation for integrating domain-specific notations. Developers can use its syntax to write more expressive and concise code when working with effectful computations.",
      "description_length": 437,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. Basic operations such as `let%bind` and `let%map` allow for cleaner handling of effectful computations. It is typically used to simplify code that involves monadic structures like option, result, or async.",
      "description_length": 405,
      "index": 119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a custom associative structure and a list of string-value pairs. Works with a type representing port name mappings, using strings as keys. Used to serialize and deserialize port configurations from structured data.",
      "description_length": 253,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.All",
      "description": "Combines monadic sequencing and custom syntax to handle effectful computations, enabling fluent chaining and transformation of wrapped values. Supports operations like bind and map, allowing for structured manipulation of types such as option and result. Provides syntactic sugar like `let%bind` to simplify complex monadic workflows. Example: safely extracting values from a list of options or composing error-handling pipelines.",
      "description_length": 430,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary numbers in hardware description or digital logic contexts.",
      "description_length": 378,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Of_bits",
      "description": "Converts integer values to bitvector representations and supports bitwise operations like packing, unpacking, multiplexing, and concatenation. Processes lists of bitvectors to generate selection logic, including priority and one-hot decoding, and validates bitvector widths and integrity. Works with bitvector types derived from integer inputs and combinatorial signals.",
      "description_length": 370,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Of_signal",
      "description": "This module offers signal manipulation and circuit synthesis utilities, including operations for packing, multiplexing, concatenating, and assigning signals, along with customizable naming conventions for signal transformation. It works with `comb t`, `comb`, and `Hardcaml.Signal.t` types to enable precise control over digital circuit design and signal routing. Specific use cases include optimizing combinational logic structures and managing signal hierarchies in hardware description workflows.",
      "description_length": 499,
      "index": 124,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Of_always",
      "description": "Provides functions to manipulate hardware description elements, including extracting signal values, assigning signals to always blocks, creating registers with optional enable signals, and defining wires with dynamic naming. Works with signal variables, register specifications, and signal generators. Used to construct sequential and combinational logic in hardware designs with precise control over signal assignments and naming conventions.",
      "description_length": 443,
      "index": 125,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process and analyze hardware or circuit descriptions by separating and accessing specific attributes of ports.",
      "description_length": 368,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a custom associative structure and a list of string-value pairs. Works with a private type representing associations keyed by port names. Used to serialize or deserialize port configurations from structured data.",
      "description_length": 251,
      "index": 127,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.All",
      "description": "Combines monadic sequencing and syntactic enhancements to manage effectful computations and transform results within contexts like option, list, or result. Provides operations such as bind and map, along with custom syntax for cleaner code structure. Enables chaining of operations while handling optional or multiple outcomes without complex nesting. For example, binding a series of optional values or transforming list elements with side effects.",
      "description_length": 449,
      "index": 128,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of `v` values to specified widths. Used for manipulating signed or unsigned binary values in hardware description or digital logic contexts.",
      "description_length": 381,
      "index": 129,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Of_bits",
      "description": "Converts between integer values and bitvector representations, supports bitwise operations like packing, unpacking, and concatenation, and provides selection mechanisms such as multiplexing and priority decoding. Works with bitvector types built from lists of boolean signals and integer values. Used for constructing and validating digital logic circuits, particularly in hardware description tasks.",
      "description_length": 400,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Of_signal",
      "description": "The module offers signal manipulation through operations like packing, multiplexing, and concatenation, alongside transformation and custom naming functions for combinational logic structures. It works with types such as `comb t` and `t`, focusing on hardware description and signal routing. Use cases include digital circuit design tasks like output modification and hierarchical signal organization with customizable naming conventions.",
      "description_length": 438,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Of_always",
      "description": "Provides functions to manipulate hardware description elements, including extracting signal values, assigning signals to always blocks, creating registers with enable conditions, and defining wires with dynamic naming. Works with signal variables, register specifications, and signal generators. Used to construct sequential logic blocks and manage signal naming conventions in hardware designs.",
      "description_length": 395,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process hardware description data for signal mapping and validation.",
      "description_length": 326,
      "index": 133,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Unsafe_assoc_by_port_name",
      "description": "Provides functions to convert between a structured data type and an association list using field names as keys. Operates on a type that maps string keys to values, enabling direct access to fields by name. Used to serialize and deserialize data structures in contexts where field names are known and fixed.",
      "description_length": 306,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.All",
      "description": "Combines monadic sequencing and transformation capabilities with a placeholder namespace, enabling structured handling of effectful operations and value conversions. Supports operations like bind and map over types such as option, result, and list, allowing for fluent composition of computations. Provides a framework for chaining transformations while maintaining context. Can be used to process optional values, handle errors gracefully, or flatten nested lists.",
      "description_length": 465,
      "index": 135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks, with automatic bit-width extension and resizing. Supports conversion between `v` and `Comb.t` for interfacing with hardware description components. Used to construct and manipulate digital signal values in circuit designs.",
      "description_length": 363,
      "index": 136,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface records with fixed field widths. Used to pack signals into a single bit vector for output, unpack them for processing, and select between multiple interface configurations based on control signals.",
      "description_length": 378,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Of_signal",
      "description": "Provides operations for constructing, manipulating, and validating hardware interface signals through packing/unpacking, multiplexing, concatenation, and renaming, operating on combinational logic interfaces and signal types. These functions support tasks like signal routing, width validation, and name transformation in hardware design contexts.",
      "description_length": 347,
      "index": 138,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Of_always",
      "description": "Provides functions to construct and manage interface containers for hardware description using the Always API. Works with signal, variable, and register types from Hardcaml, enabling creation of registers with enable signals and wires with default values. Assigns interface variables to always blocks and applies naming conventions to interface fields.",
      "description_length": 352,
      "index": 139,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process hardware description data for signal mapping and validation.",
      "description_length": 326,
      "index": 140,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a generic type wrapped in a record structure that supports string-based indexing. Used to serialize and deserialize data structures where field names are critical for mapping.",
      "description_length": 299,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.All",
      "description": "Provides a monadic framework for sequencing effectful operations and transforming results within a context. It defines type 'a t and supports bind and map operations to chain computations, along with custom syntax like `let%bind` and `let%map` for cleaner code. It enables handling of asynchronous or stateful processes, such as processing a series of optional values or error-prone computations. For example, it allows writing nested bindings to safely extract and transform values from option or result types.",
      "description_length": 511,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks, with automatic bit-width extension and resizing. Supports conversion between `v` and `Comb.t` for interoperability. Used to manipulate fixed-width signals in hardware description or digital logic contexts.",
      "description_length": 346,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface structures with fixed field widths. Used to pack signals into a single bit vector for output, unpack them for processing, and select between multiple interface configurations based on control signals.",
      "description_length": 381,
      "index": 144,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Of_signal",
      "description": "This module offers signal manipulation operations such as packing, multiplexing, renaming, and name transformation, along with value assignment and width validation, tailored for digital design workflows. It works with signal types (`Hardcaml.Signal.t`) and structured interfaces (`t`), enabling tasks like signal routing, interface abstraction, and hierarchical name management. Specific use cases include creating reusable interface components, managing complex signal hierarchies, and ensuring consistency in hardware description projects.",
      "description_length": 542,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Of_always",
      "description": "Provides functions to create and manage interface containers for hardware description, including registers, wires, and signal assignments. Works with signal and variable types from the Hardcaml library to construct always blocks. Enables naming conventions for interface fields and supports conditional register enable signals.",
      "description_length": 327,
      "index": 146,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process and analyze hardware or data structure definitions that require explicit naming and bit-width information.",
      "description_length": 372,
      "index": 147,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Operates on a custom `v` type representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity during conversions.",
      "description_length": 296,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed vectors, and supports conversions between `v` and `Comb.t`. Enables precise control over signed integer operations in hardware description or low-level numeric computations.",
      "description_length": 363,
      "index": 149,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over bit-width. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 337,
      "index": 150,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or verification contexts.",
      "description_length": 335,
      "index": 151,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.All.Monad_infix",
      "description": "Sequences monadic computations with bind and transforms their results with map, enabling chained operations on values wrapped in a context. Works with any type constructor implementing the monad interface. Used to handle effectful operations like I/O, state manipulation, or error propagation in a composable way.",
      "description_length": 313,
      "index": 152,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of effectful computations through constructs like `let%bind` and `let%map`. It supports sequencing and transformation of values within monadic contexts, such as option, result, or async. This allows for more readable and maintainable code when chaining operations that involve side effects or optional values. For example, it simplifies binding results of asynchronous calls or handling nested option types.",
      "description_length": 482,
      "index": 153,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 272,
      "index": 154,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise control over signed integer operations in hardware description or low-level numeric processing.",
      "description_length": 317,
      "index": 155,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over bit-width. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 337,
      "index": 156,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing signals or bits, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 157,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.All.Monad_infix",
      "description": "Sequences monadic computations using bind and maps values within a monadic context. Operates on types wrapped in a monad, such as option, list, or result. Enables chaining of operations that produce side effects or handle failure gracefully.",
      "description_length": 241,
      "index": 158,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.All.Let_syntax",
      "description": "Introduces custom syntax for binding and sequencing monadic operations, enabling more readable and expressive code for effectful computations. It relies on underlying monadic structures but does not define new data types or functions itself. Developers can use this syntax to chain operations in a more natural, imperative style. For example, it allows writing monadic pipelines that resemble sequential imperative code.",
      "description_length": 420,
      "index": 159,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 272,
      "index": 160,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Used for precise arithmetic in hardware description or digital logic simulations where overflow and bit-width management are critical.",
      "description_length": 340,
      "index": 161,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over width and extension. Resizes vectors to specified widths while maintaining numerical integrity during operations.",
      "description_length": 347,
      "index": 162,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring overflow handling through widened results. Enables precise manipulation of fixed-width numeric values in hardware description or verification contexts.",
      "description_length": 337,
      "index": 163,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.All.Monad_infix",
      "description": "Sequences monadic computations using bind and maps values within a monadic context. Operates on types wrapped in a monadic structure, such as option, list, or result. Enables chaining of operations that produce side effects or handle failure gracefully, like processing a series of optional values or transforming results in a list.",
      "description_length": 332,
      "index": 164,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of effectful computations through constructs like `let%bind` and `let%map`. Supports sequencing and binding within monadic contexts, simplifying workflows involving option types, lists, or other monadic structures. Allows for more readable and structured code when composing multiple effectful steps. For example, chaining multiple `let%bind` expressions can sequentially process values within a monad without nested callbacks.",
      "description_length": 502,
      "index": 165,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 292,
      "index": 166,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise arithmetic in hardware description, such as adding or comparing fixed-width signals without overflow.",
      "description_length": 323,
      "index": 167,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over width and extension. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 347,
      "index": 168,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of numeric values in hardware description or verification contexts.",
      "description_length": 323,
      "index": 169,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that support binding and lifting. Enables chaining of effectful operations and value transformations in a concise manner.",
      "description_length": 237,
      "index": 170,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner and more readable code when working with sequential computations. It relies on underlying monadic structures but does not define new data types or functions directly. Users can bind and sequence operations using intuitive notation, such as `let%bind` or `let%map`, simplifying complex workflows. This syntax is particularly useful when combined with modules that implement monadic interfaces like `Option`, `List`, or `Lwt`.",
      "description_length": 490,
      "index": 171,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Unsafe_assoc_by_port_name",
      "description": "Creates and manipulates associations between string keys and values, using association lists as the underlying structure. Accepts a list of (string, value) pairs to build a structure and converts it back to the list format. Used to map port names to associated data in network-related configurations.",
      "description_length": 300,
      "index": 172,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.All",
      "description": "Combines monadic sequencing and custom syntax to handle effectful computations, allowing operations on wrapped values like options, lists, and results. Provides `bind` and `map` for transforming and chaining computations, along with `let%bind` and `let%map` for cleaner code structure. Enables fluent processing of optional or error-prone values, such as safely extracting and combining nested options. Example: parsing a configuration by sequentially binding optional fields without explicit nesting.",
      "description_length": 501,
      "index": 173,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary values in hardware description or low-level numeric computations.",
      "description_length": 385,
      "index": 174,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integer constants. Operates on typed bit vectors and interface structures with fixed field widths. Supports multiplexing, concatenation, and selection operations for digital circuit design.",
      "description_length": 296,
      "index": 175,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Of_signal",
      "description": "This module offers functions for manipulating signal interfaces through operations like packing, multiplexing, renaming, and concatenating, along with validation and width management for structured signal representations. It works with `comb t` types and `Hardcaml.Signal.t` structures, enabling precise control over signal naming, bit-width assertions, and hardware element creation such as registers and pipelines. Use cases include designing complex digital circuits, ensuring signal integrity in hardware descriptions, and streamlining interface transformations in synthesizable code.",
      "description_length": 588,
      "index": 176,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Of_always",
      "description": "Provides functions to construct and manage hardware interface components within always blocks, including variable assignment, register creation, and wire initialization. Works with signal types, variable containers, and register specifications to model digital circuit behavior. Used to define clocked registers with enable signals and name interface fields with customizable prefixes and suffixes.",
      "description_length": 398,
      "index": 177,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. It exposes a combined list of port name-width pairs, along with separate lists for each component. Used to extract and organize interface information from hardware or circuit descriptions.",
      "description_length": 347,
      "index": 178,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Unsafe_assoc_by_port_name",
      "description": "Creates a mapping between port names and associated values, allowing conversion to and from association lists. Operates on a custom type representing port-based data structures. Used to serialize or deserialize configuration data where fields are named by port identifiers.",
      "description_length": 273,
      "index": 179,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.All",
      "description": "Combines monadic sequencing and custom syntax to enable expressive, composable effectful computations. Supports operations like bind and map across various monadic types, including option, list, and result, allowing for structured handling of asynchronous or error-prone processes. Users can write nested, readable code that chains operations while preserving context and managing side effects. For example, it can sequence API calls that return results, transform their outputs, and handle failures in a clean, declarative way.",
      "description_length": 528,
      "index": 180,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed binary numbers in hardware description or digital logic contexts.",
      "description_length": 366,
      "index": 181,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface records with fixed field widths. Used to pack signals into a single bit vector for output, unpack them for processing, and select between multiple interface configurations based on control signals.",
      "description_length": 378,
      "index": 182,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Of_signal",
      "description": "This module provides operations for manipulating hardware signal interfaces, including packing, unpacking, multiplexing, and renaming signals, along with validation of signal widths and routing. It works with combinational logic interface types (`comb t`) and signal structures (`Hardcaml.Signal.t`), enabling tasks like interface configuration and signal wiring. Specific use cases include hardware synthesis workflows and managing complex signal hierarchies in digital design.",
      "description_length": 478,
      "index": 183,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Of_always",
      "description": "Provides functions to create and manage hardware interface variables for always blocks, including assigning signals, generating registers, and wiring signals with default values. Works with signal and variable types from the Hardcaml library to construct hardware descriptions. Used to define named registers and wires in sequential logic blocks with customizable naming conventions.",
      "description_length": 383,
      "index": 184,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type elements. Extracts port names and widths as separate lists or combines them into a list of (name, width) tuples. Used to generate or inspect hardware interface configurations.",
      "description_length": 326,
      "index": 185,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Operates on a custom `v` type representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 277,
      "index": 186,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed vectors, and supports conversions between `v` and `Comb.t`. Enables precise control over signed integer operations in hardware description or low-level numeric processing.",
      "description_length": 361,
      "index": 187,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bit vectors or signals, allowing for width-aware operations and conversions. Resizes vectors to specified widths while maintaining value integrity during transformations.",
      "description_length": 353,
      "index": 188,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of vector widths in digital logic contexts, such as adjusting signal sizes or performing safe arithmetic in hardware descriptions.",
      "description_length": 386,
      "index": 189,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.All.Monad_infix",
      "description": "Sequences monadic computations using bind and maps values within a monadic context. Operates on types wrapped in a monadic structure, such as option, list, or result. Enables chaining of operations that produce side effects or handle failure gracefully, like processing a series of optional values or transforming results in a list comprehension.",
      "description_length": 346,
      "index": 190,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of effectful computations through constructs like `let%bind` and `let%map`. Supports sequencing and transformation of values within monadic contexts, such as option and result. Allows for more readable and structured code when chaining operations that involve side effects or error handling. Example: binding a series of optional values or mapping over a result without explicit nested pattern matching.",
      "description_length": 478,
      "index": 191,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a custom type representing interfaces and Base.list of (string * 'a) pairs. Used to serialize and deserialize network interface configurations by port name.",
      "description_length": 280,
      "index": 192,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.All",
      "description": "Combines monadic sequencing and syntactic enhancements to streamline effectful computations. Supports operations like bind and map on monadic values, allowing for fluent chaining and transformation of wrapped results. Provides a readable, imperative-style syntax for composing nested operations. Enables concise handling of side-effecting processes, such as parsing, state management, or I/O, with clear and structured code.",
      "description_length": 424,
      "index": 193,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed binary numbers in hardware description or digital logic contexts.",
      "description_length": 366,
      "index": 194,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on `comb` (bit vectors) and `t` (interface records) to support hardware design tasks. Enables multiplexing, concatenation, and selection operations for digital circuit descriptions.",
      "description_length": 327,
      "index": 195,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Of_signal",
      "description": "This module offers signal manipulation capabilities, including packing/unpacking, multiplexing, concatenation, and value assignment, alongside name transformation operations like prefixing and suffixing for signal interfaces. It works with combinational logic interfaces (`comb t`) and structured signal types (`Hardcaml.Signal.t`), ensuring width validation and hierarchical routing. Use cases include hardware description tasks such as signal routing optimization and interface abstraction in digital design workflows.",
      "description_length": 520,
      "index": 196,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Of_always",
      "description": "Provides functions to create and manage interface containers for hardware description, including registers, wires, and signal assignments. Works with signal and variable types from the Hardcaml library to construct always blocks. Used to define clocked behavior, initialize wires with default values, and apply naming conventions to interface fields.",
      "description_length": 350,
      "index": 197,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type elements. Extracts individual lists of names and widths from a combined list of name-width pairs. Used to process hardware description data for signal mapping and validation.",
      "description_length": 325,
      "index": 198,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a custom type representing interfaces and Base.list of (string * 'a) pairs. Used to serialize and deserialize interface configurations from named fields.",
      "description_length": 277,
      "index": 199,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.All",
      "description": "Combines monadic sequencing and custom syntax to manage effectful computations, allowing operations on types like option, list, and result. Provides `let%` and `return` for inline binding and value embedding, enabling structured error handling and stateful workflows. Chaining computations with `bind` and `map` supports asynchronous or conditional execution. For example, `let%` can extract a value from an `Option.t` while maintaining context, and `return` can inject a value into a monadic type for further processing.",
      "description_length": 521,
      "index": 200,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of `v` values to specified widths. Used for constructing and manipulating digital logic signals in hardware description contexts.",
      "description_length": 370,
      "index": 201,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integer constants or other interfaces. Operates on typed bit vectors and interface structures composed of bit vectors. Used to pack signals into a single bus, unpack from a bus, or select between multiple interface configurations based on control signals.",
      "description_length": 362,
      "index": 202,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Of_signal",
      "description": "This module offers signal manipulation functions for hardware interface design, including packing/unpacking, multiplexing, concatenation, and value assignment, alongside operations for renaming and extracting signals. It works with combinational logic interfaces (`comb t`), signal types (`Hardcaml.Signal.t`), and interface structures (`t`), focusing on routing, validation, and name management. Use cases include hardware description tasks like width validation, signal routing, and interface customization.",
      "description_length": 509,
      "index": 203,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Of_always",
      "description": "Provides functions to create and manage hardware interface containers for always blocks, including registers, wires, and signal assignments. Works with signal and variable types from the Hardcaml library to construct and name interface elements. Used to define register behavior with enable signals, wire defaults, and name annotations for hardware descriptions.",
      "description_length": 362,
      "index": 204,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process hardware description data for signal mapping and validation.",
      "description_length": 326,
      "index": 205,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a generic type wrapped in a record structure that supports string-based indexing. Used to serialize and deserialize data formats where field names are critical for lookup, such as configuration parsing or protocol message handling.",
      "description_length": 355,
      "index": 206,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.All",
      "description": "Encapsulates monadic workflows by combining sequencing and transformation of values within contextual types like option, list, and result. Provides operations such as bind and map, along with custom syntax to simplify chaining and binding, allowing for imperative-style pipelines. Users can handle optional values, iterate over lists, or manage error-prone computations with clearer code. For example, extracting a value from an option or processing a list of results becomes more straightforward and expressive.",
      "description_length": 512,
      "index": 207,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary numbers in hardware description or digital logic contexts.",
      "description_length": 378,
      "index": 208,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface structures with fixed field widths. Used to pack signals into a single bus, unpack from a bus, or select between multiple interface configurations based on control signals.",
      "description_length": 353,
      "index": 209,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.Of_signal",
      "description": "The module offers signal manipulation through packing, unpacking, multiplexing, and concatenation, alongside field renaming and adjustment for hardware interface constructs. It operates on combinational logic interfaces (`comb t`) and signal types (`Hardcaml.Signal.t`), enabling precise control over signal routing and width validation. These capabilities are applied in hardware description tasks, such as interface customization and protocol adaptation, ensuring accurate signal representation in digital designs.",
      "description_length": 516,
      "index": 210,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.Of_always",
      "description": "Provides functions to create and manage interface containers for hardware description, including registers, wires, and signal assignments. Works with signal and variable types from the Hardcaml library to define always blocks. Enables naming conventions for interface fields and simplifies register and wire instantiation with default values.",
      "description_length": 342,
      "index": 211,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, along with a combined list of port name-width pairs. Operates on strings, integers, and a custom tag type. Used to extract and organize hardware interface information from a design representation.",
      "description_length": 271,
      "index": 212,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 292,
      "index": 213,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise control over signed integer operations in hardware description or low-level numeric computations.",
      "description_length": 319,
      "index": 214,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bit vectors or signals, allowing for precise width management. Resizes values to specified bit widths while maintaining numerical integrity during conversions.",
      "description_length": 342,
      "index": 215,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of binary values in hardware description or digital logic contexts.",
      "description_length": 323,
      "index": 216,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, result, or list. Enables chaining of effectful operations like error handling, state manipulation, or asynchronous tasks.",
      "description_length": 291,
      "index": 217,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of effectful computations through constructs like `let%bind` and `let%map`. Supports chaining and binding within monadic contexts, simplifying nested expressions. Allows for more readable and structured code when working with sequences of dependent operations. Examples include simplifying error propagation and asynchronous task composition.",
      "description_length": 417,
      "index": 218,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a generic type wrapped in a record structure and Base.string keys. Used to serialize and deserialize data structures based on named fields in network-related contexts.",
      "description_length": 291,
      "index": 219,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.All",
      "description": "Combines monadic operations with syntactic enhancements to streamline complex workflows. Supports chaining of computations over wrapped types like option, list, and result, enabling safe error handling and sequential processing. Allows for expressive, readable code when managing side effects or failure-prone operations. For instance, it simplifies parsing a list of optional values or composing multiple error-handling steps in a clean, declarative manner.",
      "description_length": 458,
      "index": 220,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of `v` values to specified widths. Used for constructing and manipulating digital logic signals in hardware description contexts.",
      "description_length": 370,
      "index": 221,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface structures composed of bit vectors. Used to pack signals into a single bus, unpack from a bus, or select between multiple interface configurations based on control signals.",
      "description_length": 353,
      "index": 222,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Of_signal",
      "description": "The module provides functions for constructing and manipulating hardware interface data structures, including packing, multiplexing, and concatenating signals, operating on combinational logic types (`comb t`) to support signal routing and width validation. It also enables renaming and modifying signal fields, working with `Hardcaml.Signal.t` and interface structures (`t`), such as applying prefixes/suffixes and exposing signals as wires for hardware synthesis. These operations are critical for tasks like signal arbitration, interface abstraction, and ensuring compatibility in digital design workflows.",
      "description_length": 609,
      "index": 223,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Of_always",
      "description": "Provides functions to create and manage hardware interface variables for always blocks, including assigning signals, generating registers, and wiring signals with default values. Works with signal types and variable containers from the Hardcaml library. Used to define clocked registers with enable conditions and name interface fields with customizable prefixes and suffixes.",
      "description_length": 376,
      "index": 224,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config.Names_and_widths",
      "description": "Provides functions to retrieve a list of port name-width pairs, separate lists of port names and widths, and a list of tags. Works with lists of strings, integers, and custom tag types. Used to extract and organize hardware port information and associated metadata.",
      "description_length": 265,
      "index": 225,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values of arbitrary width. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 311,
      "index": 226,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.Make_comb.Signed",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing signed binary vectors. Resizes vectors to specified widths while preserving sign, and converts between `v` and `Comb.t` for hardware description integration.",
      "description_length": 334,
      "index": 227,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over bit-width and extension. Resizes vectors to specified widths while maintaining numerical integrity during operations.",
      "description_length": 351,
      "index": 228,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or verification contexts.",
      "description_length": 335,
      "index": 229,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.All.Monad_infix",
      "description": "Sequences monadic computations using bind and maps results through a function within the monadic context. Operates on values wrapped in a monadic type, enabling chained operations that handle side effects or asynchronous behavior. Used to transform and combine results from effectful computations like parsing, state manipulation, or I/O.",
      "description_length": 338,
      "index": 230,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner expression of effectful computations. It supports binding and sequencing through dedicated operators, improving code clarity. Though no data types are defined, it enhances usability with familiar notation. Users can write more readable monadic pipelines and handle side effects with structured, declarative syntax.",
      "description_length": 380,
      "index": 231,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a generic type wrapped in a record structure and Base.string keys. Used to serialize and deserialize data structures based on named fields in network-related contexts.",
      "description_length": 291,
      "index": 232,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.All",
      "description": "Combines monadic sequencing and custom syntax to handle effectful computations, allowing operations on wrapped values like options, results, and lists. Provides `bind` and `map` for transforming and chaining computations, along with `let%bind` and `let%map` for cleaner code structure. Enables fluent processing of nested or conditional values, such as safely extracting and combining optional data. Example: parsing a JSON structure with multiple optional fields using chained `let%bind` steps.",
      "description_length": 495,
      "index": 233,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary numbers in hardware description or low-level numeric computations.",
      "description_length": 386,
      "index": 234,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface records composed of bit vectors. Used to pack signals into a single bus, unpack from a bus, or select between multiple interface configurations based on control signals.",
      "description_length": 350,
      "index": 235,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Of_signal",
      "description": "This module offers signal manipulation capabilities, including renaming, name transformation, and interface construction, with operations like packing, unpacking, and concatenation. It works with combinational logic interfaces (`comb t`) and signal types (`Hardcaml.Signal.t`), focusing on hardware description tasks such as signal routing and width validation. Specific use cases include modifying signal names with prefixes/suffixes and managing interface structures for hardware design.",
      "description_length": 489,
      "index": 236,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Of_always",
      "description": "Provides functions to create and manage interface containers for hardware description, including registers, wires, and signal assignments. Works with signal and variable types from the Hardcaml library to construct always blocks. Enables naming conventions for interface fields and supports conditional register creation.",
      "description_length": 321,
      "index": 237,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, along with a combined list of port name-width pairs. Operates on strings, integers, and a custom tag type. Used to extract and organize interface information from hardware description data.",
      "description_length": 264,
      "index": 238,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a generic type wrapped in a record structure and Base.string keys. Used to serialize and deserialize data structures based on named fields in network-related contexts.",
      "description_length": 291,
      "index": 239,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.All",
      "description": "Provides a monadic framework for sequencing and transforming computations, allowing operations on values within a context such as option, list, or result. Supports custom syntax for cleaner composition of monadic steps, enabling readable chaining of bind and map operations. Users can handle asynchronous or error-prone workflows by linking computations that propagate values or failures. For example, parsing a JSON string, validating its structure, and extracting a field can be done with sequential bind and map expressions.",
      "description_length": 527,
      "index": 240,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary values in hardware description or digital logic contexts.",
      "description_length": 377,
      "index": 241,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on `comb` (bit vectors) and `t` (interface records) to support hardware design tasks. Enables multiplexing, concatenation, and selection operations for digital circuit descriptions.",
      "description_length": 327,
      "index": 242,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Of_signal",
      "description": "This module offers signal manipulation capabilities, including packing/unpacking, multiplexing, and concatenation, alongside validation and renaming operations for hardware interface structures. It works with combinational logic interfaces (`comb t`), signal types (`Hardcaml.Signal.t`), and interface definitions (`t`), enabling tasks like width validation and signal routing. Specific use cases include hardware synthesis, interface customization, and field-level signal transformations in digital design workflows.",
      "description_length": 517,
      "index": 243,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Of_always",
      "description": "Provides functions to construct and manage hardware interface components within always blocks, including variable assignment, register creation, and wire initialization. Operates on signal types and variable containers from the Hardcaml library. Used to define clocked registers with enable signals and name interface fields with customizable prefixes and suffixes.",
      "description_length": 365,
      "index": 244,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process and separate interface definitions in hardware description code.",
      "description_length": 330,
      "index": 245,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.Unsafe_assoc_by_port_name",
      "description": "Creates and manipulates associations between string keys and values using association lists. Operates on lists of (string * 'a) pairs and opaque data structures representing interfaces. Used to convert between structured data and string-keyed representations in network configuration parsing.",
      "description_length": 292,
      "index": 246,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.All",
      "description": "Combines monadic sequencing and custom syntax to manage effectful computations, allowing smooth chaining of operations that handle context like option, result, or list. Provides `let%` and `and%` for readable, structured workflows, enabling nested or sequential execution of stateful, asynchronous, or error-prone tasks. Operations include binding and mapping over monadic values, transforming results, and composing complex pipelines. Examples include parsing with error handling, asynchronous I/O, and stateful data processing.",
      "description_length": 529,
      "index": 247,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of `v` values to specified widths. Used for manipulating signed or unsigned binary values in hardware description or low-level numeric computations.",
      "description_length": 389,
      "index": 248,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface structures with fixed field widths. Used to pack signals into a single bit vector for output, unpack them for processing, and select between multiple interface configurations.",
      "description_length": 356,
      "index": 249,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.Of_signal",
      "description": "This module offers operations for manipulating structured signal interfaces, including packing, unpacking, multiplexing, and concatenating signals, as well as renaming and extracting signal components. It works with signal types like `Hardcaml.Signal.t` and interface structures `t`, enabling tasks such as validating bit widths, creating hardware registers, and managing signal connections. Use cases include constructing complex digital circuits, debugging signal mappings, and configuring hardware interfaces with precise width constraints.",
      "description_length": 543,
      "index": 250,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.Of_always",
      "description": "Provides functions to create and manage interface containers for hardware description, including registers, wires, and signal assignments. Works with signal and variable types from the Hardcaml library to define always blocks. Used to generate named hardware interfaces with controlled signal behavior, such as initializing wires to zero or applying consistent naming conventions.",
      "description_length": 380,
      "index": 251,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type elements. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process and separate interface definitions in hardware description workflows.",
      "description_length": 337,
      "index": 252,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Make_comb.Unsigned",
      "description": "Converts between signed and unsigned representations, performs arithmetic and comparison operations on unsigned vectors, and resizes vectors to specified widths. Operates on a custom vector type `v` with bitwise and numeric operations. Used for precise control over binary data in hardware description or low-level numerical computations.",
      "description_length": 338,
      "index": 253,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed vectors, and supports conversions between `v` and `Comb.t`. Used for precise arithmetic in hardware description or digital logic simulations where overflow handling and bit-width control are critical.",
      "description_length": 390,
      "index": 254,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over bit-width and extension. Resizes vectors to specified widths while maintaining numerical integrity during operations.",
      "description_length": 351,
      "index": 255,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of numeric values in hardware description or digital logic contexts.",
      "description_length": 324,
      "index": 256,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, result, or list. Enables chaining of effectful operations and value transformations in a concise, readable manner.",
      "description_length": 284,
      "index": 257,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner and more readable code for sequencing and binding. Supports basic types like 'unit' and 'option' with simplified expressions. Users can chain operations more naturally, such as binding values from option types or handling side effects. Examples include simplifying nested match statements and flattening monadic pipelines.",
      "description_length": 388,
      "index": 258,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.All.Let_syntax.Let_syntax",
      "description": "The module provides a set of syntactic extensions for working with monadic computations. It introduces custom syntax for binding and sequencing operations, enhancing readability in complex workflows. While no concrete data types or functions are defined, it serves as a foundation for integrating domain-specific notations. Developers can leverage its syntax to write more expressive and concise code when combined with other modules.",
      "description_length": 434,
      "index": 259,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Unsafe_assoc_by_port_name",
      "description": "Creates and manipulates associations between string keys and values, using association lists as the underlying structure. Accepts a list of (string, value) pairs to build a structure and converts it back to the list format. Used to map port names to associated data in network or configuration contexts.",
      "description_length": 303,
      "index": 260,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.All",
      "description": "Combines monadic sequencing and custom syntax to manage effectful computations, enabling clean composition of operations that carry context like errors, options, or multiple results. Provides `bind` and `map` for transforming and chaining values within monadic types, along with `let%bind` and `let%return` for imperative-style code. It supports complex workflows such as parsing, asynchronous tasks, or handling optional values through structured, nested expressions. For example, it can sequence database queries, handle error-prone operations, or process lists with context-aware transformations.",
      "description_length": 599,
      "index": 261,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary numbers in hardware description or digital logic contexts.",
      "description_length": 378,
      "index": 262,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on `comb` (bit vectors) and `t` (interface records) to support hardware design tasks. Enables multiplexing, concatenation, and selection operations for digital circuit descriptions.",
      "description_length": 327,
      "index": 263,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Of_signal",
      "description": "This module offers low-level operations for handling hardware signal interfaces, including packing, unpacking, multiplexing, and concatenating signals, as well as validating width constraints and constructing registers, pipelines, and wires. It manipulates signal names and structures through renaming, prefix/suffix additions, and field modifications, working with types like `Hardcaml.Signal.t` and structured interface definitions. These capabilities are tailored for tasks such as interface abstraction, signal routing, and hierarchical design in digital circuit synthesis.",
      "description_length": 577,
      "index": 264,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Of_always",
      "description": "Provides functions to create and manage hardware interface containers for always blocks, including registers and wires with specific initialization. Works with signal types and variable structures from the Hardcaml library to define hardware behavior. Assigns signals to variables, applies naming conventions, and constructs interfaces for synthesis-friendly code.",
      "description_length": 364,
      "index": 265,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process hardware description data for signal mapping and validation.",
      "description_length": 326,
      "index": 266,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a generic type wrapped in a record structure that supports string-based indexing. Used to serialize or deserialize data where field names must map directly to values in a list format.",
      "description_length": 307,
      "index": 267,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.All",
      "description": "Combines monadic sequencing and transformation capabilities with syntactic enhancements for cleaner effectful code. Provides operations like bind and map, along with custom syntax such as `let%bind` and `let%map`, to handle values in contexts like option and result. Enables chaining of effectful computations while maintaining clarity and avoiding nested pattern matching. For example, it allows safely composing a series of optional or error-prone steps in a linear, readable fashion.",
      "description_length": 486,
      "index": 268,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of `v` values to specified widths. Used for manipulating signed or unsigned binary numbers in hardware description or digital logic contexts.",
      "description_length": 382,
      "index": 269,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface structures with fixed field widths. Used to pack signals into a single bit vector for output, unpack them for processing, and select between multiple interface configurations based on control signals.",
      "description_length": 381,
      "index": 270,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Of_signal",
      "description": "This module offers signal manipulation capabilities, including packing/unpacking, multiplexing, concatenation, and value assignment, alongside field renaming and adjustment for hardware interface constructs. It works with combinational logic interfaces (`comb t`), signal types (`Hardcaml.Signal.t`), and interface structures (`t`), focusing on width validation and routing. Use cases include hardware description tasks like signal routing optimization and interface field transformation.",
      "description_length": 488,
      "index": 271,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Of_always",
      "description": "Provides functions to create and manage interface containers for hardware description, including registers, wires, and signal assignments. Works with signal and variable types from the Hardcaml library to define always blocks. Used to generate named hardware interfaces with controlled initialization and signal routing.",
      "description_length": 320,
      "index": 272,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process hardware description data for signal mapping and validation.",
      "description_length": 326,
      "index": 273,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Unsafe_assoc_by_port_name",
      "description": "Provides functions to convert between a structured data type and an association list using field names as keys. Operates on a type that maps string keys to values, enabling direct access by name. Used to serialize and deserialize data structures where field names are critical for lookup.",
      "description_length": 288,
      "index": 274,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.All",
      "description": "Encapsulates monadic workflows by combining bind and map operations to sequence and transform values within effectful contexts, supporting types like option, list, and result. Provides custom syntax such as `let%bind` and `let%map` to simplify nested or chained computations, reducing boilerplate and improving readability. Enables error-aware pipelines by propagating failures through chained operations or managing state transitions in a declarative manner. For example, it allows processing a series of optional values with `let%bind` steps, or transforming results of asynchronous calls using map.",
      "description_length": 601,
      "index": 275,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary numbers in hardware description or low-level numeric computations.",
      "description_length": 386,
      "index": 276,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface structures composed of bit vectors. Used to pack signals into a single bus, unpack from a bus, or select between multiple interface configurations based on control signals.",
      "description_length": 353,
      "index": 277,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Of_signal",
      "description": "This module offers signal interface manipulation through operations like packing, multiplexing, and renaming, working with structured signal types that define bit widths and connections. It enables tasks such as interface routing, width validation, and signal extraction, particularly useful in digital design workflows requiring precise control over signal hierarchies and naming.",
      "description_length": 381,
      "index": 278,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Of_always",
      "description": "Provides functions to construct and manage hardware interface components within always blocks, including variable assignment, register creation, and wire initialization. Operates on types like `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` to model digital circuit signals and variables. Used to define clocked registers with enable signals and to generate named wire interfaces for hardware description.",
      "description_length": 410,
      "index": 279,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type elements. It exposes separate lists for names and widths, as well as a combined list of name-width pairs. Used to extract and organize interface information from hardware or circuit descriptions.",
      "description_length": 346,
      "index": 280,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values of arbitrary width. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 311,
      "index": 281,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed vectors, and supports conversions between `v` and `Comb.t`. Used for precise arithmetic in hardware description or digital logic simulations where bit-width management is critical.",
      "description_length": 370,
      "index": 282,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over width and extension. Resizes vectors to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 348,
      "index": 283,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of vector widths in digital design contexts, such as adjusting signal sizes or performing safe arithmetic in hardware descriptions.",
      "description_length": 387,
      "index": 284,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, list, or result. Enables chaining of effectful operations like error handling or asynchronous tasks.",
      "description_length": 270,
      "index": 285,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner expression of effectful workflows. It supports binding and sequencing through dedicated operators, enhancing code clarity. While no data types are defined, it integrates seamlessly with existing monadic structures. Users can write more readable code for complex computations, such as handling I/O, state, or error propagation.",
      "description_length": 392,
      "index": 286,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values of arbitrary width. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 311,
      "index": 287,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed vectors with specific bit widths. Enables precise control over signed integer operations in hardware description or low-level numeric computations.",
      "description_length": 337,
      "index": 288,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise width management. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 331,
      "index": 289,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 290,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that encapsulate values with context, such as option, result, or list. Enables chaining of effectful operations and value transformations in a concise, readable manner.",
      "description_length": 284,
      "index": 291,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner handling of effectful computations through constructs like `let%bind` and `let%map`. Supports sequencing and transformation of values within monadic contexts, such as option, result, or async. Allows for more readable and concise code when chaining operations that involve side effects or error handling. For example, it simplifies binding values from an option or mapping over a result without explicit nested matches.",
      "description_length": 485,
      "index": 292,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.I",
      "description": "Handles bitwise operations on fixed-width binary values, including packing, unpacking, multiplexing, and concatenation. Works with `comb` and `t` types representing combinational logic signals. Used for constructing and validating hardware description logic, such as selecting between multiple signal sources or combining bits into larger values.",
      "description_length": 346,
      "index": 293,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make.O",
      "description": "Provides operations to convert, validate, and manipulate combinatorial signals, including packing and unpacking bits, multiplexing, concatenation, and selection based on priority or one-hot encoding. Works with `comb` and `t` types, where `t` is a wrapped combinatorial signal. Used for constructing and verifying digital logic circuits, such as routing signals or implementing control logic.",
      "description_length": 392,
      "index": 294,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.I",
      "description": "Provides operations to convert, validate, and manipulate interface structures composed of bit-widthed fields. Supports packing and unpacking interfaces into vectors, multiplexing, concatenating, and selecting between interfaces based on control signals. Works with integer values and bit-widthed data structures to construct and verify hardware interface configurations.",
      "description_length": 370,
      "index": 295,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make.O",
      "description": "Converts interface values to and from S-expressions, validates and asserts signal widths, and constructs vectors from or decomposes them into interfaces. Performs bitwise operations such as multiplexing, concatenation, and selection based on control signals. Accepts integer constants and computes field widths for interface structures.",
      "description_length": 336,
      "index": 296,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.Unsafe_assoc_by_port_name",
      "description": "Provides functions to convert between a structured data type and an association list using field names as keys. Operates on a type that maps string keys to values, enabling direct access by name. Used to serialize and deserialize data structures where field names are critical for lookup.",
      "description_length": 288,
      "index": 297,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.All",
      "description": "Provides a framework for chaining effectful operations using monadic binds and maps, supporting any type constructor that implements the monad interface. Offers custom syntax like `let%bind` and `let%map` to simplify handling of optional, error-prone, or asynchronous values. Allows seamless composition of operations such as parsing nested options, managing state, or executing I/O in a structured manner. Enables cleaner code for tasks like reading from a file, processing results, and handling failures in a single, readable flow.",
      "description_length": 533,
      "index": 298,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary values in hardware description or digital logic contexts.",
      "description_length": 377,
      "index": 299,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface records with fixed field widths. Used to pack signals into a single bit vector for output, unpack them for processing, and select between multiple interface configurations based on control signals.",
      "description_length": 378,
      "index": 300,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.Of_signal",
      "description": "This module offers signal manipulation and validation functions, including packing/unpacking, multiplexing, and renaming, tailored for hardware interface design. It works with combinational logic interfaces (`comb t`), signal types (`Hardcaml.Signal.t`), and interface structures (`t`), focusing on width validation and wiring. Use cases include synthesizing hardware designs, routing signals, and transforming interface layouts.",
      "description_length": 429,
      "index": 301,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.Of_always",
      "description": "Provides functions to create and manage hardware interface variables for always blocks, including register and wire constructs. Works with signal types and variable containers from the Hardcaml library. Assigns values to variables, applies naming conventions, and supports custom signal generation for wire interfaces.",
      "description_length": 318,
      "index": 302,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where ports are represented as pairs of strings and integers. Works with lists of strings, integers, and custom tag types. Used to extract and separate naming and size information from hardware description data.",
      "description_length": 286,
      "index": 303,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a custom type representing interfaces and lists of string-value pairs. Used to map configuration fields from a list of named values into a structured representation.",
      "description_length": 289,
      "index": 304,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.All",
      "description": "Provides a monadic framework for sequencing computations and mapping values within effectful contexts, supporting types like option, list, and result. Offers custom syntax to simplify binding and chaining of monadic operations, allowing imperative-style code for clearer effect handling. Users can construct pipelines that handle failures or multiple outcomes seamlessly. For example, it enables safe data processing by chaining transformations that may fail or return multiple results.",
      "description_length": 486,
      "index": 305,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary values in hardware description or digital logic contexts.",
      "description_length": 377,
      "index": 306,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on `comb` (bit vectors) and `t` (interface records) to support hardware design tasks. Enables multiplexing, concatenation, and selection operations for digital circuit descriptions.",
      "description_length": 327,
      "index": 307,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.Of_signal",
      "description": "This module offers signal manipulation capabilities, including packing, unpacking, multiplexing, and name transformation for hardware interface structures, operating on combinational logic types and signal interfaces. It supports tasks like width validation, signal routing, and name modification via prefixes/suffixes, enabling precise control over hardware synthesis and interface design. Use cases include optimizing signal pathways and ensuring compatibility in complex digital systems.",
      "description_length": 490,
      "index": 308,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.Of_always",
      "description": "Provides functions to create and manage hardware interface variables for always blocks, including assigning signals, generating registers, and wiring signals with default values. Works with signal and variable types from the Hardcaml library to construct hardware descriptions. Used to define named registers and wires with specific behaviors in digital circuit designs.",
      "description_length": 370,
      "index": 309,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O.Names_and_widths",
      "description": "Provides functions to retrieve a list of port name-width pairs, separate lists of port names and widths, and a list of tags. Works with lists of strings, integers, and custom tag types. Used to extract and organize hardware port information for circuit description and validation.",
      "description_length": 280,
      "index": 310,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Unsigned",
      "description": "Converts between signed and unsigned vector representations, performs arithmetic and comparison operations on vectors with automatic bit-width extension, and resizes vectors to specified widths while preserving value integrity. Operates on a custom vector type representing unsigned binary values. Used for precise arithmetic in hardware description and digital logic simulations.",
      "description_length": 380,
      "index": 311,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Signed",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with a custom `v` type representing signed binary vectors. Resizes vectors to specified widths while preserving sign during conversion.",
      "description_length": 280,
      "index": 312,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Operates on custom data types representing bits or signals, allowing for precise control over bit-width. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 338,
      "index": 313,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and resizing with sign extension. Operates on data types representing bit vectors or signals, ensuring results are widened to prevent overflow. Supports direct manipulation of hardware-like signals in digital design contexts.",
      "description_length": 339,
      "index": 314,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with a custom `v` type representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 276,
      "index": 315,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Signed",
      "description": "Provides operations for signed vector arithmetic and comparison, including addition, subtraction, multiplication, and relational checks with bit-width handling. Works with a custom `v` type representing signed vectors. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 308,
      "index": 316,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over bit-width and extension. Resizes vectors to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 352,
      "index": 317,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of numeric values in hardware description or digital logic contexts.",
      "description_length": 324,
      "index": 318,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 272,
      "index": 319,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise control over signed integer operations in hardware description or low-level numeric computations.",
      "description_length": 319,
      "index": 320,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise width control and extension. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 342,
      "index": 321,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and resizing with proper sign extension. Operates on custom types representing bit vectors or signals, ensuring results are widened to prevent overflow. Used to implement precise arithmetic logic in hardware description or verification contexts.",
      "description_length": 359,
      "index": 322,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_sequential.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 272,
      "index": 323,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_sequential.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise control over signed integer operations in hardware description or low-level numeric computations.",
      "description_length": 319,
      "index": 324,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_sequential.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over width and extension. Resizes vectors to specified widths while maintaining numerical integrity during operations.",
      "description_length": 347,
      "index": 325,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_sequential.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing signals or bits, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 326,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_comb_primitives.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value integrity.",
      "description_length": 272,
      "index": 327,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_comb_primitives.Signed",
      "description": "Provides arithmetic and comparison operations on signed vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing signed binary vectors. Resizes vectors to specified widths while preserving sign during conversion.",
      "description_length": 276,
      "index": 328,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_comb_primitives.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bit vectors or signals, allowing for width-aware operations and conversions. Resizes vectors to specified widths while maintaining value integrity during transformations.",
      "description_length": 353,
      "index": 329,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_comb_primitives.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 330,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a custom associative structure and a list of string-value pairs. Works with a type representing port name mappings, using strings as keys. Used to serialize or deserialize port configurations from structured data.",
      "description_length": 252,
      "index": 331,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.All",
      "description": "Provides a monadic framework for sequencing computations and mapping values within wrapped types like option, list, or result. Offers custom syntax such as `let%bind` and `let%map` to simplify effectful operations and improve code readability. Enables safe handling of optional values, list transformations, and error-prone workflows by chaining operations in a structured way. For instance, it allows sequentially processing a series of optional inputs or transforming results in a list without deep nesting.",
      "description_length": 509,
      "index": 332,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for constructing and manipulating digital logic signals in hardware description contexts.",
      "description_length": 366,
      "index": 333,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Of_bits",
      "description": "Converts integer values to bitvector representations and supports bitwise operations like packing, unpacking, multiplexing, and concatenation. Handles combinatorial logic signals and ensures valid bitwidths during transformations. Used to construct and validate hardware description elements in digital circuit design.",
      "description_length": 318,
      "index": 334,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Of_signal",
      "description": "This module provides functions for constructing, manipulating, and validating digital circuit signals, including operations like packing, multiplexing, and timing management, while working with combinatorial logic types and signal objects. It supports tasks such as signal routing, name customization, and output transformations, tailored for hardware design applications requiring precise signal handling and naming conventions.",
      "description_length": 429,
      "index": 335,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Of_always",
      "description": "Provides functions to manipulate hardware description elements, including extracting signal values, assigning signals to always blocks, creating registers with optional enable signals, and defining wires with dynamic naming. Works with signal variables, register specifications, and signal generators. Used to construct sequential logic blocks and manage signal naming conventions in hardware designs.",
      "description_length": 401,
      "index": 336,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type instances. Extracts port names and widths as separate lists or combines them into a list of (name, width) tuples. Used to generate or inspect hardware interface configurations during synthesis or validation processes.",
      "description_length": 368,
      "index": 337,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a custom associative structure and a list of string-keyed value pairs. Works with a private type representing associations indexed by port names. Used to serialize and deserialize port mappings in network configuration contexts.",
      "description_length": 267,
      "index": 338,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.All",
      "description": "Combines monadic sequencing and transformation capabilities with syntactic enhancements for cleaner effectful code. Supports operations like bind and map across monadic types, allowing chained computations and value manipulation. Provides intuitive syntax such as `let%bind` to simplify workflows involving effectful operations. Enables efficient handling of optional values, lists, and asynchronous computations in a structured and readable way.",
      "description_length": 446,
      "index": 339,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary values in hardware description or digital logic contexts.",
      "description_length": 377,
      "index": 340,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Of_bits",
      "description": "Converts between integer values and bitvector representations, supports bitwise operations like packing, unpacking, and concatenation, and provides selection mechanisms such as multiplexing and priority decoding. Works with bitvector types built from lists of boolean signals and integer values. Used for constructing and validating digital logic circuits with precise bit-width control.",
      "description_length": 387,
      "index": 341,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Of_signal",
      "description": "This module specializes in signal manipulation for digital circuit design, offering operations like packing/unpacking, multiplexing, concatenation, and timing control using combinatorial logic. It works with `comb t` and `comb` types, as well as `Hardcaml.Signal.t`, enabling tasks such as signal routing, transformation, and naming within hardware descriptions. Specific use cases include optimizing signal paths, managing register-based timing, and modular signal processing in circuit synthesis.",
      "description_length": 498,
      "index": 342,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Of_always",
      "description": "Provides functions to manipulate hardware description elements, including extracting signal values, assigning signals to always blocks, creating registers with enable conditions, and generating wires with custom naming. Works with signal variables, registers, and naming configurations. Used to define sequential logic and signal assignments in digital circuit descriptions.",
      "description_length": 374,
      "index": 343,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O.Names_and_widths",
      "description": "Provides access to lists of port names, their corresponding widths, and tags. Operates on strings, integers, and a tag type to represent hardware interface details. Used to extract and process information about signal ports in circuit descriptions.",
      "description_length": 248,
      "index": 344,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize",
      "description": "Converts interface values to S-expressions, validates signal widths, and packs/unpacks interfaces into vectors. Constructs interfaces from integers, multiplexes or concatenates multiple interfaces, and selects between them using priority or one-hot logic. Works with combinatorial signal interfaces and integer bit-width maps.",
      "description_length": 326,
      "index": 345,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Specialize_with_config",
      "description": "Provides operations to validate, pack, unpack, and multiplex interface structures with fixed bit widths. Works with `comb` and `t` types representing hardware interfaces and their bit-width configurations. Used to generate hardware vectors from interface data, select between multiple interface configurations, and ensure signal width consistency.",
      "description_length": 347,
      "index": 346,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize",
      "description": "Converts interface values to S-expressions, validates port widths, and packs/unpacks interfaces into vectors. Constructs interfaces from integers, multiplexes or concatenates multiple interfaces, and selects between them using priority or one-hot logic. Operates on `comb` and `t` types, which represent hardware interface structures with defined bit widths.",
      "description_length": 358,
      "index": 347,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Specialize_with_config",
      "description": "Provides operations to validate, pack, unpack, and multiplex interface structures with fixed bit widths. Works with `comb` and `t` types representing hardware interfaces and their bit-width configurations. Used to generate and verify hardware signals from integer constants, combine interfaces into vectors, and select between multiple interface configurations.",
      "description_length": 361,
      "index": 348,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.M",
      "description": "Converts interface values to S-expressions, validates port widths, and packs/unpacks interfaces into vectors. Constructs interfaces from integers, multiplexes or concatenates multiple interfaces, and selects between them using priority or one-hot logic. Operates on `comb` and `t` types, which represent hardware interface structures with defined bit widths.",
      "description_length": 358,
      "index": 349,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d.Specialize_with_config",
      "description": "Provides operations to validate, pack, unpack, and multiplex interface structures with fixed bit widths. Works with `comb` and `t` types representing hardware interfaces and their bit-width configurations. Used to generate hardware signals from integer constants, combine interfaces into vectors, and select between multiple interface configurations.",
      "description_length": 350,
      "index": 350,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize",
      "description": "Converts interface values to S-expressions, validates port widths, and packs/unpacks interfaces into vectors. Performs multiplexing, concatenation, and selection operations on interface data. Constructs interfaces from integer constants and retrieves field width information.",
      "description_length": 275,
      "index": 351,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Specialize_with_config",
      "description": "Provides operations to validate, pack, unpack, and multiplex interface structures with fixed bit widths. Works with `comb` and `t` types representing hardware interfaces and their bit-width configurations. Used to generate and verify hardware signals from integer constants, combine interfaces into vectors, and select between multiple interface configurations.",
      "description_length": 361,
      "index": 352,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.M",
      "description": "Converts interface values to S-expressions, validates signal widths, and packs/unpacks interfaces into vectors. Constructs interfaces from integers, multiplexes or concatenates multiple interfaces, and selects between them using priority or one-hot logic. Operates on `comb` and `t` types, which represent hardware interfaces with defined bit widths.",
      "description_length": 350,
      "index": 353,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a custom type representing interfaces and lists of string-value pairs. Used to serialize and deserialize interface configurations based on named fields.",
      "description_length": 276,
      "index": 354,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.All",
      "description": "Provides monadic composition and transformation capabilities, allowing sequential processing of values within wrapped types like option, list, and result. Offers custom syntax for cleaner binding and mapping, enabling structured handling of side effects and errors. Supports chaining operations on optional values or transforming results without explicit pattern matching. Example: safely extracting and processing a series of nested options or applying transformations to a list of results.",
      "description_length": 491,
      "index": 355,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary numbers in hardware description or digital logic contexts.",
      "description_length": 378,
      "index": 356,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integer constants. Operates on typed bit vectors and interface structures with fixed field widths. Supports multiplexing, concatenation, and selection operations for digital circuit design.",
      "description_length": 296,
      "index": 357,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Of_signal",
      "description": "This module offers signal manipulation capabilities, including packing/unpacking, multiplexing, concatenation, and renaming, along with interface validation and name transformation via prefixes/suffixes. It works with hardware signal types like `comb t` and `Hardcaml.Signal.t`, enabling precise control over bit-widths, register pipelines, and wire creation. Use cases include managing complex signal routing in hardware designs and ensuring port compatibility through structured name modifications.",
      "description_length": 500,
      "index": 358,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Of_always",
      "description": "Provides functions to create and manage interface containers for hardware description, including registers, wires, and signal assignments. Works with signal and variable types from the Hardcaml library to construct always blocks. Enables naming conventions for interface fields and simplifies register and wire initialization with default values.",
      "description_length": 346,
      "index": 359,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type elements. Extracts individual lists of names and widths from a combined list of name-width pairs. Used to process and separate interface definitions in hardware description code.",
      "description_length": 329,
      "index": 360,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Unsafe_assoc_by_port_name",
      "description": "Creates and manipulates associations between string keys and values, using association lists as the underlying structure. Accepts a list of (string, 'a) pairs to build a structure and converts it back to an alist for access by field names. Used to map port names to associated data in network or configuration contexts.",
      "description_length": 319,
      "index": 361,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.All",
      "description": "Combines monadic sequencing with syntactic enhancements to manage effectful computations, supporting operations like bind and map across types such as option, result, and list. Provides custom syntax like `let%bind` and `let%map` to simplify chaining and nesting of dependent actions. Enables structured error handling, state transitions, and asynchronous workflows with clearer code. For example, it allows sequential processing of optional values or composing asynchronous tasks with reduced boilerplate.",
      "description_length": 506,
      "index": 362,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary values in hardware description or digital logic contexts.",
      "description_length": 377,
      "index": 363,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on `comb` (bit vectors) and `t` (interface records) to support hardware design tasks. Enables multiplexing, concatenation, and selection operations for digital circuit descriptions.",
      "description_length": 327,
      "index": 364,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Of_signal",
      "description": "This module offers low-level manipulation of combinatorial signal interfaces through operations like packing, multiplexing, and renaming, along with validation and width assertion. It works with structured signal types such as `comb t` and `Hardcaml.Signal.t`, enabling precise control over signal routing and naming conventions. Use cases include digital circuit design tasks like interface aggregation, bit-width management, and signal name normalization in hardware description workflows.",
      "description_length": 491,
      "index": 365,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Of_always",
      "description": "Provides functions to create and manage interface containers for hardware description, including registers, wires, and signal assignments. Operates on types like `Hardcaml.Always.Variable.t` and `Hardcaml.Signal.t` to construct and name hardware elements. Used to define always blocks with named signals, register configurations, and wire defaults in digital circuit designs.",
      "description_length": 375,
      "index": 366,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d.Names_and_widths",
      "description": "Provides access to lists of port names, port widths, and tags, with a combined list of port name-width pairs. Operates on strings, integers, and a custom tag type. Used to extract and organize interface information from hardware description files.",
      "description_length": 247,
      "index": 367,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.Unsafe_assoc_by_port_name",
      "description": "Creates and manipulates associations between string keys and values, using association lists as the underlying structure. Accepts a list of (string, value) pairs to build a structure and converts it back to the list format. Used to map port names to associated data in network or configuration contexts.",
      "description_length": 303,
      "index": 368,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.All",
      "description": "Provides a framework for sequencing and transforming values within a monadic context, supporting chained operations that manage side effects or asynchronous behavior. It includes a monadic type for wrapping values and functions for binding and mapping within that context. Custom syntax simplifies the expression of monadic pipelines, allowing for clearer and more structured handling of effectful computations. Users can parse data, manage state, or perform I/O in a compositional and readable way.",
      "description_length": 499,
      "index": 369,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of `v` to a specified width. Used for manipulating signed or unsigned binary values in hardware description or digital logic contexts.",
      "description_length": 375,
      "index": 370,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on typed bit vectors and interface structures with fixed field widths. Used to pack signals into a single bit vector for output, unpack them for processing, and select between multiple interface configurations based on control signals.",
      "description_length": 381,
      "index": 371,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.Of_signal",
      "description": "This module handles signal manipulation, validation, and routing, offering functions for packing/unpacking, multiplexing, concatenating, and renaming signals within hardware interfaces. It works with combinational logic types (`comb t`), signal interfaces (`Hardcaml.Signal.t`), and structured interface definitions (`t`), enabling tasks like width validation and synthesis-friendly signal organization. Specific use cases include optimizing signal routing in digital circuits and ensuring consistent naming conventions during hardware design.",
      "description_length": 543,
      "index": 372,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.Of_always",
      "description": "Provides functions to create and manage hardware interface components within always blocks, including variable assignments, register creation, and wire initialization. Works with signal types and variable containers from the Hardcaml library to define hardware behavior. Used to generate named signals, configure registers with enable logic, and wire signals with default values.",
      "description_length": 379,
      "index": 373,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process hardware description data for signal mapping and validation.",
      "description_length": 326,
      "index": 374,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Unsafe_assoc_by_port_name",
      "description": "Creates a mapping between port names and associated values, allowing conversion to and from association lists. Operates on a custom type representing port-based data structures. Used to serialize and deserialize port configurations from structured data.",
      "description_length": 253,
      "index": 375,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.All",
      "description": "Combines monadic sequencing and custom syntax to handle effectful computations and value transformations. Supports types like option, result, and list, allowing operations such as binding and mapping across nested structures. Enables cleaner code for chaining operations, like extracting values from options or managing side effects. Examples include simplifying nested pattern matches and creating fluent pipelines for data processing.",
      "description_length": 436,
      "index": 376,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary values in hardware description or digital logic contexts.",
      "description_length": 377,
      "index": 377,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on `comb` (bit vectors) and `t` (interface records) to support hardware design tasks. Enables multiplexing, concatenation, and selection operations for digital circuit descriptions.",
      "description_length": 327,
      "index": 378,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Of_signal",
      "description": "This module provides operations for signal interface manipulation, including routing, selection, and transformation through packing, multiplexing, and field adjustments. It works with combinatorial signal interfaces (`comb t`), signal types (`Hardcaml.Signal.t`), and structured interface definitions (`t`), enabling tasks like signal concatenation and name mapping. Use cases include digital design workflows requiring dynamic signal routing or interface adaptation.",
      "description_length": 467,
      "index": 379,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Of_always",
      "description": "Provides functions to create and manage hardware interface variables for always blocks, including register and wire constructs. Operates on signal and variable types from the Hardcaml library to define hardware behavior. Assigns values to variables, applies naming conventions, and supports custom signal generation for interface fields.",
      "description_length": 337,
      "index": 380,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts port names and widths as separate lists or combines them into a list of (name, width) tuples. Used to generate hardware interface definitions or validate signal configurations.",
      "description_length": 344,
      "index": 381,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Make_comb.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values of arbitrary width. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 311,
      "index": 382,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Make_comb.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed binary vectors. Enables precise arithmetic in hardware description, such as adding or comparing fixed-width signals without overflow.",
      "description_length": 323,
      "index": 383,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Make_comb.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bits or signals, allowing for precise control over width and extension. Resizes vectors to specified widths while maintaining value integrity during conversions between signal and vector representations.",
      "description_length": 386,
      "index": 384,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Make_comb.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing bits or signals, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 385,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.All.Monad_infix",
      "description": "Sequences monadic computations and transforms their results using bind and map operations. Works with monadic types that support binding and lifting. Enables chaining of effectful operations and transformation of wrapped values in a concise manner.",
      "description_length": 248,
      "index": 386,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.All.Let_syntax",
      "description": "Introduces custom syntax for monadic operations, enabling cleaner and more readable code when working with sequential computations. It relies on underlying monadic structures but does not define new data types or functions itself. Users can chain operations using the provided syntax, such as `let%bind` or `let%map`, to handle effects like option, list, or state. This allows for more natural expression of control flow in monadic contexts.",
      "description_length": 441,
      "index": 387,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.I",
      "description": "Provides operations to convert, validate, and manipulate interface structures composed of bit-widthed signals. Works with `comb` and `t` types representing combinational logic interfaces and their bit widths. Enables packing and unpacking interfaces into vectors, multiplexing, concatenating, and selecting between interfaces based on control signals.",
      "description_length": 351,
      "index": 388,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.X_with_valid",
      "description": "Converts interface values to and from S-expressions, validates signal widths, and constructs interfaces from integer constants. Packs and unpacks interfaces into vectors, multiplexes and concatenates multiple interfaces, and selects among them using priority or one-hot logic. Operates on `comb` and `t` types, which represent hardware interfaces with defined bit widths.",
      "description_length": 371,
      "index": 389,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.O",
      "description": "Converts interface values to S-expressions, validates port widths, and packs/unpacks interfaces into vectors. Constructs interfaces from integers, multiplexes or concatenates multiple interfaces, and selects between them using priority or one-hot logic. Operates on combinatorial signal interfaces with defined bit widths.",
      "description_length": 322,
      "index": 390,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.Unsafe_assoc_by_port_name",
      "description": "Creates and manipulates associations between string keys and values, using association lists as the underlying structure. Accepts a list of (string, value) pairs to build a structure, and converts such a structure back into a list of pairs. Used to map port names to associated data in network or configuration contexts.",
      "description_length": 320,
      "index": 391,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.All",
      "description": "Combines monadic sequencing and custom syntax to manage effectful computations, allowing for structured handling of contexts like errors, lists, or asynchronous results. It supports binding and mapping over monadic values, enabling fluent composition of operations. Users can express complex workflows, such as error-prone I/O or stateful processes, with clearer syntax. Examples include chaining multiple result-producing functions or managing optional values in a readable way.",
      "description_length": 479,
      "index": 392,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of `v` values to specified widths. Used for manipulating signed or unsigned binary numbers in hardware description or digital logic contexts.",
      "description_length": 382,
      "index": 393,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on combinatorial bit vectors and interface records composed of such vectors. Used to pack signals into a single bit vector for output, unpack them for processing, and select between multiple interface configurations based on control signals.",
      "description_length": 387,
      "index": 394,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.Of_signal",
      "description": "This module offers signal manipulation capabilities, including renaming, name transformation, and interface management, with operations like packing, unpacking, and concatenation. It works with combinational logic interfaces (`comb t`) and signal types (`Hardcaml.Signal.t`), enabling tasks such as hardware signal routing and width validation. Specific use cases include modifying signal names for clarity in complex designs and ensuring compatibility during hardware synthesis.",
      "description_length": 479,
      "index": 395,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.Of_always",
      "description": "Provides functions to construct and manage hardware interface components within always blocks, including variable assignments, register creation, and wire initialization. Works with signal types, variable containers, and register specifications to model digital circuit behavior. Enables precise control over signal naming and interface structure in hardware design workflows.",
      "description_length": 376,
      "index": 396,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type elements. It exposes a combined list of port name-width pairs, enabling direct access to both identifiers and their associated bit widths. Used to extract and process hardware interface metadata during synthesis or verification workflows.",
      "description_length": 389,
      "index": 397,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Unsafe_assoc_by_port_name",
      "description": "Provides functions to convert between a structured data type and an association list using field names as keys. Operates on a type that maps string keys to values, enabling direct access by name. Used to serialize and deserialize data structures in contexts where field names are known at runtime.",
      "description_length": 297,
      "index": 398,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.All",
      "description": "Combines monadic sequencing and transformation capabilities, allowing effectful operations to be chained and values to be manipulated within contexts like option, result, or list. Provides custom syntax such as `let%bind` and `let%map` to simplify handling of nested or conditional values. It enables concise error handling, asynchronous workflows, and list comprehensions by abstracting away boilerplate. For instance, it lets you bind a value from an option or map over a result without explicit pattern matching.",
      "description_length": 515,
      "index": 399,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with automatic bit-width extension. Supports conversion between `v` and `Comb.t` and allows resizing of values to specified widths. Used for manipulating signed or unsigned binary values in hardware description or digital logic contexts.",
      "description_length": 377,
      "index": 400,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on `comb` (bit vectors) and `t` (interface records) to support hardware design tasks. Enables multiplexing, concatenation, and selection operations for digital circuit descriptions.",
      "description_length": 327,
      "index": 401,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Of_signal",
      "description": "The module provides functions for constructing, manipulating, and validating hardware interface signals through operations like packing, unpacking, and multiplexing, working with combinational logic interfaces (`comb t`) and signal types (`Hardcaml.Signal.t`). It also enables renaming and modifying signal names with prefixes/suffixes, supporting tasks such as signal routing, width validation, and interface consistency in hardware design.",
      "description_length": 441,
      "index": 402,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Of_always",
      "description": "Provides functions to create and manage hardware interface variables for always blocks, including register and wire constructs. Operates on signal and variable types from the Hardcaml library to define hardware behavior. Assigns values to variables, applies naming conventions, and supports conditional register enable signals.",
      "description_length": 327,
      "index": 403,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts port names and widths as separate lists or combines them into a list of (name, width) tuples. Used to generate hardware interface descriptions or validate signal configurations.",
      "description_length": 345,
      "index": 404,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.P",
      "description": "This module provides precomputed 32-bit bit vector constants with specific hexadecimal identifiers, designed for hardware logic operations and system monitoring configurations. It operates on `Hardcaml.Logic.Bit_vector.t` data structures, offering fixed numeric values and signal patterns for tasks like sensor parameter setup and digital logic simulation. Use cases include initializing hardware components, defining standard logic signals, and configuring voltage monitoring systems.",
      "description_length": 485,
      "index": 405,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1.Make",
      "description": "This module provides functions for initializing bit vector constants and configuring hardware-related parameters, focusing on predefined 32-bit and 64-bit values for cryptographic, simulation, and hardware design tasks. It operates on Hardcaml's Bit_vector type, along with standard logic, integers, and strings, to define configurations like clock signals, voltage monitors, and file paths. Use cases include setting up hardware descriptions, simulation environments, and monitoring systems with precise bit-patterned or textual parameters.",
      "description_length": 541,
      "index": 406,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.Make",
      "description": "Provides operations to retrieve configuration values such as number of words, bits per word, and latency metrics. Works with primitive types and custom option-wrapped data structures like collision mode and clocking mode. Used to configure hardware interfaces and optimize data transfer settings.",
      "description_length": 296,
      "index": 407,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Lut_equation",
      "description": "Provides bitwise and logical operations on a custom type `t` to construct expressions for LUT initialization. Supports constants like ground (gnd) and power (vdd), and binary operations such as AND, OR, XOR, and comparison. Used to generate specific integer values for lookup tables based on input bit patterns.",
      "description_length": 311,
      "index": 408,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_combinational_primitives",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks with proper bit-width handling. Supports conversion between `v` and `Comb.t` types, and allows resizing of values to specified widths with appropriate extension. Used for constructing and manipulating digital logic circuits with precise control over signal widths and operations.",
      "description_length": 419,
      "index": 409,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Hardcaml_sequential_primitives",
      "description": "Provides flip-flop and RAM primitives for digital circuit design, including data storage with enable and clock control. Operates on signal types to manage sequential logic elements like registers and single-port memory. Used to implement synchronous data latching and simple memory blocks in hardware descriptions.",
      "description_length": 314,
      "index": 410,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_combinational_primitives",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and bitwise comparisons. Supports resizing of values to specified widths with proper sign or zero extension. Converts between `v` and `Comb.t` types for integration with signal representations.",
      "description_length": 311,
      "index": 411,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unisim_sequential_primitives",
      "description": "Handles flip-flop and memory operations with control signals, enabling register updates and single-port RAM behavior. Accepts signal inputs for data, clock, enable, and reset to manage sequential logic. Used for implementing synchronous storage elements and simple memory blocks in hardware designs.",
      "description_length": 299,
      "index": 412,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Lut4",
      "description": "Provides operations to retrieve the maximum index value for a 4-input lookup table, and includes a function to compute the number of possible output combinations based on the index. Works with integer indices and precomputed output arrays. Used to optimize hardware synthesis by limiting input ranges and generating compact truth tables.",
      "description_length": 337,
      "index": 413,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Lut6",
      "description": "Provides operations to retrieve and manipulate precomputed lookup tables for bitwise logic functions. Works with integers and bit vectors to execute complex logical operations efficiently. Used in hardware description tasks to implement custom logic gates with predefined configurations.",
      "description_length": 287,
      "index": 414,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_xilinx_primitives",
      "description": "Converts between signal types and performs arithmetic and comparison operations on bit-vector values. Supports addition, subtraction, multiplication, and relational operations with automatic width extension and resizing. Resizes values to specified widths while preserving sign or zero extension as needed.",
      "description_length": 306,
      "index": 415,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_comb_primitives",
      "description": "Converts between a custom type and a Comb.t, and defines arithmetic and comparison operations on values of type v. Supports addition, subtraction, multiplication, and relational operators with automatic bit-width extension. Resizes values to specified widths while preserving numerical integrity.",
      "description_length": 296,
      "index": 416,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Make_sequential",
      "description": "Provides operations for manipulating and combining values of type `v`, including arithmetic operations, comparisons, and resizing. Supports conversion between `v` and `Comb.t` and ensures proper bit-width handling during operations. Used to construct and manage signals in hardware description or digital logic contexts.",
      "description_length": 320,
      "index": 417,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.I",
      "description": "Handles bitwise operations on fixed-width binary values, including packing, unpacking, multiplexing, and concatenation. Works with `comb` and `t` types representing combinational logic and width-annotated binary values. Used to construct and validate hardware description elements like bus interfaces and control logic.",
      "description_length": 319,
      "index": 418,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3.O",
      "description": "Provides operations to convert, validate, and manipulate combinatorial signals, including packing, unpacking, multiplexing, and concatenating signals of fixed width. Works with `comb` and `t` types, where `t` represents a signal of a specific width. Used to construct and verify hardware description logic, such as selecting between multiple inputs or ensuring consistent signal widths.",
      "description_length": 386,
      "index": 419,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Config",
      "description": "Provides a configuration loading mechanism that parses environment variables and JSON files into a structured record. Works with strings, integers, and nested records to represent application settings. Used to initialize application parameters from external sources during startup.",
      "description_length": 281,
      "index": 420,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Port_label",
      "description": "Provides functions to convert port labels to S-expressions, compare them lexicographically, and retrieve a list of all defined port labels. Works with the abstract type `t` representing port identifiers. Used to serialize port data for logging and ensure consistent ordering in network protocol implementations.",
      "description_length": 311,
      "index": 421,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Create",
      "description": "Converts interface values to S-expressions, validates port widths, and constructs interfaces from integers. Packs and unpacks interfaces into and from vectors, and selects or concatenates multiple interfaces based on control signals. Works with combinatorial signal interfaces and integer bit-width maps.",
      "description_length": 304,
      "index": 422,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_1d",
      "description": "Provides operations to pack and unpack interface structures into and from vectors, multiplex or concatenate interfaces, and validate or assert their bit widths. Works with combinatorial signal interfaces represented as tuples of integers and bit widths. Used to construct and manage hardware description interfaces in digital circuit design, such as routing signals through multiplexers or combining multiple ports into a single bus.",
      "description_length": 433,
      "index": 423,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_1d",
      "description": "Provides operations to manipulate and validate interface structures composed of bit-widthed signals. Includes packing, unpacking, multiplexing, and concatenation of interfaces, along with assertions and checks for width consistency. Used to construct and manage hardware interface signals in digital design workflows.",
      "description_length": 317,
      "index": 424,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Read_port_2d",
      "description": "Handles validation, packing, unpacking, and multiplexing of hardware interface structures with fixed bit widths. Operates on `comb` and `t` types to generate signals from integers, combine interfaces into vectors, and select between configurations. Supports bitwise manipulation and interface aggregation for hardware design. Examples include converting integer constants to signals, merging multiple interfaces into a single vector, and switching between interface setups based on control inputs.",
      "description_length": 497,
      "index": 425,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.Write_port_2d",
      "description": "Provides operations to pack and unpack interface structures into vectors, multiplex and concatenate interfaces, and validate or assert their bit widths. Works with `comb` and `t` types representing combinational logic interfaces. Used to construct and manage hardware interfaces in digital design workflows, such as selecting between multiple signal configurations or combining signals into a single bus.",
      "description_length": 404,
      "index": 426,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder.M",
      "description": "Provides functions to create, transform, and query values of type 'a t, including mapping over contained values and combining instances with custom logic. Operates on opaque data structures that encapsulate single values or sequences. Used to process event streams and aggregate results in real-time data pipelines.",
      "description_length": 315,
      "index": 427,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Unsafe_assoc_by_port_name",
      "description": "Provides operations to convert between a structured data type and an association list using field names as keys. Works with a generic type wrapped in a record structure that supports string-based indexing. Used to serialize and deserialize data structures in network protocols where fields are identified by names.",
      "description_length": 314,
      "index": 428,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.All",
      "description": "Combines monadic sequencing and syntactic enhancements to streamline effectful programming. Supports operations like bind and map on monadic types, allowing transformation and chaining of computations. Provides custom syntax such as `let%bind` to simplify sequential workflows with option, list, or state. Enables concise handling of side effects and nested computations in a readable format.",
      "description_length": 392,
      "index": 429,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Make_comb",
      "description": "Provides arithmetic and comparison operations on values of type `v`, including addition, subtraction, multiplication, and relational checks, with automatic bit-width extension and resizing. Supports conversion between `v` and `Comb.t` for interfacing with hardware description components. Used to construct and manipulate digital signal values in circuit designs.",
      "description_length": 363,
      "index": 430,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Of_bits",
      "description": "Converts interface values to and from bit vectors, validates signal widths, and constructs interfaces from integers or other interfaces. Operates on `comb` (bit vectors) and `t` (interface records) to support hardware design tasks. Enables multiplexing, concatenation, and selection operations for digital circuit descriptions.",
      "description_length": 327,
      "index": 431,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Of_signal",
      "description": "This module provides functions for constructing, manipulating, and validating hardware signal interfaces, including bitwise operations like packing, concatenating, and multiplexing, as well as renaming signals and modifying their names with prefixes/suffixes. It works with signal types such as `comb t` and `Hardcaml.Signal.t`, supporting tasks like register pipeline management and port width validation. Use cases include hardware design workflows requiring precise signal routing, name consistency, and bitwise manipulation.",
      "description_length": 528,
      "index": 432,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Of_always",
      "description": "Provides functions to create and manage interface containers for hardware description, including registers, wires, and signal assignments. Works with signal and variable types from the Hardcaml library to construct always blocks. Enables naming conventions for interface fields and supports conditional register creation.",
      "description_length": 321,
      "index": 433,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port.Names_and_widths",
      "description": "Provides functions to retrieve lists of port names, port widths, and tags, where port names are strings, widths are integers, and tags are custom type values. Extracts individual lists of names and widths from a combined list of (name, width) pairs. Used to process hardware description data for signal mapping and validation.",
      "description_length": 326,
      "index": 434,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync.With_interface",
      "description": "Provides operations to convert, validate, and manipulate interface data structures representing digital circuit signals. Works with `comb` and `t` types, which encapsulate signal widths and values. Enables packing and unpacking of interfaces into vectors, multiplexing, concatenation, and selection based on control signals.",
      "description_length": 324,
      "index": 435,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.I",
      "description": "Provides operations to convert, validate, and manipulate interface structures composed of bit vectors. Works with `comb` and `t` types representing combinational logic interfaces and their bit widths. Enables packing and unpacking of interfaces into vectors, multiplexing, concatenation, and selection based on control signals.",
      "description_length": 327,
      "index": 436,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing.O",
      "description": "Converts interface values to and from S-expressions, ensures consistent bit widths, and validates signal ports. Packs and unpacks interfaces into and from bit vectors, and selects or combines interfaces using multiplexing, concatenation, and priority logic. Accepts integer constants to initialize interface fields and computes the bit widths of each field.",
      "description_length": 357,
      "index": 437,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Unsigned",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with the `v` type, representing unsigned binary values. Resizes vectors to specified widths while preserving value through appropriate extension.",
      "description_length": 292,
      "index": 438,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Signed",
      "description": "Provides operations for manipulating signed vectors, including arithmetic and comparison functions that handle bit-width extension and resizing. Works with the `v` type, representing signed vectors with specific bit widths. Used for precise arithmetic in hardware description or digital logic simulations where overflow and bit-width management are critical.",
      "description_length": 358,
      "index": 439,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Uop",
      "description": "Provides arithmetic and comparison operations on unsigned vectors, including addition, subtraction, multiplication, and bitwise comparisons. Works with custom data types representing bit vectors or signals, allowing for precise width management. Resizes values to specified widths while maintaining numerical integrity during conversions.",
      "description_length": 338,
      "index": 440,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis.Sop",
      "description": "Performs arithmetic and comparison operations on signed vectors, supporting extension and resizing during operations. Works with custom data types representing signals or bits, ensuring results are widened to prevent overflow. Enables precise manipulation of fixed-width numeric values in hardware description or digital logic contexts.",
      "description_length": 336,
      "index": 441,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Byte_write_width",
      "description": "Writes binary data to a byte stream with explicit control over bit widths, supporting 8-bit and 9-bit formats. Operates on integers and byte arrays, ensuring precise alignment and padding for hardware or protocol-specific data transmission. Used to serialize sensor data or register values in embedded systems where bit-width matching is critical.",
      "description_length": 347,
      "index": 442,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Cascade_height",
      "description": "Calculates and represents the height of BRAM cascade chains, converting the value to XPM argument formats and S-expression representations. It works with an opaque type encapsulating numeric height values. Used to fine-tune BRAM configurations in FPGA designs for timing optimization.",
      "description_length": 284,
      "index": 443,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Clocking_mode",
      "description": "Handles conversion of clocking mode representations to S-expression and XPM argument formats. Operates on an abstract type representing hardware clocking configurations. Used to generate XPM-compatible display parameters from clocking settings.",
      "description_length": 244,
      "index": 444,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Collision_mode",
      "description": "Handles collision detection and response logic, offering precise geometric intersection checks and resolution calculations. Operates on custom shape and position data structures representing game entities. Used to determine and adjust object positions during simultaneous movement in physics-based simulations.",
      "description_length": 310,
      "index": 445,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Dual_port_ram",
      "description": "Provides functions to instantiate a single-clock dual-port RAM with configurable read latency, memory architecture, and byte write width. Operates on signal types and port structures defined by the Hardcaml library. Used to implement FPGA memory blocks with separate read and write ports for concurrent access in digital designs.",
      "description_length": 329,
      "index": 446,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_async",
      "description": "Creates a synchronous FIFO with configurable capacity, overflow/underflow checks, and latency adjustments. Operates on clock signals, data signals, and control signals to manage data flow between different clock domains. Used to synchronize data transfer in hardware designs where timing and flow control are critical.",
      "description_length": 318,
      "index": 447,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_memory_type",
      "description": "Provides operations to convert a FIFO memory structure into an S-expression and generate XPM argument strings. Works with a custom type representing FIFO memory configurations. Used to serialize memory settings for hardware description or configuration file generation.",
      "description_length": 269,
      "index": 448,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Fifo_sync",
      "description": "Manages digital circuit signal interfaces through operations that transform, validate, and combine `comb` and `t` types, which represent signal widths and values. Supports packing interfaces into vectors, unpacking, multiplexing, and concatenating signals based on control inputs. Allows selective access to interface elements using control signals. Enables precise manipulation of signal structures for circuit design and verification tasks.",
      "description_length": 442,
      "index": 449,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Icape3",
      "description": "Manages fixed-width binary signals through bitwise operations, packing, unpacking, and signal manipulation using `comb` and `t` types. Supports constructing and validating hardware elements like bus interfaces by combining and selecting signals of defined widths. Allows for precise control over signal routing and width consistency in digital design. For example, it can merge multiple 8-bit signals into a 32-bit bus or select between two 16-bit inputs based on a control signal.",
      "description_length": 481,
      "index": 450,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Memory_builder",
      "description": "Provides functions to access precomputed layout dimensions for memory structures, including a fixed vertical index width and a horizontal data dimension. Works with integer-based spatial configurations used in memory mapping. Used to align data rows and columns in low-level memory allocation tasks.",
      "description_length": 299,
      "index": 451,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_arch",
      "description": "Provides functions to convert a RAM configuration type to an S-expression and to generate XPM macro parameters. Works with a custom type representing Xilinx RAM primitive configurations. Used to specify RAM behavior in hardware synthesis tools via parameterized macro generation.",
      "description_length": 279,
      "index": 452,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port",
      "description": "Converts interface values to and from S-expressions, validates and asserts field widths, and packs/unpacks interfaces into vectors. Supports constant initialization from integers, multiplexing, concatenation, and selection based on priority or one-hot signals. Operates on combinatorial signals and interface structures with defined bit widths.",
      "description_length": 344,
      "index": 453,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_port_with_clear",
      "description": "Provides operations to validate, pack, and unpack interface structures, and to multiplex or concatenate multiple interfaces. Works with `comb` and `t` types representing hardware interfaces with fixed bit widths. Used to generate hardware signals from integer constants, combine interfaces into vectors, and select between multiple interface configurations.",
      "description_length": 357,
      "index": 454,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Ram_with_resizing",
      "description": "Manages interface structures using bit vectors, supporting conversion, validation, and manipulation of `comb` and `t` types. Provides operations for packing, unpacking, multiplexing, and concatenating interfaces, along with selecting fields based on control signals. Accepts integer constants to initialize interface values and computes precise bit widths for each field. Examples include converting an interface to a bit vector, combining multiple interfaces with priority logic, and extracting specific fields using control signals.",
      "description_length": 534,
      "index": 455,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Simple_dual_port_ram",
      "description": "Creates a dual-port RAM with separate write and read interfaces, supporting configurable read latency, memory optimization, and byte-write width. Operates on signals for clock, clear, addresses, enables, and data, producing a memory output signal. Used to implement Xilinx-compatible RAM in hardware designs where independent read and write operations are required.",
      "description_length": 365,
      "index": 456,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.Synthesis",
      "description": "Converts between a custom signal type and a Comb.t, and supports arithmetic and comparison operations on values of type v. Operations like addition, subtraction, multiplication, and comparisons extend arguments to avoid truncation and return results with adjusted bit widths. Resizes values to specified widths using appropriate extension methods.",
      "description_length": 347,
      "index": 457,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Hardcaml_xilinx.Sysmone1",
      "description": "This module provides functions for initializing and managing 32-bit bit vectors tailored to hardware configurations, including register addresses, signal states, and simulation monitoring parameters. It operates on Hardcaml's `Bit_vector` and `Logic.Bit_vector.t` types, enabling precise control over circuit settings and hardware register values. Specific use cases include configuring fixed binary values for hardware signals, setting initial states in digital circuits, and defining monitoring behavior for voltage channels in simulation environments.",
      "description_length": 554,
      "index": 458,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx.True_dual_port_ram",
      "description": "Creates a Xilinx-compatible true dual-port RAM with independent clocking for two ports, supporting read and write operations with configurable latency and memory architecture. Operates on signals and ports defined by Hardcaml, using separate read and write enables to manage access. Used to model memory behavior in hardware designs, particularly for simulating address collision scenarios and ensuring correct timing in synthesis.",
      "description_length": 431,
      "index": 459,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "hardcaml_xilinx",
      "description": "Provides functions to instantiate Xilinx-specific RAM and FIFO primitives, along with simulation models for verification. Works with hardware description types such as signals, registers, and memory blocks. Used to build custom Xilinx circuits with low-level LUT-based components for synthesis.",
      "description_length": 294,
      "index": 460,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Hardcaml_xilinx",
      "description": "Provides serialization, memory configuration, and signal manipulation capabilities for hardware design. Handles binary data formatting, BRAM height calculations, clocking mode conversion, collision detection, RAM and FIFO instantiation, and interface signal operations using custom types and `comb`/`t` structures. Examples include serializing sensor data, configuring dual-port RAM with separate clocks, and validating interface bit widths for hardware synthesis. Supports generating XPM parameters, managing signal vectors, and performing bitwise operations for precise digital design control.",
      "description_length": 595,
      "index": 461,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 494,
    "meaningful_modules": 462,
    "filtered_empty_modules": 32,
    "retention_rate": 0.9352226720647774
  },
  "statistics": {
    "max_description_length": 609,
    "min_description_length": 237,
    "avg_description_length": 364.030303030303,
    "embedding_file_size_mb": 1.585646629333496
  }
}