{
  "package": "janestreet_cpuid",
  "embedding_model": "Qwen/Qwen3-Embedding-0.6B",
  "embedding_dimension": 1024,
  "total_modules": 151,
  "creation_timestamp": "2025-07-15T23:35:07.343893",
  "modules": [
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Map.Diff",
      "library": "janestreet_cpuid",
      "description": "This module represents differences between AMD extended feature flags (specifically EBX bits from CPUID leaf 0x7, subleaf 0x0) across different CPU states. It provides functions to serialize and deserialize these differences, compute them between two states, apply them to a base state, and construct them from lists of per-flag changes. It is used to track and manipulate changes in AMD-specific CPU features like SME, SEV, and other advanced execution controls.",
      "description_length": 463,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Map.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "This module parses S-expressions into a map structure that associates keys with values derived from Intel CPUID feature flags. It specifically handles the EDX register flags from the CPUID instruction's version and feature information leaf. Use this module when deserializing CPU feature data stored in S-expression format for analysis or configuration purposes.",
      "description_length": 362,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Map.Key",
      "library": "janestreet_cpuid",
      "description": "This module defines a key type for mapping based on AMD CPUID version and feature information flags from the ECX register. It provides comparison and serialization functions for use in associative data structures like maps. It is used to index processor feature sets retrieved via CPUID leaf 0x1 for AMD CPUs.",
      "description_length": 309,
      "index": 2,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Map.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for a map structure that associates keys with AMD extended feature flags from subleaf 0x7:0x0 (EBX) as defined in the AMD CPUID specification. It supports reading, writing, and measuring the binary representation of these feature flag maps, enabling efficient storage or transmission of CPU capability data. Concrete use cases include persisting CPU feature metadata to disk, sending it across a network, or caching it for later analysis.",
      "description_length": 502,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Map.Key",
      "library": "janestreet_cpuid",
      "description": "This module defines a key type for mapping based on AMD CPUID version and feature information flags from the EDX register. It provides serialization and deserialization functions to and from S-expressions and a comparator for ordering keys. It is used to organize and compare processor feature flags retrieved from CPUID leaf 0x1 on AMD CPUs.",
      "description_length": 342,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Map.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module provides a function `hash_fold_t` for folding a hash state over a map of Intel CPU feature flags retrieved from the EDX register of the CPUID instruction. It works with maps where values are of a generic type `'a` and keys correspond to specific CPU feature flags. A concrete use case is hashing sets of CPU features to generate unique identifiers for processor configurations.",
      "description_length": 389,
      "index": 5,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Map.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "This module defines a mapping between AMD CPUID extended feature flags (from subleaf 0, register EBX) and a user-specified key type, using S-expressions for serialization and deserialization. It provides the `t_of_sexp` function to construct such mappings from S-expressions, enabling structured interpretation of CPU feature bits. Concrete use cases include decoding specific AMD CPU features like precise cache flush support or performance optimizations directly from configuration or diagnostic data.",
      "description_length": 503,
      "index": 6,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Map.Diff",
      "library": "janestreet_cpuid",
      "description": "This module computes and applies differences between values derived from Intel CPUID version and feature information (EDX flags). It works with mapped structures that track changes between two states of a value derived from CPU feature flags. Concrete use cases include comparing CPU capabilities across different execution contexts or validating feature flag consistency during system initialization.",
      "description_length": 401,
      "index": 7,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Map.Key",
      "library": "janestreet_cpuid",
      "description": "This module defines keys for mapping over Intel CPU feature flags from the `Version_and_feature_information` leaf (EAX=0x1), specifically interpreting the EDX bits. It provides comparison and serialization functions for these keys, enabling use in maps and persistent data structures. Concrete use cases include querying and storing processor capability metadata, such as checking for SSE2 or HTT support.",
      "description_length": 405,
      "index": 8,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Set.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "This module parses S-expressions into a set of Intel CPUID feature flags from the ECX register. It specifically handles deserialization of feature flag values into a structured set representation. Use this when loading CPU feature constraints from configuration files or test data.",
      "description_length": 281,
      "index": 9,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Set.Diff",
      "library": "janestreet_cpuid",
      "description": "This module computes and applies differences between sets of AMD extended feature flags from CPUID leaf 0x7 subleaf 0x0, specifically tracking changes in the EBX register bits. It works with set-like structures representing enabled or disabled CPU features, allowing comparison and transformation of these sets using difference operations. Concrete use cases include analyzing CPU capability changes across different processors or configurations and applying feature set deltas to validate or simulate CPU compatibility.",
      "description_length": 520,
      "index": 10,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Set.Elt",
      "library": "janestreet_cpuid",
      "description": "This module represents individual flags from the ECX register when querying AMD's extended feature flags with CPUID leaf 0x7 and subleaf 0x0. It provides set operations and comparisons for these flags, enabling precise feature detection on AMD processors. Use it to check for specific CPU capabilities like advanced instruction sets or security features directly tied to AMD's implementation.",
      "description_length": 392,
      "index": 11,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Map.Diff",
      "library": "janestreet_cpuid",
      "description": "This module represents differences between Ebx feature flags in CPUID leaf 0x7, subleaf 0x0, specifically tracking changes in Intel CPU features such as AVX512, PKS, and other extended capabilities. It provides functions to serialize, deserialize, compute, and apply diffs between flag states, enabling precise tracking of feature enablement or disablement. Concrete use cases include comparing CPU capability snapshots across reboots or configurations and validating feature support transitions during system updates.",
      "description_length": 518,
      "index": 12,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Map.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "Implements hash folding for maps of AMD extended feature flags from subleaf 0x7/0x0 EBX. Works with keyed maps where each key corresponds to a specific CPU feature bit. Useful for hashing configurations of supported CPU features into a stable state for comparison or caching.",
      "description_length": 275,
      "index": 13,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Set.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for the set of AMD extended feature flags at subleaf 0x0. It works directly with the set type defined in the parent module, enabling precise storage and transmission of CPU feature support information. These operations are used when persisting or communicating CPU capability data across systems or for later analysis.",
      "description_length": 382,
      "index": 14,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Map.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for maps of AMD CPUID version and feature information flags, specifically those stored in the ECX register. It supports reading, writing, and measuring the size of these maps in binary format, using the Bin_prot library. Concrete use cases include persisting processor feature data to disk or transmitting it across a network in a compact, efficient format.",
      "description_length": 421,
      "index": 15,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Map.Key",
      "library": "janestreet_cpuid",
      "description": "This module defines keys for mapping AMD CPU feature flags from the extended feature flags subleaf 0 (ECX) into data structures like maps or sets. It provides serialization and deserialization to and from S-expressions, as well as a comparator for ordering keys. It is used when storing or comparing CPU feature configurations, such as tracking supported instruction sets or hardware capabilities across different AMD processors.",
      "description_length": 429,
      "index": 16,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Map.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for a map structure keyed by `Key`, where the values are `Edx_flags` from Intel's extended feature flags subleaf 0. It provides functions to compute binary size, read and write binary data, and define bin_prot readers and writers for the map type. This enables efficient storage or transmission of CPU feature flag mappings tied to specific keys.",
      "description_length": 410,
      "index": 17,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Set.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "Converts an S-expression into a set of AMD extended feature flags from CPUID leaf 0x7, subleaf 0x0, specifically interpreting the EBX register. Useful for deserializing CPU feature sets from structured text formats, enabling runtime CPU capability checks based on stored configurations.",
      "description_length": 286,
      "index": 18,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Set.Diff",
      "library": "janestreet_cpuid",
      "description": "This module computes and applies differences between sets of Intel CPU feature flags from the `Ebx_flags` register when CPUID leaf 0x7 and subleaf 0x0 are used. It works with set-based representations of CPU features to enable comparison and transformation of supported instruction sets and hardware capabilities. Use this module to detect, track, and apply changes in CPU feature support across different Intel processors.",
      "description_length": 423,
      "index": 19,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Set.Diff",
      "library": "janestreet_cpuid",
      "description": "This module computes and applies differences between sets of AMD extended feature flags from CPUID leaf 0x7 subleaf 0x0. It works with set-based representations of feature flags to derive additions and removals, enabling precise tracking of feature support changes between different CPU configurations. Use this module to compare and migrate CPU feature sets in deployment validation or hardware compatibility checks.",
      "description_length": 417,
      "index": 20,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Map.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module implements a hashing function for maps of Intel CPU feature flags from the extended feature flags subleaf 0 (ECX). It provides `hash_fold_t` to combine the hash state of keys and their associated feature flag values. Use this module when needing to hash sets of supported CPU features for equality or as part of larger hash-based data structures.",
      "description_length": 358,
      "index": 21,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Set.Elt",
      "library": "janestreet_cpuid",
      "description": "This module defines individual flag elements for the EBX register of the CPUID leaf 0x7 subleaf 0x0, specifically for Intel processors. It provides set operations to work with these flags, enabling precise feature detection such as support for AVX512, UMIP, and MPX. These flags are used to determine availability of advanced CPU features directly at runtime without relying on external system information.",
      "description_length": 406,
      "index": 22,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Set.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module implements hash functions for sets of AMD CPUID feature flags, specifically those found in the EDX register for leaf 0x1. It provides `hash_fold_t` and `hash` to compute hash values for these feature sets. Useful in scenarios requiring hashing of CPU feature combinations, such as caching or comparing supported processor capabilities.",
      "description_length": 347,
      "index": 23,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Map.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "This module defines a function `t_of_sexp` that constructs a map from S-expressions, specifically parsing keys into a structured map representation. It operates on S-expressions and produces values of a map type where keys are parsed using a provided conversion function. A typical use case is deserializing AMD CPUID ECX flag data from S-expression format into a typed map for inspection or configuration.",
      "description_length": 406,
      "index": 24,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Set.Diff",
      "library": "janestreet_cpuid",
      "description": "This module computes and applies differences between sets of AMD CPUID feature flags from the EDX register of leaf 0x1. It supports operations to derive, apply, and serialize diffs between two sets of feature flags, enabling comparison and transformation of CPU capabilities. Concrete use cases include analyzing CPU feature discrepancies between systems or validating CPU compatibility based on supported features.",
      "description_length": 415,
      "index": 25,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Map.Key",
      "library": "janestreet_cpuid",
      "description": "This module defines a key type for mapping over Intel CPU feature flags from the EDX register of CPUID leaf 0x7, subleaf 0x0. It includes serialization functions to and from S-expressions and a comparator for use in map structures. It is used to query and organize support for specific CPU features such as AVX512 and MPX on Intel processors.",
      "description_length": 342,
      "index": 26,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Set.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module implements hash functions for sets of AMD extended feature flags extracted from CPUID leaf 0x7, subleaf 0x0. It provides `hash_fold_t` and `hash` to compute hash values for these sets, enabling their use in hash-based data structures like hash tables. The operations are specifically designed to work with the `Set.t` type from the `Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags` module.",
      "description_length": 406,
      "index": 27,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Map.Key",
      "library": "janestreet_cpuid",
      "description": "This module defines keys for mapping based on the EBX feature flags from CPUID leaf 0x7, subleaf 0x0, which expose specific Intel CPU features such as support for AVX512, PKU, and GFNI. It provides comparison and serialization functions (t_of_sexp, sexp_of_t) for use in associative data structures like maps. It is used to build and query feature-specific data structures keyed by these CPU feature flags.",
      "description_length": 406,
      "index": 28,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Set.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module implements hash functions for sets of Intel extended feature flags from subleaf 0x0 of CPUID leaf 0x7. It provides `hash_fold_t` and `hash` functions to compute hash values for these flag sets, enabling their use in hash-based data structures. The module works specifically with sets of flags indicating optional CPU features such as AVX512 support, which are relevant for runtime CPU capability detection and feature-specific code paths.",
      "description_length": 450,
      "index": 29,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Map.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for a map structure that associates keys with Intel CPU feature flags from leaf 0x7, subleaf 0x0. It supports reading, writing, and measuring the size of these maps in binary format, specifically for use with types that represent CPU feature sets. The module is used to persist or transmit CPU capability data efficiently in binary form, such as in system profiling or configuration tools.",
      "description_length": 453,
      "index": 30,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Map.Diff",
      "library": "janestreet_cpuid",
      "description": "This module represents differences between CPU feature flag configurations derived from Intel's CPUID instruction, specifically for subleaf 0 of leaf 0x7. It supports operations to compute, apply, and serialize diffs between feature flag states, working with arbitrary data types that represent CPU features. Concrete use cases include tracking changes in CPU capabilities across different execution environments or validating compatibility between systems based on specific feature support.",
      "description_length": 491,
      "index": 31,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Map.Diff",
      "library": "janestreet_cpuid",
      "description": "This module computes and applies differences between AMD CPUID version and feature information flags, specifically for the EDX register. It supports operations to serialize, deserialize, and compare flag states across different CPU configurations. Concrete use cases include analyzing processor capability changes between systems or validating CPU feature consistency during migration or testing.",
      "description_length": 396,
      "index": 32,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Set.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "This module parses S-expressions into sets of AMD CPUID feature flags from the ECX register at leaf 0x1. It specifically converts `Sexplib0.Sexp.t` values to `Cpuid.Amd.Version_and_feature_information.Ecx_flags.Set.t` values, representing features like SSE3 support or CMP_SSE3. Use this when deserializing AMD CPU feature sets from S-expression formatted data, such as configuration files or persisted states.",
      "description_length": 410,
      "index": 33,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Set.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for a set of AMD extended feature flags from CPUID leaf 0x7 subleaf 0x0. It operates directly on the set type derived from those flags, enabling precise storage and transmission of CPU feature capabilities. Concrete use cases include persisting CPU feature sets across sessions or sending them over a network for remote system analysis.",
      "description_length": 400,
      "index": 34,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Set.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module hashes sets of AMD extended feature flags from CPUID leaf 0x7, subleaf 0x0, specifically the EBX bitfield. It provides `hash_fold_t` and `hash` functions to compute hash values for these flag sets. Use this when you need to uniquely identify or compare CPU feature configurations related to AMD-specific extensions like CLZERO, RDPID, or MCOMMIT.",
      "description_length": 358,
      "index": 35,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Map.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "This module parses S-expressions into maps of AMD CPUID feature flags, specifically for the EDX register at leaf 0x1. It supports deserializing keyed flag values into structured maps tied to AMD processor features. Use this when loading CPU feature configurations from S-expression-based files or streams.",
      "description_length": 305,
      "index": 36,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Set.Elt",
      "library": "janestreet_cpuid",
      "description": "This module defines individual elements of a set derived from the EDX register flags obtained from the CPUID instruction's leaf 0x1 on AMD processors. It provides functions to convert these flag values to and from S-expressions and uses a comparator for ordering based on the underlying flag values. It is used to represent and manipulate specific CPU feature bits, such as presence of MMX or 3DNow! support, directly from raw CPUID results.",
      "description_length": 441,
      "index": 37,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Set.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module implements hash functions for sets of Intel CPU feature flags from the `Cpuid` instruction's extended feature subleaf 0. It provides `hash_fold_t` and `hash` functions to compute hash values for these sets, enabling their use in hash-based data structures like hash tables. The module works directly with the `Set.t` type representing CPU feature flags, specifically for hashing purposes.",
      "description_length": 400,
      "index": 38,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Set.Elt",
      "library": "janestreet_cpuid",
      "description": "This module defines individual elements of a set used to represent AMD CPUID feature flags from the ECX register of leaf 0x1. It includes serialization and deserialization functions for converting between S-expressions and flag values, and provides a comparator for ordering elements. It is used to inspect and manipulate specific processor features such as SSE3 support or APIC availability directly from the CPUID instruction's output.",
      "description_length": 437,
      "index": 39,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Set.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for a set of Intel CPU feature flags retrieved from CPUID leaf 0x7 with ECX=0x0. It works directly with the `Set.t` type representing bitflags, enabling precise storage and transmission of supported CPU features. Concrete use cases include persisting CPU capability checks for later analysis or across system restarts, and exchanging feature data between processes or over networks.",
      "description_length": 446,
      "index": 40,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Map.Key",
      "library": "janestreet_cpuid",
      "description": "This module defines keys for mapping over Intel CPUID version and feature information flags stored in the ECX register. It provides comparison and serialization functions for these keys, enabling efficient lookups and structured data handling. Use this module when working with processor feature flags retrieved via the CPUID instruction on Intel CPUs.",
      "description_length": 352,
      "index": 41,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Map.Key",
      "library": "janestreet_cpuid",
      "description": "This module defines keys for mapping over Intel CPU feature flags from the `0x7:0x0` subleaf, specifically interpreting the ECX register output. It provides comparison and serialization functions for these keys, enabling their use in associative data structures like maps. Concrete use cases include querying and organizing CPU capabilities such as support for AVX512, MPX, or SGX extensions.",
      "description_length": 392,
      "index": 42,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Map.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for maps where values are keyed by AMD CPUID feature flags from the EDX register of leaf 0x1. It provides functions to compute binary shape, size, and perform reading and writing operations on these maps. Use this module when persisting or transmitting AMD feature flag map data in binary format, such as saving processor capabilities to disk or sending them across a network.",
      "description_length": 440,
      "index": 43,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Map.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module implements a hashing function for maps of AMD extended feature flags associated with subleaf 0 of leaf 0x7. It works with keyed maps where each key corresponds to a specific AMD CPU feature flag, and the values represent their presence or configuration. It is used to efficiently compute hash values for these maps, enabling their use in hash-based data structures like hash tables or sets when tracking supported CPU features.",
      "description_length": 439,
      "index": 44,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Set.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "This module parses S-expressions into a set of Intel CPUID feature flags from the EDX register when EAX=0x1. It works with `Sexplib0.Sexp.t` input and produces a typed set structure representing enabled CPU features. Use this when deserializing CPU feature sets from configuration files or test data for precise hardware capability checks.",
      "description_length": 339,
      "index": 45,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Set.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "This module defines a function `t_of_sexp` that parses an S-expression into a set of AMD extended feature flags from CPUID leaf 0x7, subleaf 0x0. It operates on the `Sexplib0.Sexp.t` input type and returns a set type specific to the ECX register flags for that subleaf. Use this module when deserializing AMD CPU feature flag sets from S-expressions, such as when loading configuration or test data.",
      "description_length": 399,
      "index": 46,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Set.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module provides hash folding and hashing functions for sets of Intel CPUID feature flags from the ECX register. It enables computing hash values for sets of CPU features, such as SSE3 or POPCNT support, retrieved via the CPUID instruction. Use this when hashing CPU feature sets for caching, comparison, or fingerprinting purposes.",
      "description_length": 336,
      "index": 47,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Set.Elt",
      "library": "janestreet_cpuid",
      "description": "This module defines individual elements of a set representing Intel CPU feature flags from the EDX register when querying CPUID leaf 0x1. It includes functions to convert these elements to and from S-expressions and provides a comparator for ordering them. These flags represent specific hardware capabilities such as SSE support or presence of a floating-point unit.",
      "description_length": 367,
      "index": 48,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Set.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for sets of AMD CPUID feature flags found in the EDX register when CPUID leaf 0x1 is used. It directly works with the set type defined in `Cpuid.Amd.Version_and_feature_information.Edx_flags.Set`, enabling precise storage or transmission of detected processor capabilities. Use this when persisting or communicating supported CPU features across different processes or systems.",
      "description_length": 441,
      "index": 49,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Set.Diff",
      "library": "janestreet_cpuid",
      "description": "This module computes and applies differences between sets of Intel CPU feature flags from the EDX register at subleaf 0x7, leaf 0x0. It works with set-like structures representing CPU feature states, enabling comparison and transformation of feature sets. Use this module to determine added or removed features between two CPU states or to apply such changes programmatically.",
      "description_length": 376,
      "index": 50,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Map.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module implements a hashing function for maps of Intel CPU feature flags from the extended feature flags subleaf 0 (EAX=0x7, ECX=0x0), specifically targeting the EBX register. It allows computing hash values for keys representing CPU features, such as AVX512 or SGX support, enabling efficient use of these flags in hash-based data structures. A concrete use case includes tracking supported CPU features across a heterogeneous fleet for binary deployment decisions.",
      "description_length": 471,
      "index": 51,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Set.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module implements hash functions for sets of AMD CPUID feature flags from the ECX register. It provides `hash_fold_t` and `hash` to compute hash values for a set of features, using the Base.Hash library. This is used when sets of specific AMD processor capabilities need to be stored in hash tables or compared efficiently.",
      "description_length": 328,
      "index": 52,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Map.Key",
      "library": "janestreet_cpuid",
      "description": "This module defines keys for mapping AMD CPU feature flags from the EBX register of CPUID leaf 0x7, subleaf 0x0. It provides serialization to and from S-expressions and a comparator for use in map structures. It is used to represent and compare specific AMD CPU features such as support for RDSEED, SHA extensions, and other advanced instruction sets.",
      "description_length": 351,
      "index": 53,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Map.Diff",
      "library": "janestreet_cpuid",
      "description": "This module computes and applies differences between values derived from Intel CPUID leaf 0x1 ECX feature flags. It supports operations to get, apply, and serialize diffs for structured data built from these flags. Concrete use cases include tracking changes in CPU feature sets across system configurations or comparing processor capabilities between machines.",
      "description_length": 361,
      "index": 54,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Set.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for the `Cpuid.Amd.Version_and_feature_information.Ecx_flags.Set.t` type, which represents a set of CPU feature flags from the ECX register of the AMD CPUID instruction. It provides functions to compute binary size, read and write values in binary format, and define the binary shape and type class instances. This enables efficient storage or transmission of processor feature sets retrieved from CPUID leaf 0x1.",
      "description_length": 477,
      "index": 55,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Map.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module provides a function `hash_fold_t` for computing hash values of maps containing AMD CPUID feature flags from the EDX register. It operates on maps where values represent individual flag states, enabling efficient hashing of processor feature sets. Use this to generate consistent hash signatures for CPU feature configurations, such as when caching or comparing supported instruction sets.",
      "description_length": 400,
      "index": 56,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Map.Diff",
      "library": "janestreet_cpuid",
      "description": "This module represents differences between values derived from Intel CPUID leaf 0x7 subleaf 0x0 EDX feature flags. It supports operations to construct, serialize, and apply diffs to values representing CPU feature states, specifically tied to the `derived_on` type that captures CPUID-derived data. Concrete use cases include comparing and applying incremental changes to CPU feature flag configurations across different Intel processors.",
      "description_length": 438,
      "index": 57,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Set.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module implements hash functions for sets of Intel CPU feature flags retrieved from the EDX register of the CPUID instruction's leaf 0x1. It provides `hash_fold_t` and `hash` functions to compute hash values for these feature sets. Useful for caching or comparing processor feature configurations across systems.",
      "description_length": 317,
      "index": 58,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Map.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "This module defines a mapping for AMD CPUID extended feature flags from subleaf 0 when ECX is provided, specifically parsing values from S-expressions. It operates on a key-value structure where keys correspond to specific CPUID feature bits and values are typed representations of those flags. It is used to interpret low-level CPU feature information retrieved via the CPUID instruction on AMD processors, enabling feature detection for advanced CPU capabilities.",
      "description_length": 465,
      "index": 59,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Set.Elt",
      "library": "janestreet_cpuid",
      "description": "This module defines operations for working with individual flags in the EBX register of the AMD CPUID extended feature flags subleaf 0. It provides functions to convert flag values to and from S-expressions and a comparator for ordering flag elements. It is used to inspect and manipulate specific CPU feature bits returned by the CPUID instruction on AMD processors.",
      "description_length": 367,
      "index": 60,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Set.Elt",
      "library": "janestreet_cpuid",
      "description": "This module defines individual flag elements for the ECX register in CPUID leaf 0x7 subleaf 0x0, specifically supporting operations to convert between S-expressions and flag values, and providing a comparator for ordering these flags. It works with the `t` type representing each flag and a `comparator_witness` for comparison logic. Concrete use cases include parsing and serializing CPU feature flags for analysis or configuration in low-level system tools.",
      "description_length": 459,
      "index": 61,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Map.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "This module parses S-expressions into a map of Intel CPU feature flags from the EDX register of CPUID leaf 0x7 subleaf 0x0. It supports deserializing flag values keyed by identifiers defined in the `Key` module, mapping each key to its corresponding boolean feature state. Use this when loading CPU feature configurations from S-exp-based files or embedded data for runtime CPU capability checks.",
      "description_length": 396,
      "index": 62,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Map.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for maps of Intel CPUID version and feature information flags stored in the ECX register. It supports reading, writing, and measuring the binary representation of these maps, enabling efficient storage or transmission of processor feature data. Concrete use cases include persisting CPU capability fingerprints or exchanging them across process boundaries in a binary protocol.",
      "description_length": 441,
      "index": 63,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Map.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module implements a hashing function for Intel CPU feature flag maps derived from CPUID leaf 0x7, subleaf 0x0, specifically targeting the EDX register. It works with maps where keys are feature flags and values are of a generic type `'a`, enabling efficient hash-based comparisons or storage. Concrete use cases include fingerprinting CPU capabilities for runtime dispatch or configuration decisions based on supported features.",
      "description_length": 433,
      "index": 64,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Set.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module implements hash functions for sets of Intel extended feature flags from subleaf 0x7/0x0, specifically handling the EBX register bits. It provides `hash_fold_t` and `hash` functions to compute hash values for these flag sets. Use this module when you need to hash CPU feature flag configurations for caching or equality checks.",
      "description_length": 338,
      "index": 65,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Set.Diff",
      "library": "janestreet_cpuid",
      "description": "This module computes and applies differences between sets of Intel CPU feature flags from the ECX register of CPUID leaf 0x7, subleaf 0x0. It supports operations to derive a diff between two sets of flags, apply a diff to reconstruct a set, and serialize diffs to and from S-expressions. Use this when comparing or synchronizing CPU feature capabilities across systems or configurations, such as in virtualization, hardware detection, or feature-based runtime dispatch.",
      "description_length": 469,
      "index": 66,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Set.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "Converts S-expressions into sets of Intel CPU feature flags from the extended feature flags subleaf 0 (leaf 0x7, ECX=0x0). Works directly with `Sexplib0.Sexp.t` and produces values of type `Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Set.t`. Used to deserialize CPU feature flag data for runtime CPU capability checks.",
      "description_length": 329,
      "index": 67,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Set.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "Converts S-expressions into sets of Intel CPU feature flags from the extended feature flags subleaf 0 (EAX=0x7, ECX=0x0). Works with `Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Set.t` and S-expressions. Used to parse CPU feature flag data from serialized configurations or test inputs.",
      "description_length": 297,
      "index": 68,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Set.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for sets of Intel CPU feature flags from the `Cpuid` leaf 0x7 subleaf 0x0 EDX register. It works directly with the `Set.t` type representing CPU feature flags, enabling precise storage and transmission of supported CPU features. Concrete use cases include persisting CPU capability information across sessions or sharing it between processes in a binary format.",
      "description_length": 425,
      "index": 69,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Set.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "This module parses S-expressions into sets of AMD CPUID feature flags from the EDX register at leaf 0x1. It works with `Sexplib0.Sexp.t` input and produces `Set.t` values representing enabled features. Use it to deserialize AMD-specific CPU feature data stored in S-expression format.",
      "description_length": 284,
      "index": 70,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Map.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for a map structure that associates keys with AMD extended feature flags from subleaf 0x0 of leaf 0x7. It supports reading and writing map values in binary format, including size calculation and direct memory manipulation. Use this when persisting or transmitting AMD CPU feature flag data across systems or for offline analysis.",
      "description_length": 393,
      "index": 71,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Set.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "Converts S-expressions into sets of Intel CPU feature flags from the extended feature flags subleaf 0 (ECX=0). Works directly with `Sexplib0.Sexp.t` and `Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Set.t`. Used to parse and deserialize CPU feature flag data during system initialization or feature detection.",
      "description_length": 319,
      "index": 72,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Set.Diff",
      "library": "janestreet_cpuid",
      "description": "This module computes and applies differences between sets of Intel CPUID feature flags from the ECX register of leaf 0x1. It supports operations to derive the difference between two sets of flags, apply a computed difference to a base set, and construct differences from lists of flag changes. Use this module when comparing or transforming CPU feature sets across different Intel processors, such as tracking enabled features during system configuration or migration.",
      "description_length": 468,
      "index": 73,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Set.Elt",
      "library": "janestreet_cpuid",
      "description": "This module defines operations for working with individual flags in the EDX register of the Intel CPUID leaf 0x7 subleaf 0x0, specifically providing set element functionality. It supports enumeration and comparison of flags related to advanced CPU features such as AVX512 and SGX. Use this module to query and manipulate specific CPU feature bits returned by the CPUID instruction on Intel processors.",
      "description_length": 401,
      "index": 74,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Map.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "Converts S-expressions into maps of Intel CPUID version and feature information flags, specifically for values extracted from the ECX register when EAX=0x1. Works with key modules to parse and map individual flag values from serialized data. Useful for deserializing CPU feature sets from configuration files or logs into structured maps for runtime inspection or analysis.",
      "description_length": 373,
      "index": 75,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Map.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "This module implements hash folding for maps of AMD CPUID version and feature information flags, specifically keyed by the `Key` module. It provides the `hash_fold_t` function to combine the hash state of a map's contents into a single hash state. This supports efficient hashing of processor feature configurations retrieved from the CPUID instruction's EAX=0x1 leaf.",
      "description_length": 368,
      "index": 76,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Set.Elt",
      "library": "janestreet_cpuid",
      "description": "This module represents individual flags from the ECX register returned by the CPUID instruction when EAX is 0x1, specifically for Intel processors. It provides set operations and comparisons for these flags, enabling precise feature detection such as support for SSE3, PCLMULQDQ, or RDTSCP. Use cases include runtime CPU feature checks to enable or disable optimized code paths based on available instruction sets.",
      "description_length": 414,
      "index": 77,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Set.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for the `Ebx_flags.Set.t` type, which represents Intel CPU feature flags from leaf 0x7, subleaf 0x0. It provides direct `bin_read`, `bin_write`, and `bin_size` operations for efficient storage and transmission of these flag sets. Use this module when persisting or communicating CPU capability data across processes or machines.",
      "description_length": 392,
      "index": 78,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Set.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for sets of Intel CPUID version and feature information flags from the ECX register. It provides functions to compute size, write, and read these flag sets in binary format, enabling efficient storage or transmission of processor capability data. Concrete use cases include persisting CPU feature sets to disk or sending them over a network in a compact, structured way.",
      "description_length": 434,
      "index": 79,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Map.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "This module defines a mapping between CPUID extended feature flag bit positions and symbolic names, specifically for parsing and interpreting the ECX register output of the CPUID instruction's subleaf 0x7, ECX=0x0. It provides a function `t_of_sexp` that deserializes a sexp representation of these flags into a structured map, using a provided conversion function for the underlying flag type. The module is used to translate raw CPU feature bits into human-readable and machine-processable identifiers for Intel CPU features such as AVX512, PKU, and others.",
      "description_length": 559,
      "index": 80,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Set.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for sets of Intel CPUID feature flags found in the EDX register when EAX=0x1. It provides functions to compute size, write, and read these sets in binary format, using Bin_prot. Useful for persisting or transmitting processor feature information efficiently.",
      "description_length": 322,
      "index": 81,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Map.Diff",
      "library": "janestreet_cpuid",
      "description": "This module represents differences between versions of AMD CPUID ECX feature flag maps, tracking changes to specific feature flags across CPU generations. It provides functions to serialize and deserialize diffs, extract differences between specific feature sets, apply diffs to base configurations, and construct diffs from lists of changes. It works directly with AMD-specific CPU feature data structures to model incremental updates to processor capabilities.",
      "description_length": 462,
      "index": 82,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Map.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module implements binary serialization and deserialization for maps of Intel CPU feature flags from the Extended Feature Flags subleaf 0 (ECX=0x0) in leaf 0x7 of the CPUID instruction. It operates on keyed maps where keys are parameterized and values represent specific CPU feature bits. Concrete use cases include persisting or transmitting CPU capability data across systems or sessions, such as in hardware introspection tools or configuration management.",
      "description_length": 463,
      "index": 83,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Set.Diff",
      "library": "janestreet_cpuid",
      "description": "This module computes and applies differences between sets of AMD CPUID feature flags from the ECX register of leaf 0x1. It supports operations to derive a diff between two sets of flags, apply a diff to a set, and construct diffs from lists. Use this module to programmatically analyze or transform AMD-specific CPU feature capabilities, such as tracking changes between different processor models or configurations.",
      "description_length": 416,
      "index": 84,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Set.Diff",
      "library": "janestreet_cpuid",
      "description": "This module computes and applies differences between sets of Intel CPUID version and feature flags from the EDX register. It works with set-like structures representing CPU feature flags, enabling precise comparison and transformation of feature sets between two states. Use this to detect added or removed features between CPU configurations or validate expected changes after system updates.",
      "description_length": 393,
      "index": 85,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Map.Provide_of_sexp",
      "library": "janestreet_cpuid",
      "description": "Implements parsing of Intel CPUID extended feature flags (subleaf 0, ECX=0) from S-expressions into a map structure. Works with `Sexplib0.Sexp.t` input and constructs a map of feature flags tied to the specific CPUID leaf 0x7 subleaf 0 context. Used to deserialize feature flag data for runtime CPU capability checks from configuration or test files.",
      "description_length": 350,
      "index": 86,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Map.Diff",
      "library": "janestreet_cpuid",
      "description": "This module represents differences between two states of AMD extended feature flags (ECX register) when subleaf 0 is used with CPUID leaf 0x7. It provides functions to serialize, deserialize, compare, and apply changes to these flag states, specifically tracking optional differences in derived data. Concrete use cases include analyzing CPU feature support changes between system configurations or validating compatibility of AMD-specific features like SME, SEV, or virtualization extensions across reboots or migrations.",
      "description_length": 522,
      "index": 87,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Map.Provide_bin_io",
      "library": "janestreet_cpuid",
      "description": "This module provides binary serialization and deserialization functions for maps of Intel CPU feature flags found in the EDX register when CPUID leaf 0x1 is queried. It supports reading, writing, and measuring the size of these maps in binary format, using the Bin_prot library. Concrete use cases include persisting or transmitting processor feature information across systems or sessions.",
      "description_length": 390,
      "index": 88,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Map.Provide_hash",
      "library": "janestreet_cpuid",
      "description": "Implements hash folding for maps of Intel CPU feature flags retrieved from the ECX register when CPUID is called with EAX=0x1. Works directly with map values keyed by `Cpuid.Intel.Version_and_feature_information.Ecx_flags` variants. Enables hashing of these maps for use in equality checks, persistent storage, or keyed lookups tied to specific CPU features.",
      "description_length": 358,
      "index": 89,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Map",
      "library": "janestreet_cpuid",
      "description": "This module organizes map operations around AMD CPUID ECX feature identifiers, enabling creation, transformation, and comparison of keyed structures that represent processor capabilities. It provides direct access to operations for merging sequences into maps, handling duplicates, and serializing or hashing map contents, with keys defined by the Key module representing specific CPU feature flags. The Bin module supports binary encoding for storage or transmission, while the Diff module tracks and applies changes between feature flag versions. A user can parse a map from an S-expression using the Sexp module, fold its hash state for comparison, or serialize the result to disk in binary format.",
      "description_length": 701,
      "index": 90,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Unstable",
      "library": "janestreet_cpuid",
      "description": "This module defines low-level access to the EDX flags from the CPUID instruction's version and feature information leaf (EAX=0x1) on Intel processors. It provides functions for serializing, deserializing, comparing, and converting these flags to and from S-expressions, enabling both persistent storage and structured analysis of CPU capabilities. Concrete use cases include runtime CPU feature detection for enabling hardware-specific optimizations and ensuring compatibility with instruction set extensions.",
      "description_length": 509,
      "index": 91,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Set",
      "library": "janestreet_cpuid",
      "description": "This module manages sets of Intel CPU feature flags from CPUID leaf 0x7 subleaf 0, supporting operations like union, intersection, and conversion from lists, arrays, and hash tables. It provides core data types including `Elt.t` for individual flags and `t` for sets, with runtime detection, S-expression serialization, and Quickcheck support. Submodules handle hashing, differencing, binary and S-expression serialization, and direct flag manipulation, enabling tasks like comparing CPU feature states, persisting capability data, and validating instruction support across platforms. Examples include checking AVX512 availability, applying feature deltas between CPUs, and serializing detected features for inter-process communication.",
      "description_length": 736,
      "index": 92,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Map",
      "library": "janestreet_cpuid",
      "description": "This module manages mappings between keys and AMD CPUID extended feature flags from subleaf 0x7:0x0 (EBX), offering operations to create, compare, hash, and serialize these mappings. It supports computing differences between feature sets, applying those differences to base states, and persisting or transmitting flag configurations in binary or S-expression format. You can decode CPU features like SME, SEV, RDSEED, and SHA extensions from structured data, hash feature sets for caching, or track and apply changes across CPU states. Submodules handle serialization, difference computation, and key definitions, enabling use cases such as CPU capability analysis, configuration persistence, and feature comparison.",
      "description_length": 716,
      "index": 93,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Set",
      "library": "janestreet_cpuid",
      "description": "This module manages sets of AMD CPUID extended feature flags from leaf 0x7 subleaf 0x0, supporting standard set operations like union, intersection, and difference, along with transformations, serialization, and hashing. It works with individual flags (Elt.t) representing EBX register bits, enabling precise CPU feature modeling for system software validation, compatibility checks, and testing. Submodules handle set differencing, S-expression and binary (de)serialization, hashing, and flag-level manipulation, allowing tasks like comparing CPU capabilities across systems, storing feature sets persistently, or inspecting specific features such as CLZERO or RDPID. Example uses include validating runtime CPU support for security features, simulating CPU compatibility through delta application, and generating unique identifiers for feature configurations.",
      "description_length": 861,
      "index": 94,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Set",
      "library": "janestreet_cpuid",
      "description": "This module manages sets of Intel CPU EDX feature flags from CPUID leaf 0x1, supporting operations like union, mapping, filtering, and difference computation to represent and manipulate processor capabilities. It provides direct conversions from lists, arrays, and maps, along with serialization through S-expressions, binary I/O, and hash functions for storage, transmission, or comparison of feature sets across systems. The module's submodules handle parsing from S-expressions, individual flag definitions, binary serialization, and set differencing, enabling use cases such as hardware capability checks from config files, caching of feature sets via hashing, and validation of CPU feature changes after system updates.",
      "description_length": 724,
      "index": 95,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Replace_polymorphic_compare",
      "library": "janestreet_cpuid",
      "description": "This module defines comparison operations and ordering functions for the `Edx_flags.t` type, enabling direct comparisons between CPU feature flag sets retrieved from AMD processors. It includes standard comparison operators (`<`, `>`, `=`, etc.) and utilities like `min` and `max` to determine relative feature support levels. These functions are used to evaluate and compare the presence or absence of specific CPU features reported in the EDX register for AMD CPUs.",
      "description_length": 467,
      "index": 96,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Set",
      "library": "janestreet_cpuid",
      "description": "This module manages sets of Intel CPU feature flags from the ECX register of CPUID leaf 0x1, offering operations such as union, intersection, filtering, and difference computation to enable precise feature detection and compatibility checks. It includes utilities for parsing S-expressions, binary serialization, hashing, and computing differences between feature sets, supporting tasks like runtime feature verification, caching, and system migration tracking. The module works with individual flags such as SSE3, POPCNT, and RDTSCP, and provides structured representations for efficient manipulation and persistence across environments. Use it to validate hardware capabilities, generate test constraints, or serialize CPU state for storage and transmission.",
      "description_length": 760,
      "index": 97,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Map",
      "library": "janestreet_cpuid",
      "description": "This module provides a functional interface for managing Intel CPU feature flags from CPUID leaf 0x7, subleaf 0x0, supporting operations like folding, filtering, and conversion from sequences, lists, and hashtables. It works with keys representing individual feature bits and associated values, offering utilities for error handling, QuickCheck-based testing, and S-expression serialization, while submodules handle hashing, binary serialization, diffing, key definitions, and symbolic name mapping. Use it to query, compare, and persist CPU capabilities such as AVX512, MPX, or SGX in a type-safe, functional way, with support for equality checks, binary storage, and structured diffs between feature sets.",
      "description_length": 707,
      "index": 98,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Replace_polymorphic_compare",
      "library": "janestreet_cpuid",
      "description": "This module defines comparison operations and ordering functions for the `Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.t` type, which represents CPU feature flags from the Intel CPUID instruction's subleaf 0x7:0x0. It enables direct value comparisons using standard operators like `=`, `<`, `>`, and functions like `compare`, `min`, and `max`. These operations support precise feature flag analysis and selection based on CPU capabilities, such as checking for specific instruction set support or hardware features.",
      "description_length": 525,
      "index": 99,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Replace_polymorphic_compare",
      "library": "janestreet_cpuid",
      "description": "This module defines comparison operators and ordering functions for the `Edx_flags.t` type, enabling direct comparisons between CPU feature flag values. It supports operations like equality checks, relational comparisons, and min/max determination on Intel CPU feature sets retrieved from the CPUID instruction's extended feature flags subleaf 0. These functions are used when analyzing or validating supported CPU features against specific hardware capabilities.",
      "description_length": 463,
      "index": 100,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Set",
      "library": "janestreet_cpuid",
      "description": "This module manages sets of Intel CPU feature flags from CPUID leaf 0x7, subleaf 0x0, enabling construction, transformation, and analysis of CPU capabilities such as instruction sets and security features. It supports standard set operations like filtering, mapping, and deduplication, along with conversion from maps and serialization via Sexp, Bin_io, and Hash. The module integrates submodules for hashing, binary I/O, flag definitions, diffing, and S-expression conversion, allowing tasks like persisting CPU feature sets, comparing capabilities across systems, or validating hardware support at runtime. For example, it can serialize a set of supported flags to disk, compute the difference between two CPU profiles, or hash a feature set for use in a hash table.",
      "description_length": 768,
      "index": 101,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Unstable",
      "library": "janestreet_cpuid",
      "description": "This module defines low-level flags from the EBX register of the CPUID instruction's extended feature flags subleaf 0 on Intel processors, enabling direct inspection of CPU capabilities such as support for specific instruction sets or architectural features. It operates on a custom bitfield type `t` that maps to individual CPUID feature bits, allowing serialization, comparison, and parsing via `Bin_prot` and `Sexplib0`. Concrete use cases include runtime CPU feature detection for optimized code paths and compatibility checks in system-level applications.",
      "description_length": 560,
      "index": 102,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Unstable",
      "library": "janestreet_cpuid",
      "description": "This module defines low-level AMD CPU feature flags accessible via the CPUID instruction with leaf 0x7 and subleaf 0x0. It exposes individual flags indicating support for specific AMD processor features, such as advanced instruction sets and hardware capabilities. These flags are used to detect and utilize optional CPU features at runtime, particularly for performance optimization and feature-specific code paths.",
      "description_length": 416,
      "index": 103,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Set",
      "library": "janestreet_cpuid",
      "description": "This module manages sets of AMD CPUID feature flags from the EDX register of leaf 0x1, providing core operations for set manipulation alongside specialized functionality in its submodules. It supports hashing, comparison, serialization, and S-expression conversion of CPU feature sets, enabling tasks like caching, diffing, and cross-system communication of processor capabilities. Concrete operations include computing hash values, deriving and applying set differences, and converting raw flag data to and from structured formats. Submodules enhance these capabilities with precise serialization, S-expression parsing, and feature-level ordering, making it possible to analyze, store, and compare CPU features like MMX or 3DNow! support directly from CPUID results.",
      "description_length": 767,
      "index": 104,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Map",
      "library": "janestreet_cpuid",
      "description": "This module manages mappings between Intel CPUID feature flags (from EDX in leaf 0x1) and arbitrary values, enabling structured analysis of CPU capabilities. It supports operations like insertion, comparison, and transformation, with keys representing specific feature bits such as SSE2 or HTT. Child modules extend functionality to serialization in binary and S-expression formats, hashing, and computing differences between feature sets. These tools facilitate tasks like validating processor features across environments or generating unique identifiers for CPU configurations.",
      "description_length": 580,
      "index": 105,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Map",
      "library": "janestreet_cpuid",
      "description": "This module manages mappings between Intel CPUID ECX feature flags and arbitrary values, offering operations for conversion, transformation, and iteration over structured CPU feature data. It supports key-based lookups, difference computation, and both binary and S-expression serialization, enabling analysis, comparison, and persistence of processor capabilities. Functional utilities allow mapping over flag sets, merging feature data, and error-resilient construction of maps from external inputs. Submodules handle key definitions, diffing, binary encoding, S-expression parsing, and hashing, providing a complete toolkit for working with CPU feature sets across different representations and use cases.",
      "description_length": 708,
      "index": 106,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Replace_polymorphic_compare",
      "library": "janestreet_cpuid",
      "description": "This module defines comparison operators and ordering functions for the `Ebx_flags` type representing Intel CPUID extended feature flags. It supports direct comparisons between flag values using standard operators like `(<)`, `(>)`, and `(=)`, as well as utilities like `min` and `max` to determine flag precedence. These operations are specifically used when evaluating or sorting CPU feature sets based on the EBX register output of the CPUID instruction at subleaf 0 of leaf 0x7.",
      "description_length": 482,
      "index": 107,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Map",
      "library": "janestreet_cpuid",
      "description": "This module organizes AMD CPUID feature flags from EDX register values into structured maps, enabling analysis, transformation, and serialization of CPU capabilities. It supports keyed access to features like SSE and AVX, with operations to construct maps from sequences, detect duplicates, and apply transformations, while submodules handle S-expression and binary serialization, diffing of flag states, and hash computation. You can load CPU feature configurations from S-expressions, compare feature sets across systems, persist maps to disk, or generate hash signatures for instruction set profiles.",
      "description_length": 603,
      "index": 108,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Unstable",
      "library": "janestreet_cpuid",
      "description": "This module defines low-level bit flags from the EDX register of the CPUID instruction's subleaf 0 of leaf 0x7, representing optional Intel CPU features such as AVX512 and CLWB support. It provides serialization, comparison, and S-expression conversion operations for these flags. Use this module to inspect or persist CPU feature capabilities on Intel processors where those features may be present but are not guaranteed.",
      "description_length": 423,
      "index": 109,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags.Replace_polymorphic_compare",
      "library": "janestreet_cpuid",
      "description": "This module defines comparison operations and equality checks for EDX flags from the Intel CPUID instruction's version and feature information leaf. It provides functions to compare and evaluate the relative ordering of EDX flag values, such as checking if one set of flags is greater than, less than, or equal to another. These operations are useful when determining processor capabilities or feature support based on specific flag bits.",
      "description_length": 438,
      "index": 110,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Unstable",
      "library": "janestreet_cpuid",
      "description": "This module defines low-level flags from AMD's CPUID instruction for subleaf 0 of extended feature flags, specifically in the EBX register. It provides serialization, comparison, and equality operations for these flags, enabling efficient storage, transmission, and inspection of AMD CPU features. These operations are used when querying or persisting CPU capabilities, such as checking support for specific instruction sets or hardware features.",
      "description_length": 446,
      "index": 111,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Replace_polymorphic_compare",
      "library": "janestreet_cpuid",
      "description": "This module defines comparison operators and ordering functions for the `Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.t` type, enabling direct comparisons between CPU feature flag values. It supports operations like equality checks, less-than/greater-than comparisons, and utilities to select the minimum or maximum of two flag values. These functions are used when analyzing or comparing AMD CPU feature sets retrieved via the CPUID instruction at leaf 0x7 with subleaf 0x0.",
      "description_length": 483,
      "index": 112,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Map",
      "library": "janestreet_cpuid",
      "description": "This module organizes key-value mappings tied to AMD CPU feature flags from CPUID subleaf 0 (ECX), offering operations to construct, transform, and compare maps from lists, sequences, or hashtables, while handling duplicate keys. It supports direct manipulation of feature bit associations, such as tracking instruction set support or virtualization capabilities, and includes submodules for hashing, binary and S-expression serialization, and difference tracking. The keys submodule defines and serializes the feature bit identifiers, the hash module enables efficient storage in hash tables, the parser interprets S-expressions into typed flags, the binary module persists maps to memory or disk, and the diff module captures and applies changes between flag states. Example uses include validating SEV support across reboots, storing CPU capability snapshots, or comparing feature sets between AMD processors.",
      "description_length": 912,
      "index": 113,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags.Unstable",
      "library": "janestreet_cpuid",
      "description": "This module defines serialization, comparison, and S-expression conversion operations for a specific set of CPU feature flags retrieved via the CPUID instruction on AMD processors. It works directly with the `t` type, representing decoded feature bits from the EDX register when CPUID leaf 0x1 is queried. These operations support persistent storage, inter-process communication, and human-readable representation of CPU capabilities such as MMX, SSE, or APIC support.",
      "description_length": 468,
      "index": 114,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags.Set",
      "library": "janestreet_cpuid",
      "description": "This module manages sets of AMD CPUID extended feature flags from the ECX register of subleaf 0x7:0x0, offering construction, transformation, and serialization operations. It centers around the `t` type representing flag sets, with core operations like union, intersection, and difference, along with conversions to maps, S-expressions, and hash values. Child modules enable binary I/O, set differencing, S-expression parsing, and hash generation, supporting use cases such as feature detection, configuration loading, and compatibility analysis. For example, you can compute the difference between two CPU feature sets, serialize the result to disk, or generate test cases based on supported flags.",
      "description_length": 699,
      "index": 115,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Unstable",
      "library": "janestreet_cpuid",
      "description": "This module defines low-level bit-level operations and serialization routines for handling AMD CPUID feature flags stored in the ECX register. It works directly with the `t` type, representing a 32-bit value, and provides functions for binary serialization, deserialization, comparison, and S-expression conversion. Concrete use cases include persisting CPU feature information to disk, transmitting it across networks, or comparing CPU capabilities in system introspection tools.",
      "description_length": 480,
      "index": 116,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Replace_polymorphic_compare",
      "library": "janestreet_cpuid",
      "description": "This module defines comparison operations and equality checks for ECX feature flags retrieved from Intel CPUID instruction. It provides standard relational operators and comparison functions to evaluate and order ECX flag values. These operations are used when determining processor feature support levels directly from CPUID results.",
      "description_length": 334,
      "index": 117,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags.Unstable",
      "library": "janestreet_cpuid",
      "description": "This module defines low-level access to specific CPU feature flags from Intel's CPUID instruction (leaf 0x7, subleaf 0x0) in the ECX register. It includes bit-level representations and operations for querying and manipulating individual flags corresponding to optional CPU features such as AVX512, PKU, and others. These flags are used to detect and conditionally enable runtime support for advanced CPU instructions on Intel processors.",
      "description_length": 437,
      "index": 118,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Set",
      "library": "janestreet_cpuid",
      "description": "This module manages sets of Intel CPU feature flags from CPUID leaf 0x7, subleaf 0x0 (EBX register), enabling creation, transformation, and analysis of feature sets using standard set operations. It supports conversion from maps, trees, and hashtables, and includes functions for filtering, mapping, and serializing flag sets to S-expressions or binary formats. The module's submodules compute set differences for tracking feature changes, define individual flag values for precise feature detection (like AVX512 and MPX), provide hash functions for equality and caching, and implement serialization for storage or transmission. Example uses include comparing CPU capabilities across processors, detecting supported instruction sets at runtime, and persisting feature flag configurations.",
      "description_length": 788,
      "index": 119,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags.Unstable",
      "library": "janestreet_cpuid",
      "description": "This module defines low-level access to the ECX register flags from CPUID leaf 0x1 on Intel processors, specifically exposing unstable or newer flags that may not be available across all CPUs. It provides serialization, comparison, and S-expression conversion operations for the `t` type, which represents a bitmask of these flags. Concrete use cases include inspecting CPU capabilities like SSSE3, SSE4.1, and POPCNT support directly from raw CPUID results.",
      "description_length": 458,
      "index": 120,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags.Map",
      "library": "janestreet_cpuid",
      "description": "This module manages Intel CPUID extended feature flags from the EDX register of subleaf 0x7.0 using a map structure, enabling key-based construction, transformation, and error-aware manipulation of flag sets. It supports operations such as binary serialization, S-expression parsing, diffing, and hashing of CPU feature mappings, with keys representing specific features like AVX512 or MPX. Submodules provide concrete tools for serialization, key definition, diff application, configuration loading, and fingerprinting, enabling use cases from runtime CPU capability analysis to property-based testing and incremental configuration updates.",
      "description_length": 641,
      "index": 121,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags.Replace_polymorphic_compare",
      "library": "janestreet_cpuid",
      "description": "This module defines comparison operators and ordering functions for the `Ebx_flags.t` type, enabling direct comparisons between CPU feature flag sets. It supports operations like equality checks, relational comparisons, and determining minimum or maximum values between two flag sets. These functions are used to analyze and compare AMD CPU feature capabilities retrieved via the CPUID instruction.",
      "description_length": 398,
      "index": 122,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Replace_polymorphic_compare",
      "library": "janestreet_cpuid",
      "description": "This module defines comparison operators and ordering functions for `Cpuid.Amd.Version_and_feature_information.Ecx_flags.t`, enabling direct value comparisons between CPU feature flags retrieved from AMD processors. It supports standard relational operations like equality, less-than, and greater-than, as well as utilities like `min` and `max` for selecting extremal values. These operations are used when analyzing or comparing specific CPU features reported in the ECX register for CPUID leaf 0x1 on AMD architectures.",
      "description_length": 521,
      "index": 123,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags.Map",
      "library": "janestreet_cpuid",
      "description": "This module manages Intel CPUID feature flags from the EBX register of leaf 0x7 subleaf 0x0, supporting creation, transformation, and comparison of maps where keys represent individual feature bits. It enables safe population from lists, arrays, and trees, with error handling for missing or unsupported features, and integrates with submodules that provide diffing, hashing, serialization, and key definitions for these feature flags. The keys submodule defines types for features like AVX512 and GFNI with comparison and S-expression conversion, while the diff submodule tracks changes in feature enablement across system states. Hashing and serialization modules enable efficient storage, transmission, and comparison of CPU capability data, useful for fleet-wide feature tracking or configuration validation.",
      "description_length": 812,
      "index": 124,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags.Set",
      "library": "janestreet_cpuid",
      "description": "This module manages sets of AMD CPUID feature flags extracted from the ECX register at leaf 0x1, enabling creation from lists, arrays, or sequences and supporting operations like union, intersection, mapping, and filtering. It works with sets of individual flags representing features like SSE3 or APIC, and provides tools for serialization via S-expressions, binary IO, and hash representations, as well as computing and applying set differences. Specific examples include analyzing CPU compatibility, persisting feature sets to disk, or comparing processor capabilities across models using diff operations. Submodules handle parsing, element definitions, hashing, binary serialization, and set difference calculations, offering a complete toolkit for working with AMD CPU feature data.",
      "description_length": 787,
      "index": 125,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ecx_flags",
      "library": "janestreet_cpuid",
      "description": "This module represents Intel CPU feature flags from CPUID leaf 0x7, subleaf 0x0 in the ECX register, enabling structured analysis and manipulation of CPU capabilities such as AVX512, PKU, and SGX. It defines a type `t` with bitwise operations (union, intersection, complement), comparison functions (`compare`, `min`, `max`), and conversions to and from integers for runtime feature detection and conditional optimization. Submodules support set operations, serialization (Sexp, Bin_io), hashing, and symbolic flag mapping, allowing tasks like persisting CPU profiles, comparing feature sets across systems, or hashing capabilities for use in data structures. Example uses include checking for MOVDIR64B support, computing differences between CPU feature sets, or serializing a feature configuration for later analysis.",
      "description_length": 819,
      "index": 126,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Eax",
      "library": "janestreet_cpuid",
      "description": "This module decodes the EAX register output of the CPUID instruction when EAX is set to 0x1, extracting specific version and feature information from Intel processors. It provides structured access to fields like step, model, family, and extended features, which are essential for identifying processor variants. These values are useful for generating processor-specific identifiers or for making runtime decisions based on CPU capabilities.",
      "description_length": 441,
      "index": 127,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.For_testing",
      "library": "janestreet_cpuid",
      "description": "This module constructs a version and feature information record from raw integer values obtained via the CPUID instruction. It works with 32-bit integers representing the EAX, EBX, ECX, and EDX registers. A concrete use case is parsing CPU feature bits to determine support for specific instruction sets like SSE4.2 or AVX.",
      "description_length": 323,
      "index": 128,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.For_testing",
      "library": "janestreet_cpuid",
      "description": "This module constructs a record of Intel CPU feature flags from raw integer inputs, specifically targeting subleaf 0 of CPUID leaf 0x7. It works with 32-bit integers representing CPUID register outputs to decode support for advanced processor features like AVX, BMI, and SHA extensions. Use this when testing or inspecting CPU capabilities in environments where precise feature detection is required, such as JIT compilers or low-level system diagnostics.",
      "description_length": 455,
      "index": 129,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ecx_flags",
      "library": "janestreet_cpuid",
      "description": "This module handles AMD CPUID ECX register flags, offering bitwise manipulation, comparison, and serialization of 32-bit feature values. It supports set operations, structured maps, and binary encoding through submodules that enable parsing from S-expressions, tracking differences, and persisting CPU capability states. You can compare CPU features directly, merge sequences into keyed maps, or serialize results to disk in binary format. Specific uses include validating instruction set extensions, analyzing processor compatibility, and transmitting CPU feature data across systems.",
      "description_length": 585,
      "index": 130,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Edx_flags",
      "library": "janestreet_cpuid",
      "description": "This module abstracts Intel CPUID EDX feature flags as bitmasks of type `t`, supporting bitwise operations, membership checks, and semantic conversions for runtime CPU capability analysis. It enables feature validation through operations like union, intersection, and comparison, with predefined constants for features such as SSE, FPU, and HTT. Submodules handle low-level flag access, set manipulation, key-value mappings, and serialization to S-expressions or binary formats, supporting use cases like hardware-specific optimization checks and cross-system capability comparison. Examples include detecting SSE support at runtime, hashing feature sets for caching, and validating CPU changes after system updates.",
      "description_length": 716,
      "index": 131,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Ebx",
      "library": "janestreet_cpuid",
      "description": "This module decodes the EBX register result from the CPUID instruction's 0x1 leaf on AMD processors, extracting core-specific runtime values like the initial APIC ID, which varies per core. It provides mutable fields for brand index, cache line size, and maximum logical processors, reflecting dynamic processor state. Direct use cases include retrieving per-core identifiers and cache properties for low-level system management or performance tuning.",
      "description_length": 451,
      "index": 132,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Edx_flags",
      "library": "janestreet_cpuid",
      "description": "This module handles Intel CPUID extended feature flags from EDX subleaf 0x7 as bitmask types, offering bitwise operations, comparison logic, and serialization. It supports data types `Elt.t` for individual flags and `t` for flag sets, with operations including union, intersection, difference, and conversion to and from lists, maps, and S-expressions. You can detect CPU features like AVX512, compare feature sets across processors, serialize capabilities for IPC, and apply feature deltas between systems. Submodules enhance this with map-based flag manipulation, binary and S-expression encoding, and runtime feature validation.",
      "description_length": 631,
      "index": 133,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Edx_flags",
      "library": "janestreet_cpuid",
      "description": "This module handles bitwise manipulation and comparison of CPU feature flags from AMD processors' EDX register, supporting operations like checking for specific features (e.g., `sse2`, `htt`) or performing set-based queries. It provides core data types such as `t` for representing feature sets, along with comparison functions, hash computation, and serialization capabilities through its submodules. You can compare feature sets to determine support levels, serialize them to S-expressions or binary formats, or generate hashes for capability profiles. Submodules enable structured mapping, diffing, and transformation of CPU features, making it possible to analyze, store, and communicate processor capabilities derived from CPUID leaf 0x1.",
      "description_length": 743,
      "index": 134,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.For_testing",
      "library": "janestreet_cpuid",
      "description": "This module constructs a value representing AMD processor version and feature information from raw CPUID register outputs. It works with integer inputs corresponding to EAX, EBX, ECX, and EDX register values obtained from the CPUID instruction. A concrete use case is decoding low-level processor capabilities, such as supported extensions or model identifiers, directly from CPUID results for testing or system introspection.",
      "description_length": 426,
      "index": 135,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0.Ebx_flags",
      "library": "janestreet_cpuid",
      "description": "This module represents Intel CPU feature flags from the EBX register of CPUID leaf 0x7, subleaf 0, as a bitmask type supporting bitwise and set-like operations such as union, intersection, and complement. It enables runtime detection of specific capabilities like AVX2, SGX, and CLWB, and allows comparison and ordering of flag sets to determine feature precedence or compatibility. Submodules provide structured sets and maps over individual flags, supporting transformations, serialization, and diffing to track changes in CPU capabilities across environments. Direct operations include converting between integer representations and flag lists, while set-based submodules enable filtering, hashing, and persisting feature configurations for system-level optimization and validation.",
      "description_length": 785,
      "index": 136,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ecx_flags",
      "library": "janestreet_cpuid",
      "description": "This module provides bitwise operations and comparisons for analyzing CPU feature flags stored in a bitmask-like structure, where each bit represents a specific CPU capability such as virtualization, instruction set extensions, and security features. It enables checks for hardware support during runtime configuration or feature detection for optimized code paths, using the `t` type to represent the ECX register flags from CPUID leaf 0x1. Submodules handle set operations, key-based mappings, comparisons, and low-level access to individual flags, supporting tasks like serialization, feature validation, and system migration tracking. Examples include checking for SSE4.2 support, computing differences between CPU feature sets, or serializing processor capabilities to binary or S-expressions.",
      "description_length": 798,
      "index": 137,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ecx_flags",
      "library": "janestreet_cpuid",
      "description": "This module enables structured analysis of AMD CPU features from the ECX register in CPUID subleaf 0x7:0x0, combining bitwise operations, comparisons, and data structures for managing individual flags, sets, and key-value mappings. It provides types for feature flags, flag sets, and maps, with operations including union, intersection, comparison, serialization, and difference tracking across CPUs or reboots. You can detect instruction set support like VAES, validate SEV capability persistence, or compare feature sets between processors using set operations and binary or S-expression representations. Submodules handle parsing, hashing, and serialization, enabling use cases from runtime feature checks to disk-based capability logging.",
      "description_length": 742,
      "index": 138,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.For_testing",
      "library": "janestreet_cpuid",
      "description": "This module constructs a record of AMD extended feature flags from raw integer values obtained via the CPUID instruction. It works with 32-bit integers representing CPUID leaf 0x7 subleaf 0x0 feature bits. Concrete use cases include decoding hardware capabilities like advanced vector extensions or security features directly from CPU registers.",
      "description_length": 345,
      "index": 139,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information.Ebx",
      "library": "janestreet_cpuid",
      "description": "This module decodes the EBX register result of the CPUID instruction when EAX is 0x1, specifically extracting fields related to processor features and configuration. It provides mutable fields for brand index, CLFLUSH line size, maximum addressable logical processors, and the initial APIC ID. Use this module to retrieve core-specific identifiers and hardware capabilities directly tied to the current processor context.",
      "description_length": 421,
      "index": 140,
      "embedding_norm": 0.9999998807907104
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0.Ebx_flags",
      "library": "janestreet_cpuid",
      "description": "This module handles AMD CPUID extended feature flags in the EBX register, offering bitwise operations, comparisons, and set-like manipulations for CPU capability modeling. It supports structured flag sets with individual features like AVX2, RDSEED, and SMAP, enabling queries on instruction set extensions and security features. Child modules provide serialization, difference computation, and key mappings, allowing tasks such as CPU capability analysis, configuration persistence, and cross-system feature comparison. You can hash feature sets for caching, apply deltas to simulate CPU state changes, or validate runtime support for specific hardware features.",
      "description_length": 662,
      "index": 141,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information.Eax",
      "library": "janestreet_cpuid",
      "description": "This module decodes the EAX register result of the CPUID instruction when EAX is set to 0x1 on AMD processors. It extracts specific fields into a structured format containing version and feature information such as stepping, model, family, extended model, and extended family. This data is used to identify processor capabilities and architecture details directly from CPU hardware.",
      "description_length": 382,
      "index": 142,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Extended_feature_flags_subleaf_0",
      "library": "janestreet_cpuid",
      "description": "This module decodes extended feature flags from AMD CPUs using CPUID leaf 0x7 and subleaf 0x0, exposing feature bits in EBX and ECX registers to detect capabilities like memory encryption, precise cache flush, and advanced vector extensions. It provides direct access to raw feature decoding while submodules structure flag sets, maps, and operations for comparing, serializing, and tracking differences in CPU capabilities across systems or reboots. You can validate SEV support, check for VAES or RDSEED availability, or hash feature sets for configuration persistence. Operations include bitwise checks, set unions, and binary or S-expression serialization for logging and runtime analysis.",
      "description_length": 693,
      "index": 143,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd.Version_and_feature_information",
      "library": "janestreet_cpuid",
      "description": "This module captures and organizes AMD CPU version and feature data from the CPUID instruction's EAX=0x1 leaf, structuring raw register outputs into usable types for introspection and feature detection. It decodes EAX into version identifiers like stepping and family, EBX into core-specific runtime values such as APIC ID, and processes ECX and EDX into feature sets with bitwise and set-based operations. You can compare CPU capabilities, serialize feature states, or extract cache and model details for system management and compatibility analysis. Submodules support structured mapping, diffing, and binary encoding, enabling validation, storage, and cross-system transmission of CPU capability data.",
      "description_length": 704,
      "index": 144,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid.Intel.Extended_feature_flags_subleaf_0",
      "library": "janestreet_cpuid",
      "description": "This module decodes CPU feature flags from CPUID leaf 0x7, subleaf 0x0, providing structured access to modern Intel CPU capabilities such as AVX512, SGX, and MPX across EBX, ECX, and EDX registers. It exposes types and operations to manipulate feature sets as bitmasks, supporting union, intersection, comparison, and conversion to and from integers, with submodules offering advanced set operations, serialization, hashing, and symbolic flag mapping. You can detect feature support at runtime, compare capabilities across systems, serialize CPU profiles, or compute feature deltas for optimization and validation. Specific uses include checking for MOVDIR64B, applying feature masks, or persisting capability sets for later analysis.",
      "description_length": 734,
      "index": 145,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel.Version_and_feature_information",
      "library": "janestreet_cpuid",
      "description": "This module combines direct access to CPU feature flags and version data from the CPUID instruction with structured decoding of individual registers and feature sets. It exposes raw register values (EAX, EBX, ECX, EDX) and derived types like version strings and bitmask representations, enabling runtime checks for instruction set support (e.g., SSE4.2, AVX) and processor identification. Submodules handle bit-level operations, feature set comparisons, and structured field extraction from each register, supporting tasks like hashing CPU capabilities, validating hardware changes, and selecting optimized code paths based on available features. Specific examples include detecting HTT support for threading, computing feature set intersections across machines, and extracting the APIC ID for core-specific configuration.",
      "description_length": 822,
      "index": 146,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Amd",
      "library": "janestreet_cpuid",
      "description": "This module serves as a gateway to AMD-specific CPUID information, structuring raw data from CPUID instructions into typed representations for version details and feature flags. It enables retrieval of the maximum leaf value, decoding of feature bits, and construction of canonical identifiers, supporting operations like feature detection, capability comparison, and system introspection. Leaf 0x1 data is organized into version identifiers and feature sets with accessors for APIC ID, cache configuration, and model-specific details, while Leaf 0x7 data exposes extended features such as memory encryption, RDSEED, and AVX support with set operations and serialization. Use cases include validating SEV support, hashing CPU capabilities for configuration tracking, and comparing feature sets across systems or reboots.",
      "description_length": 820,
      "index": 147,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Registers",
      "library": "janestreet_cpuid",
      "description": "This module represents CPUID register values and provides a function to print their contents. It works with the `t` type, which encodes register data. Use this module to inspect or debug CPUID results by outputting register values to standard output.",
      "description_length": 250,
      "index": 148,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Cpuid.Intel",
      "library": "janestreet_cpuid",
      "description": "This module serves as a gateway to Intel-specific CPUID instruction results, offering structured access to processor version information and feature flags across multiple leaves and subleaves. It exposes core data types such as CPUID leaf values, version identifiers, and feature bitmasks, with operations to query, compare, and manipulate these capabilities, enabling tasks like detecting AVX512 support, extracting processor family and model, or validating HTT for threading. Submodules refine access to specific feature sets from leaf 0x7 and provide utilities for bitmask operations, serialization, and symbolic flag mapping, allowing users to compute feature deltas, persist CPU profiles, or select optimized code paths based on runtime capabilities.",
      "description_length": 755,
      "index": 149,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Cpuid",
      "library": "janestreet_cpuid",
      "description": "This module detects CPU features and checks for instruction set extensions like SSE3, SSE4.1, AVX, and FMA, using register data to determine capabilities and support for optimized code paths. It works with a variant type representing AMD and Intel CPUs, and includes modules that structure raw CPUID data into typed representations for version details, feature flags, and register values. The AMD-specific module organizes Leaf 0x1 and Leaf 0x7 data into typed feature sets with accessors and set operations, supporting use cases like validating SEV support or comparing CPU capabilities across systems. The Intel-specific module provides structured access to version information and feature bitmasks, enabling detection of AVX512 support, extraction of processor family data, and selection of optimized code paths based on runtime capabilities.",
      "description_length": 845,
      "index": 150,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 151,
    "meaningful_modules": 151,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 912,
    "min_description_length": 250,
    "avg_description_length": 483.1324503311258,
    "embedding_file_size_mb": 0.5490474700927734
  }
}