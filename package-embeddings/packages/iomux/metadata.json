{
  "package": "iomux",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 5,
  "creation_timestamp": "2025-08-14T22:51:37.249390",
  "modules": [
    {
      "module_path": "Iomux.Poll.Flags",
      "library": "iomux",
      "description": "This module represents and manipulates event flags for file descriptors used in the `poll(2)` system call. It provides constants for standard flags like `POLLIN`, `POLLOUT`, and `POLLERR`, along with operations to combine flags using `(+)` and check membership with `mem`. It is used to specify and interpret event conditions when monitoring file descriptors for I/O readiness.",
      "description_length": 377,
      "index": 0,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iomux.Util.Raw",
      "library": "iomux",
      "description": "Returns the maximum number of files that can be opened simultaneously by the process. Uses system-specific mechanisms to determine the limit, typically querying OS-level configuration. Useful for resource management and tuning file descriptor limits in network or I/O-bound applications.",
      "description_length": 287,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iomux.Util",
      "library": "iomux",
      "description": "Implements conversions between Unix file descriptors and integer representations and retrieves system-specific file descriptor limits. Works with Unix.file_descr and int types. Enables managing file descriptor resources and integrating with system APIs that require raw file descriptors.",
      "description_length": 287,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Iomux.Poll",
      "library": "iomux",
      "description": "This module directly binds the `poll(2)` and `ppoll(2)` system calls for monitoring I/O readiness on file descriptors. It provides functions to configure and manage an internal poller buffer with file descriptors and event flags, wait for events with optional timeouts, and inspect results. Concrete use cases include implementing network servers that handle multiple connections concurrently or managing asynchronous I/O operations in event loops.",
      "description_length": 448,
      "index": 3,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Iomux",
      "library": "iomux",
      "description": "This module provides low-level I/O multiplexing capabilities through direct bindings to `poll(2)` and `ppoll(2)`, enabling efficient monitoring of multiple file descriptors for readiness events. It works with Unix file descriptors and integer representations, offering functions to configure event masks, wait for I/O events with timeouts, and process results. Concrete use cases include building scalable network servers and implementing custom event loops for asynchronous I/O handling.",
      "description_length": 488,
      "index": 4,
      "embedding_norm": 0.9999999403953552
    }
  ],
  "filtering": {
    "total_modules_in_package": 5,
    "meaningful_modules": 5,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 488,
    "min_description_length": 287,
    "avg_description_length": 377.4,
    "embedding_file_size_mb": 0.07286834716796875
  }
}