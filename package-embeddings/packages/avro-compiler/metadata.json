{
  "package": "avro-compiler",
  "embedding_model": "Qwen/Qwen3-Embedding-8B",
  "embedding_dimension": 4096,
  "total_modules": 5,
  "creation_timestamp": "2025-08-14T22:55:53.960423",
  "modules": [
    {
      "module_path": "Avro_compiler_lib.Codegen.Code",
      "library": "avro-compiler.lib",
      "description": "Represents and manipulates OCaml source code as an abstract structure. Provides a way to build and combine code fragments using the `t` type and render them into strings with `to_string`. Useful for generating OCaml modules programmatically, such as during schema-driven code generation.",
      "description_length": 287,
      "index": 0,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Avro_compiler_lib.Codegen",
      "library": "avro-compiler.lib",
      "description": "This module generates OCaml code from Avro schemas, producing a list of code fragments that represent the corresponding data types and serialization logic. It works directly with Avro schema definitions and uses an abstract code representation to build valid OCaml source code. A typical use case is automatically generating OCaml modules for data serialization and deserialization based on Avro schema files.",
      "description_length": 409,
      "index": 1,
      "embedding_norm": 1.0
    },
    {
      "module_path": "Avro_compiler_lib.Util",
      "library": "avro-compiler.lib",
      "description": "This module provides functions for working with optional values and lists. It includes `list_keep_some` to filter and extract values from a list of options, and `map_opt` to apply a function to an optional value if it is present. These functions are useful for handling data transformations in scenarios like parsing or data validation where optional fields are common.",
      "description_length": 369,
      "index": 2,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Avro_compiler_lib.Schema",
      "library": "avro-compiler.lib",
      "description": "This module defines data structures for representing Avro schema types, including atomic types, records, enums, arrays, and unions, along with operations to serialize and deserialize these schemas to and from JSON. It provides functions to parse schemas from strings or files, convert schemas to human-readable string representations, and manipulate schema components like record fields. Concrete use cases include validating Avro schema definitions, generating schema representations for code generation, and interfacing with Avro data in serialization workflows.",
      "description_length": 564,
      "index": 3,
      "embedding_norm": 0.9999999403953552
    },
    {
      "module_path": "Avro_compiler_lib",
      "library": "avro-compiler.lib",
      "description": "The module provides three submodules: Codegen generates OCaml code from Avro schemas, producing data type definitions and serialization logic as code fragments. Schema defines and manipulates Avro schema structures like records, enums, and unions, with JSON serialization and parsing capabilities. Util offers concise operations for handling optional values and lists, such as filtering and transforming optional data fields during parsing or validation workflows.",
      "description_length": 464,
      "index": 4,
      "embedding_norm": 1.0
    }
  ],
  "filtering": {
    "total_modules_in_package": 5,
    "meaningful_modules": 5,
    "filtered_empty_modules": 0,
    "retention_rate": 1.0
  },
  "statistics": {
    "max_description_length": 564,
    "min_description_length": 287,
    "avg_description_length": 418.6,
    "embedding_file_size_mb": 0.07279014587402344
  }
}